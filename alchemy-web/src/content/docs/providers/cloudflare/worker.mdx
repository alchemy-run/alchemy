---
title: Worker
description: Learn how to deploy, configure, and manage Cloudflare Workers using Alchemy for serverless functions at the edge.
---

A [Cloudflare Worker](https://developers.cloudflare.com/workers/) is a serverless function that runs on Cloudflare's global network.

## Quick Start

Deploy a minimal Worker with a single HTTP handler:

```ts
import { Worker } from "alchemy/cloudflare";

export const worker = await Worker("api", {
  name: "api-worker",
  entrypoint: "./src/api.ts",
});
```

```ts
// ./src/api.ts
export default {
  async fetch(){
    return new Response("OK");
  },
};
```

## Handle requests (common tasks)

Implement HTTP handlers for API endpoints, static content, and dynamic responses with proper error handling:

```ts
export default {
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;
    
    try {
      // Route-based handling
      switch (path) {
        case "/api/users":
          return await handleUsers(request);
        case "/api/health":
          return new Response(JSON.stringify({ status: "ok", timestamp: Date.now() }), {
            headers: { "content-type": "application/json" }
          });
        default:
          return new Response("Not Found", { status: 404 });
      }
    } catch (error) {
      return new Response(JSON.stringify({ error: "Internal Server Error" }), {
        status: 500,
        headers: { "content-type": "application/json" }
      });
    }
  }
};

async function handleUsers(request: Request): Promise<Response> {
  if (request.method === "POST") {
    const userData = await request.json();
    // Process user data
    return new Response(JSON.stringify({ id: "123", ...userData }), {
      status: 201,
      headers: { "content-type": "application/json" }
    });
  }
  
  // GET request - return users list
  return new Response(JSON.stringify({ users: [] }), {
    headers: { "content-type": "application/json" }
  });
}
```

**Common patterns:**
- **REST APIs**: Handle GET/POST/PUT/DELETE methods
- **Webhooks**: Process incoming webhook payloads
- **Proxies**: Forward requests to backend services
- **Static serving**: Serve HTML, CSS, JS files

## Bindings & Types (access external resources)

Use bindings to attach KV, R2, Durable Objects, secrets, and other resources to the Worker. 
Configure Worker properties for compatibility, observability, and runtime limits:

```ts
import { Worker, KVNamespace, R2Bucket } from "alchemy/cloudflare";

const cache = await KVNamespace("cache", { title: "cache-store" });
const storage = await R2Bucket("storage", { name: "user-storage" });

export const worker = await Worker("api", {
  name: "api-worker",           // Worker name
  entrypoint: "./src/api.ts",   // Main entry point
  cwd: "./src",                    // Project root directory
  format: "esm",                   // Module format (esm/cjs)
  compatibilityDate: "2024-01-01", // Workers runtime version
  compatibilityFlags: ["nodejs_compat"], // Feature flags
  adopt: true,                 // Adopt existing Worker
  bindings: {
    CACHE: cache, 
    STORAGE: storage,
    API_KEY: "secret-value"    // Environment variables (plain_text binding)  
  },
  observability: {
    enabled: true              // Enable logging (default: true)
  },
  sourceMap: true,             // Enable source maps for debugging
  limits: { 
    cpu_ms: 50_000             // Max CPU time (default: 30_000) -> Changing this has potential cost implications
  }
});
```

Access bindings using modern `env` import or traditional parameter approach:
```ts
import { env } from "cloudflare:workers";

export default {
  async fetch(request: Request, env: Env) {
    await env.CACHE.get("key");
    return new Response("OK");
  },
};
```

Global scope initialization (when appropriate):
```ts
import { env } from "cloudflare:workers";
import ApiClient from "example-api-client";

const apiClient = new ApiClient({ apiKey: env.API_KEY });

export default {
  async fetch(request: Request) {
    return new Response("Initialized with API key");
  },
};
```
Infer Worker Env Types (recommended):
Binding types can be inferred from the Worker in your alchemy.run.ts script:
```ts
// alchemy.run.ts
import type { worker } from "../alchemy.run.ts";

export default {
  async fetch(request, env: typeof worker.Env) {
    await env.CACHE.get("key");
  },
};
```

Type augmentation example (project-wide types):
```ts
// env.d.ts
import type { worker } from "./alchemy.run";

declare module "cloudflare:workers" {
  namespace Cloudflare {
    interface Env extends typeof worker.Env {}
  }
}
```


## Queue Processing (event-driven Workers)

Configure Workers to consume messages from queues with automatic retries, batching, and dead letter queues for reliable background processing:
```ts
import { Worker, Queue } from "alchemy/cloudflare";

const taskQueue = await Queue("task-queue", {
  name: "task-processing"
});

const failedQueue = await Queue("failed-tasks", {
  name: "failed-tasks"
});

export const processor = await Worker("processor", {
  entrypoint: "./src/processor.ts",
  bindings: {
    TASK_QUEUE: taskQueue  // Producer - bind queue for sending messages
  },
  eventSources: [{  // Consumer - configure processing settings
    queue: taskQueue,
    settings: {
      batchSize: 15,           
      maxConcurrency: 3,       
      maxRetries: 5,           
      maxWaitTimeMs: 2500,     
      retryDelay: 60,          
      deadLetterQueue: failedQueue  
    }
  }]
});
```

**Queue Consumer Settings:**

| Setting | Purpose | Default | Example |
|---------|---------|---------|----------|
| `batchSize` | Messages processed per batch | 10 | `15` |
| `maxConcurrency` | Concurrent Worker invocations | 2 | `3` |
| `maxRetries` | Retry attempts for failed messages | 3 | `5` |
| `maxWaitTimeMs` | Max wait time to fill a batch | 500 | `2500` |
| `retryDelay` | Delay between retries (seconds) | 30 | `120` |
| `deadLetterQueue` | Queue for permanently failed messages | undefined | `failedQueue` |

**Consumer implementation:**
```ts
// ./src/processor.ts
import type { MessageBatch } from "@cloudflare/workers-types";

export default {
  async queue(batch: MessageBatch, env: Env) {
    for (const message of batch.messages) {
      try {
        const data = message.body;
        await processTask(data);
        message.ack(); // Acknowledge successful processing
      } catch (error) {
        message.retry(); // Retry on failure - respects maxRetries
      }
    }
  }
};
```

**When to use:** Background job processing, webhook handling, email processing, image optimization, data synchronization.

## Smart Placement (performance optimization)

Enable automatic network optimization by configuring smart placement to reduce latency and improve performance:

```ts
export const optimizedWorker = await Worker("api", {
  entrypoint: "./src/api.ts",
  placement: {
    mode: "smart"  // Automatically optimize placement for performance
  }
});
```

**Benefits:**
- ✅ Automatic network optimization based on performance metrics
- ✅ Reduced latency for global users
- ✅ No infrastructure management required
- ✅ Seamless scaling across Cloudflare's network

**When to use:** Global applications, latency-sensitive APIs, high-traffic workloads, applications with geographically distributed users.
:::note
You can learn more about [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement/) in the Cloudflare documentation.
:::

## Local development & configuration

Mirror production bindings in emulation, schedule tasks with cron, and serve static assets:

```ts
// Local development configuration
await Worker("api", { 
  entrypoint: "./src/api.ts", 
  dev: { port: 8787 } 
});

// Scheduled tasks with cron triggers
export const cronWorker = await Worker("cron-tasks", {
  entrypoint: "./src/cron.ts",
  crons: [
    "0 0 * * *",     // Run daily at midnight UTC
    "0 */6 * * *",   // Run every 6 hours
    "0 12 * * MON"   // Run Mondays at noon UTC
  ]
});

// Static assets serving
const assets = await Assets({ path: "./public" });

export const frontend = await Worker("frontend", {
  entrypoint: "./src/worker.ts",
  bindings: { ASSETS: assets }
});
```

**Scheduled handler implementation:**
```ts
// ./src/cron.ts
import type { ScheduledEvent } from "@cloudflare/workers-types";

export default {
  async scheduled(event: ScheduledEvent, env: Env) {
    const cron = event.cron;
    
    switch (cron) {
      case "0 0 * * *":
        await dailyCleanup(env);
        break;
      case "0 */6 * * *":
        await syncData(env);
        break;
    }
  }
};
```

**Common cron patterns:**
- `"0 0 * * *"` - Daily at midnight UTC
- `"0 */12 * * *"` - Every 12 hours
- `"0 9 * * MON-FRI"` - Weekdays at 9 AM UTC
- `"*/15 * * * *"` - Every 15 minutes

## Advanced patterns (Worker composition, RPC, Durable Objects)

Build distributed systems using Worker-to-Worker communication, RPC patterns, and Durable Object sharing:

**Self-binding and circular dependencies:**
```ts
import { Worker, Self, WorkerStub } from "alchemy/cloudflare";

// Self-binding pattern
export const service = await Worker("auth-service", {
  entrypoint: "./src/auth.ts",
  bindings: { SELF: Self }
});

// Breaking circular dependencies with WorkerStub
const authStub = WorkerStub("auth", { name: "auth-service" });

export const apiWorker = await Worker("api", {
  entrypoint: "./src/api.ts",
  bindings: { AUTH: authStub }
});

export const authWorker = await Worker("auth", {
  entrypoint: "./src/auth.ts",
  bindings: { API: apiWorker }
});
```


### Service Mesh Pattern

```ts
// Gateway Worker coordinates requests
export const gateway = await Worker("gateway", {
  entrypoint: "./src/gateway.ts",
  bindings: {
    USER_SERVICE: userService,
    ORDER_SERVICE: orderService,
    PAYMENT_SERVICE: paymentService
  },
  routes: ["api.example.com/*"]
});

// Individual service Workers
const userService = await Worker("users", {
  entrypoint: "./src/users.ts",
  bindings: { AUTH: authWorker }
});

const orderService = await Worker("orders", {
  entrypoint: "./src/orders.ts", 
  bindings: { 
    USERS: userService,
    PAYMENTS: paymentService
  }
});
```

**Benefits:**
- ✅ Distributed system architecture
- ✅ Service isolation and independent scaling  
- ✅ Fault tolerance and graceful degradation
- ✅ Clear separation of concerns

**RPC pattern with WorkerEntrypoint:**
```ts
import { Worker, type } from "alchemy/cloudflare";
import type MyRPC from "./src/rpc";

export const rpcWorker = await Worker("rpc", {
  entrypoint: "./src/rpc.ts",
  rpc: type<MyRPC>,
});

// ./src/rpc.ts
import { WorkerEntrypoint } from "cloudflare:workers";

export default class MyRPC extends WorkerEntrypoint {
  async getData(id: string): Promise<{ id: string }> {
    return { id };
  }
}
```

**Durable Object sharing:**
```ts
import { Worker, DurableObjectNamespace } from "alchemy/cloudflare";

const data = await Worker("data", {
  entrypoint: "./src/data.ts",
  bindings: {
    STORAGE: DurableObjectNamespace("storage", { className: "DataStorage" }),
  },
});

await Worker("api", {
  entrypoint: "./src/api.ts",
  bindings: { STORAGE: data.bindings.STORAGE },
});
```

## Deploy, preview, and routing

Enable preview URLs for testing and configure production routing with domains and routes:

```ts
// Preview Worker for testing
const preview = await Worker("preview", {
  name: "my-worker",
  entrypoint: "./src/worker.ts",
  version: "pr-123",
  url: true,
});

console.log(preview.url);
```

**When to use `url: true`**

- **Use for**: CI previews, demos, short-lived feature previews, and sharing a build with reviewers.  
- **Do not use for production**: Route production traffic via `domains` or `routes` to ensure DNS/TLS control and SLAs.  

Define routes and domains alongside the Worker to keep routing policies readable:
```ts
import { Worker, Zone } from "alchemy/cloudflare";

const zone = await Zone("example", { name: "example.com", type: "full" });

export const api = await Worker("api", {
  entrypoint: "./src/api.ts",
  routes: [
    "backend.example.com/*",
    { pattern: "api.example.com/*", zoneId: zone.id },
  ],
  domains: ["admin.example.com"],
});
```

**When to use `url: true`:** CI previews, demos, short-lived feature previews. **Do not use for production** prefer `domains`/`routes` for DNS/TLS control.

:::caution
Preview URLs may be unavailable for Durable Objects or special bindings. See [Preview URL](https://developers.cloudflare.com/workers/configuration/previews/#limitations) for details.
:::

Generate `wrangler.json` only if absolutely needed, Alchemy highly encourages you to codify your Worker configuration in your `alchemy.run.ts` script:
```ts
import { WranglerJson } from "alchemy/cloudflare";

await WranglerJson({
  worker: api,
  transform: {
    wrangler: (spec) => ({
      ...spec,
      vars: { ...spec.vars, CUSTOM_VAR: "value" },
    }),
  },
});
```

## Troubleshooting (common issues)

**Binding Resolution Errors:** Ensure bindings are configured in Worker definition.
```ts
// ❌ Missing binding configuration
await env.CACHE.get("key"); // ReferenceError

// ✅ Correctly configured
const cache = await KVNamespace("cache", { title: "cache-store" });
export const worker = await Worker("api", {
  bindings: { CACHE: cache }
});
```

**Queue Consumer Failures:** Always acknowledge or retry messages.
```ts
// ❌ Missing acknowledgment
export default {
  async queue(batch: MessageBatch) {
    for (const message of batch.messages) {
      await processTask(message.body);
      // Missing: message.ack() or message.retry()
    }
  }
};

// ✅ Proper message handling
export default {
  async queue(batch: MessageBatch) {
    for (const message of batch.messages) {
      try {
        await processTask(message.body);
        message.ack();
      } catch (error) {
        message.retry();
      }
    }
  }
};
```

**Preview URL Limitations:** Use routes/domains for Durable Objects and production traffic. See [Cloudflare Docs - Previews Limitations](https://developers.cloudflare.com/workers/configuration/previews/#limitations) for details.
**Performance Issues:** Enable smart placement, increase CPU limits, use global scope initialization, cache data in KV, minimize cold starts.

## Next steps

- Static Assets: See [Assets](/providers/cloudflare/assets)
- Durable Objects & RPC: See [Durable Object Namespace](/providers/cloudflare/durable-object-namespace)
- Deploy & routing: See [Route](/providers/cloudflare/route), [Custom Domain](/providers/cloudflare/custom-domain), and [Zone](/providers/cloudflare/zone)


