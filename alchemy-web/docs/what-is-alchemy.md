# What is Alchemy

Alchemy is a TypeScript-native Infrastructure-as-Code (IaC) library with zero dependencies that lets you model resources that are automatically created, updated, and deleted.

## What is Infrastructure as Code?

Infrastructure as Code means writing code that defines your infrastructure instead of manually creating it. 

Let's say you need a database. Instead of clicking through a cloud console, you write:

```typescript
const database = await Database("main", { 
  engine: "postgres",
  size: "small"
});

// Access properties directly
console.log(database.connectionString);
```

Run this code, and the actual database gets created. Change the size to "medium" and run it again - your database will be updated. Remove the code, and the database will be deleted.

Your code becomes the blueprint for repeatable infrastructure. The IaC tool (Alchemy in this case) handles the synchronization between your code and the real world.

## How Alchemy Works

```typescript
// Define and deploy a resource with a single async function call
const bucket = await Bucket("assets", { name: "my-app-assets" });

// Access properties directly
console.log(bucket.url);
```

## Zero Dependencies

Alchemy has no dependencies and runs anywhere JavaScript runs.

```typescript
// Install with your preferred package manager
bun add alchemy
```

## Just Async Functions

Resources in Alchemy are implemented as async functions, not complex classes or abstractions with sharp edge gotchas.

```typescript
// Create a resource by awaiting a function
const worker = await Worker("api", {
  name: "my-api",
  entrypoint: "./src/index.ts"
});
```

## Runs Anywhere

Alchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.

```typescript
// Browser environment
const app = alchemy("my-browser-app");

// Lambda function
export const handler = async () => {
  await alchemy.run("customer-id", async () => {
    await Worker(..)
  })
};
```

## Transparent State

State is stored as plain JSON files you can inspect, edit, and version control.

```json
// .alchemy/my-app/prod/api.json
{
  "provider": "cloudflare::Worker",
  "status": "created",
  "output": {
    "id": "my-api",
    "url": "https://my-api.workers.dev"
  },
  "props": {
    "name": "my-api",
    "entrypoint": "./src/index.ts"
  }
}
```

## Pluggable State

Alchemy supports custom state backends including file systems, cloud storage, or databases.

```typescript
// Use Cloudflare R2 for state
const app = alchemy("my-app", {
  stateStore: (scope) => new R2StateStore(scope, {
    bucketName: "my-state-bucket"
  })
});
```

[Learn more about custom state stores](./guides/custom-state-store.md)

## No Inter-Process Communication

Unlike Terraform, Pulumi, and SST which rely on Go processes, Alchemy runs everything in your JavaScript runtime.

```typescript
// Initialize app - no external processes started
const app = alchemy("my-app");

// Create resources - all executed in JavaScript
const bucket = await Bucket("assets", { name: "my-assets" });

// Finalize - everything happens in JavaScript
await app.finalize();
```

## Direct API Integration

Alchemy resources call service APIs directly using fetch, without requiring SDKs.

```typescript
// Resource implementation using direct API calls
if (this.phase === "delete") {
  await fetch(`https://api.example.com/resources/${this.output.id}`, {
    method: "DELETE",
    headers: { "Authorization": `Bearer ${apiKey}` }
  });
  return this.destroy();
}
```

## Custom Resources in Minutes

Create new resource types with a simple function that implements create, update, and delete operations.

```typescript
export const Database = Resource(
  "myservice::Database",
  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {
    if (this.phase === "delete") {
      // Delete logic
      return this.destroy();
    } else if (this.phase === "update") {
      // Update logic
      return this({ id: "db-123", ...props });
    } else {
      // Create logic
      return this({ id: "db-123", ...props });
    }
  }
);
```

## Optimized for AI

Alchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.

```typescript
// 1. Copy Alchemy's .cursorrules into your repo
// 2. Ask AI: "Create a resource for Neon Database"
// 3. Get a working implementation in seconds

// Result: Complete implementation with proper lifecycle handling
export const Database = Resource(
  "neon::Database",
  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {
    // Full resource implementation generated by AI
  }
);
```

[Learn more about AI-generated resources](./guides/custom-resources.md)

## Fast Deployments

Alchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.

```typescript
// No IPC, no Go toolchains, no CloudFormation waiting
// Just direct JavaScript execution calling APIs
// $ time bun ./alchemy.run.ts
// real    0m1.234s
```

## Flexible Scoping

Alchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.

```typescript
// Root and stage scopes
const app = alchemy("my-app", { 
  stage: "prod",
  password: "prod-secret"  // Encryption password for this scope
});
```

## Secure Secrets

Alchemy encrypts sensitive values in state files.

```typescript
// Define a secret
const apiKey = alchemy.secret(process.env.API_KEY);

// Use it in a resource
const worker = await Worker("api", {
  bindings: { API_KEY: apiKey }
});

// In state files, it's encrypted
// "API_KEY": { "@secret": "Tgz3e/WAscu4U1oanm5S4YXH..." }
```

## Scoped Encryption and State

Each scope can have a different encryption password and state store.

```ts
// Nested scopes can have different passwords and state stores
await alchemy.run("backend", { 
  password: "backend-secret",
  stateStore: new DatabaseStateStore()
}, async (scope) => {
  // Create resources in this scope
  await Worker("api", { /* ... */ });
  
  // Deeper nesting works too
  await alchemy.run("database", async () => {
    await Database("main", { /* ... */ });
  });
});
```

## Application Examples

Alchemy works for a wide range of infrastructure use cases.

```typescript
// Cloudflare Workers and Static Sites
const site = await StaticSite("Website", {
  name: "my-app",
  dir: "./dist"
});

// AWS Lambda Functions
const func = await Function("api", {
  handler: "src/lambda.handler",
  environment: { TABLE_NAME: table.name }
});

// Third-party APIs like Stripe
const product = await Product("pro-plan", {
  name: "Pro Plan",
  description: "Professional subscription tier"
});
```

## Getting Started

Ready to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.
