// Generated Cloudflare Worker types for compatibility date: 2025-06-01
// Compatibility flags: nodejs_compat, experimental
// DO NOT EDIT THIS FILE DIRECTLY

// Basic types
export interface Fetcher {
  fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;
  connect(address: SocketAddress | string, options?: SocketOptions): Socket;
}

export interface Service<_Methods = Record<string, unknown>> extends Fetcher {
  connect(address: SocketAddress | string, options?: SocketOptions): Socket;
}

export interface SocketAddress {
  hostname: string;
  port: number;
}

export interface SocketOptions {
  secureTransport?: "off" | "on" | "starttls";
  allowHalfOpen?: boolean;
}

export interface Socket {
  readable: ReadableStream;
  writable: WritableStream;
  opened: Promise<SocketInfo>;
  closed: Promise<void>;
  close(): Promise<void>;
  upgraded: boolean;
  secureTransport?: "off" | "on" | "starttls";
  startTls(): Socket;
}

interface SocketInfo {
  localAddress?: string;
  remoteAddress?: string;
}

// KV Namespace
export interface KVNamespace {
  get(key: string, options?: KVGetOptions): Promise<string | null>;
  get(key: string, type: "text"): Promise<string | null>;
  get(key: string, type: "json"): Promise<any>;
  get(key: string, type: "arrayBuffer"): Promise<ArrayBuffer | null>;
  get(key: string, type: "stream"): Promise<ReadableStream | null>;
  getWithMetadata(key: string, options?: KVGetOptions): Promise<KVGetResult>;
  getWithMetadata(key: string, type: "text"): Promise<KVGetResult<string>>;
  getWithMetadata(key: string, type: "json"): Promise<KVGetResult<any>>;
  getWithMetadata(
    key: string,
    type: "arrayBuffer",
  ): Promise<KVGetResult<ArrayBuffer>>;
  getWithMetadata(
    key: string,
    type: "stream",
  ): Promise<KVGetResult<ReadableStream>>;
  put(
    key: string,
    value: string | ArrayBuffer | ArrayBufferView | ReadableStream,
    options?: KVPutOptions,
  ): Promise<void>;
  delete(key: string): Promise<void>;
  list(options?: KVListOptions): Promise<KVListResult>;
}

export interface KVGetOptions {
  type?: "text" | "json" | "arrayBuffer" | "stream";
  cacheTtl?: number;
}

export interface KVGetResult<T = unknown> {
  value: T | null;
  metadata: unknown;
  cacheStatus?: string;
}

export interface KVPutOptions {
  expiration?: number;
  expirationTtl?: number;
  metadata?: any;
}

export interface KVListOptions {
  prefix?: string;
  limit?: number;
  cursor?: string;
}

export interface KVListResult {
  keys: KVKey[];
  list_complete: boolean;
  cursor?: string;
}

export interface KVKey {
  name: string;
  expiration?: number;
  metadata?: unknown;
}

// R2 Bucket
export interface R2Bucket {
  get(key: string, options?: R2GetOptions): Promise<R2Object | null>;
  put(
    key: string,
    object: ReadableStream | ArrayBuffer | ArrayBufferView | string | Blob,
    options?: R2PutOptions,
  ): Promise<R2Object>;
  delete(keys: string | string[]): Promise<void>;
  list(options?: R2ListOptions): Promise<R2Objects>;
  head(key: string): Promise<R2Object | null>;
  createMultipartUpload(
    key: string,
    options?: R2CreateMultipartUploadOptions,
  ): Promise<R2MultipartUpload>;
  resumeMultipartUpload(key: string, uploadId: string): R2MultipartUpload;
}

export interface R2GetOptions {
  range?: R2Range;
  onlyIf?: R2Conditional;
}

export interface R2PutOptions {
  httpMetadata?: R2HTTPMetadata;
  customMetadata?: Record<string, string>;
  onlyIf?: R2Conditional;
  sha1?: ArrayBuffer;
  sha256?: ArrayBuffer;
  md5?: ArrayBuffer;
}

export interface R2ListOptions {
  limit?: number;
  prefix?: string;
  cursor?: string;
  delimiter?: string;
  startAfter?: string;
  include?: ("httpMetadata" | "customMetadata")[];
}

export interface R2Object {
  key: string;
  version: string;
  size: number;
  etag: string;
  httpEtag: string;
  uploaded: Date;
  checksums: R2Checksums;
  httpMetadata?: R2HTTPMetadata;
  customMetadata?: Record<string, string>;
  range?: R2Range;
  body: ReadableStream;
  bodyUsed: boolean;
  arrayBuffer(): Promise<ArrayBuffer>;
  text(): Promise<string>;
  json(): Promise<any>;
  blob(): Promise<Blob>;
}

export interface R2Objects {
  objects: R2Object[];
  truncated: boolean;
  cursor?: string;
  delimitedPrefixes: string[];
}

export interface R2Range {
  offset?: number;
  length?: number;
  suffix?: number;
}

export interface R2Conditional {
  etagMatches?: string | string[];
  etagDoesNotMatch?: string | string[];
  uploadedBefore?: Date;
  uploadedAfter?: Date;
}

export interface R2HTTPMetadata {
  contentType?: string;
  contentLanguage?: string;
  contentDisposition?: string;
  contentEncoding?: string;
  cacheControl?: string;
  cacheExpiry?: Date;
}

export interface R2Checksums {
  md5?: ArrayBuffer;
  sha1?: ArrayBuffer;
  sha256?: ArrayBuffer;
  sha384?: ArrayBuffer;
  sha512?: ArrayBuffer;
}

export interface R2CreateMultipartUploadOptions {
  httpMetadata?: R2HTTPMetadata;
  customMetadata?: Record<string, string>;
}

export interface R2MultipartUpload {
  key: string;
  uploadId: string;
  uploadPart(
    partNumber: number,
    value: ReadableStream | ArrayBuffer | ArrayBufferView | string | Blob,
  ): Promise<R2UploadedPart>;
  complete(uploadedParts: R2UploadedPart[]): Promise<R2Object>;
  abort(): Promise<void>;
}

export interface R2UploadedPart {
  partNumber: number;
  etag: string;
}

// D1 Database
export interface D1Database {
  prepare(query: string): D1PreparedStatement;
  dump(): Promise<ArrayBuffer>;
  batch<T = unknown>(statements: D1PreparedStatement[]): Promise<D1Result<T>[]>;
  exec(query: string): Promise<D1ExecResult>;
  withSession<T>(callback: (db: D1Database) => Promise<T>): Promise<T>;
}

export interface D1PreparedStatement {
  bind(...values: unknown[]): D1PreparedStatement;
  first<T = unknown>(colName?: string): Promise<T | null>;
  run(): Promise<D1Result>;
  all<T = unknown>(): Promise<D1Result<T[]>>;
  raw<T = unknown[]>(): Promise<T[]>;
}

export interface D1Result<T = Record<string, unknown>> {
  success: boolean;
  meta: D1Meta;
  results?: T;
  error?: string;
}

export interface D1ExecResult {
  count: number;
  duration: number;
}

export interface D1Meta {
  duration: number;
  size_after: number;
  rows_read: number;
  rows_written: number;
  last_row_id?: number;
  changed_db: boolean;
  changes: number;
}

// Durable Object Namespace
export interface DurableObjectNamespace<T = DurableObjectStub> {
  newUniqueId(
    options?: DurableObjectNamespaceNewUniqueIdOptions,
  ): DurableObjectId;
  idFromName(name: string): DurableObjectId;
  idFromString(id: string): DurableObjectId;
  get(id: DurableObjectId): T;
}

export interface DurableObjectNamespaceNewUniqueIdOptions {
  jurisdiction?: DurableObjectJurisdiction;
}

export type DurableObjectJurisdiction = "eu" | "fedramp";

export interface DurableObjectId {
  toString(): string;
  equals(other: DurableObjectId): boolean;
  getName(): string | undefined;
}

export interface DurableObjectStub extends Fetcher {
  id: DurableObjectId;
  name?: string;
}

// Queue
export interface Queue<Body = unknown> {
  send(message: Body, options?: QueueSendOptions): Promise<void>;
  sendBatch(
    messages: QueueMessage<Body>[],
    options?: QueueSendBatchOptions,
  ): Promise<void>;
}

export interface QueueMessage<Body = unknown> {
  body: Body;
  contentType?: string;
  delaySeconds?: number;
}

export interface QueueSendOptions {
  contentType?: string;
  delaySeconds?: number;
}

export interface QueueSendBatchOptions {
  delaySeconds?: number;
}

// Vectorize Index
export interface VectorizeIndex {
  query(
    vector: number[] | VectorizeVector,
    options?: VectorizeQueryOptions,
  ): Promise<VectorizeMatches>;
  insert(vectors: VectorizeVector[]): Promise<VectorizeInsertResult>;
  upsert(vectors: VectorizeVector[]): Promise<VectorizeUpsertResult>;
  deleteByIds(ids: string[]): Promise<VectorizeDeleteResult>;
  describe(): Promise<VectorizeIndexDetails>;
  getByIds(ids: string[]): Promise<VectorizeVector[]>;
}

export interface VectorizeVector {
  id: string;
  values: number[];
  metadata?: Record<string, unknown>;
  namespace?: string;
}

export interface VectorizeQueryOptions {
  topK?: number;
  namespace?: string;
  filter?: Record<string, unknown>;
  returnValues?: boolean;
  returnMetadata?: boolean;
}

export interface VectorizeMatches {
  matches: VectorizeMatch[];
  count: number;
}

export interface VectorizeMatch {
  id: string;
  score: number;
  values?: number[];
  metadata?: Record<string, unknown>;
}

export interface VectorizeInsertResult {
  count: number;
  ids: string[];
}

export interface VectorizeUpsertResult {
  count: number;
  ids: string[];
}

export interface VectorizeDeleteResult {
  count: number;
  ids: string[];
}

export interface VectorizeIndexDetails {
  name: string;
  description?: string;
  dimensions: number;
  metric: string;
  vectors_count: number;
}

// Analytics Engine
export interface AnalyticsEngineDataset {
  writeDataPoint(event: AnalyticsEngineDataPoint): void;
}

export interface AnalyticsEngineDataPoint {
  indexes?: string[];
  doubles?: number[];
  blobs?: string[];
}

// AI Gateway
export interface AiGateway {
  get(options: AiGatewayGetOptions): Promise<AiGatewayLogEntry[]>;
  getLog(options: AiGatewayGetOptions): Promise<AiGatewayLogEntry[]>;
  getUrl(): string;
  patchLog(id: string, data: any): Promise<void>;
  run(input: any, options?: any): Promise<any>;
}

export interface AiGatewayGetOptions {
  orderBy?: string;
  direction?: "asc" | "desc";
  limit?: number;
  cursor?: string;
}

export interface AiGatewayLogEntry {
  id: string;
  timestamp: string;
  level: string;
  message: string;
}

// Hyperdrive
export interface Hyperdrive {
  connectionString: string;
  host: string;
  port: number;
  database: string;
  user: string;
}

// Workflow
export interface Workflow<P = unknown> {
  create(
    options?: WorkflowInstanceCreateOptions<P>,
  ): Promise<WorkflowInstance<P>>;
  get(id: string): Promise<WorkflowInstance<P>>;
}

export interface WorkflowInstanceCreateOptions<P = unknown> {
  id?: string;
  params?: P;
}

export interface WorkflowInstance<_P = unknown> {
  id: string;
  status: WorkflowInstanceStatus;
  output?: unknown;
  error?: WorkflowInstanceError;
  pause(): Promise<void>;
  resume(): Promise<void>;
  restart(): Promise<void>;
  terminate(): Promise<void>;
}

export interface WorkflowInstanceStatus {
  status:
    | "queued"
    | "running"
    | "paused"
    | "terminated"
    | "complete"
    | "failed";
  error?: WorkflowInstanceError;
  output?: unknown;
}

export interface WorkflowInstanceError {
  message: string;
  name: string;
  stack?: string;
}

// Images Binding
export interface ImagesBinding {
  get(id: string): Promise<ArrayBuffer>;
}

// Worker Version Metadata
export interface WorkerVersionMetadata {
  id: string;
  tag: string;
  timestamp: string;
}

// RPC types
export namespace Rpc {
  export type Provider<
    Methods,
    _WorkerInterface extends "fetch" | "connect" = "fetch" | "connect",
  > = {
    [K in keyof Methods]: Methods[K];
  };
}

// AI types (for nodejs_compat mode)
export interface Ai<Models = {}> {
  run<ModelName extends keyof Models>(
    model: ModelName | string,
    input: any,
    options?: any,
  ): Promise<any>;
}
