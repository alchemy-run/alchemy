import type { Context } from "../../context.js";
import { Resource } from "../../resource.js";
import { createCloudControlClient, type ProgressEvent } from "./client.js";
import { AlreadyExistsError } from "./error.js";

/**
 * Properties for creating or updating a Cloud Control resource
 */
export interface CloudControlResourceProps {
  /**
   * The type name of the resource (e.g. AWS::S3::Bucket)
   */
  typeName: string;

  /**
   * The desired state of the resource
   */
  desiredState: Record<string, any>;

  /**
   * Optional AWS region
   * @default AWS_REGION environment variable
   */
  region?: string;

  /**
   * AWS access key ID (overrides environment variable)
   */
  accessKeyId?: string;

  /**
   * AWS secret access key (overrides environment variable)
   */
  secretAccessKey?: string;

  /**
   * AWS session token for temporary credentials
   */
  sessionToken?: string;
}

/**
 * Output returned after Cloud Control resource creation/update
 */
export interface CloudControlResource
  extends Resource<"aws::CloudControlResource">,
    CloudControlResourceProps {
  /**
   * The identifier of the resource
   */
  id: string;

  /**
   * Time at which the resource was created
   */
  createdAt: number;
}

interface CloudControlResourceInfo {
  identifier: string;
  typeName: string;
  properties: Record<string, any>;
}

interface CloudControlError {
  code?: string;
  message?: string;
}

// Register wildcard deletion handler for AWS::* pattern
// registerDeletionHandler(
//   "AWS::*",
//   //
// );

// Cache for memoizing resource handlers
const resourceHandlers: Record<string, any> = {};

/**
 * Creates a memoized Resource handler for a CloudFormation resource type
 *
 * @param typeName CloudFormation resource type (e.g., "AWS::S3::Bucket")
 * @returns A memoized Resource handler for the specified type
 */
export function createResourceType(typeName: string) {
  return (resourceHandlers[typeName] ??= Resource(
    typeName,
    function (
      this: Context<CloudControlResource>,
      id: string,
      props: Omit<CloudControlResourceProps, "typeName">,
    ) {
      return CloudControlLifecycle.bind(this)(id, {
        typeName,
        desiredState: props,
      });
    },
  ));
}

/**
 * AWS Cloud Control Resource (Generic Handler)
 *
 * This exported resource provides a generic way to manage any AWS resource
 * supported by the Cloud Control API by explicitly passing the `typeName`.
 * It is intended for direct use when the specific resource type might not be
 * known at compile time or when not using the typed Proxy interface.
 *
 * For the strongly-typed Proxy interface (e.g., `AWS.S3.Bucket(...)`), Alchemy
 * uses internal handlers generated by the `createResourceType` factory function.
 *
 * Creates and manages AWS resources using the Cloud Control API.
 *
 * @example
 * // Create an S3 bucket
 * const bucket = await CloudControlResource("my-bucket", {
 *   typeName: "AWS::S3::Bucket",
 *   desiredState: {
 *     BucketName: "my-unique-bucket-name",
 *     VersioningConfiguration: {
 *       Status: "Enabled"
 *     }
 *   }
 * });
 *
 * @example
 * // Create a DynamoDB table
 * const table = await CloudControlResource("users-table", {
 *   typeName: "AWS::DynamoDB::Table",
 *   desiredState: {
 *     TableName: "users",
 *     AttributeDefinitions: [
 *       {
 *         AttributeName: "id",
 *         AttributeType: "S"
 *       }
 *     ],
 *     KeySchema: [
 *       {
 *         AttributeName: "id",
 *         KeyType: "HASH"
 *       }
 *     ],
 *     ProvisionedThroughput: {
 *       ReadCapacityUnits: 5,
 *       WriteCapacityUnits: 5
 *     }
 *   }
 * });
 */
export const CloudControlResource = Resource(
  "aws::CloudControlResource",
  CloudControlLifecycle,
);

async function CloudControlLifecycle(
  this: Context<CloudControlResource>,
  id: string,
  props: CloudControlResourceProps,
) {
  const client = await createCloudControlClient({
    region: props.region,
    accessKeyId: props.accessKeyId,
    secretAccessKey: props.secretAccessKey,
    sessionToken: props.sessionToken,
  });

  if (this.phase === "delete") {
    if (this.output?.id) {
      try {
        await client.deleteResource(props.typeName, this.output.id);
      } catch (error) {
        // Log but don't throw on cleanup errors
        console.error(`Error deleting resource ${id}:`, error);
      }
    }
    return this.destroy();
  }

  let response: ProgressEvent | undefined;
  if (this.phase === "update" && this.output?.id) {
    // Update existing resource
    response = await client.updateResource(
      props.typeName,
      this.output.id,
      // TODO: use fast-json-patch to compute a diff of properties
      props.desiredState,
    );
  } else {
    // Create new resource
    try {
      response = await client.createResource(
        props.typeName,
        props.desiredState,
      );
    } catch (error) {
      if (error instanceof AlreadyExistsError) {
        console.log("Resource already exists, updating", error.progressEvent);

        response = await client.updateResource(
          props.typeName,
          error.progressEvent.Identifier!,
          // TODO: use fast-json-patch to compute a diff of properties
          // props.desiredState,
        );
      } else {
        throw error;
      }
    }
  }

  if (response.OperationStatus === "FAILED") {
    throw new Error(
      `Failed to ${this.phase} resource ${id}: ${response.ErrorCode}`,
    );
  }

  return this({
    ...props,
    id: response.Identifier!,
    createdAt: Date.now(),
  });
}
