import { compare } from "fast-json-patch";
import { Effect } from "effect";
import type { Context } from "../../context.ts";
import {
  registerDynamicResource,
  Resource,
  type Provider,
} from "../../resource.ts";
import type { ProgressEvent } from "./client.ts";
import {
  AlreadyExistsError,
  ConcurrentOperationError,
  NotFoundError,
  UpdateFailedError,
  createResource,
  deleteResource,
  getResource,
  updateResource,
  poll,
  makeCloudControlConfig,
  runWithCloudControl,
  type CloudControlOptions,
} from "./effect-client.ts";
import readOnlyPropertiesMap from "./properties.ts";

/**
 * Properties for creating or updating a Cloud Control resource
 */
export interface CloudControlResourceProps extends CloudControlOptions {
  /**
   * The type name of the resource (e.g. AWS::S3::Bucket)
   */
  typeName: string;

  /**
   * The desired state of the resource
   */
  desiredState: Record<string, any>;

  /**
   * If true, adopt existing resource instead of failing when resource already exists
   */
  adopt?: boolean;
}

/**
 * Output returned after Cloud Control resource creation/update
 */
export interface CloudControlResource
  extends Resource<"aws::CloudControlResource">,
    CloudControlResourceProps {
  /**
   * The identifier of the resource
   */
  id: string;

  /**
   * Time at which the resource was created
   */
  createdAt: number;
}

// Register wildcard deletion handler for AWS::* pattern
// registerDeletionHandler(
//   "AWS::*",
//   //
// );

// Cache for memoizing resource handlers
const resourceHandlers: Record<string, any> = {};

/**
 * Filters out read-only properties from a resource state
 * @param typeName AWS resource type name (e.g., "AWS::S3::Bucket")
 * @param state Resource state object
 * @returns Filtered state object without read-only properties
 */
function filterReadOnlyProperties(
  typeName: string,
  state: Record<string, any>,
): Record<string, any> {
  // Parse the type name to get service and resource
  const [service, resource] = typeName.replace("AWS::", "").split("::");
  const readOnlyProps =
    (readOnlyPropertiesMap as any)[service]?.[resource] || [];

  const filtered: Record<string, any> = {};
  for (const [key, value] of Object.entries(state)) {
    if (!readOnlyProps.includes(key)) {
      filtered[key] = value;
    }
  }

  return filtered;
}

/**
 * Creates a memoized Resource handler for a CloudFormation resource type
 *
 * @param typeName CloudFormation resource type (e.g., "AWS::S3::Bucket")
 * @returns A memoized Resource handler for the specified type
 */
export function createResourceType(typeName: string) {
  return (resourceHandlers[typeName] ??= Resource(
    typeName,
    function (
      this: Context<CloudControlResource, CloudControlResourceProps>,
      id: string,
      props: Record<string, any> & CloudControlResourceProps,
    ) {
      // Extract Alchemy-specific properties and CloudControl options
      const {
        adopt,
        region,
        accessKeyId,
        secretAccessKey,
        sessionToken,
        initialPollingDelay,
        maxPollingDelay,
        maxRetries,
        ...desiredState
      } = props;

      return CloudControlLifecycle.bind(this)(id, {
        typeName,
        desiredState,
        adopt,
        region,
        accessKeyId,
        secretAccessKey,
        sessionToken,
        initialPollingDelay,
        maxPollingDelay,
        maxRetries,
      });
    },
  ));
}

/**
 * AWS Cloud Control Resource (Generic Handler)
 *
 * This exported resource provides a generic way to manage any AWS resource
 * supported by the Cloud Control API by explicitly passing the `typeName`.
 * It is intended for direct use when the specific resource type might not be
 * known at compile time or when not using the typed Proxy interface.
 *
 * For the strongly-typed Proxy interface (e.g., `AWS.S3.Bucket(...)`), Alchemy
 * uses internal handlers generated by the `createResourceType` factory function.
 *
 * Creates and manages AWS resources using the Cloud Control API.
 *
 * @example
 * // Create an S3 bucket
 * const bucket = await CloudControlResource("my-bucket", {
 *   typeName: "AWS::S3::Bucket",
 *   desiredState: {
 *     BucketName: "my-unique-bucket-name",
 *     VersioningConfiguration: {
 *       Status: "Enabled"
 *     }
 *   }
 * });
 *
 * @example
 * // Create a DynamoDB table
 * const table = await CloudControlResource("users-table", {
 *   typeName: "AWS::DynamoDB::Table",
 *   desiredState: {
 *     TableName: "users",
 *     AttributeDefinitions: [
 *       {
 *         AttributeName: "id",
 *         AttributeType: "S"
 *       }
 *     ],
 *     KeySchema: [
 *       {
 *         AttributeName: "id",
 *         KeyType: "HASH"
 *       }
 *     ],
 *     ProvisionedThroughput: {
 *       ReadCapacityUnits: 5,
 *       WriteCapacityUnits: 5
 *     }
 *   }
 * });
 */
export const CloudControlResource = Resource(
  "aws::CloudControlResource",
  CloudControlLifecycle,
);

// register a catch-all for AWS::* resources (Resources created with the Control API)
registerDynamicResource((typeName) => {
  if (typeName.startsWith("AWS::")) {
    return Resource(
      typeName,
      function (
        this: Context<CloudControlResource, CloudControlResourceProps>,
        id: string,
        props: Omit<CloudControlResourceProps, "typeName">,
      ) {
        return CloudControlLifecycle.bind(this)(id, {
          typeName,
          ...props,
        });
      },
    ) as unknown as Provider;
  }
  return undefined;
});

async function CloudControlLifecycle(
  this: Context<CloudControlResource, CloudControlResourceProps>,
  id: string,
  props: CloudControlResourceProps,
) {
  // Extract CloudControl options from props
  const {
    typeName,
    desiredState,
    adopt,
    region,
    accessKeyId,
    secretAccessKey,
    sessionToken,
    initialPollingDelay,
    maxPollingDelay,
    maxRetries,
  } = props;

  const cloudControlOptions: CloudControlOptions = {
    region,
    accessKeyId,
    secretAccessKey,
    sessionToken,
    initialPollingDelay,
    maxPollingDelay,
    maxRetries,
  };

  if (this.phase === "delete") {
    if (this.output?.id) {
      const deleteEffect = deleteResource(typeName, this.output.id).pipe(
        Effect.catchTag("NotFoundError", () => Effect.succeed({} as ProgressEvent))
      );

      await Effect.runPromise(runWithCloudControl(deleteEffect, cloudControlOptions));
    }
    return this.destroy();
  }

  let response: ProgressEvent | undefined;
  if (this.phase === "update" && this.output?.id) {
    // Update existing resource
    response = await updateResourceWithPatchEffect(
      typeName,
      this.output.id,
      this.output.desiredState,
      desiredState,
      cloudControlOptions,
    );
  } else {
    // Create new resource
    const createEffect = createResource(typeName, desiredState).pipe(
      Effect.catchTag("AlreadyExistsError", (error) => {
        if (!adopt) {
          return Effect.fail(error);
        }
        
        // Adopt existing resource by getting it and applying patches
        return getResource(typeName, error.progressEvent.Identifier!).pipe(
          Effect.flatMap((resource) => {
            if (!resource) {
              return Effect.fail(error);
            }
            return Effect.tryPromise(() => 
              updateResourceWithPatchEffect(
                typeName, 
                error.progressEvent.Identifier!,
                resource,
                desiredState,
                cloudControlOptions,
              )
            ).pipe(Effect.map(() => error.progressEvent));
          })
        );
      }),
      Effect.catchTag("ConcurrentOperationError", (error) => {
        console.log(error.message);
        if (!adopt) {
          return Effect.fail(error);
        }
        
        console.log(
          `Waiting for concurrent operation with request token '${error.requestToken}' to complete`,
        );

        // Wait for the concurrent operation to complete by polling it
        return poll(error.requestToken).pipe(
          Effect.flatMap((concurrentResult) => {
            // Get the resource created by the concurrent operation
            return getResource(typeName, concurrentResult.Identifier!).pipe(
              Effect.flatMap((resource) => {
                if (!resource) {
                  return Effect.fail(error);
                }
                // Apply our desired state as a patch to the existing resource
                return Effect.tryPromise(() => 
                  updateResourceWithPatchEffect(
                    typeName,
                    concurrentResult.Identifier!,
                    resource,
                    desiredState,
                    cloudControlOptions,
                  )
                ).pipe(Effect.map(() => concurrentResult));
              })
            );
          }),
          Effect.catchTag("UpdateFailedError", () => {
            // If the concurrent operation failed, try to create the resource ourselves
            return createResource(typeName, desiredState);
          })
        );
      })
    );

    response = await Effect.runPromise(runWithCloudControl(createEffect, cloudControlOptions));
  }

  if (response.OperationStatus === "FAILED") {
    throw new Error(
      `Failed to ${this.phase} resource ${id}: ${response.ErrorCode}`,
    );
  }

  // Get the final resource state
  const finalState = await Effect.runPromise(
    runWithCloudControl(getResource(typeName, response.Identifier!), cloudControlOptions)
  );

  return this({
    ...props,
    id: response.Identifier!,
    createdAt: Date.now(),
    ...(finalState || {}),
  });
}

async function updateResourceWithPatchEffect(
  typeName: string,
  resourceId: string,
  currentState: Record<string, any>,
  desiredState: Record<string, any>,
  cloudControlOptions: CloudControlOptions,
): Promise<ProgressEvent> {
  // Filter out read-only properties to avoid patch conflicts
  const filteredCurrentState = filterReadOnlyProperties(typeName, currentState);

  // Create and apply patch
  const patchDocument = compare(filteredCurrentState, desiredState);
  
  const updateEffect = updateResource(typeName, resourceId, patchDocument);
  
  return await Effect.runPromise(runWithCloudControl(updateEffect, cloudControlOptions));
}
