#!/usr/bin/env bun

/**
 * Script to download and parse the AWS CloudFormation Resource Specification.
 * This script downloads the specification from the official AWS URL and parses it
 * to prepare for TypeScript type generation.
 */

import { compile } from "json-schema-to-typescript";
import { mkdir, writeFile } from "node:fs/promises";
import { dirname } from "node:path";

const CFN_SPEC_URL =
  "https://d1uauaxba7bl26.cloudfront.net/latest/gzip/CloudFormationResourceSpecification.json";
const OUTPUT_FILE = "alchemy/src/aws/control/types.d.ts";

interface ResourceTypeProperty {
  Documentation?: string;
  Required?: boolean;
  Type: string;
  PrimitiveType?: string;
  PrimitiveItemType?: string;
  ItemType?: string;
  UpdateType?: string;
}

interface ResourceType {
  Documentation?: string;
  Properties: Record<string, ResourceTypeProperty>;
  Attributes?: Record<string, ResourceTypeProperty>;
}

interface CloudFormationSpec {
  ResourceTypes: Record<string, ResourceType>;
  PropertyTypes: Record<string, Record<string, ResourceTypeProperty>>;
}

function convertPropertyToJSONSchema(prop: ResourceTypeProperty): any {
  const schema: any = {
    description: prop.Documentation,
  };

  // Handle primitive types
  if (prop.PrimitiveType) {
    schema.type = prop.PrimitiveType.toLowerCase();
    if (schema.type === "integer" || schema.type === "double") {
      schema.type = "number";
    }
  }
  // Handle array types
  else if (prop.Type === "List" || prop.Type === "Array") {
    schema.type = "array";
    if (prop.PrimitiveItemType) {
      schema.items = {
        type: prop.PrimitiveItemType.toLowerCase(),
      };
      if (schema.items.type === "integer" || schema.items.type === "double") {
        schema.items.type = "number";
      }
    } else if (prop.ItemType) {
      schema.items = convertPropertyToJSONSchema({
        Type: prop.ItemType,
      });
    }
  }
  // Handle map types
  else if (prop.Type === "Map") {
    schema.type = "object";
    schema.additionalProperties = true;
  }
  // Handle references to other types
  else if (prop.Type) {
    schema.type = "object";
    schema.properties = {};
    schema.additionalProperties = false;
  }

  return schema;
}

function convertToJSONSchema(
  resourceType: ResourceType,
  typeName: string,
): any {
  const schema: any = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: typeName,
    type: "object",
    additionalProperties: false,
    required: [] as string[],
    properties: {} as Record<string, any>,
  };

  // Add description if available
  if (resourceType.Documentation) {
    schema.description = resourceType.Documentation;
  }

  // Convert properties
  for (const [propName, prop] of Object.entries(resourceType.Properties)) {
    if (prop.Required) {
      schema.required.push(propName);
    }

    schema.properties[propName] = convertPropertyToJSONSchema(prop);
  }

  return schema;
}

async function downloadSpec(): Promise<CloudFormationSpec> {
  console.log("Downloading CloudFormation specification...");
  const response = await fetch(CFN_SPEC_URL);

  if (!response.ok) {
    throw new Error(`Failed to download specification: ${response.statusText}`);
  }

  const spec = await response.json();
  console.log("Successfully downloaded specification");
  return spec;
}

async function generateTypes(spec: CloudFormationSpec): Promise<string> {
  console.log("Generating TypeScript types...");

  const declarations: string[] = [];
  declarations.push(`// Generated by scripts/generate-aws-control-types.ts
// DO NOT EDIT THIS FILE DIRECTLY

import type { Resource } from "../../resource.js";

declare namespace AWS {`);

  // Process each resource type
  for (const [typeName, cfnResourceType] of Object.entries(
    spec.ResourceTypes,
  )) {
    const [service, resource] = typeName.replace("AWS::", "").split("::");

    // Generate props interface
    const propsSchema = convertToJSONSchema(
      cfnResourceType,
      `${resource}Props`,
    );
    const propsType = await compile(propsSchema, `${resource}Props`, {
      bannerComment: "",
      style: { semi: true, singleQuote: false },
    });

    // Generate resource interface extending Resource<T>
    declarations.push(`  namespace ${service} {
    ${propsType.replace(/export interface/, "interface").replace(/\n/g, "\n    ")}
    
    interface ${resource} extends Resource<"AWS::${service}::${resource}">, ${resource}Props {
      // Additional properties from Cloud Control API
      Arn?: string;
      CreationTime?: string;
      LastUpdateTime?: string;
    }

    function ${resource}(id: string, props: ${resource}Props): Promise<${resource}>;
  }`);
  }

  declarations.push("}"); // Close AWS namespace
  declarations.push("\nexport = AWS;");

  return declarations.join("\n");
}

async function writeTypes(types: string): Promise<void> {
  console.log(`Writing types to ${OUTPUT_FILE}...`);
  await mkdir(dirname(OUTPUT_FILE), { recursive: true });
  await writeFile(OUTPUT_FILE, types);
  console.log("Successfully wrote type definitions");
}

async function main() {
  try {
    const spec = await downloadSpec();
    const types = await generateTypes(spec);
    await writeTypes(types);
    console.log("Successfully generated AWS CloudFormation type definitions");
  } catch (error) {
    console.error("Error generating type definitions:", error);
    process.exit(1);
  }
}

// Only run if this is the main module
if (
  import.meta.url ===
  new URL(import.meta.resolve("./generate-aws-control-types.ts")).href
) {
  main();
}

export { downloadSpec, generateTypes, writeTypes };
