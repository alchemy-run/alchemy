import {
  createClient,
  defineConfig,
  type OpenApiOperationObject,
} from "@hey-api/openapi-ts";
import { $ } from "bun";
import { patchMissingEndpoints, patchMissingProperties } from "./patch.ts";

interface Endpoint {
  type: "endpoint";
  prop: string;
  path: string;
  method: string;
  description?: string;
  summary?: string;
  paramsType: string;
  paramsRequired: boolean;
  responseType?: string;
}

// 1. Fetch the OpenAPI spec from PlanetScale
const spec = await fetch("https://api.planetscale.com/v1/openapi-spec")
  .then((res) => res.json())
  .then(patchMissingEndpoints);

// 2. Generate types using hey-api
const config = await defineConfig({
  input: { path: spec as any },
  output: { path: "alchemy/src/planetscale/api" },
  plugins: [{ name: "@hey-api/typescript" }],
  parser: {
    patch: patchMissingProperties,
  },
});
await createClient(config);

// 3. Extract endpoints and types
const types = new Set<string>();
const endpoints = Object.entries(spec.paths).flatMap(([path, value]) =>
  Object.entries(value)
    .filter(([key]) => ["get", "post", "put", "delete", "patch"].includes(key))
    .map(([method, operation]) => {
      const endpoint = parseEndpoint(
        method,
        path,
        operation as OpenApiOperationObject.V2_0_X,
      );
      if (endpoint.responseType) {
        types.add(endpoint.responseType);
      }
      if (endpoint.paramsType) {
        types.add(endpoint.paramsType);
      }
      return endpoint;
    }),
);

// 4. Build the API object
const apiObject = convertEndpointsToObject(endpoints);
const apiString = buildApi(apiObject);
const imports = [
  "import type {",
  ...Array.from(types)
    .sort()
    .map((type) => `  ${type},`),
  '} from "./types.gen.ts";',
  'import type { Secret } from "../../secret.ts";',
].join("\n");

// 5. Generate the client
const banner =
  "// This file is auto-generated by scripts/planetscale/generate.ts. Do not edit manually.";
const template = await Bun.file("scripts/planetscale/template.ts").text();
const output = template
  .replace("// @ts-nocheck", banner)
  .replace("/* {IMPORTS} */", imports)
  .replace("/* {ENDPOINTS} */", apiString);

await Bun.write("alchemy/src/planetscale/api/client.gen.ts", output);

// 6. Generate the index file
await Bun.write(
  "alchemy/src/planetscale/api/index.ts",
  `// This file is auto-generated by scripts/planetscale/generate.ts. Do not edit manually.

export * from "./client.gen.ts";
export * from "./types.gen.ts";`,
);

// 7. Format the files
await $`biome check --fix --unsafe alchemy/src/planetscale/api/*.ts`;

function parseEndpoint(
  method: string,
  path: string,
  operation: OpenApiOperationObject.V2_0_X,
): Endpoint {
  const operationName = toPascalCase(operation.operationId ?? "");
  const responseType = Object.values(operation.responses).flatMap(
    (response) => {
      if (!response) return [];
      if ("$ref" in response) return [extractRef(response.$ref)];
      if (response.schema?.$ref) return [extractRef(response.schema.$ref)];
      if (response.schema) return [`${operationName}Response`];
      return [];
    },
  )[0];

  return {
    type: "endpoint",
    prop:
      method === "get" && operation.operationId?.startsWith("list")
        ? "list"
        : method,
    path,
    method,
    description: parseDescription(operation.description),
    summary: parseDescription(operation.summary),
    paramsType: `${operationName}Data`,
    paramsRequired:
      operation.parameters?.some(
        (param) => "required" in param && param.required,
      ) ?? false,
    responseType,
  };

  function extractRef($ref: string) {
    return $ref.split("/").pop() as string;
  }

  function parseDescription(description: string | undefined) {
    description = description?.trim();
    return description ? description : undefined;
  }

  function toPascalCase(str: string) {
    return str.replace(/(^\w|[-_]\w)/g, (match) =>
      match.toUpperCase().replace(/[-_]/g, ""),
    );
  }
}

interface APIObject {
  [key: string]: Endpoint | APIObject;
}

function convertEndpointsToObject(endpoints: Endpoint[]): APIObject {
  const result: APIObject = {};
  for (const endpoint of endpoints) {
    set(result, toObjectPath(endpoint), endpoint);
  }
  return result;

  function set(obj: any, path: string, value: any) {
    const parts = path.split(".");
    let current = obj;
    for (const part of parts.slice(0, -1)) {
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }
    current[parts[parts.length - 1]!] = value;
  }

  function toObjectPath(endpoint: Endpoint) {
    const path = endpoint.path
      .split("/")
      .filter((part) => !!part && !part.startsWith("{") && !part.endsWith("}"))
      .map(toCamelCase)
      .join(".");
    return `${path}.${endpoint.prop}`;
  }

  function toCamelCase(str: string) {
    return str.replace(/([-_]\w)/g, (match) =>
      match.toUpperCase().replace(/[-_]/g, ""),
    );
  }
}

function buildApi(api: APIObject, level = 0) {
  const lines: string[] = [];
  for (const [key, value] of Object.entries(api)) {
    if (value.type === "endpoint") {
      lines.push(
        buildEndpointFunction(value as Endpoint)
          .split("\n")
          .map((line) => `  ${line}`)
          .join("\n"),
      );
    } else {
      lines.push(
        `  ${key}${level === 0 ? " =" : ":"} {`,
        ...buildApi(value as APIObject, level + 1)
          .split("\n")
          .map((line) => `  ${line}`),
        `  }${level === 0 ? ";" : ","}`,
      );
    }
  }
  return lines.join("\n");
}

function buildEndpointFunction(endpoint: Endpoint) {
  const fn = [
    "/**",
    ` * ${endpoint.summary}`,
    " *",
    ...(endpoint.description
      ?.split("\n")
      .map((line, i) => ` * ${i === 0 ? "@description " : ""}${line}`) ?? []),
    " */",
    `${endpoint.prop}: async <TResult extends ResultType = "json">(${endpoint.paramsRequired ? "params" : "params?"}: RequestType<${endpoint.paramsType}, TResult>) => {`,
    `  return await this.request<${endpoint.responseType ?? "unknown"}, TResult>({`,
    `    method: "${endpoint.method.toUpperCase()}",`,
    `    path: "${endpoint.path}",`,
    "    params,",
    "  });",
    "},",
  ];
  return fn.join("\n");
}
