#!/usr/bin/env bun
import { mkdir, writeFile } from "node:fs/promises";
import { join } from "node:path";
import prettier from "prettier";

const OUTPUT_DIR = "alchemy/src/cloudflare/workerd";
const _DEFAULT_OUTPUT = join(OUTPUT_DIR, "default.ts");

// Default compatibility configuration
const _DEFAULT_COMPATIBILITY = {
  date: "2025-01-01",
  flags: ["nodejs_compat"],
};

// Common compatibility configurations to generate types for
const COMPATIBILITY_VARIANTS = [
  {
    name: "default",
    date: "2025-01-01",
    flags: ["nodejs_compat"],
  },
  {
    name: "legacy",
    date: "2024-01-01",
    flags: [],
  },
  {
    name: "bleeding-edge",
    date: "2025-06-01",
    flags: ["nodejs_compat", "experimental"],
  },
];

interface WorkerConfiguration {
  compatibilityDate?: string;
  compatibilityFlags?: string[];
}

/**
 * Extracts Worker runtime types using wrangler's type generation approach
 */
async function extractWorkerTypes(
  config: WorkerConfiguration,
): Promise<string> {
  // For now, return the current manually vendored types as a starting point
  // TODO: Integrate with miniflare/wrangler APIs to generate types programmatically

  return `// Generated Cloudflare Worker types for compatibility date: ${config.compatibilityDate}
// Compatibility flags: ${config.compatibilityFlags?.join(", ") || "none"}
// DO NOT EDIT THIS FILE DIRECTLY

// Basic types
export interface Fetcher {
  fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;
  connect(address: SocketAddress | string, options?: SocketOptions): Socket;
}

export interface Service<Methods = Record<string, unknown>> extends Fetcher {
  connect(address: SocketAddress | string, options?: SocketOptions): Socket;
}

export interface SocketAddress {
  hostname: string;
  port: number;
}

export interface SocketOptions {
  secureTransport?: "off" | "on" | "starttls";
  allowHalfOpen?: boolean;
}

export interface Socket {
  readable: ReadableStream;
  writable: WritableStream;
  opened: Promise<SocketInfo>;
  closed: Promise<void>;
  close(): Promise<void>;
  upgraded: boolean;
  secureTransport?: "off" | "on" | "starttls";
  startTls(): Socket;
}

interface SocketInfo {
  localAddress?: string;
  remoteAddress?: string;
}

// KV Namespace
export interface KVNamespace {
  get(key: string, options?: KVGetOptions): Promise<string | null>;
  get(key: string, type: "text"): Promise<string | null>;
  get(key: string, type: "json"): Promise<any>;
  get(key: string, type: "arrayBuffer"): Promise<ArrayBuffer | null>;
  get(key: string, type: "stream"): Promise<ReadableStream | null>;
  getWithMetadata(key: string, options?: KVGetOptions): Promise<KVGetResult>;
  getWithMetadata(key: string, type: "text"): Promise<KVGetResult<string>>;
  getWithMetadata(key: string, type: "json"): Promise<KVGetResult<any>>;
  getWithMetadata(
    key: string,
    type: "arrayBuffer",
  ): Promise<KVGetResult<ArrayBuffer>>;
  getWithMetadata(
    key: string,
    type: "stream",
  ): Promise<KVGetResult<ReadableStream>>;
  put(
    key: string,
    value: string | ArrayBuffer | ArrayBufferView | ReadableStream,
    options?: KVPutOptions,
  ): Promise<void>;
  delete(key: string): Promise<void>;
  list(options?: KVListOptions): Promise<KVListResult>;
}

export interface KVGetOptions {
  type?: "text" | "json" | "arrayBuffer" | "stream";
  cacheTtl?: number;
}

export interface KVGetResult<T = unknown> {
  value: T | null;
  metadata: unknown;
  cacheStatus?: string;
}

export interface KVPutOptions {
  expiration?: number;
  expirationTtl?: number;
  metadata?: any;
}

export interface KVListOptions {
  prefix?: string;
  limit?: number;
  cursor?: string;
}

export interface KVListResult {
  keys: KVKey[];
  list_complete: boolean;
  cursor?: string;
}

export interface KVKey {
  name: string;
  expiration?: number;
  metadata?: unknown;
}

// R2 Bucket
export interface R2Bucket {
  get(key: string, options?: R2GetOptions): Promise<R2Object | null>;
  put(
    key: string,
    object: ReadableStream | ArrayBuffer | ArrayBufferView | string | Blob,
    options?: R2PutOptions,
  ): Promise<R2Object>;
  delete(keys: string | string[]): Promise<void>;
  list(options?: R2ListOptions): Promise<R2Objects>;
  head(key: string): Promise<R2Object | null>;
  createMultipartUpload(
    key: string,
    options?: R2CreateMultipartUploadOptions,
  ): Promise<R2MultipartUpload>;
  resumeMultipartUpload(key: string, uploadId: string): R2MultipartUpload;
}

export interface R2GetOptions {
  range?: R2Range;
  onlyIf?: R2Conditional;
}

export interface R2PutOptions {
  httpMetadata?: R2HTTPMetadata;
  customMetadata?: Record<string, string>;
  onlyIf?: R2Conditional;
  sha1?: ArrayBuffer;
  sha256?: ArrayBuffer;
  md5?: ArrayBuffer;
}

export interface R2ListOptions {
  limit?: number;
  prefix?: string;
  cursor?: string;
  delimiter?: string;
  startAfter?: string;
  include?: ("httpMetadata" | "customMetadata")[];
}

export interface R2Object {
  key: string;
  version: string;
  size: number;
  etag: string;
  httpEtag: string;
  uploaded: Date;
  checksums: R2Checksums;
  httpMetadata?: R2HTTPMetadata;
  customMetadata?: Record<string, string>;
  range?: R2Range;
  body: ReadableStream;
  bodyUsed: boolean;
  arrayBuffer(): Promise<ArrayBuffer>;
  text(): Promise<string>;
  json(): Promise<any>;
  blob(): Promise<Blob>;
}

export interface R2Objects {
  objects: R2Object[];
  truncated: boolean;
  cursor?: string;
  delimitedPrefixes: string[];
}

export interface R2Range {
  offset?: number;
  length?: number;
  suffix?: number;
}

export interface R2Conditional {
  etagMatches?: string | string[];
  etagDoesNotMatch?: string | string[];
  uploadedBefore?: Date;
  uploadedAfter?: Date;
}

export interface R2HTTPMetadata {
  contentType?: string;
  contentLanguage?: string;
  contentDisposition?: string;
  contentEncoding?: string;
  cacheControl?: string;
  cacheExpiry?: Date;
}

export interface R2Checksums {
  md5?: ArrayBuffer;
  sha1?: ArrayBuffer;
  sha256?: ArrayBuffer;
  sha384?: ArrayBuffer;
  sha512?: ArrayBuffer;
}

export interface R2CreateMultipartUploadOptions {
  httpMetadata?: R2HTTPMetadata;
  customMetadata?: Record<string, string>;
}

export interface R2MultipartUpload {
  key: string;
  uploadId: string;
  uploadPart(
    partNumber: number,
    value: ReadableStream | ArrayBuffer | ArrayBufferView | string | Blob,
  ): Promise<R2UploadedPart>;
  complete(uploadedParts: R2UploadedPart[]): Promise<R2Object>;
  abort(): Promise<void>;
}

export interface R2UploadedPart {
  partNumber: number;
  etag: string;
}

// D1 Database
export interface D1Database {
  prepare(query: string): D1PreparedStatement;
  dump(): Promise<ArrayBuffer>;
  batch<T = unknown>(statements: D1PreparedStatement[]): Promise<D1Result<T>[]>;
  exec(query: string): Promise<D1ExecResult>;
  withSession<T>(callback: (db: D1Database) => Promise<T>): Promise<T>;
}

export interface D1PreparedStatement {
  bind(...values: unknown[]): D1PreparedStatement;
  first<T = unknown>(colName?: string): Promise<T | null>;
  run(): Promise<D1Result>;
  all<T = unknown>(): Promise<D1Result<T[]>>;
  raw<T = unknown[]>(): Promise<T[]>;
}

export interface D1Result<T = Record<string, unknown>> {
  success: boolean;
  meta: D1Meta;
  results?: T;
  error?: string;
}

export interface D1ExecResult {
  count: number;
  duration: number;
}

export interface D1Meta {
  duration: number;
  size_after: number;
  rows_read: number;
  rows_written: number;
  last_row_id?: number;
  changed_db: boolean;
  changes: number;
}

// Durable Object Namespace
export interface DurableObjectNamespace<T = DurableObjectStub> {
  newUniqueId(
    options?: DurableObjectNamespaceNewUniqueIdOptions,
  ): DurableObjectId;
  idFromName(name: string): DurableObjectId;
  idFromString(id: string): DurableObjectId;
  get(id: DurableObjectId): T;
}

export interface DurableObjectNamespaceNewUniqueIdOptions {
  jurisdiction?: DurableObjectJurisdiction;
}

export type DurableObjectJurisdiction = "eu" | "fedramp";

export interface DurableObjectId {
  toString(): string;
  equals(other: DurableObjectId): boolean;
  getName(): string | undefined;
}

export interface DurableObjectStub extends Fetcher {
  id: DurableObjectId;
  name?: string;
}

// Queue
export interface Queue<Body = unknown> {
  send(message: Body, options?: QueueSendOptions): Promise<void>;
  sendBatch(
    messages: QueueMessage<Body>[],
    options?: QueueSendBatchOptions,
  ): Promise<void>;
}

export interface QueueMessage<Body = unknown> {
  body: Body;
  contentType?: string;
  delaySeconds?: number;
}

export interface QueueSendOptions {
  contentType?: string;
  delaySeconds?: number;
}

export interface QueueSendBatchOptions {
  delaySeconds?: number;
}

// Vectorize Index
export interface VectorizeIndex {
  query(
    vector: number[] | VectorizeVector,
    options?: VectorizeQueryOptions,
  ): Promise<VectorizeMatches>;
  insert(vectors: VectorizeVector[]): Promise<VectorizeInsertResult>;
  upsert(vectors: VectorizeVector[]): Promise<VectorizeUpsertResult>;
  deleteByIds(ids: string[]): Promise<VectorizeDeleteResult>;
  describe(): Promise<VectorizeIndexDetails>;
  getByIds(ids: string[]): Promise<VectorizeVector[]>;
}

export interface VectorizeVector {
  id: string;
  values: number[];
  metadata?: Record<string, unknown>;
  namespace?: string;
}

export interface VectorizeQueryOptions {
  topK?: number;
  namespace?: string;
  filter?: Record<string, unknown>;
  returnValues?: boolean;
  returnMetadata?: boolean;
}

export interface VectorizeMatches {
  matches: VectorizeMatch[];
  count: number;
}

export interface VectorizeMatch {
  id: string;
  score: number;
  values?: number[];
  metadata?: Record<string, unknown>;
}

export interface VectorizeInsertResult {
  count: number;
  ids: string[];
}

export interface VectorizeUpsertResult {
  count: number;
  ids: string[];
}

export interface VectorizeDeleteResult {
  count: number;
  ids: string[];
}

export interface VectorizeIndexDetails {
  name: string;
  description?: string;
  dimensions: number;
  metric: string;
  vectors_count: number;
}

// Analytics Engine
export interface AnalyticsEngineDataset {
  writeDataPoint(event: AnalyticsEngineDataPoint): void;
}

export interface AnalyticsEngineDataPoint {
  indexes?: string[];
  doubles?: number[];
  blobs?: string[];
}

// AI Gateway
export interface AiGateway {
  get(options: AiGatewayGetOptions): Promise<AiGatewayLogEntry[]>;
  getLog(options: AiGatewayGetOptions): Promise<AiGatewayLogEntry[]>;
  getUrl(): string;
  patchLog(id: string, data: any): Promise<void>;
  run(input: any, options?: any): Promise<any>;
}

export interface AiGatewayGetOptions {
  orderBy?: string;
  direction?: "asc" | "desc";
  limit?: number;
  cursor?: string;
}

export interface AiGatewayLogEntry {
  id: string;
  timestamp: string;
  level: string;
  message: string;
}

// Hyperdrive
export interface Hyperdrive {
  connectionString: string;
  host: string;
  port: number;
  database: string;
  user: string;
}

// Workflow
export interface Workflow<P = unknown> {
  create(
    options?: WorkflowInstanceCreateOptions<P>,
  ): Promise<WorkflowInstance<P>>;
  get(id: string): Promise<WorkflowInstance<P>>;
}

export interface WorkflowInstanceCreateOptions<P = unknown> {
  id?: string;
  params?: P;
}

export interface WorkflowInstance<P = unknown> {
  id: string;
  status: WorkflowInstanceStatus;
  output?: unknown;
  error?: WorkflowInstanceError;
  pause(): Promise<void>;
  resume(): Promise<void>;
  restart(): Promise<void>;
  terminate(): Promise<void>;
}

export interface WorkflowInstanceStatus {
  status:
    | "queued"
    | "running"
    | "paused"
    | "terminated"
    | "complete"
    | "failed";
  error?: WorkflowInstanceError;
  output?: unknown;
}

export interface WorkflowInstanceError {
  message: string;
  name: string;
  stack?: string;
}

// Images Binding
export interface ImagesBinding {
  get(id: string): Promise<ArrayBuffer>;
}

// Worker Version Metadata
export interface WorkerVersionMetadata {
  id: string;
  tag: string;
  timestamp: string;
}

// RPC types
export namespace Rpc {
  export type Provider<
    Methods,
    WorkerInterface extends "fetch" | "connect" = "fetch" | "connect",
  > = {
    [K in keyof Methods]: Methods[K];
  };
}

${
  config.compatibilityFlags?.includes("nodejs_compat")
    ? `
// AI types (for nodejs_compat mode)
export interface Ai<Models = {}> {
  run<ModelName extends keyof Models>(
    model: ModelName | string,
    input: any,
    options?: any
  ): Promise<any>;
}
`
    : ""
}
`;
}

async function generateTypeFile(
  variant: (typeof COMPATIBILITY_VARIANTS)[0],
): Promise<void> {
  console.log(`Generating types for variant: ${variant.name}`);

  const config: WorkerConfiguration = {
    compatibilityDate: variant.date,
    compatibilityFlags: variant.flags,
  };

  const types = await extractWorkerTypes(config);

  // Format with prettier
  const formattedTypes = await prettier.format(types, {
    parser: "typescript",
    semi: true,
    singleQuote: false,
    trailingComma: "es5",
    printWidth: 80,
    tabWidth: 2,
    useTabs: false,
  });

  const outputPath = join(OUTPUT_DIR, `${variant.name}.ts`);
  await writeFile(outputPath, formattedTypes);
  console.log(`Generated types for ${variant.name} at ${outputPath}`);
}

async function generateIndexFile(): Promise<void> {
  const indexContent = `// Generated Cloudflare Worker types index
// DO NOT EDIT THIS FILE DIRECTLY

// Export default compatibility variant
export * from "./default.js";

// Export all variants
${COMPATIBILITY_VARIANTS.map((v) => `export * as ${v.name} from "./${v.name}.js";`).join("\n")}
`;

  const formattedIndex = await prettier.format(indexContent, {
    parser: "typescript",
    semi: true,
    singleQuote: false,
    trailingComma: "es5",
    printWidth: 80,
    tabWidth: 2,
    useTabs: false,
  });

  const indexPath = join(OUTPUT_DIR, "index.ts");
  await writeFile(indexPath, formattedIndex);
  console.log(`Generated index file at ${indexPath}`);
}

export async function generateCloudflareWorkerTypes(): Promise<void> {
  console.log("Generating Cloudflare Worker types...");

  // Ensure output directory exists
  await mkdir(OUTPUT_DIR, { recursive: true });

  // Generate types for each compatibility variant
  for (const variant of COMPATIBILITY_VARIANTS) {
    await generateTypeFile(variant);
  }

  // Generate index file
  await generateIndexFile();

  console.log("Successfully generated Cloudflare Worker type definitions");
}

// If this script is run directly, execute the generation
if (import.meta.main) {
  try {
    await generateCloudflareWorkerTypes();
  } catch (error) {
    console.error(
      "Error generating Cloudflare Worker type definitions:",
      error,
    );
    process.exit(1);
  }
}
