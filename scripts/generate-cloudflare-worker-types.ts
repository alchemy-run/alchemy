#!/usr/bin/env bun
import { readFile } from "node:fs/promises";
import { mkdir, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { Miniflare } from "miniflare";
import { version } from "workerd";
import prettier from "prettier";

const OUTPUT_DIR = "alchemy/src/cloudflare/workerd";

interface Config {
  compatibility_date?: string;
  compatibility_flags?: string[];
}

/**
 * Generates runtime types for a Workers project based on the provided project configuration.
 *
 * This function is designed to be isolated and portable, making it easy to integrate into various
 * build processes or development workflows. It handles the whole process of generating runtime
 * types, from ensuring the output directory exists to spawning the workerd process (via Miniflare)
 * and writing the generated types to a file.
 *
 * @throws {Error} If the config file does not have a compatibility date.
 */
export async function generateRuntimeTypes({
  config: { compatibility_date, compatibility_flags = [] },
  outFile = "default.ts",
}: {
  config: Pick<Config, "compatibility_date" | "compatibility_flags">;
  outFile?: string;
}): Promise<{ runtimeHeader: string; runtimeTypes: string }> {
  if (!compatibility_date) {
    throw new Error("Config must have a compatibility date.");
  }

  const header = `// Runtime types generated with workerd@${version} ${compatibility_date} ${compatibility_flags.sort().join(",")}`;

  try {
    const lines = (await readFile(join(OUTPUT_DIR, outFile), "utf8")).split("\n");
    const existingHeader = lines.find((line) =>
      line.startsWith("// Runtime types generated with workerd@")
    );
    const existingTypesStart = lines.findIndex(
      (line) => line === "// Begin runtime types"
    );
    if (existingHeader === header && existingTypesStart !== -1) {
      console.log("Using cached runtime types: ", header);

      return {
        runtimeHeader: header,
        runtimeTypes: lines.slice(existingTypesStart + 1).join("\n"),
      };
    }
  } catch (e) {
    if ((e as { code: string }).code !== "ENOENT") {
      throw e;
    }
  }

  const types = await generate({
    compatibilityDate: compatibility_date,
    // Ignore nodejs compat flags as there is currently no mechanism to generate these dynamically.
    compatibilityFlags: compatibility_flags.filter(
      (flag) => !flag.includes("nodejs_compat")
    ),
  });

  return { runtimeHeader: header, runtimeTypes: types };
}

/**
 * Generates runtime types for Cloudflare Workers by spawning a workerd process with the type-generation
 * worker, and then making a request to that worker to fetch types.
 */
async function generate({
  compatibilityDate,
  compatibilityFlags = [],
}: {
  compatibilityDate: string;
  compatibilityFlags?: string[];
}) {
  const worker = (await readFile(require.resolve("workerd/worker.mjs"))).toString();
  const mf = new Miniflare({
    compatibilityDate: "2024-01-01",
    compatibilityFlags: ["nodejs_compat", "rtti_api"],
    modules: true,
    script: worker,
  });

  const flagsString = compatibilityFlags.length
    ? `+${compatibilityFlags.join("+")}`
    : "";

  const path = `http://dummy.com/${compatibilityDate}${flagsString}`;

  try {
    const res = await mf.dispatchFetch(path);
    const text = await res.text();

    if (!res.ok) {
      throw new Error(text);
    }

    return text;
  } finally {
    await mf.dispose();
  }
}

async function generateTypeFile(): Promise<void> {
  console.log("Generating types for latest compatibility date");

  // Always generate for today's date as requested by sam-goodwin
  const today = new Date();
  const compatibilityDate = today.toISOString().split('T')[0]; // YYYY-MM-DD format

  const config: Config = {
    compatibility_date: compatibilityDate,
    compatibility_flags: ["nodejs_compat"],
  };

  const { runtimeHeader, runtimeTypes } = await generateRuntimeTypes({
    config,
    outFile: "default.ts"
  });

  // Simple approach: only export the specific types needed by bound.ts
  // Keep all ambient declarations as-is, and add specific export statements at the end
  const exportedTypes = runtimeTypes + `

// Explicit type re-exports for bound.ts imports
export type { DispatchNamespace };
export type { VectorizeIndex };
export type { Workflow };
export type { WorkerVersionMetadata };
export type { Rpc };

// These interfaces already exist above, just re-export them
export type { KVNamespace };
export type { R2Bucket };  
export type { D1Database };
export type { DurableObjectNamespace };
export type { Queue };
export type { AnalyticsEngineDataset };
export type { AiGateway };
export type { Hyperdrive };
export type { ImagesBinding };
export type { Fetcher };
export type { Service };
export type { SocketAddress };
export type { SocketOptions };
`;

  const fileContent = `${runtimeHeader}
// DO NOT EDIT THIS FILE DIRECTLY

// Begin runtime types
${exportedTypes}`;

  // Format with prettier
  const formattedTypes = await prettier.format(fileContent, {
    parser: "typescript",
    semi: true,
    singleQuote: false,
    trailingComma: "es5",
    printWidth: 80,
    tabWidth: 2,
    useTabs: false,
  });

  const outputPath = join(OUTPUT_DIR, "default.ts");
  await writeFile(outputPath, formattedTypes);
  console.log(`Generated types for ${compatibilityDate} at ${outputPath}`);
}

async function generateIndexFile(): Promise<void> {
  const indexContent = `// Generated Cloudflare Worker types index
// DO NOT EDIT THIS FILE DIRECTLY

// Export default compatibility variant (latest)
export * from "./default.js";
`;

  const formattedIndex = await prettier.format(indexContent, {
    parser: "typescript",
    semi: true,
    singleQuote: false,
    trailingComma: "es5",
    printWidth: 80,
    tabWidth: 2,
    useTabs: false,
  });

  const indexPath = join(OUTPUT_DIR, "index.ts");
  await writeFile(indexPath, formattedIndex);
  console.log(`Generated index file at ${indexPath}`);
}

export async function generateCloudflareWorkerTypes(): Promise<void> {
  console.log("Generating Cloudflare Worker types...");

  // Ensure output directory exists
  await mkdir(OUTPUT_DIR, { recursive: true });

  // Generate types for latest date
  await generateTypeFile();

  // Generate index file
  await generateIndexFile();

  console.log("Successfully generated Cloudflare Worker type definitions");
}

// If this script is run directly, execute the generation
if (import.meta.main) {
  try {
    await generateCloudflareWorkerTypes();
  } catch (error) {
    console.error(
      "Error generating Cloudflare Worker type definitions:",
      error,
    );
    process.exit(1);
  }
}
