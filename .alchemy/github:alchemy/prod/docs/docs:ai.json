{
  "kind": "ai::Object",
  "id": "docs/ai",
  "fqn": "github:alchemy/prod/docs/docs/ai",
  "seq": 25,
  "data": {},
  "status": "updated",
  "output": {
    "type": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "object": {
      "groups": [
        {
          "category": "Resource",
          "filename": "data.ts",
          "identifier": "Data"
        },
        {
          "category": "Resource",
          "filename": "vue-file.ts",
          "identifier": "VueFile"
        },
        {
          "category": "Resource",
          "filename": "astro-file.ts",
          "identifier": "AstroFile"
        },
        {
          "category": "Resource",
          "filename": "css-file.ts",
          "identifier": "CSSFile"
        },
        {
          "category": "Resource",
          "filename": "html-file.ts",
          "identifier": "HTMLFile"
        },
        {
          "category": "Resource",
          "filename": "document.ts",
          "identifier": "Document"
        },
        {
          "category": "Resource",
          "filename": "yaml-file.ts",
          "identifier": "YAMLFile"
        },
        {
          "category": "Client",
          "filename": "client.ts",
          "identifier": "createModel"
        },
        {
          "category": "Resource",
          "filename": "typescript-file.ts",
          "identifier": "TypeScriptFile"
        },
        {
          "category": "Utility",
          "filename": "ark.ts",
          "identifier": "ark"
        },
        {
          "category": "Resource",
          "filename": "json-file.ts",
          "identifier": "JSONFile"
        }
      ]
    },
    "messages": [
      {
        "role": "user",
        "content": "Identify and classify the documents that need to be written for the '      alchemy/src/ai' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/ai Service has the following resources:\n[data.ts](alchemy/src/ai/data.ts)\n\n[vue-file.ts](alchemy/src/ai/vue-file.ts)\n\n[astro-file.ts](alchemy/src/ai/astro-file.ts)\n\n[css-file.ts](alchemy/src/ai/css-file.ts)\n\n[html-file.ts](alchemy/src/ai/html-file.ts)\n\n[document.ts](alchemy/src/ai/document.ts)\n\n[yaml-file.ts](alchemy/src/ai/yaml-file.ts)\n\n[client.ts](alchemy/src/ai/client.ts)\n\n[typescript-file.ts](alchemy/src/ai/typescript-file.ts)\n\n[ark.ts](alchemy/src/ai/ark.ts)\n\n[json-file.ts](alchemy/src/ai/json-file.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...).\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/ai/ark.ts\n```ts\nimport {\n  type Tool as AITool,\n  type Schema,\n  type ToolExecutionOptions,\n  tool as aitool,\n  jsonSchema,\n} from \"ai\";\nimport { ArkErrors, type JsonSchema, type type } from \"arktype\";\n\nexport namespace ark {\n  export function schema<T>(type: JsonSchema): Schema<T>;\n  export function schema<T extends type>(type: T): Schema<type.infer<T>> {\n    const jsonSchemaObj = type.toJsonSchema() as any;\n    const processedSchema = processSchema(jsonSchemaObj);\n\n    return jsonSchema(processedSchema, {\n      validate: (value) => {\n        const out = type(value) as type.infer<T> | type.errors;\n        if (out instanceof ArkErrors) {\n          return {\n            success: false,\n            error: new Error(out.summary),\n          };\n        }\n        return {\n          success: true,\n          value: out,\n        };\n      },\n    });\n  }\n\n  /**\n   * Recursively processes a JSON schema and sets additionalProperties: false\n   * for any object types.\n   *\n   * Structured Outputs requires additionalProperties: false\n   */\n  function processSchema(schema: any): any {\n    if (!schema || typeof schema !== \"object\") return schema;\n\n    // Create a copy to avoid mutating the original\n    const result = { ...schema };\n\n    // Convert anyOf with all const values to enum\n    if (result.anyOf && Array.isArray(result.anyOf)) {\n      const allConst = result.anyOf.every(\n        (item: any) => item && typeof item === \"object\" && \"const\" in item,\n      );\n\n      if (allConst) {\n        // Extract all const values\n        const enumValues = result.anyOf.map((item: any) => item.const);\n\n        // Determine the type based on the first const value\n        // Assuming all const values are of the same type\n        const firstType = typeof enumValues[0];\n\n        // Replace anyOf with enum\n        delete result.anyOf;\n        result.type = firstType;\n        result.enum = enumValues;\n      } else {\n        // Process each item in anyOf\n        result.anyOf = result.anyOf.map(processSchema);\n      }\n    }\n\n    // If this is an object type, set additionalProperties: false\n    if (result.type === \"object\") {\n      result.additionalProperties = false;\n      result.properties ??= {};\n    }\n\n    // Process properties of objects\n    if (result.properties && typeof result.properties === \"object\") {\n      result.properties = Object.fromEntries(\n        Object.entries(result.properties).map(([key, value]) => [\n          key,\n          processSchema(value),\n        ]),\n      );\n    }\n\n    // Process items in arrays\n    if (result.items) {\n      result.items = processSchema(result.items);\n    }\n\n    // Process allOf, oneOf\n    for (const key of [\"allOf\", \"oneOf\"]) {\n      if (Array.isArray(result[key])) {\n        result[key] = result[key].map(processSchema);\n      }\n    }\n\n    return result;\n  }\n\n  export interface Tool<Input extends type, Output>\n    extends Omit<AITool<Schema<type.infer<Input>>>, \"parameters\" | \"execute\"> {\n    description?: string;\n    parameters: Input;\n    execute: (\n      input: type.infer<Input>,\n      options: ToolExecutionOptions,\n    ) => Promise<Output>;\n  }\n\n  export function tool<Input extends type, Output>(\n    tool: Tool<Input, Output>,\n  ): AITool<Schema<type.infer<Input>>, Output> {\n    return aitool({\n      ...tool,\n      parameters: ark.schema<Input>(tool.parameters),\n    } as any);\n  }\n}\n\n```\n\n// alchemy/src/ai/astro-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport prettier from \"prettier\";\nimport type { Context } from \"../context\";\nimport { StaticAstroFile } from \"../fs/static-astro-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating an AstroFile\n */\nexport interface AstroFileProps {\n  /**\n   * Path to the Astro file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate an Astro component using:\n   *   ${alchemy.file(\"src/types.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return Astro code inside ```astro fences\n   * @default \"You are an Astro component generator. Create Astro components based on the user's requirements. Your response MUST include only Astro code inside ```astro fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Prettier configuration to use for formatting the Astro code\n   * If not provided, will use the default Prettier configuration\n   */\n  prettierConfig?: prettier.Options;\n}\n\n/**\n * An Astro file that can be created, updated, and deleted\n */\nexport interface AstroFile extends AstroFileProps, Resource<\"ai::AstroFile\"> {\n  /**\n   * Content of the Astro file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for Astro file generation\n */\nconst DEFAULT_ASTRO_SYSTEM_PROMPT =\n  \"You are an Astro component generator. Create Astro components based on the user's requirements. Your response MUST include only Astro code inside ```astro fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating Astro files using AI models.\n * Extracts Astro code from between ```astro fences, validates the response,\n * and formats the code with Prettier.\n *\n * @example\n * // Create a simple Astro component\n * const header = await AstroFile(\"header\", {\n *   path: \"./src/components/Header.astro\",\n *   prompt: await alchemy`\n *     Generate an Astro header component with:\n *     - Site logo\n *     - Navigation menu with Home, About, Services, Contact links\n *     - Mobile responsive design\n *     - Dark/light mode toggle\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate an Astro page with data fetching\n * const blogPost = await AstroFile(\"blog-post\", {\n *   path: \"./src/pages/blog/[slug].astro\",\n *   prompt: await alchemy`\n *     Create an Astro blog post page that:\n *     - Uses getStaticPaths to generate pages from a CMS\n *     - Renders markdown content\n *     - Includes author info, publication date, and related posts\n *     - Has social sharing buttons\n *\n *     Use the following types:\n *     ${alchemy.file(\"src/types/Blog.ts\")}\n *   `,\n *   temperature: 0.2,\n *   prettierConfig: {\n *     semi: false,\n *     singleQuote: true,\n *     printWidth: 120\n *   }\n * });\n *\n * @example\n * // Generate a layout with custom system prompt\n * const mainLayout = await AstroFile(\"main-layout\", {\n *   path: \"./src/layouts/MainLayout.astro\",\n *   prompt: await alchemy`\n *     Create the main layout for an Astro site that:\n *     - Includes common head metadata and SEO optimization\n *     - Has slots for page content, header, and footer\n *     - Imports and uses the Header and Footer components\n *     - Sets up viewport and responsive configurations\n *   `,\n *   system: \"You are an expert Astro developer. Create a single Astro layout file inside ```astro fences with no additional text. Follow Astro best practices and include proper typing in the frontmatter section.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const AstroFile = Resource(\n  \"ai::AstroFile\",\n  async function (\n    this: Context<AstroFile>,\n    id: string,\n    props: AstroFileProps\n  ): Promise<AstroFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_ASTRO_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate Astro code\n    let { code, error } = await extractAstroCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one Astro code block inside \\`\\`\\`astro fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractAstroCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid Astro code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Format the code with Prettier\n    try {\n      // Set default parser to astro\n      const prettierOptions: prettier.Options = {\n        parser: \"astro\",\n        ...props.prettierConfig,\n      };\n\n      // Format the code\n      code = await prettier.format(code, prettierOptions);\n    } catch (error) {\n      // If Prettier formatting fails, just use the unformatted code\n      console.warn(\"Failed to format Astro code with Prettier:\", error);\n    }\n\n    // Use StaticAstroFile to create/update the file\n    const file = await StaticAstroFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts Astro code from between ```astro fences\n * Validates that exactly one Astro code block exists\n *\n * @param text The text to extract Astro code from\n * @returns The extracted Astro code or error message\n */\nasync function extractAstroCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const astroCodeRegex = /```astro\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(astroCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No Astro code block found in the response. Please include your code within ```astro fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple Astro code blocks found in the response. Please provide exactly one code block within ```astro fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/client.ts\n```ts\nimport { anthropic } from \"@ai-sdk/anthropic\";\nimport { openai } from \"@ai-sdk/openai\";\nimport type { Secret } from \"../secret\";\n\n/**\n * Model configuration for AI operations\n */\nexport interface ModelConfig {\n  /**\n   * Model ID to use\n   * @default 'gpt-4o'\n   */\n  id?: string;\n\n  /**\n   * Model provider name\n   * @default 'openai'\n   */\n  provider?: string;\n\n  /**\n   * Model-specific options\n   */\n  options?: Record<string, any>;\n}\n\n/**\n * Configuration for creating an OpenAI client\n */\nexport interface ClientConfig {\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n}\n\n/**\n * Creates an OpenAI-compatible client with the given configuration\n */\nexport function createModel(config: ClientConfig) {\n  if (config.model?.provider === \"anthropic\") {\n    return anthropic(config.model?.id ?? \"claude-3-7-sonnet-latest\");\n  } else {\n    return openai(config.model?.id ?? \"gpt-4o\");\n  }\n}\n\n/**\n * Maximum time to retry in milliseconds (5 minutes)\n */\nconst MAX_RETRY_TIME = 5 * 60 * 1000;\n\n/**\n * Initial delay between retries in milliseconds\n */\nconst INITIAL_RETRY_DELAY = 1000;\n\n/**\n * Maximum number of retries\n */\nconst MAX_RETRIES = 10;\n\n/**\n * Handles rate limiting with exponential backoff\n * @param fn Function to retry\n * @returns Result of the function\n * @throws Error if max retries or time is exceeded\n */\nexport async function withRateLimitRetry<T>(fn: () => Promise<T>): Promise<T> {\n  let retryCount = 0;\n  let lastError: Error | null = null;\n  let startTime = Date.now();\n\n  while (true) {\n    try {\n      return await fn();\n    } catch (error: any) {\n      lastError = error;\n\n      console.log(\"retry error\", error);\n\n      // Check if we should retry\n      const isRateLimit = error.statusCode === 429;\n      const timeElapsed = Date.now() - startTime;\n      const shouldRetry =\n        isRateLimit && retryCount < MAX_RETRIES && timeElapsed < MAX_RETRY_TIME;\n\n      if (!shouldRetry) {\n        throw error;\n      }\n\n      // Calculate delay with exponential backoff\n      const delay = Math.min(\n        INITIAL_RETRY_DELAY * Math.pow(2, retryCount),\n        MAX_RETRY_TIME - timeElapsed\n      );\n\n      console.log(`Retrying in ${delay}ms`);\n\n      // Wait before retrying\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      retryCount++;\n    }\n  }\n}\n\n```\n\n// alchemy/src/ai/css-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticCSSFile } from \"../fs/static-css-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a CSSFile\n */\nexport interface CSSFileProps {\n  /**\n   * Path to the CSS file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate CSS styles for:\n   *   ${alchemy.file(\"src/components/Button.jsx\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return CSS code inside ```css fences\n   * @default \"You are a CSS code generator. Create CSS code based on the user's requirements. Your response MUST include only CSS code inside ```css fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A CSS file that can be created, updated, and deleted\n */\nexport interface CSSFile extends CSSFileProps, Resource<\"ai::CSSFile\"> {\n  /**\n   * Content of the CSS file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for CSS file generation\n */\nconst DEFAULT_CSS_SYSTEM_PROMPT =\n  \"You are a CSS code generator. Create CSS code based on the user's requirements. Your response MUST include only CSS code inside ```css fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating CSS files using AI models.\n * Extracts CSS code from between ```css fences and validates the response.\n *\n * @example\n * // Create styles for a website\n * const mainStyles = await CSSFile(\"main-styles\", {\n *   path: \"./public/css/main.css\",\n *   prompt: await alchemy`\n *     Generate modern CSS styles for a company website with:\n *     - Clean, minimalist design\n *     - Primary color: #0062ff\n *     - Secondary color: #6c757d\n *     - Light gray background\n *     - Responsive layout for mobile, tablet, and desktop\n *     - Custom styles for buttons, cards, and navigation\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate CSS based on existing HTML\n * const componentStyles = await CSSFile(\"component-styles\", {\n *   path: \"./src/styles/component.css\",\n *   prompt: await alchemy`\n *     Create CSS styles for this HTML component:\n *     ${alchemy.file(\"src/components/Card.html\")}\n *\n *     The styles should be:\n *     - Modern and clean\n *     - Include hover effects and transitions\n *     - Support both light and dark themes\n *     - Use CSS variables for colors and spacing\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate CSS animation with custom system prompt\n * const animationStyles = await CSSFile(\"animations\", {\n *   path: \"./src/styles/animations.css\",\n *   prompt: await alchemy`\n *     Create CSS animations for:\n *     - Fade in/out\n *     - Slide in from different directions\n *     - Pulse effect\n *     - Bounce effect\n *     - Scale in/out\n *     - Rotate\n *\n *     Each animation should be reusable via class names.\n *   `,\n *   system: \"You are an expert CSS animator. Create a single CSS file inside ```css fences with no additional text. Use modern CSS animation techniques and include vendor prefixes where needed for browser compatibility.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const CSSFile = Resource(\n  \"ai::CSSFile\",\n  async function (\n    this: Context<CSSFile>,\n    id: string,\n    props: CSSFileProps\n  ): Promise<CSSFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_CSS_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate CSS code\n    let { code, error } = await extractCSSCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one CSS code block inside \\`\\`\\`css fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractCSSCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid CSS code: ${retryResult.error}\\n${retryText}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticCSSFile to create/update the file\n    const file = await StaticCSSFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts CSS code from between ```css fences\n * Validates that exactly one CSS code block exists\n *\n * @param text The text to extract CSS code from\n * @returns The extracted CSS code or error message\n */\nasync function extractCSSCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const cssCodeRegex = /```css\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(cssCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No CSS code block found in the response. Please include your code within ```css fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple CSS code blocks found in the response. Please provide exactly one code block within ```css fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/data.ts\n```ts\nimport { generateObject, type CoreMessage } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { createModel, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating an AI Object\n */\nexport interface DataProps<T extends Type<any, any>> {\n  /**\n   * The ArkType schema to validate and structure the generated content\n   */\n  schema: T | JsonSchema;\n\n  /**\n   * Prompt for generating the content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a description for:\n   *   ${alchemy.file(\"src/data.ts\")}\n   * `\n   */\n  prompt?: string;\n\n  /**\n   * Message history for the conversation\n   * If provided, this will be used instead of the prompt\n   */\n  messages?: CoreMessage[];\n\n  /**\n   * System prompt to guide the AI's behavior\n   * @example\n   * system: \"You are a technical writer tasked with describing code\"\n   */\n  system?: string;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Whether to freeze the generated object\n   * @default false\n   */\n  freeze?: boolean;\n}\n\n/**\n * A resource that uses AI to generate structured content based on a schema\n */\nexport interface Data<T> extends Resource<\"ai::Object\"> {\n  type: JsonSchema;\n\n  /**\n   * The generated content, typed according to the provided schema\n   */\n  object: T;\n\n  /**\n   * Updated message history with the AI's response appended\n   */\n  messages: CoreMessage[];\n\n  /**\n   * Time at which the content was generated\n   */\n  createdAt: number;\n}\n\n/**\n * Resource for generating structured content using the Vercel AI SDK.\n * Supports powerful context handling through the alchemy template literal tag.\n *\n * @example\n * // Generate a product description with specific fields\n * const productSchema = type({\n *   name: \"string\",\n *   description: \"string\",\n *   features: \"string[]\",\n *   price: \"number\"\n * });\n *\n * const product = await Data(\"new-product\", {\n *   schema: productSchema,\n *   prompt: \"Generate a product description for a new smartphone\",\n *   system: \"You are a product copywriter specializing in tech products\",\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\",\n *     options: {\n *       temperature: 0.7\n *     }\n *   }\n * });\n *\n * console.log(product.object); // Typed as per schema\n *\n * @example\n * // Generate code documentation with context\n * const docSchema = type({\n *   summary: \"string\",\n *   parameters: {\n *     name: \"string\",\n *     type: \"string\",\n *     description: \"string\"\n *   }[],\n *   returns: \"string\"\n * });\n *\n * const docs = await Data(\"function-docs\", {\n *   schema: docSchema,\n *   prompt: await alchemy`\n *     Generate documentation for this function:\n *     ${alchemy.file(\"src/utils/format.ts\")}\n *   `,\n *   system: \"You are a technical documentation writer\",\n *   temperature: 0.2\n * });\n *\n * @example\n * // Using message history for iterative generation\n * const feedbackSchema = type({\n *   rating: \"number\",\n *   positives: \"string[]\",\n *   improvements: \"string[]\",\n *   summary: \"string\"\n * });\n *\n * const feedback = await Data(\"product-feedback\", {\n *   schema: feedbackSchema,\n *   messages: [\n *     { role: \"user\", content: \"I'd like feedback on my product design\" },\n *     { role: \"assistant\", content: \"I'd be happy to provide feedback. What's your product?\" },\n *     { role: \"user\", content: \"It's a new smart home device that...\" }\n *   ],\n *   system: \"You are a product design expert providing structured feedback\",\n *   temperature: 0.3\n * });\n */\nexport const Data = Resource(\"ai::Object\", async function <\n  const T extends Type<any, any>,\n>(this: Context<Data<any>>, id: string, props: DataProps<T>): Promise<\n  Data<type.infer<T>>\n> {\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  // Validate that either prompt or messages is provided\n  if (!props.prompt && !props.messages) {\n    throw new Error(\"Either prompt or messages must be provided\");\n  }\n\n  if (this.phase === \"update\" && props.freeze) {\n    return this(this.output);\n  }\n\n  // Create messages array if only prompt is provided\n  const messages = props.messages || [{ role: \"user\", content: props.prompt! }];\n\n  // Generate structured output using generateObject\n  const { object } = await generateObject({\n    model: createModel(props),\n    // Convert ArkType schema to Zod schema for generateObject\n    // This is needed because generateObject expects a Zod schema\n    schema: ark.schema<type.infer<T>>(props.schema),\n    providerOptions: props.model?.options,\n    system:\n      props.system ||\n      \"You are an AI assistant tasked with generating structured content.\",\n    messages,\n    ...(props.temperature === undefined\n      ? {}\n      : // some models error if you provide it (rather than ignoring it)\n        { temperature: props.temperature }),\n  });\n\n  // Create updated message history with the structured response\n  const responseText = JSON.stringify(object);\n  const updatedMessages = [\n    ...messages,\n    {\n      role: \"assistant\" as const,\n      content: responseText,\n    },\n  ];\n\n  // Return the resource with typed content and updated messages\n  return this({\n    type: props.schema,\n    object: object,\n    messages: updatedMessages,\n    createdAt: Date.now(),\n  });\n});\n\n```\n\n// alchemy/src/ai/document.ts\n```ts\nimport { generateText, type CoreMessage } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticTextFile } from \"../fs/static-text-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createModel, withRateLimitRetry, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating a Document\n */\nexport interface DocumentProps {\n  /**\n   * Title of the document\n   *\n   * @default id\n   */\n  title?: string;\n\n  /**\n   * Optional path to the markdown document\n   * If provided, document will be written to this path\n   */\n  path?: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate docs using:\n   *   ${alchemy.file(\"src/api.ts\")}\n   * `\n   */\n  prompt?: string;\n\n  /**\n   * Message history for conversation-based generation\n   * If provided, this will be used instead of the prompt\n   * @example\n   * messages: [\n   *   { role: \"user\", content: \"Generate API documentation for this file\" },\n   *   { role: \"assistant\", content: \"I'll create detailed API docs. What file should I document?\" },\n   *   { role: \"user\", content: \"Please document src/api.ts\" }\n   * ]\n   */\n  messages?: CoreMessage[];\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return a single markdown document inside ```md fences\n   * @default \"You are a technical documentation writer. Create a single markdown document based on the user's requirements. Your response MUST include only a single markdown document inside ```md fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Maximum number of tokens to generate.\n   * Higher values allow for longer documents but may increase cost and generation time.\n   * @default 10000\n   */\n  maxTokens?: number;\n\n  /**\n   * Freeze the document after creation (do not re-generate on updates)\n   * @default false\n   */\n  freeze?: boolean;\n}\n\n/**\n * A markdown document that can be created, updated, and deleted\n */\nexport interface Document extends DocumentProps, Resource<\"docs::Document\"> {\n  /**\n   * The title of the document\n   */\n  title: string;\n\n  /**\n   * Content of the document\n   */\n  content: string;\n\n  /**\n   * Updated message history with the document response appended\n   */\n  messages: CoreMessage[];\n\n  /**\n   * Time at which the document was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the document was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * File resource if path was provided\n   */\n  file?: StaticTextFile;\n}\n\n/**\n * Default system prompt for markdown document generation\n */\nconst DEFAULT_MD_SYSTEM_PROMPT =\n  \"You are a technical documentation writer. Create a single markdown document based on the user's requirements. Your response MUST include only a single markdown document inside ```md fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for managing AI-generated markdown documents using the Vercel AI SDK.\n * Supports powerful context handling through the alchemy template literal tag.\n *\n * @example\n * // Create an in-memory document (no file created)\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   prompt: await alchemy`\n *     Generate API documentation based on these source files:\n *     ${alchemy.file(\"src/api.ts\")}\n *     ${alchemy.file(\"src/types.ts\")}\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Create a document and write it to disk\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   path: \"./docs/api.md\",\n *   prompt: await alchemy`\n *     Generate API documentation based on these source files:\n *     ${alchemy.file(\"src/api.ts\")}\n *     ${alchemy.file(\"src/types.ts\")}\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Use message history for iterative document generation\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   path: \"./docs/api.md\",\n *   messages: [\n *     { role: \"user\", content: \"Create API documentation for these files\" },\n *     { role: \"assistant\", content: \"I'll help you create API documentation. Please provide the files.\" },\n *     { role: \"user\", content: \"Here are the files: [file contents]\" }\n *   ],\n *   system: \"You are a technical documentation writer. Generate clear and concise API documentation.\",\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Use alchemy template literals with file collections and temperature control\n * const modelDocs = await Document(\"models\", {\n *   title: \"Data Models\",\n *   path: \"./docs/models.md\",\n *   prompt: await alchemy`\n *     Write documentation for these data models:\n *     ${alchemy.files(\"src/models/user.ts\", \"src/models/post.ts\")}\n *   `,\n *   temperature: 0.2 // Lower temperature for more deterministic output\n * });\n *\n * @example\n * // Advanced model configuration with custom provider options and custom system prompt\n * const techDocs = await Document(\"tech-specs\", {\n *   title: \"Technical Specifications\",\n *   path: \"./docs/tech-specs.md\",\n *   prompt: await alchemy`\n *     Create detailed technical specifications based on these requirements:\n *     ${alchemy.file(\"requirements/system.md\")}\n *   `,\n *   system: \"You are an expert technical writer specializing in system specifications. Create a single markdown document inside ```md fences with no additional text.\",\n *   model: {\n *     id: \"o3-mini\",\n *     provider: \"openai\",\n *     options: {\n *       reasoningEffort: \"high\"\n *     }\n *   },\n *   temperature: 0.1\n * });\n */\nexport const Document = Resource(\n  \"docs::Document\",\n  async function (\n    this: Context<Document>,\n    id: string,\n    props: DocumentProps\n  ): Promise<Document> {\n    // Validate that either prompt or messages are provided\n    if (!props.prompt && !props.messages) {\n      throw new Error(\"Either prompt or messages must be provided\");\n    }\n\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    if (this.phase === \"update\" && props.freeze) {\n      if (props.path) {\n        const filePath = props.path;\n        const fileId = `${id}-file`;\n\n        await StaticTextFile(fileId, filePath, this.output!.content);\n      }\n      return this(this.output);\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_MD_SYSTEM_PROMPT;\n\n    // Generate initial content with rate limit retry\n    const { text } = await withRateLimitRetry(async () => {\n      return generateText({\n        model: createModel(props),\n        ...(props.messages\n          ? { messages: props.messages }\n          : { prompt: props.prompt! }),\n        system,\n        maxTokens: props.maxTokens || 8192,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : // some models error if you provide it (rather than ignoring it)\n            { temperature: props.temperature }),\n      });\n    });\n\n    // Extract and validate markdown content\n    let { content, error } = extractMarkdownContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one markdown document inside \\`\\`\\`md fences.`;\n\n      const { text: retryText } = await withRateLimitRetry(async () => {\n        return generateText({\n          model: createModel(props),\n          ...(props.messages\n            ? { messages: props.messages }\n            : { prompt: props.prompt! }),\n          system: errorSystem,\n          providerOptions: props.model?.options,\n          ...(props.temperature === undefined\n            ? {}\n            : { temperature: props.temperature }),\n        });\n      });\n\n      const retryResult = extractMarkdownContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid markdown content: ${retryResult.error}\\n${retryText}`\n        );\n      }\n\n      content = retryResult.content;\n    }\n\n    // Create result object\n    const result: Partial<Document> = {\n      ...props,\n      content,\n      messages: [\n        ...(props.messages || [{ role: \"user\", content: props.prompt! }]),\n        { role: \"assistant\", content },\n      ],\n      createdAt: this.output?.createdAt || Date.now(),\n      updatedAt: Date.now(),\n      title: props.title || id,\n    };\n\n    // Write file if path is provided\n    if (props.path) {\n      const filePath = props.path;\n      const fileId = `${id}-file`;\n\n      result.file = await StaticTextFile(fileId, filePath, content);\n    }\n\n    // Return the resource\n    return this(result as Document);\n  }\n);\n\n/**\n * Extracts markdown content from between ```md fences\n * Validates that exactly one markdown code block exists\n *\n * @param text The text to extract markdown content from\n * @returns The extracted markdown content or error message\n */\nfunction extractMarkdownContent(text: string): {\n  content: string;\n  error?: string;\n} {\n  const lines = text.split(\"\\n\");\n  const startIdx = lines.findIndex((line) => line.trim() === \"```md\");\n\n  if (startIdx === -1) {\n    return {\n      content: \"\",\n      error:\n        \"No markdown code block found in the response. Please include your markdown content within ```md fences.\",\n    };\n  }\n\n  const rest = lines.slice(startIdx + 1);\n  const endRelativeIdx = rest\n    .map((line) => line.trim() === \"```\")\n    .lastIndexOf(true);\n\n  if (endRelativeIdx === -1) {\n    return {\n      content: \"\",\n      error: \"Markdown block was not closed properly.\",\n    };\n  }\n\n  const endIdx = startIdx + 1 + endRelativeIdx;\n\n  const content = lines\n    .slice(startIdx + 1, endIdx)\n    .join(\"\\n\")\n    .trim();\n\n  return { content };\n}\n\n```\n\n// alchemy/src/ai/html-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticHTMLFile } from \"../fs/static-html-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating an HTMLFile\n */\nexport interface HTMLFileProps {\n  /**\n   * Path to the HTML file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate an HTML page using:\n   *   ${alchemy.file(\"src/templates/base.html\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return HTML code inside ```html fences\n   * @default \"You are an HTML code generator. Create HTML code based on the user's requirements. Your response MUST include only HTML code inside ```html fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * An HTML file that can be created, updated, and deleted\n */\nexport interface HTMLFile extends HTMLFileProps, Resource<\"ai::HTMLFile\"> {\n  /**\n   * Content of the HTML file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for HTML file generation\n */\nconst DEFAULT_HTML_SYSTEM_PROMPT =\n  \"You are an HTML code generator. Create HTML code based on the user's requirements. Your response MUST include only HTML code inside ```html fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating HTML files using AI models.\n * Extracts HTML code from between ```html fences and validates the response.\n *\n * @example\n * // Create a simple landing page\n * const landingPage = await HTMLFile(\"landing-page\", {\n *   path: \"./public/index.html\",\n *   prompt: await alchemy`\n *     Generate a modern landing page for a SaaS product with:\n *     - Hero section with headline and call-to-action\n *     - Features section with 3 key features\n *     - Pricing section with 3 tiers\n *     - Testimonials section with 2 customer quotes\n *     - Contact form and footer\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate an HTML email template\n * const emailTemplate = await HTMLFile(\"welcome-email\", {\n *   path: \"./emails/welcome.html\",\n *   prompt: await alchemy`\n *     Create an HTML email template for welcoming new users to our platform.\n *     The email should include:\n *     - Company logo and branding\n *     - Personalized welcome message (use {{name}} placeholder)\n *     - Three steps to get started\n *     - Support contact information\n *     - Unsubscribe footer\n *\n *     Make sure it's responsive and works in all major email clients.\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate an HTML component with custom system prompt\n * const navComponent = await HTMLFile(\"navigation\", {\n *   path: \"./components/nav.html\",\n *   prompt: await alchemy`\n *     Create a responsive navigation component with:\n *     - Logo in the left corner\n *     - Navigation links: Home, Products, Services, About, Contact\n *     - Mobile hamburger menu that expands/collapses\n *     - Login/signup buttons on the right side\n *     - Dark/light mode toggle\n *   `,\n *   system: \"You are an expert HTML/CSS developer specializing in responsive components. Create a single HTML file inside ```html fences with no additional text. Use modern HTML5 semantic elements and inline CSS if needed.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const HTMLFile = Resource(\n  \"ai::HTMLFile\",\n  async function (\n    this: Context<HTMLFile>,\n    id: string,\n    props: HTMLFileProps\n  ): Promise<HTMLFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_HTML_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate HTML code\n    let { code, error } = await extractHTMLCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one HTML code block inside \\`\\`\\`html fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractHTMLCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid HTML code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticHTMLFile to create/update the file\n    const file = await StaticHTMLFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts HTML code from between ```html fences\n * Validates that exactly one HTML code block exists\n *\n * @param text The text to extract HTML code from\n * @returns The extracted HTML code or error message\n */\nasync function extractHTMLCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const htmlCodeRegex = /```html\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(htmlCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No HTML code block found in the response. Please include your code within ```html fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple HTML code blocks found in the response. Please provide exactly one code block within ```html fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/json-file.ts\n```ts\nimport { generateObject, generateText } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { StaticJsonFile } from \"../fs/static-json-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a JSONFile\n */\nexport interface JSONFileProps<\n  T extends Type<any, any> | undefined = undefined,\n> {\n  /**\n   * Path to the JSON file\n   */\n  path: string;\n\n  /**\n   * Optional ArkType schema to validate and structure the generated JSON\n   * When provided, the resource will use generateObject with schema validation\n   * When not provided, it will extract JSON from between ```json fences\n   */\n  schema?: T;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a JSON configuration for:\n   *   ${alchemy.file(\"src/config.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * @default Depends on whether schema is provided\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Whether to pretty-print the JSON with indentation\n   * @default true\n   */\n  pretty?: boolean;\n\n  /**\n   * Number of spaces to use for indentation when pretty-printing\n   * @default 2\n   */\n  indent?: number;\n}\n\n/**\n * A JSON file that can be created, updated, and deleted\n */\nexport interface JSONFile<T = any>\n  extends Omit<JSONFileProps, \"schema\">,\n    Resource<\"ai::JSONFile\"> {\n  /**\n   * Content of the JSON file as a string\n   */\n  content: string;\n\n  /**\n   * Parsed JSON object\n   */\n  json: T;\n\n  /**\n   * Schema used to validate the JSON (if provided)\n   */\n  schema?: JsonSchema;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for JSON file generation without schema\n */\nconst DEFAULT_JSON_SYSTEM_PROMPT =\n  \"You are a JSON generator. Create valid JSON based on the user's requirements. Your response MUST include only JSON inside ```json fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating JSON files using AI models.\n * Can operate in two modes:\n * 1. With schema: Uses generateObject with type validation\n * 2. Without schema: Extracts JSON from between ```json fences\n *\n * @example\n * // Generate a configuration file with freeform JSON\n * const config = await JSONFile(\"app-config\", {\n *   path: \"./config/app.json\",\n *   prompt: await alchemy`\n *     Generate a configuration for a web application with:\n *     - Server settings (port, host, timeout)\n *     - Database connection details (redact any passwords)\n *     - Logging configuration\n *     - Feature flags\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate JSON with schema validation\n * import { type } from \"arktype\";\n *\n * const userSchema = type({\n *   users: [{\n *     id: \"string\",\n *     name: \"string\",\n *     email: \"string\",\n *     role: \"'admin' | 'user' | 'guest'\",\n *     permissions: \"string[]\",\n *     active: \"boolean\"\n *   }]\n * });\n *\n * const userData = await JSONFile(\"user-data\", {\n *   path: \"./data/users.json\",\n *   schema: userSchema,\n *   prompt: \"Generate sample user data for an application with various roles and permissions\",\n *   temperature: 0.2\n * });\n *\n * // Type-safe access to the generated data\n * console.log(userData.json.users[0].role); // Typed as 'admin' | 'user' | 'guest'\n *\n * @example\n * // Generate API mock data with custom system prompt\n * const apiMock = await JSONFile(\"api-mock\", {\n *   path: \"./mocks/products-api.json\",\n *   prompt: await alchemy`\n *     Create mock data for a product catalog API response with:\n *     - 10 products with different categories\n *     - Each product should have id, name, price, category, inventory, and image_url\n *     - Include pagination metadata (total, page, limit)\n *   `,\n *   system: \"You are an API design expert. Create realistic mock JSON data that follows REST API best practices. Your response must be valid JSON inside ```json fences.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   },\n *   pretty: true,\n *   indent: 4\n * });\n */\nexport const JSONFile = Resource(\"ai::JSONFile\", async function <\n  const T extends Type<any, any> | undefined = undefined,\n>(this: Context<JSONFile<T extends Type<any, any> ? type.infer<T> : any>>, id: string, props: JSONFileProps<T>): Promise<\n  JSONFile<T extends Type<any, any> ? type.infer<T> : any>\n> {\n  // Handle deletion phase\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  let jsonContent: string;\n  let jsonObject: any;\n\n  // Check if schema is provided\n  if (props.schema) {\n    // Use schema-based generation\n    const { object } = await generateObject({\n      model: createModel(props),\n      schema: ark.schema<type.infer<typeof props.schema>>(props.schema),\n      providerOptions: props.model?.options,\n      system:\n        props.system ||\n        \"Generate a valid JSON object based on the provided requirements.\",\n      prompt: props.prompt,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    jsonObject = object;\n\n    // Use StaticJsonFile to create the file\n    const file = await StaticJsonFile(\"file\", props.path, jsonObject);\n    jsonContent = file.content;\n  } else {\n    // Use fence-based extraction\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_JSON_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate JSON content\n    let { content, error } = await extractJSONContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one valid JSON block inside \\`\\`\\`json fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractJSONContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(`Failed to generate valid JSON: ${retryResult.error}`);\n      }\n\n      content = retryResult.content;\n    }\n\n    // Parse JSON to get the object representation\n    jsonObject = JSON.parse(content);\n\n    // Use StaticJsonFile to create the file\n    const file = await StaticJsonFile(\"file\", props.path, jsonObject);\n    jsonContent = file.content;\n  }\n\n  // Return the resource\n  return this({\n    ...props,\n    schema: props.schema,\n    content: jsonContent,\n    json: jsonObject,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  });\n});\n\n/**\n * Extracts JSON content from between ```json fences\n * Validates that exactly one JSON code block exists\n *\n * @param text The text to extract JSON from\n * @returns The extracted JSON or error message\n */\nasync function extractJSONContent(\n  text: string\n): Promise<{ content: string; error?: string }> {\n  const jsonCodeRegex = /```json\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(jsonCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      content: \"\",\n      error:\n        \"No JSON code block found in the response. Please include your JSON within ```json fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      content: \"\",\n      error:\n        \"Multiple JSON code blocks found in the response. Please provide exactly one JSON block within ```json fences.\",\n    };\n  }\n\n  const content = matches[0][1].trim();\n\n  // Validate JSON can be parsed\n  try {\n    JSON.parse(content);\n    return { content };\n  } catch (e) {\n    return {\n      content: \"\",\n      error: `Invalid JSON: ${(e as Error).message}. Please provide valid JSON syntax.`,\n    };\n  }\n}\n\n```\n\n// alchemy/src/ai/typescript-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticTypeScriptFile } from \"../fs/static-typescript-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createModel, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating a TypeScriptFile\n */\nexport interface TypeScriptFileProps {\n  /**\n   * Path to the TypeScript file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a TypeScript utility function using:\n   *   ${alchemy.file(\"src/types.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return TypeScript code inside ```ts fences\n   * @default \"You are a TypeScript code generator. Create TypeScript code based on the user's requirements. Your response MUST include only TypeScript code inside ```ts fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Prettier configuration to use for formatting the TypeScript code\n   * If not provided, will use the default Prettier configuration\n   */\n  prettierConfig?: object;\n}\n\n/**\n * A TypeScript file that can be created, updated, and deleted\n */\nexport interface TypeScriptFile\n  extends TypeScriptFileProps,\n    Resource<\"ai::TypeScriptFile\"> {\n  /**\n   * Content of the TypeScript file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for TypeScript file generation\n */\nconst DEFAULT_TS_SYSTEM_PROMPT =\n  \"You are a TypeScript code generator. Create TypeScript code based on the user's requirements. Your response MUST include only TypeScript code inside ```ts fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating TypeScript files using AI models.\n * Extracts TypeScript code from between ```ts fences, validates the response,\n * and formats the code with Prettier.\n *\n * @example\n * // Create a utility function\n * const utils = await TypeScriptFile(\"string-utils\", {\n *   path: \"./src/utils/string-utils.ts\",\n *   prompt: await alchemy`\n *     Generate TypeScript utility functions for string manipulation:\n *     - Capitalize first letter\n *     - Truncate with ellipsis\n *     - Convert to camelCase and kebab-case\n *     - Remove special characters\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate a TypeScript class with custom formatting\n * const userService = await TypeScriptFile(\"user-service\", {\n *   path: \"./src/services/UserService.ts\",\n *   prompt: await alchemy`\n *     Create a UserService class that handles user authentication and profile management.\n *     The service should use the User type from:\n *     ${alchemy.file(\"src/types/User.ts\")}\n *\n *     Include methods for:\n *     - login(email, password)\n *     - register(user)\n *     - updateProfile(userId, profileData)\n *     - deleteAccount(userId)\n *   `,\n *   temperature: 0.2,\n *   prettierConfig: {\n *     semi: false,\n *     singleQuote: true,\n *     printWidth: 120\n *   }\n * });\n *\n * @example\n * // Generate a React hook with custom system prompt\n * const useFormHook = await TypeScriptFile(\"use-form\", {\n *   path: \"./src/hooks/useForm.ts\",\n *   prompt: await alchemy`\n *     Create a custom React hook called useForm that handles form state, validation, and submission.\n *     It should support:\n *     - Initial values\n *     - Validation rules\n *     - Field errors\n *     - Form submission with loading state\n *     - Reset functionality\n *   `,\n *   system: \"You are an expert React developer specializing in TypeScript hooks. Create a single TypeScript file inside ```ts fences with no additional text. Follow React best practices and include proper typing.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const TypeScriptFile = Resource(\n  \"ai::TypeScriptFile\",\n  async function (\n    this: Context<TypeScriptFile>,\n    id: string,\n    props: TypeScriptFileProps\n  ): Promise<TypeScriptFile> {\n    // Handle delete phase\n    if (this.phase === \"delete\") {\n      // StaticTypeScriptFile will handle the deletion\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_TS_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate TypeScript code\n    let { code, error } = await extractTypeScriptCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one TypeScript code block inside \\`\\`\\`ts fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractTypeScriptCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid TypeScript code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticTypeScriptFile to create/update the file\n    const file = await StaticTypeScriptFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts TypeScript code from between ```ts fences\n * Validates that exactly one TypeScript code block exists\n *\n * @param text The text to extract TypeScript code from\n * @returns The extracted TypeScript code or error message\n */\nasync function extractTypeScriptCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const tsCodeRegex = /```ts\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(tsCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No TypeScript code block found in the response. Please include your code within ```ts fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple TypeScript code blocks found in the response. Please provide exactly one code block within ```ts fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/vue-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticVueFile } from \"../fs/static-vue-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a VueFile\n */\nexport interface VueFileProps {\n  /**\n   * Path to the Vue file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a Vue component using:\n   *   ${alchemy.file(\"src/api.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return a single Vue component inside ```vue fences\n   * @default \"You are a Vue component generator. Create a single Vue component based on the user's requirements. Your response MUST include only a single Vue component inside ```vue fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A Vue file that can be created, updated, and deleted\n */\nexport interface VueFile extends VueFileProps, Resource<\"ai::VueFile\"> {\n  /**\n   * Content of the Vue file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for Vue file generation\n */\nconst DEFAULT_VUE_SYSTEM_PROMPT =\n  \"You are a Vue component generator. Create a single Vue component based on the user's requirements. Your response MUST include only a single Vue component inside ```vue fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating Vue files using AI models.\n * Extracts Vue code from between ```vue fences and validates the response.\n *\n * @example\n * // Create a simple Vue component\n * const button = await VueFile(\"button-component\", {\n *   path: \"./src/components/Button.vue\",\n *   prompt: await alchemy`\n *     Generate a customizable button Vue component with:\n *     - Primary, secondary, and outline variants\n *     - Small, medium, and large sizes\n *     - Loading state with spinner\n *     - Disabled state\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate a Vue component using existing files as reference\n * const userCard = await VueFile(\"user-card\", {\n *   path: \"./src/components/UserCard.vue\",\n *   prompt: await alchemy`\n *     Create a UserCard Vue component that displays user information.\n *     Follow the styling patterns from:\n *     ${alchemy.file(\"src/components/Card.vue\")}\n *\n *     Use the user type from:\n *     ${alchemy.file(\"src/types/User.ts\")}\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate a complex form component with validation and custom system prompt\n * const form = await VueFile(\"registration-form\", {\n *   path: \"./src/components/RegistrationForm.vue\",\n *   prompt: await alchemy`\n *     Generate a registration form Vue component with:\n *     - Email, password, and confirm password fields\n *     - Form validation using Vuelidate or similar\n *     - Error messages for each field\n *     - Submit handler that emits form data\n *\n *     Follow these style guidelines:\n *     ${alchemy.file(\"src/styles/guidelines.md\")}\n *   `,\n *   system: \"You are an expert Vue component creator specializing in form components with validation. Create a single Vue component inside ```vue fences with no additional text.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const VueFile = Resource(\n  \"ai::VueFile\",\n  async function (\n    this: Context<VueFile>,\n    id: string,\n    props: VueFileProps\n  ): Promise<VueFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_VUE_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate Vue code\n    let { code, error } = await extractVueCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one Vue component inside \\`\\`\\`vue fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractVueCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid Vue code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticVueFile to create/update the file\n    const file = await StaticVueFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts Vue code from between ```vue fences\n * Validates that exactly one Vue code block exists\n *\n * @param text The text to extract Vue code from\n * @returns The extracted Vue code or error message\n */\nasync function extractVueCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const vueCodeRegex = /```vue\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(vueCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No Vue code block found in the response. Please include your code within ```vue fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple Vue code blocks found in the response. Please provide exactly one code block within ```vue fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/yaml-file.ts\n```ts\nimport { generateObject, generateText } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { StaticYamlFile } from \"../fs/static-yaml-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a YAMLFile\n */\nexport interface YAMLFileProps<\n  T extends Type<any, any> | undefined = undefined,\n> {\n  /**\n   * Path to the YAML file\n   */\n  path: string;\n\n  /**\n   * Optional ArkType schema to validate and structure the generated YAML\n   * When provided, the resource will use generateObject with schema validation\n   * When not provided, it will extract YAML from between ```yaml fences\n   */\n  schema?: T;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a YAML configuration for:\n   *   ${alchemy.file(\"src/serverless.js\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * @default Depends on whether schema is provided\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A YAML file that can be created, updated, and deleted\n */\nexport interface YAMLFile<T = any>\n  extends Omit<YAMLFileProps, \"schema\">,\n    Resource<\"ai::YAMLFile\"> {\n  /**\n   * Content of the YAML file as a string\n   */\n  content: string;\n\n  /**\n   * Parsed YAML object\n   */\n  yaml: T;\n\n  /**\n   * Schema used to validate the YAML (if provided)\n   */\n  schema?: JsonSchema;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for YAML file generation without schema\n */\nconst DEFAULT_YAML_SYSTEM_PROMPT =\n  \"You are a YAML generator. Create valid YAML based on the user's requirements. Your response MUST include only YAML inside ```yaml fences. Do not include any other text, explanations, or multiple code blocks. Use standard YAML syntax with proper indentation. Use quotes around strings that contain special characters when necessary.\";\n\n/**\n * Resource for generating YAML files using AI models.\n * Can operate in two modes:\n * 1. With schema: Uses generateObject with type validation, then converts to YAML\n * 2. Without schema: Extracts YAML from between ```yaml fences\n *\n * @example\n * // Generate a serverless configuration file\n * const serverlessConfig = await YAMLFile(\"serverless-config\", {\n *   path: \"./serverless.yml\",\n *   prompt: await alchemy`\n *     Generate a serverless.yml configuration for an AWS Lambda API with:\n *     - A service name \"user-api\"\n *     - Node.js 16.x runtime\n *     - Three functions: createUser, getUser, and listUsers\n *     - API Gateway endpoints for each function\n *     - DynamoDB table for users\n *     - IAM permissions for DynamoDB access\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate YAML with schema validation\n * import { type } from \"arktype\";\n *\n * const k8sConfigSchema = type({\n *   apiVersion: \"string\",\n *   kind: \"string\",\n *   metadata: {\n *     name: \"string\",\n *     namespace: \"string?\",\n *     labels: \"Record<string, string>?\"\n *   },\n *   spec: {\n *     replicas: \"number\",\n *     selector: {\n *       matchLabels: \"Record<string, string>\"\n *     },\n *     template: {\n *       metadata: {\n *         labels: \"Record<string, string>\"\n *       },\n *       spec: {\n *         containers: [{\n *           name: \"string\",\n *           image: \"string\",\n *           ports: [{\n *             containerPort: \"number\"\n *           }]\n *         }]\n *       }\n *     }\n *   }\n * });\n *\n * const deployment = await YAMLFile(\"k8s-deployment\", {\n *   path: \"./kubernetes/deployment.yaml\",\n *   schema: k8sConfigSchema,\n *   prompt: \"Generate a Kubernetes deployment for a web application named 'frontend' with 3 replicas using the nginx:latest image and exposing port 80\",\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate GitHub Actions workflow with custom system prompt\n * const workflow = await YAMLFile(\"github-workflow\", {\n *   path: \"./.github/workflows/ci.yml\",\n *   prompt: await alchemy`\n *     Create a GitHub Actions workflow for a Node.js project that:\n *     - Runs on push to main and pull requests\n *     - Sets up Node.js 18\n *     - Installs dependencies with npm\n *     - Runs linting and tests\n *     - Builds the project\n *     - Deploys to GitHub Pages on success (main branch only)\n *   `,\n *   system: \"You are a DevOps expert specializing in GitHub Actions workflows. Create a single YAML file inside ```yaml fences with no additional text. Follow GitHub Actions best practices and use proper YAML syntax.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const YAMLFile = Resource(\"ai::YAMLFile\", async function <\n  const T extends Type<any, any> | undefined = undefined,\n>(this: Context<YAMLFile<T extends Type<any, any> ? type.infer<T> : any>>, id: string, props: YAMLFileProps<T>): Promise<\n  YAMLFile<T extends Type<any, any> ? type.infer<T> : any>\n> {\n  // Handle deletion phase\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  let yamlContent: string;\n  let yamlObject: any;\n\n  // Check if schema is provided\n  if (props.schema) {\n    // Use schema-based generation\n    const { object } = await generateObject({\n      model: createModel(props),\n      schema: ark.schema<type.infer<typeof props.schema>>(props.schema),\n      providerOptions: props.model?.options,\n      system:\n        props.system ||\n        \"Generate a valid object based on the provided requirements.\",\n      prompt: props.prompt,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    yamlObject = object;\n\n    // Let StaticYamlFile handle the YAML conversion\n    const file = await StaticYamlFile(\"file\", props.path, yamlObject);\n    yamlContent = file.content;\n  } else {\n    // Use fence-based extraction\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_YAML_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate YAML content\n    let { content, error } = await extractYAMLContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one YAML block inside \\`\\`\\`yaml fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractYAMLContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(`Failed to generate valid YAML: ${retryResult.error}`);\n      }\n\n      content = retryResult.content;\n    }\n\n    yamlContent = content;\n\n    // Create the file with the string content\n    const file = await StaticYamlFile(\"file\", props.path, yamlContent);\n\n    // We need to parse the YAML to get the object representation\n    const yaml = await import(\"yaml\");\n    yamlObject = yaml.parse(yamlContent);\n  }\n\n  // Return the resource\n  return this({\n    ...props,\n    schema: props.schema,\n    content: yamlContent,\n    yaml: yamlObject,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  });\n});\n\n/**\n * Extracts YAML content from between ```yaml fences\n * Validates that exactly one YAML code block exists\n *\n * @param text The text to extract YAML from\n * @returns The extracted YAML or error message\n */\nasync function extractYAMLContent(\n  text: string\n): Promise<{ content: string; error?: string }> {\n  // Check for yaml or yml fence blocks\n  const yamlCodeRegex = /```(yaml|yml)\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(yamlCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      content: \"\",\n      error:\n        \"No YAML code block found in the response. Please include your YAML within ```yaml fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      content: \"\",\n      error:\n        \"Multiple YAML code blocks found in the response. Please provide exactly one YAML block within ```yaml fences.\",\n    };\n  }\n\n  const content = matches[0][2].trim();\n\n  // We don't validate YAML parsing here because js-yaml might not be available\n  // Validation will happen at usage time if needed\n  return { content };\n}\n\n```"
      },
      {
        "role": "assistant",
        "content": "{\"groups\":[{\"category\":\"Resource\",\"filename\":\"data.ts\",\"identifier\":\"Data\"},{\"category\":\"Resource\",\"filename\":\"vue-file.ts\",\"identifier\":\"VueFile\"},{\"category\":\"Resource\",\"filename\":\"astro-file.ts\",\"identifier\":\"AstroFile\"},{\"category\":\"Resource\",\"filename\":\"css-file.ts\",\"identifier\":\"CSSFile\"},{\"category\":\"Resource\",\"filename\":\"html-file.ts\",\"identifier\":\"HTMLFile\"},{\"category\":\"Resource\",\"filename\":\"document.ts\",\"identifier\":\"Document\"},{\"category\":\"Resource\",\"filename\":\"yaml-file.ts\",\"identifier\":\"YAMLFile\"},{\"category\":\"Client\",\"filename\":\"client.ts\",\"identifier\":\"createModel\"},{\"category\":\"Resource\",\"filename\":\"typescript-file.ts\",\"identifier\":\"TypeScriptFile\"},{\"category\":\"Utility\",\"filename\":\"ark.ts\",\"identifier\":\"ark\"},{\"category\":\"Resource\",\"filename\":\"json-file.ts\",\"identifier\":\"JSONFile\"}]}"
      }
    ],
    "createdAt": 1744513136657,
    "Kind": "ai::Object",
    "ID": "docs/ai",
    "FQN": "github:alchemy/prod/docs/docs/ai",
    "Seq": 25
  },
  "props": {
    "model": {
      "id": "o3-mini",
      "provider": "openai",
      "options": {
        "reasoningEffort": "high"
      }
    },
    "freeze": true,
    "temperature": 0.1,
    "schema": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "system": "You are a technical writer tasked with identifying the distinct documents that need to be written for a document group (folder) in a documentation site.\nYou will be provided with a list of documents and instructions on how to classify them.\nEach document has a title, file name, and category.\n    \n",
    "prompt": "Identify and classify the documents that need to be written for the '      alchemy/src/ai' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/ai Service has the following resources:\n[data.ts](alchemy/src/ai/data.ts)\n\n[vue-file.ts](alchemy/src/ai/vue-file.ts)\n\n[astro-file.ts](alchemy/src/ai/astro-file.ts)\n\n[css-file.ts](alchemy/src/ai/css-file.ts)\n\n[html-file.ts](alchemy/src/ai/html-file.ts)\n\n[document.ts](alchemy/src/ai/document.ts)\n\n[yaml-file.ts](alchemy/src/ai/yaml-file.ts)\n\n[client.ts](alchemy/src/ai/client.ts)\n\n[typescript-file.ts](alchemy/src/ai/typescript-file.ts)\n\n[ark.ts](alchemy/src/ai/ark.ts)\n\n[json-file.ts](alchemy/src/ai/json-file.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...), or it is the Workflow or DurableObject classes.\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/ai/ark.ts\n```ts\nimport {\n  type Tool as AITool,\n  type Schema,\n  type ToolExecutionOptions,\n  tool as aitool,\n  jsonSchema,\n} from \"ai\";\nimport { ArkErrors, type JsonSchema, type type } from \"arktype\";\n\nexport namespace ark {\n  export function schema<T>(type: JsonSchema): Schema<T>;\n  export function schema<T extends type>(type: T): Schema<type.infer<T>> {\n    const jsonSchemaObj = type.toJsonSchema() as any;\n    const processedSchema = processSchema(jsonSchemaObj);\n\n    return jsonSchema(processedSchema, {\n      validate: (value) => {\n        const out = type(value) as type.infer<T> | type.errors;\n        if (out instanceof ArkErrors) {\n          return {\n            success: false,\n            error: new Error(out.summary),\n          };\n        }\n        return {\n          success: true,\n          value: out,\n        };\n      },\n    });\n  }\n\n  /**\n   * Recursively processes a JSON schema and sets additionalProperties: false\n   * for any object types.\n   *\n   * Structured Outputs requires additionalProperties: false\n   */\n  function processSchema(schema: any): any {\n    if (!schema || typeof schema !== \"object\") return schema;\n\n    // Create a copy to avoid mutating the original\n    const result = { ...schema };\n\n    // Convert anyOf with all const values to enum\n    if (result.anyOf && Array.isArray(result.anyOf)) {\n      const allConst = result.anyOf.every(\n        (item: any) => item && typeof item === \"object\" && \"const\" in item,\n      );\n\n      if (allConst) {\n        // Extract all const values\n        const enumValues = result.anyOf.map((item: any) => item.const);\n\n        // Determine the type based on the first const value\n        // Assuming all const values are of the same type\n        const firstType = typeof enumValues[0];\n\n        // Replace anyOf with enum\n        delete result.anyOf;\n        result.type = firstType;\n        result.enum = enumValues;\n      } else {\n        // Process each item in anyOf\n        result.anyOf = result.anyOf.map(processSchema);\n      }\n    }\n\n    // If this is an object type, set additionalProperties: false\n    if (result.type === \"object\") {\n      result.additionalProperties = false;\n      result.properties ??= {};\n    }\n\n    // Process properties of objects\n    if (result.properties && typeof result.properties === \"object\") {\n      result.properties = Object.fromEntries(\n        Object.entries(result.properties).map(([key, value]) => [\n          key,\n          processSchema(value),\n        ]),\n      );\n    }\n\n    // Process items in arrays\n    if (result.items) {\n      result.items = processSchema(result.items);\n    }\n\n    // Process allOf, oneOf\n    for (const key of [\"allOf\", \"oneOf\"]) {\n      if (Array.isArray(result[key])) {\n        result[key] = result[key].map(processSchema);\n      }\n    }\n\n    return result;\n  }\n\n  export interface Tool<Input extends type, Output>\n    extends Omit<AITool<Schema<type.infer<Input>>>, \"parameters\" | \"execute\"> {\n    description?: string;\n    parameters: Input;\n    execute: (\n      input: type.infer<Input>,\n      options: ToolExecutionOptions,\n    ) => Promise<Output>;\n  }\n\n  export function tool<Input extends type, Output>(\n    tool: Tool<Input, Output>,\n  ): AITool<Schema<type.infer<Input>>, Output> {\n    return aitool({\n      ...tool,\n      parameters: ark.schema<Input>(tool.parameters),\n    } as any);\n  }\n}\n\n```\n\n// alchemy/src/ai/astro-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport prettier from \"prettier\";\nimport type { Context } from \"../context\";\nimport { StaticAstroFile } from \"../fs/static-astro-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating an AstroFile\n */\nexport interface AstroFileProps {\n  /**\n   * Path to the Astro file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate an Astro component using:\n   *   ${alchemy.file(\"src/types.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return Astro code inside ```astro fences\n   * @default \"You are an Astro component generator. Create Astro components based on the user's requirements. Your response MUST include only Astro code inside ```astro fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Prettier configuration to use for formatting the Astro code\n   * If not provided, will use the default Prettier configuration\n   */\n  prettierConfig?: prettier.Options;\n}\n\n/**\n * An Astro file that can be created, updated, and deleted\n */\nexport interface AstroFile extends AstroFileProps, Resource<\"ai::AstroFile\"> {\n  /**\n   * Content of the Astro file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for Astro file generation\n */\nconst DEFAULT_ASTRO_SYSTEM_PROMPT =\n  \"You are an Astro component generator. Create Astro components based on the user's requirements. Your response MUST include only Astro code inside ```astro fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating Astro files using AI models.\n * Extracts Astro code from between ```astro fences, validates the response,\n * and formats the code with Prettier.\n *\n * @example\n * // Create a simple Astro component\n * const header = await AstroFile(\"header\", {\n *   path: \"./src/components/Header.astro\",\n *   prompt: await alchemy`\n *     Generate an Astro header component with:\n *     - Site logo\n *     - Navigation menu with Home, About, Services, Contact links\n *     - Mobile responsive design\n *     - Dark/light mode toggle\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate an Astro page with data fetching\n * const blogPost = await AstroFile(\"blog-post\", {\n *   path: \"./src/pages/blog/[slug].astro\",\n *   prompt: await alchemy`\n *     Create an Astro blog post page that:\n *     - Uses getStaticPaths to generate pages from a CMS\n *     - Renders markdown content\n *     - Includes author info, publication date, and related posts\n *     - Has social sharing buttons\n *\n *     Use the following types:\n *     ${alchemy.file(\"src/types/Blog.ts\")}\n *   `,\n *   temperature: 0.2,\n *   prettierConfig: {\n *     semi: false,\n *     singleQuote: true,\n *     printWidth: 120\n *   }\n * });\n *\n * @example\n * // Generate a layout with custom system prompt\n * const mainLayout = await AstroFile(\"main-layout\", {\n *   path: \"./src/layouts/MainLayout.astro\",\n *   prompt: await alchemy`\n *     Create the main layout for an Astro site that:\n *     - Includes common head metadata and SEO optimization\n *     - Has slots for page content, header, and footer\n *     - Imports and uses the Header and Footer components\n *     - Sets up viewport and responsive configurations\n *   `,\n *   system: \"You are an expert Astro developer. Create a single Astro layout file inside ```astro fences with no additional text. Follow Astro best practices and include proper typing in the frontmatter section.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const AstroFile = Resource(\n  \"ai::AstroFile\",\n  async function (\n    this: Context<AstroFile>,\n    id: string,\n    props: AstroFileProps\n  ): Promise<AstroFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_ASTRO_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate Astro code\n    let { code, error } = await extractAstroCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one Astro code block inside \\`\\`\\`astro fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractAstroCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid Astro code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Format the code with Prettier\n    try {\n      // Set default parser to astro\n      const prettierOptions: prettier.Options = {\n        parser: \"astro\",\n        ...props.prettierConfig,\n      };\n\n      // Format the code\n      code = await prettier.format(code, prettierOptions);\n    } catch (error) {\n      // If Prettier formatting fails, just use the unformatted code\n      console.warn(\"Failed to format Astro code with Prettier:\", error);\n    }\n\n    // Use StaticAstroFile to create/update the file\n    const file = await StaticAstroFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts Astro code from between ```astro fences\n * Validates that exactly one Astro code block exists\n *\n * @param text The text to extract Astro code from\n * @returns The extracted Astro code or error message\n */\nasync function extractAstroCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const astroCodeRegex = /```astro\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(astroCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No Astro code block found in the response. Please include your code within ```astro fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple Astro code blocks found in the response. Please provide exactly one code block within ```astro fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/client.ts\n```ts\nimport { anthropic } from \"@ai-sdk/anthropic\";\nimport { openai } from \"@ai-sdk/openai\";\nimport type { Secret } from \"../secret\";\n\n/**\n * Model configuration for AI operations\n */\nexport interface ModelConfig {\n  /**\n   * Model ID to use\n   * @default 'gpt-4o'\n   */\n  id?: string;\n\n  /**\n   * Model provider name\n   * @default 'openai'\n   */\n  provider?: string;\n\n  /**\n   * Model-specific options\n   */\n  options?: Record<string, any>;\n}\n\n/**\n * Configuration for creating an OpenAI client\n */\nexport interface ClientConfig {\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n}\n\n/**\n * Creates an OpenAI-compatible client with the given configuration\n */\nexport function createModel(config: ClientConfig) {\n  if (config.model?.provider === \"anthropic\") {\n    return anthropic(config.model?.id ?? \"claude-3-7-sonnet-latest\");\n  } else {\n    return openai(config.model?.id ?? \"gpt-4o\");\n  }\n}\n\n/**\n * Maximum time to retry in milliseconds (5 minutes)\n */\nconst MAX_RETRY_TIME = 5 * 60 * 1000;\n\n/**\n * Initial delay between retries in milliseconds\n */\nconst INITIAL_RETRY_DELAY = 1000;\n\n/**\n * Maximum number of retries\n */\nconst MAX_RETRIES = 10;\n\n/**\n * Handles rate limiting with exponential backoff\n * @param fn Function to retry\n * @returns Result of the function\n * @throws Error if max retries or time is exceeded\n */\nexport async function withRateLimitRetry<T>(fn: () => Promise<T>): Promise<T> {\n  let retryCount = 0;\n  let lastError: Error | null = null;\n  let startTime = Date.now();\n\n  while (true) {\n    try {\n      return await fn();\n    } catch (error: any) {\n      lastError = error;\n\n      console.log(\"retry error\", error);\n\n      // Check if we should retry\n      const isRateLimit = error.statusCode === 429;\n      const timeElapsed = Date.now() - startTime;\n      const shouldRetry =\n        isRateLimit && retryCount < MAX_RETRIES && timeElapsed < MAX_RETRY_TIME;\n\n      if (!shouldRetry) {\n        throw error;\n      }\n\n      // Calculate delay with exponential backoff\n      const delay = Math.min(\n        INITIAL_RETRY_DELAY * Math.pow(2, retryCount),\n        MAX_RETRY_TIME - timeElapsed\n      );\n\n      console.log(`Retrying in ${delay}ms`);\n\n      // Wait before retrying\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      retryCount++;\n    }\n  }\n}\n\n```\n\n// alchemy/src/ai/css-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticCSSFile } from \"../fs/static-css-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a CSSFile\n */\nexport interface CSSFileProps {\n  /**\n   * Path to the CSS file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate CSS styles for:\n   *   ${alchemy.file(\"src/components/Button.jsx\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return CSS code inside ```css fences\n   * @default \"You are a CSS code generator. Create CSS code based on the user's requirements. Your response MUST include only CSS code inside ```css fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A CSS file that can be created, updated, and deleted\n */\nexport interface CSSFile extends CSSFileProps, Resource<\"ai::CSSFile\"> {\n  /**\n   * Content of the CSS file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for CSS file generation\n */\nconst DEFAULT_CSS_SYSTEM_PROMPT =\n  \"You are a CSS code generator. Create CSS code based on the user's requirements. Your response MUST include only CSS code inside ```css fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating CSS files using AI models.\n * Extracts CSS code from between ```css fences and validates the response.\n *\n * @example\n * // Create styles for a website\n * const mainStyles = await CSSFile(\"main-styles\", {\n *   path: \"./public/css/main.css\",\n *   prompt: await alchemy`\n *     Generate modern CSS styles for a company website with:\n *     - Clean, minimalist design\n *     - Primary color: #0062ff\n *     - Secondary color: #6c757d\n *     - Light gray background\n *     - Responsive layout for mobile, tablet, and desktop\n *     - Custom styles for buttons, cards, and navigation\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate CSS based on existing HTML\n * const componentStyles = await CSSFile(\"component-styles\", {\n *   path: \"./src/styles/component.css\",\n *   prompt: await alchemy`\n *     Create CSS styles for this HTML component:\n *     ${alchemy.file(\"src/components/Card.html\")}\n *\n *     The styles should be:\n *     - Modern and clean\n *     - Include hover effects and transitions\n *     - Support both light and dark themes\n *     - Use CSS variables for colors and spacing\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate CSS animation with custom system prompt\n * const animationStyles = await CSSFile(\"animations\", {\n *   path: \"./src/styles/animations.css\",\n *   prompt: await alchemy`\n *     Create CSS animations for:\n *     - Fade in/out\n *     - Slide in from different directions\n *     - Pulse effect\n *     - Bounce effect\n *     - Scale in/out\n *     - Rotate\n *\n *     Each animation should be reusable via class names.\n *   `,\n *   system: \"You are an expert CSS animator. Create a single CSS file inside ```css fences with no additional text. Use modern CSS animation techniques and include vendor prefixes where needed for browser compatibility.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const CSSFile = Resource(\n  \"ai::CSSFile\",\n  async function (\n    this: Context<CSSFile>,\n    id: string,\n    props: CSSFileProps\n  ): Promise<CSSFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_CSS_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate CSS code\n    let { code, error } = await extractCSSCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one CSS code block inside \\`\\`\\`css fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractCSSCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid CSS code: ${retryResult.error}\\n${retryText}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticCSSFile to create/update the file\n    const file = await StaticCSSFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts CSS code from between ```css fences\n * Validates that exactly one CSS code block exists\n *\n * @param text The text to extract CSS code from\n * @returns The extracted CSS code or error message\n */\nasync function extractCSSCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const cssCodeRegex = /```css\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(cssCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No CSS code block found in the response. Please include your code within ```css fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple CSS code blocks found in the response. Please provide exactly one code block within ```css fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/data.ts\n```ts\nimport { generateObject, type CoreMessage } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { createModel, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating an AI Object\n */\nexport interface DataProps<T extends Type<any, any>> {\n  /**\n   * The ArkType schema to validate and structure the generated content\n   */\n  schema: T | JsonSchema;\n\n  /**\n   * Prompt for generating the content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a description for:\n   *   ${alchemy.file(\"src/data.ts\")}\n   * `\n   */\n  prompt?: string;\n\n  /**\n   * Message history for the conversation\n   * If provided, this will be used instead of the prompt\n   */\n  messages?: CoreMessage[];\n\n  /**\n   * System prompt to guide the AI's behavior\n   * @example\n   * system: \"You are a technical writer tasked with describing code\"\n   */\n  system?: string;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Whether to freeze the generated object\n   * @default false\n   */\n  freeze?: boolean;\n}\n\n/**\n * A resource that uses AI to generate structured content based on a schema\n */\nexport interface Data<T> extends Resource<\"ai::Object\"> {\n  type: JsonSchema;\n\n  /**\n   * The generated content, typed according to the provided schema\n   */\n  object: T;\n\n  /**\n   * Updated message history with the AI's response appended\n   */\n  messages: CoreMessage[];\n\n  /**\n   * Time at which the content was generated\n   */\n  createdAt: number;\n}\n\n/**\n * Resource for generating structured content using the Vercel AI SDK.\n * Supports powerful context handling through the alchemy template literal tag.\n *\n * @example\n * // Generate a product description with specific fields\n * const productSchema = type({\n *   name: \"string\",\n *   description: \"string\",\n *   features: \"string[]\",\n *   price: \"number\"\n * });\n *\n * const product = await Data(\"new-product\", {\n *   schema: productSchema,\n *   prompt: \"Generate a product description for a new smartphone\",\n *   system: \"You are a product copywriter specializing in tech products\",\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\",\n *     options: {\n *       temperature: 0.7\n *     }\n *   }\n * });\n *\n * console.log(product.object); // Typed as per schema\n *\n * @example\n * // Generate code documentation with context\n * const docSchema = type({\n *   summary: \"string\",\n *   parameters: {\n *     name: \"string\",\n *     type: \"string\",\n *     description: \"string\"\n *   }[],\n *   returns: \"string\"\n * });\n *\n * const docs = await Data(\"function-docs\", {\n *   schema: docSchema,\n *   prompt: await alchemy`\n *     Generate documentation for this function:\n *     ${alchemy.file(\"src/utils/format.ts\")}\n *   `,\n *   system: \"You are a technical documentation writer\",\n *   temperature: 0.2\n * });\n *\n * @example\n * // Using message history for iterative generation\n * const feedbackSchema = type({\n *   rating: \"number\",\n *   positives: \"string[]\",\n *   improvements: \"string[]\",\n *   summary: \"string\"\n * });\n *\n * const feedback = await Data(\"product-feedback\", {\n *   schema: feedbackSchema,\n *   messages: [\n *     { role: \"user\", content: \"I'd like feedback on my product design\" },\n *     { role: \"assistant\", content: \"I'd be happy to provide feedback. What's your product?\" },\n *     { role: \"user\", content: \"It's a new smart home device that...\" }\n *   ],\n *   system: \"You are a product design expert providing structured feedback\",\n *   temperature: 0.3\n * });\n */\nexport const Data = Resource(\"ai::Object\", async function <\n  const T extends Type<any, any>,\n>(this: Context<Data<any>>, id: string, props: DataProps<T>): Promise<\n  Data<type.infer<T>>\n> {\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  // Validate that either prompt or messages is provided\n  if (!props.prompt && !props.messages) {\n    throw new Error(\"Either prompt or messages must be provided\");\n  }\n\n  if (this.phase === \"update\" && props.freeze) {\n    return this(this.output);\n  }\n\n  // Create messages array if only prompt is provided\n  const messages = props.messages || [{ role: \"user\", content: props.prompt! }];\n\n  // Generate structured output using generateObject\n  const { object } = await generateObject({\n    model: createModel(props),\n    // Convert ArkType schema to Zod schema for generateObject\n    // This is needed because generateObject expects a Zod schema\n    schema: ark.schema<type.infer<T>>(props.schema),\n    providerOptions: props.model?.options,\n    system:\n      props.system ||\n      \"You are an AI assistant tasked with generating structured content.\",\n    messages,\n    ...(props.temperature === undefined\n      ? {}\n      : // some models error if you provide it (rather than ignoring it)\n        { temperature: props.temperature }),\n  });\n\n  // Create updated message history with the structured response\n  const responseText = JSON.stringify(object);\n  const updatedMessages = [\n    ...messages,\n    {\n      role: \"assistant\" as const,\n      content: responseText,\n    },\n  ];\n\n  // Return the resource with typed content and updated messages\n  return this({\n    type: props.schema,\n    object: object,\n    messages: updatedMessages,\n    createdAt: Date.now(),\n  });\n});\n\n```\n\n// alchemy/src/ai/document.ts\n```ts\nimport { generateText, type CoreMessage } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticTextFile } from \"../fs/static-text-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createModel, withRateLimitRetry, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating a Document\n */\nexport interface DocumentProps {\n  /**\n   * Title of the document\n   *\n   * @default id\n   */\n  title?: string;\n\n  /**\n   * Optional path to the markdown document\n   * If provided, document will be written to this path\n   */\n  path?: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate docs using:\n   *   ${alchemy.file(\"src/api.ts\")}\n   * `\n   */\n  prompt?: string;\n\n  /**\n   * Message history for conversation-based generation\n   * If provided, this will be used instead of the prompt\n   * @example\n   * messages: [\n   *   { role: \"user\", content: \"Generate API documentation for this file\" },\n   *   { role: \"assistant\", content: \"I'll create detailed API docs. What file should I document?\" },\n   *   { role: \"user\", content: \"Please document src/api.ts\" }\n   * ]\n   */\n  messages?: CoreMessage[];\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return a single markdown document inside ```md fences\n   * @default \"You are a technical documentation writer. Create a single markdown document based on the user's requirements. Your response MUST include only a single markdown document inside ```md fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Maximum number of tokens to generate.\n   * Higher values allow for longer documents but may increase cost and generation time.\n   * @default 10000\n   */\n  maxTokens?: number;\n\n  /**\n   * Freeze the document after creation (do not re-generate on updates)\n   * @default false\n   */\n  freeze?: boolean;\n}\n\n/**\n * A markdown document that can be created, updated, and deleted\n */\nexport interface Document extends DocumentProps, Resource<\"docs::Document\"> {\n  /**\n   * The title of the document\n   */\n  title: string;\n\n  /**\n   * Content of the document\n   */\n  content: string;\n\n  /**\n   * Updated message history with the document response appended\n   */\n  messages: CoreMessage[];\n\n  /**\n   * Time at which the document was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the document was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * File resource if path was provided\n   */\n  file?: StaticTextFile;\n}\n\n/**\n * Default system prompt for markdown document generation\n */\nconst DEFAULT_MD_SYSTEM_PROMPT =\n  \"You are a technical documentation writer. Create a single markdown document based on the user's requirements. Your response MUST include only a single markdown document inside ```md fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for managing AI-generated markdown documents using the Vercel AI SDK.\n * Supports powerful context handling through the alchemy template literal tag.\n *\n * @example\n * // Create an in-memory document (no file created)\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   prompt: await alchemy`\n *     Generate API documentation based on these source files:\n *     ${alchemy.file(\"src/api.ts\")}\n *     ${alchemy.file(\"src/types.ts\")}\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Create a document and write it to disk\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   path: \"./docs/api.md\",\n *   prompt: await alchemy`\n *     Generate API documentation based on these source files:\n *     ${alchemy.file(\"src/api.ts\")}\n *     ${alchemy.file(\"src/types.ts\")}\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Use message history for iterative document generation\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   path: \"./docs/api.md\",\n *   messages: [\n *     { role: \"user\", content: \"Create API documentation for these files\" },\n *     { role: \"assistant\", content: \"I'll help you create API documentation. Please provide the files.\" },\n *     { role: \"user\", content: \"Here are the files: [file contents]\" }\n *   ],\n *   system: \"You are a technical documentation writer. Generate clear and concise API documentation.\",\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Use alchemy template literals with file collections and temperature control\n * const modelDocs = await Document(\"models\", {\n *   title: \"Data Models\",\n *   path: \"./docs/models.md\",\n *   prompt: await alchemy`\n *     Write documentation for these data models:\n *     ${alchemy.files(\"src/models/user.ts\", \"src/models/post.ts\")}\n *   `,\n *   temperature: 0.2 // Lower temperature for more deterministic output\n * });\n *\n * @example\n * // Advanced model configuration with custom provider options and custom system prompt\n * const techDocs = await Document(\"tech-specs\", {\n *   title: \"Technical Specifications\",\n *   path: \"./docs/tech-specs.md\",\n *   prompt: await alchemy`\n *     Create detailed technical specifications based on these requirements:\n *     ${alchemy.file(\"requirements/system.md\")}\n *   `,\n *   system: \"You are an expert technical writer specializing in system specifications. Create a single markdown document inside ```md fences with no additional text.\",\n *   model: {\n *     id: \"o3-mini\",\n *     provider: \"openai\",\n *     options: {\n *       reasoningEffort: \"high\"\n *     }\n *   },\n *   temperature: 0.1\n * });\n */\nexport const Document = Resource(\n  \"docs::Document\",\n  async function (\n    this: Context<Document>,\n    id: string,\n    props: DocumentProps\n  ): Promise<Document> {\n    // Validate that either prompt or messages are provided\n    if (!props.prompt && !props.messages) {\n      throw new Error(\"Either prompt or messages must be provided\");\n    }\n\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    if (this.phase === \"update\" && props.freeze) {\n      if (props.path) {\n        const filePath = props.path;\n        const fileId = `${id}-file`;\n\n        await StaticTextFile(fileId, filePath, this.output!.content);\n      }\n      return this(this.output);\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_MD_SYSTEM_PROMPT;\n\n    // Generate initial content with rate limit retry\n    const { text } = await withRateLimitRetry(async () => {\n      return generateText({\n        model: createModel(props),\n        ...(props.messages\n          ? { messages: props.messages }\n          : { prompt: props.prompt! }),\n        system,\n        maxTokens: props.maxTokens || 8192,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : // some models error if you provide it (rather than ignoring it)\n            { temperature: props.temperature }),\n      });\n    });\n\n    // Extract and validate markdown content\n    let { content, error } = extractMarkdownContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one markdown document inside \\`\\`\\`md fences.`;\n\n      const { text: retryText } = await withRateLimitRetry(async () => {\n        return generateText({\n          model: createModel(props),\n          ...(props.messages\n            ? { messages: props.messages }\n            : { prompt: props.prompt! }),\n          system: errorSystem,\n          providerOptions: props.model?.options,\n          ...(props.temperature === undefined\n            ? {}\n            : { temperature: props.temperature }),\n        });\n      });\n\n      const retryResult = extractMarkdownContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid markdown content: ${retryResult.error}\\n${retryText}`\n        );\n      }\n\n      content = retryResult.content;\n    }\n\n    // Create result object\n    const result: Partial<Document> = {\n      ...props,\n      content,\n      messages: [\n        ...(props.messages || [{ role: \"user\", content: props.prompt! }]),\n        { role: \"assistant\", content },\n      ],\n      createdAt: this.output?.createdAt || Date.now(),\n      updatedAt: Date.now(),\n      title: props.title || id,\n    };\n\n    // Write file if path is provided\n    if (props.path) {\n      const filePath = props.path;\n      const fileId = `${id}-file`;\n\n      result.file = await StaticTextFile(fileId, filePath, content);\n    }\n\n    // Return the resource\n    return this(result as Document);\n  }\n);\n\n/**\n * Extracts markdown content from between ```md fences\n * Validates that exactly one markdown code block exists\n *\n * @param text The text to extract markdown content from\n * @returns The extracted markdown content or error message\n */\nfunction extractMarkdownContent(text: string): {\n  content: string;\n  error?: string;\n} {\n  const lines = text.split(\"\\n\");\n  const startIdx = lines.findIndex((line) => line.trim() === \"```md\");\n\n  if (startIdx === -1) {\n    return {\n      content: \"\",\n      error:\n        \"No markdown code block found in the response. Please include your markdown content within ```md fences.\",\n    };\n  }\n\n  const rest = lines.slice(startIdx + 1);\n  const endRelativeIdx = rest\n    .map((line) => line.trim() === \"```\")\n    .lastIndexOf(true);\n\n  if (endRelativeIdx === -1) {\n    return {\n      content: \"\",\n      error: \"Markdown block was not closed properly.\",\n    };\n  }\n\n  const endIdx = startIdx + 1 + endRelativeIdx;\n\n  const content = lines\n    .slice(startIdx + 1, endIdx)\n    .join(\"\\n\")\n    .trim();\n\n  return { content };\n}\n\n```\n\n// alchemy/src/ai/html-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticHTMLFile } from \"../fs/static-html-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating an HTMLFile\n */\nexport interface HTMLFileProps {\n  /**\n   * Path to the HTML file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate an HTML page using:\n   *   ${alchemy.file(\"src/templates/base.html\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return HTML code inside ```html fences\n   * @default \"You are an HTML code generator. Create HTML code based on the user's requirements. Your response MUST include only HTML code inside ```html fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * An HTML file that can be created, updated, and deleted\n */\nexport interface HTMLFile extends HTMLFileProps, Resource<\"ai::HTMLFile\"> {\n  /**\n   * Content of the HTML file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for HTML file generation\n */\nconst DEFAULT_HTML_SYSTEM_PROMPT =\n  \"You are an HTML code generator. Create HTML code based on the user's requirements. Your response MUST include only HTML code inside ```html fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating HTML files using AI models.\n * Extracts HTML code from between ```html fences and validates the response.\n *\n * @example\n * // Create a simple landing page\n * const landingPage = await HTMLFile(\"landing-page\", {\n *   path: \"./public/index.html\",\n *   prompt: await alchemy`\n *     Generate a modern landing page for a SaaS product with:\n *     - Hero section with headline and call-to-action\n *     - Features section with 3 key features\n *     - Pricing section with 3 tiers\n *     - Testimonials section with 2 customer quotes\n *     - Contact form and footer\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate an HTML email template\n * const emailTemplate = await HTMLFile(\"welcome-email\", {\n *   path: \"./emails/welcome.html\",\n *   prompt: await alchemy`\n *     Create an HTML email template for welcoming new users to our platform.\n *     The email should include:\n *     - Company logo and branding\n *     - Personalized welcome message (use {{name}} placeholder)\n *     - Three steps to get started\n *     - Support contact information\n *     - Unsubscribe footer\n *\n *     Make sure it's responsive and works in all major email clients.\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate an HTML component with custom system prompt\n * const navComponent = await HTMLFile(\"navigation\", {\n *   path: \"./components/nav.html\",\n *   prompt: await alchemy`\n *     Create a responsive navigation component with:\n *     - Logo in the left corner\n *     - Navigation links: Home, Products, Services, About, Contact\n *     - Mobile hamburger menu that expands/collapses\n *     - Login/signup buttons on the right side\n *     - Dark/light mode toggle\n *   `,\n *   system: \"You are an expert HTML/CSS developer specializing in responsive components. Create a single HTML file inside ```html fences with no additional text. Use modern HTML5 semantic elements and inline CSS if needed.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const HTMLFile = Resource(\n  \"ai::HTMLFile\",\n  async function (\n    this: Context<HTMLFile>,\n    id: string,\n    props: HTMLFileProps\n  ): Promise<HTMLFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_HTML_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate HTML code\n    let { code, error } = await extractHTMLCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one HTML code block inside \\`\\`\\`html fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractHTMLCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid HTML code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticHTMLFile to create/update the file\n    const file = await StaticHTMLFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts HTML code from between ```html fences\n * Validates that exactly one HTML code block exists\n *\n * @param text The text to extract HTML code from\n * @returns The extracted HTML code or error message\n */\nasync function extractHTMLCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const htmlCodeRegex = /```html\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(htmlCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No HTML code block found in the response. Please include your code within ```html fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple HTML code blocks found in the response. Please provide exactly one code block within ```html fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/json-file.ts\n```ts\nimport { generateObject, generateText } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { StaticJsonFile } from \"../fs/static-json-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a JSONFile\n */\nexport interface JSONFileProps<\n  T extends Type<any, any> | undefined = undefined,\n> {\n  /**\n   * Path to the JSON file\n   */\n  path: string;\n\n  /**\n   * Optional ArkType schema to validate and structure the generated JSON\n   * When provided, the resource will use generateObject with schema validation\n   * When not provided, it will extract JSON from between ```json fences\n   */\n  schema?: T;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a JSON configuration for:\n   *   ${alchemy.file(\"src/config.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * @default Depends on whether schema is provided\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Whether to pretty-print the JSON with indentation\n   * @default true\n   */\n  pretty?: boolean;\n\n  /**\n   * Number of spaces to use for indentation when pretty-printing\n   * @default 2\n   */\n  indent?: number;\n}\n\n/**\n * A JSON file that can be created, updated, and deleted\n */\nexport interface JSONFile<T = any>\n  extends Omit<JSONFileProps, \"schema\">,\n    Resource<\"ai::JSONFile\"> {\n  /**\n   * Content of the JSON file as a string\n   */\n  content: string;\n\n  /**\n   * Parsed JSON object\n   */\n  json: T;\n\n  /**\n   * Schema used to validate the JSON (if provided)\n   */\n  schema?: JsonSchema;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for JSON file generation without schema\n */\nconst DEFAULT_JSON_SYSTEM_PROMPT =\n  \"You are a JSON generator. Create valid JSON based on the user's requirements. Your response MUST include only JSON inside ```json fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating JSON files using AI models.\n * Can operate in two modes:\n * 1. With schema: Uses generateObject with type validation\n * 2. Without schema: Extracts JSON from between ```json fences\n *\n * @example\n * // Generate a configuration file with freeform JSON\n * const config = await JSONFile(\"app-config\", {\n *   path: \"./config/app.json\",\n *   prompt: await alchemy`\n *     Generate a configuration for a web application with:\n *     - Server settings (port, host, timeout)\n *     - Database connection details (redact any passwords)\n *     - Logging configuration\n *     - Feature flags\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate JSON with schema validation\n * import { type } from \"arktype\";\n *\n * const userSchema = type({\n *   users: [{\n *     id: \"string\",\n *     name: \"string\",\n *     email: \"string\",\n *     role: \"'admin' | 'user' | 'guest'\",\n *     permissions: \"string[]\",\n *     active: \"boolean\"\n *   }]\n * });\n *\n * const userData = await JSONFile(\"user-data\", {\n *   path: \"./data/users.json\",\n *   schema: userSchema,\n *   prompt: \"Generate sample user data for an application with various roles and permissions\",\n *   temperature: 0.2\n * });\n *\n * // Type-safe access to the generated data\n * console.log(userData.json.users[0].role); // Typed as 'admin' | 'user' | 'guest'\n *\n * @example\n * // Generate API mock data with custom system prompt\n * const apiMock = await JSONFile(\"api-mock\", {\n *   path: \"./mocks/products-api.json\",\n *   prompt: await alchemy`\n *     Create mock data for a product catalog API response with:\n *     - 10 products with different categories\n *     - Each product should have id, name, price, category, inventory, and image_url\n *     - Include pagination metadata (total, page, limit)\n *   `,\n *   system: \"You are an API design expert. Create realistic mock JSON data that follows REST API best practices. Your response must be valid JSON inside ```json fences.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   },\n *   pretty: true,\n *   indent: 4\n * });\n */\nexport const JSONFile = Resource(\"ai::JSONFile\", async function <\n  const T extends Type<any, any> | undefined = undefined,\n>(this: Context<JSONFile<T extends Type<any, any> ? type.infer<T> : any>>, id: string, props: JSONFileProps<T>): Promise<\n  JSONFile<T extends Type<any, any> ? type.infer<T> : any>\n> {\n  // Handle deletion phase\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  let jsonContent: string;\n  let jsonObject: any;\n\n  // Check if schema is provided\n  if (props.schema) {\n    // Use schema-based generation\n    const { object } = await generateObject({\n      model: createModel(props),\n      schema: ark.schema<type.infer<typeof props.schema>>(props.schema),\n      providerOptions: props.model?.options,\n      system:\n        props.system ||\n        \"Generate a valid JSON object based on the provided requirements.\",\n      prompt: props.prompt,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    jsonObject = object;\n\n    // Use StaticJsonFile to create the file\n    const file = await StaticJsonFile(\"file\", props.path, jsonObject);\n    jsonContent = file.content;\n  } else {\n    // Use fence-based extraction\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_JSON_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate JSON content\n    let { content, error } = await extractJSONContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one valid JSON block inside \\`\\`\\`json fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractJSONContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(`Failed to generate valid JSON: ${retryResult.error}`);\n      }\n\n      content = retryResult.content;\n    }\n\n    // Parse JSON to get the object representation\n    jsonObject = JSON.parse(content);\n\n    // Use StaticJsonFile to create the file\n    const file = await StaticJsonFile(\"file\", props.path, jsonObject);\n    jsonContent = file.content;\n  }\n\n  // Return the resource\n  return this({\n    ...props,\n    schema: props.schema,\n    content: jsonContent,\n    json: jsonObject,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  });\n});\n\n/**\n * Extracts JSON content from between ```json fences\n * Validates that exactly one JSON code block exists\n *\n * @param text The text to extract JSON from\n * @returns The extracted JSON or error message\n */\nasync function extractJSONContent(\n  text: string\n): Promise<{ content: string; error?: string }> {\n  const jsonCodeRegex = /```json\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(jsonCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      content: \"\",\n      error:\n        \"No JSON code block found in the response. Please include your JSON within ```json fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      content: \"\",\n      error:\n        \"Multiple JSON code blocks found in the response. Please provide exactly one JSON block within ```json fences.\",\n    };\n  }\n\n  const content = matches[0][1].trim();\n\n  // Validate JSON can be parsed\n  try {\n    JSON.parse(content);\n    return { content };\n  } catch (e) {\n    return {\n      content: \"\",\n      error: `Invalid JSON: ${(e as Error).message}. Please provide valid JSON syntax.`,\n    };\n  }\n}\n\n```\n\n// alchemy/src/ai/typescript-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticTypeScriptFile } from \"../fs/static-typescript-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createModel, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating a TypeScriptFile\n */\nexport interface TypeScriptFileProps {\n  /**\n   * Path to the TypeScript file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a TypeScript utility function using:\n   *   ${alchemy.file(\"src/types.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return TypeScript code inside ```ts fences\n   * @default \"You are a TypeScript code generator. Create TypeScript code based on the user's requirements. Your response MUST include only TypeScript code inside ```ts fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Prettier configuration to use for formatting the TypeScript code\n   * If not provided, will use the default Prettier configuration\n   */\n  prettierConfig?: object;\n}\n\n/**\n * A TypeScript file that can be created, updated, and deleted\n */\nexport interface TypeScriptFile\n  extends TypeScriptFileProps,\n    Resource<\"ai::TypeScriptFile\"> {\n  /**\n   * Content of the TypeScript file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for TypeScript file generation\n */\nconst DEFAULT_TS_SYSTEM_PROMPT =\n  \"You are a TypeScript code generator. Create TypeScript code based on the user's requirements. Your response MUST include only TypeScript code inside ```ts fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating TypeScript files using AI models.\n * Extracts TypeScript code from between ```ts fences, validates the response,\n * and formats the code with Prettier.\n *\n * @example\n * // Create a utility function\n * const utils = await TypeScriptFile(\"string-utils\", {\n *   path: \"./src/utils/string-utils.ts\",\n *   prompt: await alchemy`\n *     Generate TypeScript utility functions for string manipulation:\n *     - Capitalize first letter\n *     - Truncate with ellipsis\n *     - Convert to camelCase and kebab-case\n *     - Remove special characters\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate a TypeScript class with custom formatting\n * const userService = await TypeScriptFile(\"user-service\", {\n *   path: \"./src/services/UserService.ts\",\n *   prompt: await alchemy`\n *     Create a UserService class that handles user authentication and profile management.\n *     The service should use the User type from:\n *     ${alchemy.file(\"src/types/User.ts\")}\n *\n *     Include methods for:\n *     - login(email, password)\n *     - register(user)\n *     - updateProfile(userId, profileData)\n *     - deleteAccount(userId)\n *   `,\n *   temperature: 0.2,\n *   prettierConfig: {\n *     semi: false,\n *     singleQuote: true,\n *     printWidth: 120\n *   }\n * });\n *\n * @example\n * // Generate a React hook with custom system prompt\n * const useFormHook = await TypeScriptFile(\"use-form\", {\n *   path: \"./src/hooks/useForm.ts\",\n *   prompt: await alchemy`\n *     Create a custom React hook called useForm that handles form state, validation, and submission.\n *     It should support:\n *     - Initial values\n *     - Validation rules\n *     - Field errors\n *     - Form submission with loading state\n *     - Reset functionality\n *   `,\n *   system: \"You are an expert React developer specializing in TypeScript hooks. Create a single TypeScript file inside ```ts fences with no additional text. Follow React best practices and include proper typing.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const TypeScriptFile = Resource(\n  \"ai::TypeScriptFile\",\n  async function (\n    this: Context<TypeScriptFile>,\n    id: string,\n    props: TypeScriptFileProps\n  ): Promise<TypeScriptFile> {\n    // Handle delete phase\n    if (this.phase === \"delete\") {\n      // StaticTypeScriptFile will handle the deletion\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_TS_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate TypeScript code\n    let { code, error } = await extractTypeScriptCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one TypeScript code block inside \\`\\`\\`ts fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractTypeScriptCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid TypeScript code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticTypeScriptFile to create/update the file\n    const file = await StaticTypeScriptFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts TypeScript code from between ```ts fences\n * Validates that exactly one TypeScript code block exists\n *\n * @param text The text to extract TypeScript code from\n * @returns The extracted TypeScript code or error message\n */\nasync function extractTypeScriptCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const tsCodeRegex = /```ts\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(tsCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No TypeScript code block found in the response. Please include your code within ```ts fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple TypeScript code blocks found in the response. Please provide exactly one code block within ```ts fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/vue-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticVueFile } from \"../fs/static-vue-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a VueFile\n */\nexport interface VueFileProps {\n  /**\n   * Path to the Vue file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a Vue component using:\n   *   ${alchemy.file(\"src/api.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return a single Vue component inside ```vue fences\n   * @default \"You are a Vue component generator. Create a single Vue component based on the user's requirements. Your response MUST include only a single Vue component inside ```vue fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A Vue file that can be created, updated, and deleted\n */\nexport interface VueFile extends VueFileProps, Resource<\"ai::VueFile\"> {\n  /**\n   * Content of the Vue file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for Vue file generation\n */\nconst DEFAULT_VUE_SYSTEM_PROMPT =\n  \"You are a Vue component generator. Create a single Vue component based on the user's requirements. Your response MUST include only a single Vue component inside ```vue fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating Vue files using AI models.\n * Extracts Vue code from between ```vue fences and validates the response.\n *\n * @example\n * // Create a simple Vue component\n * const button = await VueFile(\"button-component\", {\n *   path: \"./src/components/Button.vue\",\n *   prompt: await alchemy`\n *     Generate a customizable button Vue component with:\n *     - Primary, secondary, and outline variants\n *     - Small, medium, and large sizes\n *     - Loading state with spinner\n *     - Disabled state\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate a Vue component using existing files as reference\n * const userCard = await VueFile(\"user-card\", {\n *   path: \"./src/components/UserCard.vue\",\n *   prompt: await alchemy`\n *     Create a UserCard Vue component that displays user information.\n *     Follow the styling patterns from:\n *     ${alchemy.file(\"src/components/Card.vue\")}\n *\n *     Use the user type from:\n *     ${alchemy.file(\"src/types/User.ts\")}\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate a complex form component with validation and custom system prompt\n * const form = await VueFile(\"registration-form\", {\n *   path: \"./src/components/RegistrationForm.vue\",\n *   prompt: await alchemy`\n *     Generate a registration form Vue component with:\n *     - Email, password, and confirm password fields\n *     - Form validation using Vuelidate or similar\n *     - Error messages for each field\n *     - Submit handler that emits form data\n *\n *     Follow these style guidelines:\n *     ${alchemy.file(\"src/styles/guidelines.md\")}\n *   `,\n *   system: \"You are an expert Vue component creator specializing in form components with validation. Create a single Vue component inside ```vue fences with no additional text.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const VueFile = Resource(\n  \"ai::VueFile\",\n  async function (\n    this: Context<VueFile>,\n    id: string,\n    props: VueFileProps\n  ): Promise<VueFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_VUE_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate Vue code\n    let { code, error } = await extractVueCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one Vue component inside \\`\\`\\`vue fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractVueCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid Vue code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticVueFile to create/update the file\n    const file = await StaticVueFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts Vue code from between ```vue fences\n * Validates that exactly one Vue code block exists\n *\n * @param text The text to extract Vue code from\n * @returns The extracted Vue code or error message\n */\nasync function extractVueCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const vueCodeRegex = /```vue\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(vueCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No Vue code block found in the response. Please include your code within ```vue fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple Vue code blocks found in the response. Please provide exactly one code block within ```vue fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/yaml-file.ts\n```ts\nimport { generateObject, generateText } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { StaticYamlFile } from \"../fs/static-yaml-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a YAMLFile\n */\nexport interface YAMLFileProps<\n  T extends Type<any, any> | undefined = undefined,\n> {\n  /**\n   * Path to the YAML file\n   */\n  path: string;\n\n  /**\n   * Optional ArkType schema to validate and structure the generated YAML\n   * When provided, the resource will use generateObject with schema validation\n   * When not provided, it will extract YAML from between ```yaml fences\n   */\n  schema?: T;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a YAML configuration for:\n   *   ${alchemy.file(\"src/serverless.js\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * @default Depends on whether schema is provided\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A YAML file that can be created, updated, and deleted\n */\nexport interface YAMLFile<T = any>\n  extends Omit<YAMLFileProps, \"schema\">,\n    Resource<\"ai::YAMLFile\"> {\n  /**\n   * Content of the YAML file as a string\n   */\n  content: string;\n\n  /**\n   * Parsed YAML object\n   */\n  yaml: T;\n\n  /**\n   * Schema used to validate the YAML (if provided)\n   */\n  schema?: JsonSchema;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for YAML file generation without schema\n */\nconst DEFAULT_YAML_SYSTEM_PROMPT =\n  \"You are a YAML generator. Create valid YAML based on the user's requirements. Your response MUST include only YAML inside ```yaml fences. Do not include any other text, explanations, or multiple code blocks. Use standard YAML syntax with proper indentation. Use quotes around strings that contain special characters when necessary.\";\n\n/**\n * Resource for generating YAML files using AI models.\n * Can operate in two modes:\n * 1. With schema: Uses generateObject with type validation, then converts to YAML\n * 2. Without schema: Extracts YAML from between ```yaml fences\n *\n * @example\n * // Generate a serverless configuration file\n * const serverlessConfig = await YAMLFile(\"serverless-config\", {\n *   path: \"./serverless.yml\",\n *   prompt: await alchemy`\n *     Generate a serverless.yml configuration for an AWS Lambda API with:\n *     - A service name \"user-api\"\n *     - Node.js 16.x runtime\n *     - Three functions: createUser, getUser, and listUsers\n *     - API Gateway endpoints for each function\n *     - DynamoDB table for users\n *     - IAM permissions for DynamoDB access\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate YAML with schema validation\n * import { type } from \"arktype\";\n *\n * const k8sConfigSchema = type({\n *   apiVersion: \"string\",\n *   kind: \"string\",\n *   metadata: {\n *     name: \"string\",\n *     namespace: \"string?\",\n *     labels: \"Record<string, string>?\"\n *   },\n *   spec: {\n *     replicas: \"number\",\n *     selector: {\n *       matchLabels: \"Record<string, string>\"\n *     },\n *     template: {\n *       metadata: {\n *         labels: \"Record<string, string>\"\n *       },\n *       spec: {\n *         containers: [{\n *           name: \"string\",\n *           image: \"string\",\n *           ports: [{\n *             containerPort: \"number\"\n *           }]\n *         }]\n *       }\n *     }\n *   }\n * });\n *\n * const deployment = await YAMLFile(\"k8s-deployment\", {\n *   path: \"./kubernetes/deployment.yaml\",\n *   schema: k8sConfigSchema,\n *   prompt: \"Generate a Kubernetes deployment for a web application named 'frontend' with 3 replicas using the nginx:latest image and exposing port 80\",\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate GitHub Actions workflow with custom system prompt\n * const workflow = await YAMLFile(\"github-workflow\", {\n *   path: \"./.github/workflows/ci.yml\",\n *   prompt: await alchemy`\n *     Create a GitHub Actions workflow for a Node.js project that:\n *     - Runs on push to main and pull requests\n *     - Sets up Node.js 18\n *     - Installs dependencies with npm\n *     - Runs linting and tests\n *     - Builds the project\n *     - Deploys to GitHub Pages on success (main branch only)\n *   `,\n *   system: \"You are a DevOps expert specializing in GitHub Actions workflows. Create a single YAML file inside ```yaml fences with no additional text. Follow GitHub Actions best practices and use proper YAML syntax.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const YAMLFile = Resource(\"ai::YAMLFile\", async function <\n  const T extends Type<any, any> | undefined = undefined,\n>(this: Context<YAMLFile<T extends Type<any, any> ? type.infer<T> : any>>, id: string, props: YAMLFileProps<T>): Promise<\n  YAMLFile<T extends Type<any, any> ? type.infer<T> : any>\n> {\n  // Handle deletion phase\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  let yamlContent: string;\n  let yamlObject: any;\n\n  // Check if schema is provided\n  if (props.schema) {\n    // Use schema-based generation\n    const { object } = await generateObject({\n      model: createModel(props),\n      schema: ark.schema<type.infer<typeof props.schema>>(props.schema),\n      providerOptions: props.model?.options,\n      system:\n        props.system ||\n        \"Generate a valid object based on the provided requirements.\",\n      prompt: props.prompt,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    yamlObject = object;\n\n    // Let StaticYamlFile handle the YAML conversion\n    const file = await StaticYamlFile(\"file\", props.path, yamlObject);\n    yamlContent = file.content;\n  } else {\n    // Use fence-based extraction\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_YAML_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate YAML content\n    let { content, error } = await extractYAMLContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one YAML block inside \\`\\`\\`yaml fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractYAMLContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(`Failed to generate valid YAML: ${retryResult.error}`);\n      }\n\n      content = retryResult.content;\n    }\n\n    yamlContent = content;\n\n    // Create the file with the string content\n    const file = await StaticYamlFile(\"file\", props.path, yamlContent);\n\n    // We need to parse the YAML to get the object representation\n    const yaml = await import(\"yaml\");\n    yamlObject = yaml.parse(yamlContent);\n  }\n\n  // Return the resource\n  return this({\n    ...props,\n    schema: props.schema,\n    content: yamlContent,\n    yaml: yamlObject,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  });\n});\n\n/**\n * Extracts YAML content from between ```yaml fences\n * Validates that exactly one YAML code block exists\n *\n * @param text The text to extract YAML from\n * @returns The extracted YAML or error message\n */\nasync function extractYAMLContent(\n  text: string\n): Promise<{ content: string; error?: string }> {\n  // Check for yaml or yml fence blocks\n  const yamlCodeRegex = /```(yaml|yml)\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(yamlCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      content: \"\",\n      error:\n        \"No YAML code block found in the response. Please include your YAML within ```yaml fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      content: \"\",\n      error:\n        \"Multiple YAML code blocks found in the response. Please provide exactly one YAML block within ```yaml fences.\",\n    };\n  }\n\n  const content = matches[0][2].trim();\n\n  // We don't validate YAML parsing here because js-yaml might not be available\n  // Validation will happen at usage time if needed\n  return { content };\n}\n\n```"
  }
}