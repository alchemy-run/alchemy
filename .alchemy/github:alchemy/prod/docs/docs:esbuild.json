{
  "kind": "ai::Object",
  "id": "docs/esbuild",
  "fqn": "github:alchemy/prod/docs/docs/esbuild",
  "seq": 51,
  "data": {},
  "status": "updated",
  "output": {
    "type": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "object": {
      "groups": [
        {
          "category": "Resource",
          "filename": "bundle.ts",
          "identifier": "Bundle"
        }
      ]
    },
    "messages": [
      {
        "role": "user",
        "content": "Identify and classify the documents that need to be written for the '      alchemy/src/esbuild' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/esbuild Service has the following resources:\n[bundle.ts](alchemy/src/esbuild/bundle.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...).\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/esbuild/bundle.ts\n```ts\nimport * as esbuild from \"esbuild\";\nimport crypto from \"node:crypto\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating an esbuild bundle\n */\nexport interface BundleProps {\n  /**\n   * Entry point for the bundle\n   * Path to the source file to bundle (e.g., \"src/handler.ts\")\n   */\n  entryPoint: string;\n\n  /**\n   * Output directory for the bundle\n   * Directory where the bundled file will be written\n   */\n  outdir?: string;\n\n  /**\n   * Output filename for the bundle\n   * Full path to the output file, overrides outdir if specified\n   */\n  outfile?: string;\n\n  /**\n   * Bundle format\n   * iife: Immediately Invoked Function Expression\n   * cjs: CommonJS\n   * esm: ECMAScript Modules\n   */\n  format?: \"iife\" | \"cjs\" | \"esm\";\n\n  /**\n   * Target environment\n   * Examples: 'node16', 'node18', 'es2020'\n   */\n  target?: string | string[];\n\n  /**\n   * Whether to minify the output\n   */\n  minify?: boolean;\n\n  /**\n   * Whether to generate sourcemaps\n   * inline: Include sourcemap in bundle\n   * external: Generate separate .map file\n   * both: Generate both inline and external\n   */\n  sourcemap?: boolean | \"inline\" | \"external\" | \"both\";\n\n  /**\n   * External packages to exclude from bundle\n   * Array of package names to mark as external\n   */\n  external?: string[];\n\n  /**\n   * Platform to target\n   * browser: Browser environment\n   * node: Node.js environment\n   * neutral: Platform-agnostic\n   */\n  platform?: \"browser\" | \"node\" | \"neutral\";\n\n  /**\n   * Additional esbuild options\n   * Any other valid esbuild BuildOptions\n   */\n  options?: Partial<esbuild.BuildOptions>;\n}\n\n/**\n * Output returned after bundle creation/update\n */\nexport interface Bundle extends Resource<\"esbuild::Bundle\"> {\n  /**\n   * Path to the bundled file\n   * Absolute or relative path to the generated bundle\n   */\n  path: string;\n\n  /**\n   * SHA-256 hash of the bundle contents\n   * Used for cache busting and content verification\n   */\n  hash: string;\n}\n\n/**\n * esbuild Bundle Resource\n *\n * Creates and manages bundled JavaScript/TypeScript files using esbuild.\n * Supports various output formats, sourcemaps, and platform targets.\n *\n * @example\n * // Bundle a TypeScript file for Node.js\n * const bundle = await Bundle(\"handler\", {\n *   entryPoint: \"src/handler.ts\",\n *   outdir: \".alchemy/.out\",\n *   format: \"esm\",\n *   platform: \"node\",\n *   target: \"node18\"\n * });\n */\nexport const Bundle = Resource(\n  \"esbuild::Bundle\",\n  {\n    alwaysUpdate: true,\n  },\n  async function (\n    this: Context<Bundle>,\n    id: string,\n    props: BundleProps,\n  ): Promise<Bundle> {\n    // Determine output path\n    const outputPath = getOutputPath(props);\n\n    // Ensure output directory exists\n    await fs.promises.mkdir(path.dirname(outputPath), { recursive: true });\n\n    if (this.phase === \"delete\") {\n      await fs.promises.unlink(outputPath).catch(() => {});\n      // Also clean up sourcemap if it exists\n      await fs.promises.unlink(outputPath + \".map\").catch(() => {});\n      return this.destroy();\n    }\n\n    const result = await bundle(props);\n    // Calculate hash of the output\n    const contents = await fs.promises.readFile(outputPath);\n    const hash = crypto.createHash(\"sha256\").update(contents).digest(\"hex\");\n\n    // Store metadata in context\n    await this.set(\"metafile\", result.metafile);\n    await this.set(\"hash\", hash);\n\n    // Return output info\n    return this({\n      path: outputPath,\n      hash,\n    });\n  },\n);\n\nexport async function bundle(props: BundleProps) {\n  const outputPath = getOutputPath(props);\n  // Build the bundle\n  return await esbuild.build({\n    entryPoints: [props.entryPoint],\n    outfile: outputPath,\n    bundle: true,\n    format: props.format,\n    target: props.target,\n    minify: props.minify,\n    sourcemap: props.sourcemap,\n    external: props.external,\n    platform: props.platform,\n    metafile: true,\n    write: true,\n    ...props.options,\n  });\n}\n\nfunction getOutputPath(props: BundleProps) {\n  return (\n    props.outfile ||\n    path.join(\n      props.outdir || \"dist\",\n      path.basename(props.entryPoint, path.extname(props.entryPoint)) + \".js\",\n    )\n  );\n}\n\n```"
      },
      {
        "role": "assistant",
        "content": "{\"groups\":[{\"category\":\"Resource\",\"filename\":\"bundle.ts\",\"identifier\":\"Bundle\"}]}"
      }
    ],
    "createdAt": 1744513377290,
    "Kind": "ai::Object",
    "ID": "docs/esbuild",
    "FQN": "github:alchemy/prod/docs/docs/esbuild",
    "Seq": 51
  },
  "props": {
    "model": {
      "id": "o3-mini",
      "provider": "openai",
      "options": {
        "reasoningEffort": "high"
      }
    },
    "freeze": true,
    "temperature": 0.1,
    "schema": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "system": "You are a technical writer tasked with identifying the distinct documents that need to be written for a document group (folder) in a documentation site.\nYou will be provided with a list of documents and instructions on how to classify them.\nEach document has a title, file name, and category.\n    \n",
    "prompt": "Identify and classify the documents that need to be written for the '      alchemy/src/esbuild' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/esbuild Service has the following resources:\n[bundle.ts](alchemy/src/esbuild/bundle.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...), or it is the Workflow or DurableObject classes.\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/esbuild/bundle.ts\n```ts\nimport * as esbuild from \"esbuild\";\nimport crypto from \"node:crypto\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating an esbuild bundle\n */\nexport interface BundleProps {\n  /**\n   * Entry point for the bundle\n   * Path to the source file to bundle (e.g., \"src/handler.ts\")\n   */\n  entryPoint: string;\n\n  /**\n   * Output directory for the bundle\n   * Directory where the bundled file will be written\n   */\n  outdir?: string;\n\n  /**\n   * Output filename for the bundle\n   * Full path to the output file, overrides outdir if specified\n   */\n  outfile?: string;\n\n  /**\n   * Bundle format\n   * iife: Immediately Invoked Function Expression\n   * cjs: CommonJS\n   * esm: ECMAScript Modules\n   */\n  format?: \"iife\" | \"cjs\" | \"esm\";\n\n  /**\n   * Target environment\n   * Examples: 'node16', 'node18', 'es2020'\n   */\n  target?: string | string[];\n\n  /**\n   * Whether to minify the output\n   */\n  minify?: boolean;\n\n  /**\n   * Whether to generate sourcemaps\n   * inline: Include sourcemap in bundle\n   * external: Generate separate .map file\n   * both: Generate both inline and external\n   */\n  sourcemap?: boolean | \"inline\" | \"external\" | \"both\";\n\n  /**\n   * External packages to exclude from bundle\n   * Array of package names to mark as external\n   */\n  external?: string[];\n\n  /**\n   * Platform to target\n   * browser: Browser environment\n   * node: Node.js environment\n   * neutral: Platform-agnostic\n   */\n  platform?: \"browser\" | \"node\" | \"neutral\";\n\n  /**\n   * Additional esbuild options\n   * Any other valid esbuild BuildOptions\n   */\n  options?: Partial<esbuild.BuildOptions>;\n}\n\n/**\n * Output returned after bundle creation/update\n */\nexport interface Bundle extends Resource<\"esbuild::Bundle\"> {\n  /**\n   * Path to the bundled file\n   * Absolute or relative path to the generated bundle\n   */\n  path: string;\n\n  /**\n   * SHA-256 hash of the bundle contents\n   * Used for cache busting and content verification\n   */\n  hash: string;\n}\n\n/**\n * esbuild Bundle Resource\n *\n * Creates and manages bundled JavaScript/TypeScript files using esbuild.\n * Supports various output formats, sourcemaps, and platform targets.\n *\n * @example\n * // Bundle a TypeScript file for Node.js\n * const bundle = await Bundle(\"handler\", {\n *   entryPoint: \"src/handler.ts\",\n *   outdir: \".alchemy/.out\",\n *   format: \"esm\",\n *   platform: \"node\",\n *   target: \"node18\"\n * });\n */\nexport const Bundle = Resource(\n  \"esbuild::Bundle\",\n  {\n    alwaysUpdate: true,\n  },\n  async function (\n    this: Context<Bundle>,\n    id: string,\n    props: BundleProps\n  ): Promise<Bundle> {\n    // Determine output path\n    const outDirPath =\n      props.outfile != null ? path.dirname(props.outfile) : props.outdir;\n\n    if (outDirPath == null) {\n      throw new Error(\n        `You need to specify either outfile or outdir in your bundle configuration ${JSON.stringify(props)}`\n      );\n    }\n\n    // Ensure output directory exists\n    await fs.promises.mkdir(path.dirname(outDirPath), { recursive: true });\n    if (this.phase === \"delete\") {\n      await fs.promises.rm(outDirPath, { recursive: true });\n    }\n\n    const result = await bundle(props);\n    // Check that bundle created output an file for the given entrypoint\n    // Use bundle metada data to retrieve its content\n    const bundleOutputPath = Object.entries(result.metafile.outputs).find(\n      ([file, output]) => {\n        if (output.entryPoint === undefined) {\n          return false;\n        }\n        // resolve to absolute and then relative to ensure consistent result (e.g. ./src/handler.ts instead of src/handler.ts)\n        const relativeOutput = path.relative(\n          process.cwd(),\n          path.resolve(output.entryPoint)\n        );\n        return (\n          relativeOutput ===\n          path.relative(\n            process.cwd(),\n            path.resolve(process.cwd(), props.entryPoint)\n          )\n        );\n      }\n    )?.[0];\n\n    if (!bundleOutputPath) {\n      throw new Error(`Unable to find a compiled file`);\n    }\n\n    // Calculate hash of the output\n    const bundleOutputContent = await fs.promises.readFile(bundleOutputPath);\n    const hash = crypto\n      .createHash(\"sha256\")\n      .update(bundleOutputContent)\n      .digest(\"hex\");\n\n    // Store metadata in context\n    await this.set(\"metafile\", result.metafile);\n    await this.set(\"hash\", hash);\n\n    // Return output info\n    return this({\n      path: bundleOutputPath,\n      hash,\n    });\n  }\n);\n\nexport async function bundle(props: BundleProps) {\n  return await esbuild.build({\n    ...props.options,\n    entryPoints: [props.entryPoint],\n    outdir: props.outdir,\n    outfile: props.outfile,\n    bundle: true,\n    format: props.format,\n    target: props.target,\n    minify: props.minify,\n    sourcemap: props.sourcemap,\n    external: [\n      \"node:async_hooks\",\n      ...(props.external ?? []),\n      ...(props.options?.external ?? []),\n    ],\n    platform: props.platform,\n    metafile: true,\n    write: true,\n  });\n}\n\n```"
  }
}