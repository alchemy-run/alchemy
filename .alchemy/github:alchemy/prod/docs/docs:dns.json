{
  "kind": "ai::Object",
  "id": "docs/dns",
  "fqn": "github:alchemy/prod/docs/docs/dns",
  "seq": 52,
  "data": {},
  "status": "updated",
  "output": {
    "type": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "object": {
      "groups": [
        {
          "category": "Types",
          "filename": "record.ts",
          "identifier": "DnsRecordType"
        },
        {
          "category": "Utility",
          "filename": "godaddy.ts",
          "identifier": "updateNameservers"
        },
        {
          "category": "Resource",
          "filename": "import-dns.ts",
          "identifier": "ImportDnsRecords"
        }
      ]
    },
    "messages": [
      {
        "role": "user",
        "content": "Identify and classify the documents that need to be written for the '      alchemy/src/dns' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/dns Service has the following resources:\n[record.ts](alchemy/src/dns/record.ts)\n\n[godaddy.ts](alchemy/src/dns/godaddy.ts)\n\n[import-dns.ts](alchemy/src/dns/import-dns.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...).\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/dns/godaddy.ts\n```ts\nexport type UpdateNameserversOptions = {\n  domain: string;\n  apiKey: string;\n  apiSecret: string;\n  nameservers: string[];\n};\n\nexport async function updateNameservers(options: UpdateNameserversOptions) {\n  const url = `https://api.godaddy.com/v1/domains/${options.domain}/nameservers`;\n\n  const response = await fetch(url, {\n    method: \"PUT\",\n    headers: {\n      Authorization: `sso-key ${options.apiKey}:${options.apiSecret}`,\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\",\n    },\n    body: JSON.stringify({\n      nameservers: options.nameservers,\n    }),\n  });\n\n  if (response.ok) {\n    console.log(`✅ Nameservers updated for ${options.domain}`);\n  } else {\n    const error = await response.json();\n    console.error(`❌ Failed to update nameservers:`, error);\n  }\n}\n\n```\n\n// alchemy/src/dns/import-dns.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { DEFAULT_RECORD_TYPES, type DnsRecordType } from \"./record\";\n\n/**\n * DNS record response structure from Cloudflare DNS API\n * with both data (original) and content (for compatibility)\n */\nexport interface DnsApiRecord {\n  name: string;\n  type: DnsRecordType;\n  TTL: number;\n  data: string;\n  content: string; // Added for compatibility with DnsRecords\n  ttl: number; // Normalized ttl (lowercase)\n  priority?: number; // Priority for MX and SRV records\n}\n\n/**\n * Cloudflare DNS-over-HTTPS API response structure\n */\ninterface CloudflareDNSResponse {\n  Status: number;\n  TC: boolean;\n  RD: boolean;\n  RA: boolean;\n  AD: boolean;\n  CD: boolean;\n  Question: Array<{\n    name: string;\n    type: number;\n  }>;\n  Answer?: {\n    name: string;\n    type: number;\n    TTL: number;\n    data: string;\n  }[];\n}\n\n/**\n * Properties for importing DNS records\n */\nexport interface ImportDnsRecordsProps {\n  /**\n   * The domain to fetch DNS records for\n   */\n  domain: string;\n\n  /**\n   * Specific record types to fetch. If not provided, defaults to all supported types.\n   */\n  recordTypes?: DnsRecordType[];\n\n  /**\n   * Bump the resource to force a new import\n   */\n  bump?: number;\n}\n\n/**\n * Output returned after DNS records import\n */\nexport interface ImportDnsRecords\n  extends Resource<\"dns::ImportDnsRecords\">,\n    ImportDnsRecordsProps {\n  /**\n   * The DNS records as a flat array, directly compatible with DnsRecords function\n   */\n  records: DnsApiRecord[];\n\n  /**\n   * Time at which the records were imported\n   */\n  importedAt: number;\n}\n\n/**\n * Map numeric DNS record type to string type\n */\nfunction mapDnsRecordType(type: number): DnsRecordType {\n  const typeMap: Record<number, DnsRecordType> = {\n    1: \"A\",\n    2: \"NS\",\n    5: \"CNAME\",\n    6: \"SOA\",\n    15: \"MX\",\n    16: \"TXT\",\n    28: \"AAAA\",\n    33: \"SRV\",\n    12: \"PTR\",\n  };\n\n  return typeMap[type] || \"A\";\n}\n\n/**\n * Import DNS records for a domain using Cloudflare's DNS-over-HTTPS API.\n * This resource allows you to fetch DNS records for a domain and store them\n * in a structured format.\n *\n * @example\n * // Import all default record types\n * const allRecords = await ImportDnsRecords(\"example.com\", {\n *   domain: \"example.com\"\n * });\n *\n * @example\n * // Import only specific record types\n * const specificRecords = await ImportDnsRecords(\"example.com\", {\n *   domain: \"example.com\",\n *   recordTypes: [\"A\", \"MX\"]\n * });\n *\n * @example\n * // Import DNS records and transfer them to a Cloudflare zone\n * const dnsRecords = await ImportDnsRecords(\"dns-records\", {\n *   domain: \"example.com\",\n * });\n *\n * const zone = await Zone(\"example.com\", {\n *   name: \"example.com\",\n *   type: \"full\",\n * });\n *\n * // Records are directly compatible with DnsRecords function\n * await DnsRecords(\"transfer-dns-records\", {\n *   zoneId: zone.id,\n *   records: dnsRecords.records,\n * });\n */\nexport const ImportDnsRecords = Resource(\n  \"dns::ImportDnsRecords\",\n  async function (\n    this: Context<ImportDnsRecords>,\n    id: string,\n    props: ImportDnsRecordsProps\n  ): Promise<ImportDnsRecords> {\n    // For delete phase, just return destroyed state since this is a read-only resource\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    const recordTypes = props.recordTypes || DEFAULT_RECORD_TYPES;\n    const allRecords: DnsApiRecord[] = [];\n\n    for (const type of recordTypes) {\n      try {\n        const res = await fetch(\n          `https://cloudflare-dns.com/dns-query?name=${props.domain}&type=${type}`,\n          {\n            headers: {\n              accept: \"application/dns-json\",\n            },\n          }\n        );\n\n        if (!res.ok) {\n          throw new Error(`Failed to fetch ${type} records: ${res.statusText}`);\n        }\n\n        const data = (await res.json()) as CloudflareDNSResponse;\n\n        if (data.Answer) {\n          // Transform records to be compatible with DnsRecords function\n          const compatRecords = data.Answer.map((record) => {\n            const recordType = mapDnsRecordType(record.type);\n            const result: DnsApiRecord = {\n              name: record.name,\n              type: recordType,\n              TTL: record.TTL,\n              data: record.data,\n              content: record.data, // Default mapping\n              ttl: record.TTL, // Normalized lowercase ttl\n            };\n\n            // Special handling for MX records to split priority and content\n            if (recordType === \"MX\") {\n              const parts = record.data.split(\" \");\n              if (parts.length >= 2) {\n                const priority = Number.parseInt(parts[0], 10);\n                // Join the rest as hostname in case there are spaces\n                const hostname = parts.slice(1).join(\" \");\n\n                if (!isNaN(priority)) {\n                  result.priority = priority;\n                  result.content = hostname;\n                }\n              }\n            }\n\n            return result;\n          });\n\n          allRecords.push(...compatRecords);\n        }\n      } catch (error) {\n        console.warn(\n          `Failed to fetch ${type} records for ${props.domain}:`,\n          error\n        );\n      }\n    }\n\n    // Return the resource with fetched records as a flat array\n    return this({\n      domain: props.domain,\n      recordTypes: [...recordTypes],\n      records: allRecords,\n      importedAt: Date.now(),\n    });\n  }\n);\n\n```\n\n// alchemy/src/dns/record.ts\n```ts\n/**\n * DNS record types supported across different providers\n */\nexport type DnsRecordType =\n  | \"A\"\n  | \"AAAA\"\n  | \"MX\"\n  | \"TXT\"\n  | \"NS\"\n  | \"CNAME\"\n  | \"SOA\"\n  | \"SRV\"\n  | \"PTR\";\n\n/**\n * Default DNS record types to fetch\n */\nexport const DEFAULT_RECORD_TYPES: readonly DnsRecordType[] = [\n  \"A\",\n  \"AAAA\",\n  \"MX\",\n  \"TXT\",\n  \"NS\",\n  \"CNAME\",\n  \"SOA\",\n  \"SRV\",\n] as const;\n\n/**\n * Base DNS record interface with common properties\n */\nexport interface DnsRecordBase {\n  /**\n   * DNS record name (e.g., \"example.com\", \"subdomain.example.com\")\n   */\n  name: string;\n\n  /**\n   * Record type (A, AAAA, CNAME, etc.)\n   */\n  type: DnsRecordType;\n}\n\n/**\n * DNS record response structure from DNS-over-HTTPS APIs\n */\nexport interface DohDnsRecord extends DnsRecordBase {\n  /**\n   * Time To Live in seconds\n   */\n  TTL: number;\n\n  /**\n   * Record data/content (varies by record type)\n   */\n  data: string;\n}\n\n/**\n * Comprehensive DNS record structure for creating/managing records\n */\nexport interface DnsRecord extends DnsRecordBase {\n  /**\n   * DNS record content (e.g., IP address, hostname)\n   */\n  content: string;\n\n  /**\n   * Time To Live (TTL) in seconds\n   * Setting to 1 means 'automatic'\n   * Value must be between 60 and 86400, with minimum reduced to 30 for Enterprise zones\n   * @default 1\n   */\n  ttl?: number;\n\n  /**\n   * Whether the record is receiving proxied traffic through Cloudflare\n   * @default false\n   */\n  proxied?: boolean;\n\n  /**\n   * Comments or notes about the record\n   */\n  comment?: string;\n\n  /**\n   * Record tags\n   */\n  tags?: string[];\n\n  /**\n   * Priority value for MX/SRV records\n   */\n  priority?: number;\n}\n\n/**\n * DNS record with provider-specific ID and metadata\n */\nexport interface DnsRecordWithMetadata extends DnsRecord {\n  /**\n   * Record ID\n   */\n  id: string;\n\n  /**\n   * Zone or domain ID the record belongs to\n   */\n  zoneId: string;\n\n  /**\n   * Time at which the record was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the record was last modified\n   */\n  modifiedAt?: number;\n}\n\n```"
      },
      {
        "role": "assistant",
        "content": "{\"groups\":[{\"category\":\"Types\",\"filename\":\"record.ts\",\"identifier\":\"DnsRecordType\"},{\"category\":\"Utility\",\"filename\":\"godaddy.ts\",\"identifier\":\"updateNameservers\"},{\"category\":\"Resource\",\"filename\":\"import-dns.ts\",\"identifier\":\"ImportDnsRecords\"}]}"
      }
    ],
    "createdAt": 1744513397521,
    "Kind": "ai::Object",
    "ID": "docs/dns",
    "FQN": "github:alchemy/prod/docs/docs/dns",
    "Seq": 52
  },
  "props": {
    "model": {
      "id": "o3-mini",
      "provider": "openai",
      "options": {
        "reasoningEffort": "high"
      }
    },
    "freeze": true,
    "temperature": 0.1,
    "schema": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "system": "You are a technical writer tasked with identifying the distinct documents that need to be written for a document group (folder) in a documentation site.\nYou will be provided with a list of documents and instructions on how to classify them.\nEach document has a title, file name, and category.\n    \n",
    "prompt": "Identify and classify the documents that need to be written for the '      alchemy/src/dns' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/dns Service has the following resources:\n[record.ts](alchemy/src/dns/record.ts)\n\n[godaddy.ts](alchemy/src/dns/godaddy.ts)\n\n[import-dns.ts](alchemy/src/dns/import-dns.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...), or it is the Workflow or DurableObject classes.\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/dns/godaddy.ts\n```ts\nexport type UpdateNameserversOptions = {\n  domain: string;\n  apiKey: string;\n  apiSecret: string;\n  nameservers: string[];\n};\n\nexport async function updateNameservers(options: UpdateNameserversOptions) {\n  const url = `https://api.godaddy.com/v1/domains/${options.domain}/nameservers`;\n\n  const response = await fetch(url, {\n    method: \"PUT\",\n    headers: {\n      Authorization: `sso-key ${options.apiKey}:${options.apiSecret}`,\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\",\n    },\n    body: JSON.stringify({\n      nameservers: options.nameservers,\n    }),\n  });\n\n  if (response.ok) {\n    console.log(`✅ Nameservers updated for ${options.domain}`);\n  } else {\n    const error = await response.json();\n    console.error(`❌ Failed to update nameservers:`, error);\n  }\n}\n\n```\n\n// alchemy/src/dns/import-dns.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { DEFAULT_RECORD_TYPES, type DnsRecordType } from \"./record\";\n\n/**\n * DNS record response structure from Cloudflare DNS API\n * with both data (original) and content (for compatibility)\n */\nexport interface DnsApiRecord {\n  name: string;\n  type: DnsRecordType;\n  TTL: number;\n  data: string;\n  content: string; // Added for compatibility with DnsRecords\n  ttl: number; // Normalized ttl (lowercase)\n  priority?: number; // Priority for MX and SRV records\n}\n\n/**\n * Cloudflare DNS-over-HTTPS API response structure\n */\ninterface CloudflareDNSResponse {\n  Status: number;\n  TC: boolean;\n  RD: boolean;\n  RA: boolean;\n  AD: boolean;\n  CD: boolean;\n  Question: Array<{\n    name: string;\n    type: number;\n  }>;\n  Answer?: {\n    name: string;\n    type: number;\n    TTL: number;\n    data: string;\n  }[];\n}\n\n/**\n * Properties for importing DNS records\n */\nexport interface ImportDnsRecordsProps {\n  /**\n   * The domain to fetch DNS records for\n   */\n  domain: string;\n\n  /**\n   * Specific record types to fetch. If not provided, defaults to all supported types.\n   */\n  recordTypes?: DnsRecordType[];\n\n  /**\n   * Bump the resource to force a new import\n   */\n  bump?: number;\n}\n\n/**\n * Output returned after DNS records import\n */\nexport interface ImportDnsRecords\n  extends Resource<\"dns::ImportDnsRecords\">,\n    ImportDnsRecordsProps {\n  /**\n   * The DNS records as a flat array, directly compatible with DnsRecords function\n   */\n  records: DnsApiRecord[];\n\n  /**\n   * Time at which the records were imported\n   */\n  importedAt: number;\n}\n\n/**\n * Map numeric DNS record type to string type\n */\nfunction mapDnsRecordType(type: number): DnsRecordType {\n  const typeMap: Record<number, DnsRecordType> = {\n    1: \"A\",\n    2: \"NS\",\n    5: \"CNAME\",\n    6: \"SOA\",\n    15: \"MX\",\n    16: \"TXT\",\n    28: \"AAAA\",\n    33: \"SRV\",\n    12: \"PTR\",\n  };\n\n  return typeMap[type] || \"A\";\n}\n\n/**\n * Import DNS records for a domain using Cloudflare's DNS-over-HTTPS API.\n * This resource allows you to fetch DNS records for a domain and store them\n * in a structured format.\n *\n * @example\n * // Import all default record types\n * const allRecords = await ImportDnsRecords(\"example.com\", {\n *   domain: \"example.com\"\n * });\n *\n * @example\n * // Import only specific record types\n * const specificRecords = await ImportDnsRecords(\"example.com\", {\n *   domain: \"example.com\",\n *   recordTypes: [\"A\", \"MX\"]\n * });\n *\n * @example\n * // Import DNS records and transfer them to a Cloudflare zone\n * const dnsRecords = await ImportDnsRecords(\"dns-records\", {\n *   domain: \"example.com\",\n * });\n *\n * const zone = await Zone(\"example.com\", {\n *   name: \"example.com\",\n *   type: \"full\",\n * });\n *\n * // Records are directly compatible with DnsRecords function\n * await DnsRecords(\"transfer-dns-records\", {\n *   zoneId: zone.id,\n *   records: dnsRecords.records,\n * });\n */\nexport const ImportDnsRecords = Resource(\n  \"dns::ImportDnsRecords\",\n  async function (\n    this: Context<ImportDnsRecords>,\n    id: string,\n    props: ImportDnsRecordsProps\n  ): Promise<ImportDnsRecords> {\n    // For delete phase, just return destroyed state since this is a read-only resource\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    const recordTypes = props.recordTypes || DEFAULT_RECORD_TYPES;\n    const allRecords: DnsApiRecord[] = [];\n\n    for (const type of recordTypes) {\n      try {\n        const res = await fetch(\n          `https://cloudflare-dns.com/dns-query?name=${props.domain}&type=${type}`,\n          {\n            headers: {\n              accept: \"application/dns-json\",\n            },\n          }\n        );\n\n        if (!res.ok) {\n          throw new Error(`Failed to fetch ${type} records: ${res.statusText}`);\n        }\n\n        const data = (await res.json()) as CloudflareDNSResponse;\n\n        if (data.Answer) {\n          // Transform records to be compatible with DnsRecords function\n          const compatRecords = data.Answer.map((record) => {\n            const recordType = mapDnsRecordType(record.type);\n            const result: DnsApiRecord = {\n              name: record.name,\n              type: recordType,\n              TTL: record.TTL,\n              data: record.data,\n              content: record.data, // Default mapping\n              ttl: record.TTL, // Normalized lowercase ttl\n            };\n\n            // Special handling for MX records to split priority and content\n            if (recordType === \"MX\") {\n              const parts = record.data.split(\" \");\n              if (parts.length >= 2) {\n                const priority = Number.parseInt(parts[0], 10);\n                // Join the rest as hostname in case there are spaces\n                const hostname = parts.slice(1).join(\" \");\n\n                if (!isNaN(priority)) {\n                  result.priority = priority;\n                  result.content = hostname;\n                }\n              }\n            }\n\n            return result;\n          });\n\n          allRecords.push(...compatRecords);\n        }\n      } catch (error) {\n        console.warn(\n          `Failed to fetch ${type} records for ${props.domain}:`,\n          error\n        );\n      }\n    }\n\n    // Return the resource with fetched records as a flat array\n    return this({\n      domain: props.domain,\n      recordTypes: [...recordTypes],\n      records: allRecords,\n      importedAt: Date.now(),\n    });\n  }\n);\n\n```\n\n// alchemy/src/dns/record.ts\n```ts\n/**\n * DNS record types supported across different providers\n */\nexport type DnsRecordType =\n  | \"A\"\n  | \"AAAA\"\n  | \"MX\"\n  | \"TXT\"\n  | \"NS\"\n  | \"CNAME\"\n  | \"SOA\"\n  | \"SRV\"\n  | \"PTR\";\n\n/**\n * Default DNS record types to fetch\n */\nexport const DEFAULT_RECORD_TYPES: readonly DnsRecordType[] = [\n  \"A\",\n  \"AAAA\",\n  \"MX\",\n  \"TXT\",\n  \"NS\",\n  \"CNAME\",\n  \"SOA\",\n  \"SRV\",\n] as const;\n\n/**\n * Base DNS record interface with common properties\n */\nexport interface DnsRecordBase {\n  /**\n   * DNS record name (e.g., \"example.com\", \"subdomain.example.com\")\n   */\n  name: string;\n\n  /**\n   * Record type (A, AAAA, CNAME, etc.)\n   */\n  type: DnsRecordType;\n}\n\n/**\n * DNS record response structure from DNS-over-HTTPS APIs\n */\nexport interface DohDnsRecord extends DnsRecordBase {\n  /**\n   * Time To Live in seconds\n   */\n  TTL: number;\n\n  /**\n   * Record data/content (varies by record type)\n   */\n  data: string;\n}\n\n/**\n * Comprehensive DNS record structure for creating/managing records\n */\nexport interface DnsRecord extends DnsRecordBase {\n  /**\n   * DNS record content (e.g., IP address, hostname)\n   */\n  content: string;\n\n  /**\n   * Time To Live (TTL) in seconds\n   * Setting to 1 means 'automatic'\n   * Value must be between 60 and 86400, with minimum reduced to 30 for Enterprise zones\n   * @default 1\n   */\n  ttl?: number;\n\n  /**\n   * Whether the record is receiving proxied traffic through Cloudflare\n   * @default false\n   */\n  proxied?: boolean;\n\n  /**\n   * Comments or notes about the record\n   */\n  comment?: string;\n\n  /**\n   * Record tags\n   */\n  tags?: string[];\n\n  /**\n   * Priority value for MX/SRV records\n   */\n  priority?: number;\n}\n\n/**\n * DNS record with provider-specific ID and metadata\n */\nexport interface DnsRecordWithMetadata extends DnsRecord {\n  /**\n   * Record ID\n   */\n  id: string;\n\n  /**\n   * Zone or domain ID the record belongs to\n   */\n  zoneId: string;\n\n  /**\n   * Time at which the record was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the record was last modified\n   */\n  modifiedAt?: number;\n}\n\n```"
  }
}