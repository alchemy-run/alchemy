{
  "kind": "ai::Object",
  "id": "docs/stripe",
  "fqn": "github:alchemy/prod/docs/docs/stripe",
  "seq": 68,
  "data": {},
  "status": "updated",
  "output": {
    "type": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "object": {
      "groups": [
        {
          "category": "Resource",
          "filename": "price.md",
          "identifier": "Price"
        },
        {
          "category": "Resource",
          "filename": "product.md",
          "identifier": "Product"
        },
        {
          "category": "Resource",
          "filename": "webhook.md",
          "identifier": "WebhookEndpoint"
        }
      ]
    },
    "messages": [
      {
        "role": "user",
        "content": "Identify and classify the documents that need to be written for the '      alchemy/src/stripe' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/stripe Service has the following resources:\n[price.ts](alchemy/src/stripe/price.ts)\n\n[product.ts](alchemy/src/stripe/product.ts)\n\n[webhook.ts](alchemy/src/stripe/webhook.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...).\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/stripe/price.ts\n```ts\nimport Stripe from \"stripe\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for price recurring configuration\n */\nexport interface PriceRecurring {\n  /**\n   * Specifies billing frequency. Either 'day', 'week', 'month' or 'year'.\n   */\n  interval: Stripe.PriceCreateParams.Recurring.Interval;\n\n  /**\n   * The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months.\n   */\n  intervalCount?: number;\n\n  /**\n   * Configures how the quantity per period should be determined, can be either 'metered' or 'licensed'.\n   * 'licensed' will automatically bill the quantity set for a plan when adding it to a subscription,\n   * 'metered' will aggregate the total usage based on usage records.\n   */\n  usageType?: Stripe.PriceCreateParams.Recurring.UsageType;\n\n  /**\n   * Specifies a usage aggregation strategy for prices of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period,\n   * `last_during_period` for picking the last usage record reported within a period,\n   * `last_ever` for picking the last usage record ever (across period bounds) or `max` which picks the usage record with the maximum reported usage during a period.\n   */\n  aggregateUsage?: Stripe.PriceCreateParams.Recurring.AggregateUsage;\n}\n\ntype TaxBehavior = Stripe.PriceCreateParams.TaxBehavior;\ntype BillingScheme = Stripe.PriceCreateParams.BillingScheme;\n\n/**\n * Properties for creating a Stripe price\n */\nexport interface PriceProps {\n  /**\n   * The ID of the product that this price will belong to\n   */\n  product: string;\n\n  /**\n   * Three-letter ISO currency code, in lowercase. Must be a supported currency.\n   */\n  currency: string;\n\n  /**\n   * A positive integer in cents (or local equivalent) representing how much to charge (e.g., 999 for $9.99).\n   * Alternatively, use unit_amount_decimal to specify a precise amount.\n   */\n  unitAmount?: number;\n\n  /**\n   * Same as unit_amount, but accepts a decimal string (e.g., '9.99') with at most 12 decimal places.\n   * Only one of unit_amount and unit_amount_decimal can be set.\n   */\n  unitAmountDecimal?: string;\n\n  /**\n   * Whether the price can be used for new purchases\n   */\n  active?: boolean;\n\n  /**\n   * Describes how to compute the price per period. Either `per_unit` or `tiered`.\n   * `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`)\n   * will be charged per unit in `quantity`.\n   * `tiered` indicates that the unit pricing will be computed using a tiering strategy.\n   */\n  billingScheme?: BillingScheme;\n\n  /**\n   * A brief description of the price, hidden from customers.\n   */\n  nickname?: string;\n\n  /**\n   * The recurring components of a price such as `interval` and `interval_count`.\n   */\n  recurring?: PriceRecurring;\n\n  /**\n   * Set of key-value pairs that you can attach to an object.\n   */\n  metadata?: Record<string, string>;\n\n  /**\n   * Specifies whether the price is considered inclusive of taxes or exclusive of taxes.\n   * One of inclusive, exclusive, or unspecified.\n   */\n  taxBehavior?: TaxBehavior;\n}\n\n/**\n * Output from the Stripe price\n */\nexport interface Price extends Resource<\"stripe::Price\">, PriceProps {\n  /**\n   * The ID of the price\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  /**\n   * Has the value true if the object exists in live mode or the value false if the object exists in test mode\n   */\n  livemode: boolean;\n\n  /**\n   * The type of the price - either 'one_time' or 'recurring'\n   */\n  type: Stripe.Price.Type;\n\n  /**\n   * The lookup key (if any) used by the customer to identify this price object\n   */\n  lookupKey?: string;\n}\n\n/**\n * Create and manage Stripe prices for products\n *\n * @example\n * // Create a one-time fixed price for a product\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999, // $29.99\n *   product: \"prod_xyz\"\n * });\n *\n * @example\n * // Create a recurring subscription price with fixed monthly billing\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499, // $14.99/month\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n *\n * @example\n * // Create a metered price for usage-based billing\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25, // $0.25 per GB\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n *\n * @example\n * // Create a tiered price with tax behavior\n * const tieredPrice = await Price(\"enterprise\", {\n *   currency: \"usd\",\n *   unitAmount: 10000, // $100.00\n *   product: \"prod_xyz\",\n *   billingScheme: \"tiered\",\n *   taxBehavior: \"exclusive\",\n *   metadata: {\n *     tier: \"enterprise\",\n *     features: \"all\"\n *   }\n * });\n */\nexport const Price = Resource(\n  \"stripe::Price\",\n  async function (\n    this: Context<Price>,\n    id: string,\n    props: PriceProps,\n  ): Promise<Price> {\n    // Get Stripe API key from context or environment\n    const apiKey = process.env.STRIPE_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"STRIPE_API_KEY environment variable is required\");\n    }\n\n    // Initialize Stripe client\n    const stripe = new Stripe(apiKey);\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.phase === \"delete\" && this.output?.id) {\n          // Prices can't be deleted, only deactivated\n          await stripe.prices.update(this.output.id, { active: false });\n        }\n      } catch (error) {\n        // Ignore if the price doesn't exist\n        console.error(\"Error deactivating price:\", error);\n      }\n\n      return this.destroy();\n    } else {\n      try {\n        let price: Stripe.Price;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing price (limited properties can be updated)\n          price = await stripe.prices.update(this.output.id, {\n            active: props.active,\n            metadata: props.metadata,\n            nickname: props.nickname,\n          });\n        } else {\n          // Create new price\n          const createParams: Stripe.PriceCreateParams = {\n            currency: props.currency,\n            product: props.product,\n            active: props.active,\n            billing_scheme: props.billingScheme,\n            nickname: props.nickname,\n            metadata: props.metadata,\n            tax_behavior: props.taxBehavior,\n          };\n\n          // Add unit amount fields\n          if (props.unitAmount !== undefined) {\n            createParams.unit_amount = props.unitAmount;\n          } else if (props.unitAmountDecimal !== undefined) {\n            createParams.unit_amount_decimal = props.unitAmountDecimal;\n          }\n\n          // Add recurring parameters if present\n          if (props.recurring) {\n            createParams.recurring = {\n              interval: props.recurring.interval,\n              interval_count: props.recurring.intervalCount,\n              usage_type: props.recurring.usageType,\n              aggregate_usage: props.recurring.aggregateUsage,\n            };\n          }\n\n          price = await stripe.prices.create(createParams);\n        }\n\n        // Transform Stripe recurring object to our format\n        const recurring = price.recurring\n          ? {\n              interval: price.recurring\n                .interval as Stripe.PriceCreateParams.Recurring.Interval,\n              intervalCount: price.recurring.interval_count,\n              usageType: price.recurring\n                .usage_type as Stripe.PriceCreateParams.Recurring.UsageType,\n              aggregateUsage: price.recurring\n                .aggregate_usage as Stripe.PriceCreateParams.Recurring.AggregateUsage,\n            }\n          : undefined;\n\n        // Map Stripe API response to our output format\n        return this({\n          id: price.id,\n          product:\n            typeof price.product === \"string\"\n              ? price.product\n              : price.product.id,\n          currency: price.currency,\n          unitAmount: price.unit_amount || undefined,\n          unitAmountDecimal: price.unit_amount_decimal || undefined,\n          active: price.active,\n          billingScheme: price.billing_scheme as BillingScheme,\n          nickname: price.nickname || undefined,\n          recurring: recurring,\n          metadata: price.metadata || undefined,\n          taxBehavior: price.tax_behavior as TaxBehavior,\n          createdAt: price.created,\n          livemode: price.livemode,\n          type: price.type as Stripe.Price.Type,\n          lookupKey: price.lookup_key || undefined,\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating price:\", error);\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/stripe/product.ts\n```ts\nimport Stripe from \"stripe\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\ntype ProductType = Stripe.Product.Type;\n\n/**\n * Properties for creating a Stripe product\n */\nexport interface ProductProps {\n  /**\n   * The product's name\n   */\n  name: string;\n\n  /**\n   * The product's description\n   */\n  description?: string;\n\n  /**\n   * Whether the product is active\n   */\n  active?: boolean;\n\n  /**\n   * A list of up to 8 URLs of images for this product\n   */\n  images?: string[];\n\n  /**\n   * A URL of the product's thumbnail\n   */\n  url?: string;\n\n  /**\n   * Whether this product is shipped (physical goods)\n   */\n  shippable?: boolean;\n\n  /**\n   * Product type: good, service\n   */\n  type?: ProductType;\n\n  /**\n   * Unit label to use on invoices\n   */\n  unitLabel?: string;\n\n  /**\n   * A label for the product to be displayed on Checkout\n   */\n  statementDescriptor?: string;\n\n  /**\n   * Set of key-value pairs for this product\n   */\n  metadata?: Record<string, string>;\n\n  /**\n   * Default tax code for the product\n   */\n  taxCode?: string;\n}\n\n/**\n * Output from the Stripe product\n */\nexport interface Product extends Resource<\"stripe::Product\">, ProductProps {\n  /**\n   * The ID of the product\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  /**\n   * Has the value true if the object exists in live mode or the value false if the object exists in test mode\n   */\n  livemode: boolean;\n\n  /**\n   * Time at which the object was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * Whether this product can be used for Checkout/Payment Links\n   */\n  packageDimensions?: {\n    height: number;\n    length: number;\n    weight: number;\n    width: number;\n  };\n}\n\n/**\n * Create and manage Stripe products\n *\n * @example\n * // Create a basic digital product\n * const digitalProduct = await Product(\"basic-software\", {\n *   name: \"Basic Software License\",\n *   description: \"Single-user license for basic software package\",\n *   metadata: {\n *     type: \"digital\",\n *     features: \"basic\"\n *   }\n * });\n *\n * @example\n * // Create a physical product with shipping details\n * const physicalProduct = await Product(\"premium-hardware\", {\n *   name: \"Premium Hardware Kit\",\n *   description: \"Complete hardware kit with premium components\",\n *   shippable: true,\n *   images: [\"https://example.com/hardware-kit.jpg\"],\n *   unitLabel: \"kit\",\n *   statementDescriptor: \"PREMIUM HW KIT\"\n * });\n *\n * @example\n * // Create a service product with tax code\n * const serviceProduct = await Product(\"consulting\", {\n *   name: \"Professional Consulting\",\n *   description: \"Expert consulting services\",\n *   type: \"service\",\n *   taxCode: \"txcd_10000000\",\n *   metadata: {\n *     industry: \"technology\",\n *     expertise: \"cloud\"\n *   }\n * });\n */\nexport const Product = Resource(\n  \"stripe::Product\",\n  async function (\n    this: Context<Product>,\n    id: string,\n    props: ProductProps,\n  ): Promise<Product> {\n    // Get Stripe API key from context or environment\n    const apiKey = process.env.STRIPE_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"STRIPE_API_KEY environment variable is required\");\n    }\n\n    // Initialize Stripe client\n    const stripe = new Stripe(apiKey);\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.phase === \"delete\" && this.output?.id) {\n          await stripe.products.update(this.output.id, { active: false });\n        }\n      } catch (error) {\n        // Ignore if the product doesn't exist\n        console.error(\"Error deactivating product:\", error);\n      }\n\n      // Return a minimal output for deleted state\n      return this.destroy();\n    } else {\n      try {\n        let product: Stripe.Product;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing product\n          product = await stripe.products.update(this.output.id, {\n            name: props.name,\n            description: props.description,\n            active: props.active,\n            images: props.images,\n            url: props.url,\n            statement_descriptor: props.statementDescriptor,\n            metadata: props.metadata,\n            tax_code: props.taxCode,\n          });\n        } else {\n          // Create new product\n          product = await stripe.products.create({\n            name: props.name,\n            description: props.description,\n            active: props.active,\n            images: props.images,\n            url: props.url,\n            shippable: props.shippable,\n            type: props.type as Stripe.ProductCreateParams.Type,\n            unit_label: props.unitLabel,\n            statement_descriptor: props.statementDescriptor,\n            metadata: props.metadata,\n            tax_code: props.taxCode,\n          });\n        }\n\n        return this({\n          id: product.id,\n          name: product.name,\n          description: product.description || undefined,\n          active: product.active,\n          images: product.images || undefined,\n          url: product.url || undefined,\n          shippable: product.shippable || undefined,\n          type: product.type as ProductType,\n          unitLabel: product.unit_label || undefined,\n          statementDescriptor: product.statement_descriptor || undefined,\n          metadata: product.metadata || undefined,\n          taxCode:\n            typeof product.tax_code === \"string\" ? product.tax_code : undefined,\n          createdAt: product.created,\n          livemode: product.livemode,\n          updatedAt: product.updated,\n          packageDimensions: product.package_dimensions || undefined,\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating product:\", error);\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/stripe/webhook.ts\n```ts\nimport Stripe from \"stripe\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\nexport type EnabledEvent = Stripe.WebhookEndpointUpdateParams.EnabledEvent;\n\n/**\n * Properties for creating a Stripe webhook endpoint\n */\nexport interface WebhookEndpointProps {\n  /**\n   * The URL of the webhook endpoint\n   */\n  url: string;\n\n  /**\n   * The list of events to enable for this endpoint\n   */\n  enabledEvents: EnabledEvent[];\n\n  /**\n   * Description of the webhook\n   */\n  description?: string;\n\n  /**\n   * Whether the webhook is active\n   */\n  active?: boolean;\n\n  /**\n   * The API version events are rendered as for this webhook\n   */\n  apiVersion?: string;\n\n  /**\n   * Whether to include mounted endpoint events automatically\n   */\n  connect?: boolean;\n\n  /**\n   * Webhook endpoint metadata\n   */\n  metadata?: Record<string, string>;\n}\n\n/**\n * Output from the Stripe webhook endpoint\n */\nexport interface WebhookEndpoint\n  extends Resource<\"stripe::WebhookEndpoint\">,\n    WebhookEndpointProps {\n  /**\n   * The ID of the webhook\n   */\n  id: string;\n\n  /**\n   * The webhook endpoint's secret key, used to verify signatures on received events\n   */\n  secret: string;\n\n  /**\n   * The webhook endpoint's application\n   */\n  application?: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  /**\n   * Has the value true if the object exists in live mode or the value false if the object exists in test mode\n   */\n  livemode: boolean;\n\n  /**\n   * Time at which the object was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * The status of the webhook\n   */\n  status: string;\n}\n\n/**\n * Create and manage Stripe webhook endpoints\n *\n * @example\n * // Create a basic webhook for payment events\n * const paymentWebhook = await WebhookEndpoint(\"payment-webhook\", {\n *   url: \"https://api.example.com/stripe/payments\",\n *   enabledEvents: [\n *     \"payment_intent.succeeded\",\n *     \"payment_intent.payment_failed\"\n *   ],\n *   description: \"Webhook for payment notifications\"\n * });\n *\n * @example\n * // Create a webhook for subscription management\n * const subscriptionWebhook = await WebhookEndpoint(\"subscription-webhook\", {\n *   url: \"https://api.example.com/stripe/subscriptions\",\n *   enabledEvents: [\n *     \"customer.subscription.created\",\n *     \"customer.subscription.updated\",\n *     \"customer.subscription.deleted\",\n *     \"invoice.payment_succeeded\",\n *     \"invoice.payment_failed\"\n *   ],\n *   description: \"Webhook for subscription lifecycle events\"\n * });\n *\n * @example\n * // Create a webhook for Connect platform events\n * const connectWebhook = await WebhookEndpoint(\"connect-webhook\", {\n *   url: \"https://api.example.com/stripe/connect\",\n *   enabledEvents: [\n *     \"account.updated\",\n *     \"account.application.deauthorized\",\n *     \"payout.created\",\n *     \"payout.failed\"\n *   ],\n *   connect: true,\n *   metadata: {\n *     platform: \"connect\",\n *     environment: \"production\"\n *   }\n * });\n */\nexport const WebhookEndpoint = Resource(\n  \"stripe::WebhookEndpoint\",\n  async function (\n    this: Context<WebhookEndpoint>,\n    id: string,\n    props: WebhookEndpointProps,\n  ) {\n    // Get Stripe API key from context or environment\n    const apiKey = process.env.STRIPE_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"STRIPE_API_KEY environment variable is required\");\n    }\n\n    // Initialize Stripe client\n    const stripe = new Stripe(apiKey);\n\n    if (this.phase === \"delete\") {\n      try {\n        // Get the webhook ID from the stored output\n        if (this.phase === \"delete\" && this.output?.id) {\n          await stripe.webhookEndpoints.del(this.output.id);\n        }\n      } catch (error) {\n        // Ignore if the webhook doesn't exist\n        console.error(\"Error deleting webhook:\", error);\n      }\n\n      return this.destroy();\n    } else {\n      try {\n        let webhook: Stripe.WebhookEndpoint;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing webhook\n          webhook = await stripe.webhookEndpoints.update(this.output.id, {\n            url: props.url,\n            enabled_events: props.enabledEvents,\n            description: props.description,\n            disabled: props.active === false,\n            metadata: props.metadata,\n          });\n        } else {\n          // Create new webhook\n          webhook = await stripe.webhookEndpoints.create({\n            url: props.url,\n            enabled_events: props.enabledEvents,\n            description: props.description,\n            metadata: props.metadata,\n          });\n\n          // For connect parameter, need to handle it separately if it exists\n          if (props.connect !== undefined) {\n            // Note: connect is specified at creation time and cannot be updated\n            console.log(\n              \"Note: 'connect' parameter will be applied at creation time only\",\n            );\n          }\n        }\n\n        // Store the secret if available\n        let secret = \"\";\n        if (webhook.secret) {\n          secret = webhook.secret;\n        } else if (this.phase === \"update\" && this.output?.secret) {\n          secret = this.output.secret;\n        }\n\n        return this({\n          id: webhook.id,\n          url: webhook.url,\n          enabledEvents: webhook.enabled_events as EnabledEvent[],\n          description: webhook.description || undefined,\n          active: webhook.status === \"enabled\",\n          apiVersion: webhook.api_version || undefined,\n          // connect: !!webhook.connect,\n          metadata: webhook.metadata || undefined,\n          secret: secret,\n          application: webhook.application || undefined,\n          createdAt: webhook.created,\n          livemode: webhook.livemode,\n          updatedAt: webhook.created, // Using created timestamp as updated\n          status: webhook.status,\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating webhook:\", error);\n        throw error;\n      }\n    }\n  },\n);\n\n```"
      },
      {
        "role": "assistant",
        "content": "{\"groups\":[{\"category\":\"Resource\",\"filename\":\"price.md\",\"identifier\":\"Price\"},{\"category\":\"Resource\",\"filename\":\"product.md\",\"identifier\":\"Product\"},{\"category\":\"Resource\",\"filename\":\"webhook.md\",\"identifier\":\"WebhookEndpoint\"}]}"
      }
    ],
    "createdAt": 1744513517806,
    "Kind": "ai::Object",
    "ID": "docs/stripe",
    "FQN": "github:alchemy/prod/docs/docs/stripe",
    "Seq": 68
  },
  "props": {
    "model": {
      "id": "o3-mini",
      "provider": "openai",
      "options": {
        "reasoningEffort": "high"
      }
    },
    "freeze": true,
    "temperature": 0.1,
    "schema": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "system": "You are a technical writer tasked with identifying the distinct documents that need to be written for a document group (folder) in a documentation site.\nYou will be provided with a list of documents and instructions on how to classify them.\nEach document has a title, file name, and category.\n    \n",
    "prompt": "Identify and classify the documents that need to be written for the '      alchemy/src/stripe' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/stripe Service has the following resources:\n[price.ts](alchemy/src/stripe/price.ts)\n\n[product.ts](alchemy/src/stripe/product.ts)\n\n[webhook.ts](alchemy/src/stripe/webhook.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...), or it is the Workflow or DurableObject classes.\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/stripe/price.ts\n```ts\nimport Stripe from \"stripe\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for price recurring configuration\n */\nexport interface PriceRecurring {\n  /**\n   * Specifies billing frequency. Either 'day', 'week', 'month' or 'year'.\n   */\n  interval: Stripe.PriceCreateParams.Recurring.Interval;\n\n  /**\n   * The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months.\n   */\n  intervalCount?: number;\n\n  /**\n   * Configures how the quantity per period should be determined, can be either 'metered' or 'licensed'.\n   * 'licensed' will automatically bill the quantity set for a plan when adding it to a subscription,\n   * 'metered' will aggregate the total usage based on usage records.\n   */\n  usageType?: Stripe.PriceCreateParams.Recurring.UsageType;\n\n  /**\n   * Specifies a usage aggregation strategy for prices of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period,\n   * `last_during_period` for picking the last usage record reported within a period,\n   * `last_ever` for picking the last usage record ever (across period bounds) or `max` which picks the usage record with the maximum reported usage during a period.\n   */\n  aggregateUsage?: Stripe.PriceCreateParams.Recurring.AggregateUsage;\n}\n\ntype TaxBehavior = Stripe.PriceCreateParams.TaxBehavior;\ntype BillingScheme = Stripe.PriceCreateParams.BillingScheme;\n\n/**\n * Properties for creating a Stripe price\n */\nexport interface PriceProps {\n  /**\n   * The ID of the product that this price will belong to\n   */\n  product: string;\n\n  /**\n   * Three-letter ISO currency code, in lowercase. Must be a supported currency.\n   */\n  currency: string;\n\n  /**\n   * A positive integer in cents (or local equivalent) representing how much to charge (e.g., 999 for $9.99).\n   * Alternatively, use unit_amount_decimal to specify a precise amount.\n   */\n  unitAmount?: number;\n\n  /**\n   * Same as unit_amount, but accepts a decimal string (e.g., '9.99') with at most 12 decimal places.\n   * Only one of unit_amount and unit_amount_decimal can be set.\n   */\n  unitAmountDecimal?: string;\n\n  /**\n   * Whether the price can be used for new purchases\n   */\n  active?: boolean;\n\n  /**\n   * Describes how to compute the price per period. Either `per_unit` or `tiered`.\n   * `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`)\n   * will be charged per unit in `quantity`.\n   * `tiered` indicates that the unit pricing will be computed using a tiering strategy.\n   */\n  billingScheme?: BillingScheme;\n\n  /**\n   * A brief description of the price, hidden from customers.\n   */\n  nickname?: string;\n\n  /**\n   * The recurring components of a price such as `interval` and `interval_count`.\n   */\n  recurring?: PriceRecurring;\n\n  /**\n   * Set of key-value pairs that you can attach to an object.\n   */\n  metadata?: Record<string, string>;\n\n  /**\n   * Specifies whether the price is considered inclusive of taxes or exclusive of taxes.\n   * One of inclusive, exclusive, or unspecified.\n   */\n  taxBehavior?: TaxBehavior;\n}\n\n/**\n * Output from the Stripe price\n */\nexport interface Price extends Resource<\"stripe::Price\">, PriceProps {\n  /**\n   * The ID of the price\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  /**\n   * Has the value true if the object exists in live mode or the value false if the object exists in test mode\n   */\n  livemode: boolean;\n\n  /**\n   * The type of the price - either 'one_time' or 'recurring'\n   */\n  type: Stripe.Price.Type;\n\n  /**\n   * The lookup key (if any) used by the customer to identify this price object\n   */\n  lookupKey?: string;\n}\n\n/**\n * Create and manage Stripe prices for products\n *\n * @example\n * // Create a one-time fixed price for a product\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999, // $29.99\n *   product: \"prod_xyz\"\n * });\n *\n * @example\n * // Create a recurring subscription price with fixed monthly billing\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499, // $14.99/month\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n *\n * @example\n * // Create a metered price for usage-based billing\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25, // $0.25 per GB\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n *\n * @example\n * // Create a tiered price with tax behavior\n * const tieredPrice = await Price(\"enterprise\", {\n *   currency: \"usd\",\n *   unitAmount: 10000, // $100.00\n *   product: \"prod_xyz\",\n *   billingScheme: \"tiered\",\n *   taxBehavior: \"exclusive\",\n *   metadata: {\n *     tier: \"enterprise\",\n *     features: \"all\"\n *   }\n * });\n */\nexport const Price = Resource(\n  \"stripe::Price\",\n  async function (\n    this: Context<Price>,\n    id: string,\n    props: PriceProps,\n  ): Promise<Price> {\n    // Get Stripe API key from context or environment\n    const apiKey = process.env.STRIPE_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"STRIPE_API_KEY environment variable is required\");\n    }\n\n    // Initialize Stripe client\n    const stripe = new Stripe(apiKey);\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.phase === \"delete\" && this.output?.id) {\n          // Prices can't be deleted, only deactivated\n          await stripe.prices.update(this.output.id, { active: false });\n        }\n      } catch (error) {\n        // Ignore if the price doesn't exist\n        console.error(\"Error deactivating price:\", error);\n      }\n\n      return this.destroy();\n    } else {\n      try {\n        let price: Stripe.Price;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing price (limited properties can be updated)\n          price = await stripe.prices.update(this.output.id, {\n            active: props.active,\n            metadata: props.metadata,\n            nickname: props.nickname,\n          });\n        } else {\n          // Create new price\n          const createParams: Stripe.PriceCreateParams = {\n            currency: props.currency,\n            product: props.product,\n            active: props.active,\n            billing_scheme: props.billingScheme,\n            nickname: props.nickname,\n            metadata: props.metadata,\n            tax_behavior: props.taxBehavior,\n          };\n\n          // Add unit amount fields\n          if (props.unitAmount !== undefined) {\n            createParams.unit_amount = props.unitAmount;\n          } else if (props.unitAmountDecimal !== undefined) {\n            createParams.unit_amount_decimal = props.unitAmountDecimal;\n          }\n\n          // Add recurring parameters if present\n          if (props.recurring) {\n            createParams.recurring = {\n              interval: props.recurring.interval,\n              interval_count: props.recurring.intervalCount,\n              usage_type: props.recurring.usageType,\n              aggregate_usage: props.recurring.aggregateUsage,\n            };\n          }\n\n          price = await stripe.prices.create(createParams);\n        }\n\n        // Transform Stripe recurring object to our format\n        const recurring = price.recurring\n          ? {\n              interval: price.recurring\n                .interval as Stripe.PriceCreateParams.Recurring.Interval,\n              intervalCount: price.recurring.interval_count,\n              usageType: price.recurring\n                .usage_type as Stripe.PriceCreateParams.Recurring.UsageType,\n              aggregateUsage: price.recurring\n                .aggregate_usage as Stripe.PriceCreateParams.Recurring.AggregateUsage,\n            }\n          : undefined;\n\n        // Map Stripe API response to our output format\n        return this({\n          id: price.id,\n          product:\n            typeof price.product === \"string\"\n              ? price.product\n              : price.product.id,\n          currency: price.currency,\n          unitAmount: price.unit_amount || undefined,\n          unitAmountDecimal: price.unit_amount_decimal || undefined,\n          active: price.active,\n          billingScheme: price.billing_scheme as BillingScheme,\n          nickname: price.nickname || undefined,\n          recurring: recurring,\n          metadata: price.metadata || undefined,\n          taxBehavior: price.tax_behavior as TaxBehavior,\n          createdAt: price.created,\n          livemode: price.livemode,\n          type: price.type as Stripe.Price.Type,\n          lookupKey: price.lookup_key || undefined,\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating price:\", error);\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/stripe/product.ts\n```ts\nimport Stripe from \"stripe\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\ntype ProductType = Stripe.Product.Type;\n\n/**\n * Properties for creating a Stripe product\n */\nexport interface ProductProps {\n  /**\n   * The product's name\n   */\n  name: string;\n\n  /**\n   * The product's description\n   */\n  description?: string;\n\n  /**\n   * Whether the product is active\n   */\n  active?: boolean;\n\n  /**\n   * A list of up to 8 URLs of images for this product\n   */\n  images?: string[];\n\n  /**\n   * A URL of the product's thumbnail\n   */\n  url?: string;\n\n  /**\n   * Whether this product is shipped (physical goods)\n   */\n  shippable?: boolean;\n\n  /**\n   * Product type: good, service\n   */\n  type?: ProductType;\n\n  /**\n   * Unit label to use on invoices\n   */\n  unitLabel?: string;\n\n  /**\n   * A label for the product to be displayed on Checkout\n   */\n  statementDescriptor?: string;\n\n  /**\n   * Set of key-value pairs for this product\n   */\n  metadata?: Record<string, string>;\n\n  /**\n   * Default tax code for the product\n   */\n  taxCode?: string;\n}\n\n/**\n * Output from the Stripe product\n */\nexport interface Product extends Resource<\"stripe::Product\">, ProductProps {\n  /**\n   * The ID of the product\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  /**\n   * Has the value true if the object exists in live mode or the value false if the object exists in test mode\n   */\n  livemode: boolean;\n\n  /**\n   * Time at which the object was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * Whether this product can be used for Checkout/Payment Links\n   */\n  packageDimensions?: {\n    height: number;\n    length: number;\n    weight: number;\n    width: number;\n  };\n}\n\n/**\n * Create and manage Stripe products\n *\n * @example\n * // Create a basic digital product\n * const digitalProduct = await Product(\"basic-software\", {\n *   name: \"Basic Software License\",\n *   description: \"Single-user license for basic software package\",\n *   metadata: {\n *     type: \"digital\",\n *     features: \"basic\"\n *   }\n * });\n *\n * @example\n * // Create a physical product with shipping details\n * const physicalProduct = await Product(\"premium-hardware\", {\n *   name: \"Premium Hardware Kit\",\n *   description: \"Complete hardware kit with premium components\",\n *   shippable: true,\n *   images: [\"https://example.com/hardware-kit.jpg\"],\n *   unitLabel: \"kit\",\n *   statementDescriptor: \"PREMIUM HW KIT\"\n * });\n *\n * @example\n * // Create a service product with tax code\n * const serviceProduct = await Product(\"consulting\", {\n *   name: \"Professional Consulting\",\n *   description: \"Expert consulting services\",\n *   type: \"service\",\n *   taxCode: \"txcd_10000000\",\n *   metadata: {\n *     industry: \"technology\",\n *     expertise: \"cloud\"\n *   }\n * });\n */\nexport const Product = Resource(\n  \"stripe::Product\",\n  async function (\n    this: Context<Product>,\n    id: string,\n    props: ProductProps,\n  ): Promise<Product> {\n    // Get Stripe API key from context or environment\n    const apiKey = process.env.STRIPE_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"STRIPE_API_KEY environment variable is required\");\n    }\n\n    // Initialize Stripe client\n    const stripe = new Stripe(apiKey);\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.phase === \"delete\" && this.output?.id) {\n          await stripe.products.update(this.output.id, { active: false });\n        }\n      } catch (error) {\n        // Ignore if the product doesn't exist\n        console.error(\"Error deactivating product:\", error);\n      }\n\n      // Return a minimal output for deleted state\n      return this.destroy();\n    } else {\n      try {\n        let product: Stripe.Product;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing product\n          product = await stripe.products.update(this.output.id, {\n            name: props.name,\n            description: props.description,\n            active: props.active,\n            images: props.images,\n            url: props.url,\n            statement_descriptor: props.statementDescriptor,\n            metadata: props.metadata,\n            tax_code: props.taxCode,\n          });\n        } else {\n          // Create new product\n          product = await stripe.products.create({\n            name: props.name,\n            description: props.description,\n            active: props.active,\n            images: props.images,\n            url: props.url,\n            shippable: props.shippable,\n            type: props.type as Stripe.ProductCreateParams.Type,\n            unit_label: props.unitLabel,\n            statement_descriptor: props.statementDescriptor,\n            metadata: props.metadata,\n            tax_code: props.taxCode,\n          });\n        }\n\n        return this({\n          id: product.id,\n          name: product.name,\n          description: product.description || undefined,\n          active: product.active,\n          images: product.images || undefined,\n          url: product.url || undefined,\n          shippable: product.shippable || undefined,\n          type: product.type as ProductType,\n          unitLabel: product.unit_label || undefined,\n          statementDescriptor: product.statement_descriptor || undefined,\n          metadata: product.metadata || undefined,\n          taxCode:\n            typeof product.tax_code === \"string\" ? product.tax_code : undefined,\n          createdAt: product.created,\n          livemode: product.livemode,\n          updatedAt: product.updated,\n          packageDimensions: product.package_dimensions || undefined,\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating product:\", error);\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/stripe/webhook.ts\n```ts\nimport Stripe from \"stripe\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\nexport type EnabledEvent = Stripe.WebhookEndpointUpdateParams.EnabledEvent;\n\n/**\n * Properties for creating a Stripe webhook endpoint\n */\nexport interface WebhookEndpointProps {\n  /**\n   * The URL of the webhook endpoint\n   */\n  url: string;\n\n  /**\n   * The list of events to enable for this endpoint\n   */\n  enabledEvents: EnabledEvent[];\n\n  /**\n   * Description of the webhook\n   */\n  description?: string;\n\n  /**\n   * Whether the webhook is active\n   */\n  active?: boolean;\n\n  /**\n   * The API version events are rendered as for this webhook\n   */\n  apiVersion?: string;\n\n  /**\n   * Whether to include mounted endpoint events automatically\n   */\n  connect?: boolean;\n\n  /**\n   * Webhook endpoint metadata\n   */\n  metadata?: Record<string, string>;\n}\n\n/**\n * Output from the Stripe webhook endpoint\n */\nexport interface WebhookEndpoint\n  extends Resource<\"stripe::WebhookEndpoint\">,\n    WebhookEndpointProps {\n  /**\n   * The ID of the webhook\n   */\n  id: string;\n\n  /**\n   * The webhook endpoint's secret key, used to verify signatures on received events\n   */\n  secret: string;\n\n  /**\n   * The webhook endpoint's application\n   */\n  application?: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  /**\n   * Has the value true if the object exists in live mode or the value false if the object exists in test mode\n   */\n  livemode: boolean;\n\n  /**\n   * Time at which the object was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * The status of the webhook\n   */\n  status: string;\n}\n\n/**\n * Create and manage Stripe webhook endpoints\n *\n * @example\n * // Create a basic webhook for payment events\n * const paymentWebhook = await WebhookEndpoint(\"payment-webhook\", {\n *   url: \"https://api.example.com/stripe/payments\",\n *   enabledEvents: [\n *     \"payment_intent.succeeded\",\n *     \"payment_intent.payment_failed\"\n *   ],\n *   description: \"Webhook for payment notifications\"\n * });\n *\n * @example\n * // Create a webhook for subscription management\n * const subscriptionWebhook = await WebhookEndpoint(\"subscription-webhook\", {\n *   url: \"https://api.example.com/stripe/subscriptions\",\n *   enabledEvents: [\n *     \"customer.subscription.created\",\n *     \"customer.subscription.updated\",\n *     \"customer.subscription.deleted\",\n *     \"invoice.payment_succeeded\",\n *     \"invoice.payment_failed\"\n *   ],\n *   description: \"Webhook for subscription lifecycle events\"\n * });\n *\n * @example\n * // Create a webhook for Connect platform events\n * const connectWebhook = await WebhookEndpoint(\"connect-webhook\", {\n *   url: \"https://api.example.com/stripe/connect\",\n *   enabledEvents: [\n *     \"account.updated\",\n *     \"account.application.deauthorized\",\n *     \"payout.created\",\n *     \"payout.failed\"\n *   ],\n *   connect: true,\n *   metadata: {\n *     platform: \"connect\",\n *     environment: \"production\"\n *   }\n * });\n */\nexport const WebhookEndpoint = Resource(\n  \"stripe::WebhookEndpoint\",\n  async function (\n    this: Context<WebhookEndpoint>,\n    id: string,\n    props: WebhookEndpointProps,\n  ) {\n    // Get Stripe API key from context or environment\n    const apiKey = process.env.STRIPE_API_KEY;\n    if (!apiKey) {\n      throw new Error(\"STRIPE_API_KEY environment variable is required\");\n    }\n\n    // Initialize Stripe client\n    const stripe = new Stripe(apiKey);\n\n    if (this.phase === \"delete\") {\n      try {\n        // Get the webhook ID from the stored output\n        if (this.phase === \"delete\" && this.output?.id) {\n          await stripe.webhookEndpoints.del(this.output.id);\n        }\n      } catch (error) {\n        // Ignore if the webhook doesn't exist\n        console.error(\"Error deleting webhook:\", error);\n      }\n\n      return this.destroy();\n    } else {\n      try {\n        let webhook: Stripe.WebhookEndpoint;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing webhook\n          webhook = await stripe.webhookEndpoints.update(this.output.id, {\n            url: props.url,\n            enabled_events: props.enabledEvents,\n            description: props.description,\n            disabled: props.active === false,\n            metadata: props.metadata,\n          });\n        } else {\n          // Create new webhook\n          webhook = await stripe.webhookEndpoints.create({\n            url: props.url,\n            enabled_events: props.enabledEvents,\n            description: props.description,\n            metadata: props.metadata,\n          });\n\n          // For connect parameter, need to handle it separately if it exists\n          if (props.connect !== undefined) {\n            // Note: connect is specified at creation time and cannot be updated\n            console.log(\n              \"Note: 'connect' parameter will be applied at creation time only\",\n            );\n          }\n        }\n\n        // Store the secret if available\n        let secret = \"\";\n        if (webhook.secret) {\n          secret = webhook.secret;\n        } else if (this.phase === \"update\" && this.output?.secret) {\n          secret = this.output.secret;\n        }\n\n        return this({\n          id: webhook.id,\n          url: webhook.url,\n          enabledEvents: webhook.enabled_events as EnabledEvent[],\n          description: webhook.description || undefined,\n          active: webhook.status === \"enabled\",\n          apiVersion: webhook.api_version || undefined,\n          // connect: !!webhook.connect,\n          metadata: webhook.metadata || undefined,\n          secret: secret,\n          application: webhook.application || undefined,\n          createdAt: webhook.created,\n          livemode: webhook.livemode,\n          updatedAt: webhook.created, // Using created timestamp as updated\n          status: webhook.status,\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating webhook:\", error);\n        throw error;\n      }\n    }\n  },\n);\n\n```"
  }
}