{
  "kind": "docs::Document",
  "id": "docs/ai/AstroFile",
  "fqn": "github:alchemy/prod/docs/docs/ai/AstroFile",
  "seq": 31,
  "data": {},
  "status": "updated",
  "output": {
    "title": "AstroFile",
    "path": "alchemy-web/docs/providers/ai/astro-file.md",
    "freeze": true,
    "model": {
      "id": "claude-3-5-sonnet-latest",
      "provider": "anthropic"
    },
    "prompt": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         ai Service:\n[data.ts](alchemy/src/ai/data.ts)\n\n[vue-file.ts](alchemy/src/ai/vue-file.ts)\n\n[astro-file.ts](alchemy/src/ai/astro-file.ts)\n\n[css-file.ts](alchemy/src/ai/css-file.ts)\n\n[html-file.ts](alchemy/src/ai/html-file.ts)\n\n[document.ts](alchemy/src/ai/document.ts)\n\n[yaml-file.ts](alchemy/src/ai/yaml-file.ts)\n\n[client.ts](alchemy/src/ai/client.ts)\n\n[typescript-file.ts](alchemy/src/ai/typescript-file.ts)\n\n[ark.ts](alchemy/src/ai/ark.ts)\n\n[json-file.ts](alchemy/src/ai/json-file.ts)\n\nWrite concise documentation for the \"        AstroFile\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         AstroFile\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         AstroFile } from \"alchemy/        ai\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         AstroFile } from \"alchemy/        ai\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        \n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Creating Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroying Resources\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value ðŸ˜µâ€ðŸ’«\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n// env.d.ts\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n### 4. Scope-Based Destruction\n\n```typescript\n// Destroy all resources in a scope\nimport { destroy } from \"alchemy\";\nconst scope = alchemy.scope(\"temporary\");\nconst tempFile = await File(\"temp.txt\", { ... });\n\nawait destroy(scope);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// Clean up test resources reliably with try/finally\nconst scope = alchemy.scope(\"test\");\ntry {\n  // Create test resources\n} finally {\n  await destroy(scope);\n}\n```\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\nâ”œâ”€â”€ dev (Stage Scope)\nâ”‚   â”œâ”€â”€ api (Nested Scope)\nâ”‚   â””â”€â”€ database (Resource)\nâ””â”€â”€ prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/ai/ark.ts\n```ts\nimport {\n  type Tool as AITool,\n  type Schema,\n  type ToolExecutionOptions,\n  tool as aitool,\n  jsonSchema,\n} from \"ai\";\nimport { ArkErrors, type JsonSchema, type type } from \"arktype\";\n\nexport namespace ark {\n  export function schema<T>(type: JsonSchema): Schema<T>;\n  export function schema<T extends type>(type: T): Schema<type.infer<T>> {\n    const jsonSchemaObj = type.toJsonSchema() as any;\n    const processedSchema = processSchema(jsonSchemaObj);\n\n    return jsonSchema(processedSchema, {\n      validate: (value) => {\n        const out = type(value) as type.infer<T> | type.errors;\n        if (out instanceof ArkErrors) {\n          return {\n            success: false,\n            error: new Error(out.summary),\n          };\n        }\n        return {\n          success: true,\n          value: out,\n        };\n      },\n    });\n  }\n\n  /**\n   * Recursively processes a JSON schema and sets additionalProperties: false\n   * for any object types.\n   *\n   * Structured Outputs requires additionalProperties: false\n   */\n  function processSchema(schema: any): any {\n    if (!schema || typeof schema !== \"object\") return schema;\n\n    // Create a copy to avoid mutating the original\n    const result = { ...schema };\n\n    // Convert anyOf with all const values to enum\n    if (result.anyOf && Array.isArray(result.anyOf)) {\n      const allConst = result.anyOf.every(\n        (item: any) => item && typeof item === \"object\" && \"const\" in item,\n      );\n\n      if (allConst) {\n        // Extract all const values\n        const enumValues = result.anyOf.map((item: any) => item.const);\n\n        // Determine the type based on the first const value\n        // Assuming all const values are of the same type\n        const firstType = typeof enumValues[0];\n\n        // Replace anyOf with enum\n        delete result.anyOf;\n        result.type = firstType;\n        result.enum = enumValues;\n      } else {\n        // Process each item in anyOf\n        result.anyOf = result.anyOf.map(processSchema);\n      }\n    }\n\n    // If this is an object type, set additionalProperties: false\n    if (result.type === \"object\") {\n      result.additionalProperties = false;\n      result.properties ??= {};\n    }\n\n    // Process properties of objects\n    if (result.properties && typeof result.properties === \"object\") {\n      result.properties = Object.fromEntries(\n        Object.entries(result.properties).map(([key, value]) => [\n          key,\n          processSchema(value),\n        ]),\n      );\n    }\n\n    // Process items in arrays\n    if (result.items) {\n      result.items = processSchema(result.items);\n    }\n\n    // Process allOf, oneOf\n    for (const key of [\"allOf\", \"oneOf\"]) {\n      if (Array.isArray(result[key])) {\n        result[key] = result[key].map(processSchema);\n      }\n    }\n\n    return result;\n  }\n\n  export interface Tool<Input extends type, Output>\n    extends Omit<AITool<Schema<type.infer<Input>>>, \"parameters\" | \"execute\"> {\n    description?: string;\n    parameters: Input;\n    execute: (\n      input: type.infer<Input>,\n      options: ToolExecutionOptions,\n    ) => Promise<Output>;\n  }\n\n  export function tool<Input extends type, Output>(\n    tool: Tool<Input, Output>,\n  ): AITool<Schema<type.infer<Input>>, Output> {\n    return aitool({\n      ...tool,\n      parameters: ark.schema<Input>(tool.parameters),\n    } as any);\n  }\n}\n\n```\n\n// alchemy/src/ai/astro-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport prettier from \"prettier\";\nimport type { Context } from \"../context\";\nimport { StaticAstroFile } from \"../fs/static-astro-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating an AstroFile\n */\nexport interface AstroFileProps {\n  /**\n   * Path to the Astro file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate an Astro component using:\n   *   ${alchemy.file(\"src/types.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return Astro code inside ```astro fences\n   * @default \"You are an Astro component generator. Create Astro components based on the user's requirements. Your response MUST include only Astro code inside ```astro fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Prettier configuration to use for formatting the Astro code\n   * If not provided, will use the default Prettier configuration\n   */\n  prettierConfig?: prettier.Options;\n}\n\n/**\n * An Astro file that can be created, updated, and deleted\n */\nexport interface AstroFile extends AstroFileProps, Resource<\"ai::AstroFile\"> {\n  /**\n   * Content of the Astro file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for Astro file generation\n */\nconst DEFAULT_ASTRO_SYSTEM_PROMPT =\n  \"You are an Astro component generator. Create Astro components based on the user's requirements. Your response MUST include only Astro code inside ```astro fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating Astro files using AI models.\n * Extracts Astro code from between ```astro fences, validates the response,\n * and formats the code with Prettier.\n *\n * @example\n * // Create a simple Astro component\n * const header = await AstroFile(\"header\", {\n *   path: \"./src/components/Header.astro\",\n *   prompt: await alchemy`\n *     Generate an Astro header component with:\n *     - Site logo\n *     - Navigation menu with Home, About, Services, Contact links\n *     - Mobile responsive design\n *     - Dark/light mode toggle\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate an Astro page with data fetching\n * const blogPost = await AstroFile(\"blog-post\", {\n *   path: \"./src/pages/blog/[slug].astro\",\n *   prompt: await alchemy`\n *     Create an Astro blog post page that:\n *     - Uses getStaticPaths to generate pages from a CMS\n *     - Renders markdown content\n *     - Includes author info, publication date, and related posts\n *     - Has social sharing buttons\n *\n *     Use the following types:\n *     ${alchemy.file(\"src/types/Blog.ts\")}\n *   `,\n *   temperature: 0.2,\n *   prettierConfig: {\n *     semi: false,\n *     singleQuote: true,\n *     printWidth: 120\n *   }\n * });\n *\n * @example\n * // Generate a layout with custom system prompt\n * const mainLayout = await AstroFile(\"main-layout\", {\n *   path: \"./src/layouts/MainLayout.astro\",\n *   prompt: await alchemy`\n *     Create the main layout for an Astro site that:\n *     - Includes common head metadata and SEO optimization\n *     - Has slots for page content, header, and footer\n *     - Imports and uses the Header and Footer components\n *     - Sets up viewport and responsive configurations\n *   `,\n *   system: \"You are an expert Astro developer. Create a single Astro layout file inside ```astro fences with no additional text. Follow Astro best practices and include proper typing in the frontmatter section.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const AstroFile = Resource(\n  \"ai::AstroFile\",\n  async function (\n    this: Context<AstroFile>,\n    id: string,\n    props: AstroFileProps\n  ): Promise<AstroFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_ASTRO_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate Astro code\n    let { code, error } = await extractAstroCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one Astro code block inside \\`\\`\\`astro fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractAstroCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid Astro code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Format the code with Prettier\n    try {\n      // Set default parser to astro\n      const prettierOptions: prettier.Options = {\n        parser: \"astro\",\n        ...props.prettierConfig,\n      };\n\n      // Format the code\n      code = await prettier.format(code, prettierOptions);\n    } catch (error) {\n      // If Prettier formatting fails, just use the unformatted code\n      console.warn(\"Failed to format Astro code with Prettier:\", error);\n    }\n\n    // Use StaticAstroFile to create/update the file\n    const file = await StaticAstroFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts Astro code from between ```astro fences\n * Validates that exactly one Astro code block exists\n *\n * @param text The text to extract Astro code from\n * @returns The extracted Astro code or error message\n */\nasync function extractAstroCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const astroCodeRegex = /```astro\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(astroCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No Astro code block found in the response. Please include your code within ```astro fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple Astro code blocks found in the response. Please provide exactly one code block within ```astro fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/client.ts\n```ts\nimport { anthropic } from \"@ai-sdk/anthropic\";\nimport { openai } from \"@ai-sdk/openai\";\nimport type { Secret } from \"../secret\";\n\n/**\n * Model configuration for AI operations\n */\nexport interface ModelConfig {\n  /**\n   * Model ID to use\n   * @default 'gpt-4o'\n   */\n  id?: string;\n\n  /**\n   * Model provider name\n   * @default 'openai'\n   */\n  provider?: string;\n\n  /**\n   * Model-specific options\n   */\n  options?: Record<string, any>;\n}\n\n/**\n * Configuration for creating an OpenAI client\n */\nexport interface ClientConfig {\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n}\n\n/**\n * Creates an OpenAI-compatible client with the given configuration\n */\nexport function createModel(config: ClientConfig) {\n  if (config.model?.provider === \"anthropic\") {\n    return anthropic(config.model?.id ?? \"claude-3-7-sonnet-latest\");\n  } else {\n    return openai(config.model?.id ?? \"gpt-4o\");\n  }\n}\n\n/**\n * Maximum time to retry in milliseconds (5 minutes)\n */\nconst MAX_RETRY_TIME = 5 * 60 * 1000;\n\n/**\n * Initial delay between retries in milliseconds\n */\nconst INITIAL_RETRY_DELAY = 1000;\n\n/**\n * Maximum number of retries\n */\nconst MAX_RETRIES = 10;\n\n/**\n * Handles rate limiting with exponential backoff\n * @param fn Function to retry\n * @returns Result of the function\n * @throws Error if max retries or time is exceeded\n */\nexport async function withRateLimitRetry<T>(fn: () => Promise<T>): Promise<T> {\n  let retryCount = 0;\n  let lastError: Error | null = null;\n  let startTime = Date.now();\n\n  while (true) {\n    try {\n      return await fn();\n    } catch (error: any) {\n      lastError = error;\n\n      console.log(\"retry error\", error);\n\n      // Check if we should retry\n      const isRateLimit = error.statusCode === 429;\n      const timeElapsed = Date.now() - startTime;\n      const shouldRetry =\n        isRateLimit && retryCount < MAX_RETRIES && timeElapsed < MAX_RETRY_TIME;\n\n      if (!shouldRetry) {\n        throw error;\n      }\n\n      // Calculate delay with exponential backoff\n      const delay = Math.min(\n        INITIAL_RETRY_DELAY * Math.pow(2, retryCount),\n        MAX_RETRY_TIME - timeElapsed\n      );\n\n      console.log(`Retrying in ${delay}ms`);\n\n      // Wait before retrying\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      retryCount++;\n    }\n  }\n}\n\n```\n\n// alchemy/src/ai/css-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticCSSFile } from \"../fs/static-css-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a CSSFile\n */\nexport interface CSSFileProps {\n  /**\n   * Path to the CSS file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate CSS styles for:\n   *   ${alchemy.file(\"src/components/Button.jsx\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return CSS code inside ```css fences\n   * @default \"You are a CSS code generator. Create CSS code based on the user's requirements. Your response MUST include only CSS code inside ```css fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A CSS file that can be created, updated, and deleted\n */\nexport interface CSSFile extends CSSFileProps, Resource<\"ai::CSSFile\"> {\n  /**\n   * Content of the CSS file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for CSS file generation\n */\nconst DEFAULT_CSS_SYSTEM_PROMPT =\n  \"You are a CSS code generator. Create CSS code based on the user's requirements. Your response MUST include only CSS code inside ```css fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating CSS files using AI models.\n * Extracts CSS code from between ```css fences and validates the response.\n *\n * @example\n * // Create styles for a website\n * const mainStyles = await CSSFile(\"main-styles\", {\n *   path: \"./public/css/main.css\",\n *   prompt: await alchemy`\n *     Generate modern CSS styles for a company website with:\n *     - Clean, minimalist design\n *     - Primary color: #0062ff\n *     - Secondary color: #6c757d\n *     - Light gray background\n *     - Responsive layout for mobile, tablet, and desktop\n *     - Custom styles for buttons, cards, and navigation\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate CSS based on existing HTML\n * const componentStyles = await CSSFile(\"component-styles\", {\n *   path: \"./src/styles/component.css\",\n *   prompt: await alchemy`\n *     Create CSS styles for this HTML component:\n *     ${alchemy.file(\"src/components/Card.html\")}\n *\n *     The styles should be:\n *     - Modern and clean\n *     - Include hover effects and transitions\n *     - Support both light and dark themes\n *     - Use CSS variables for colors and spacing\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate CSS animation with custom system prompt\n * const animationStyles = await CSSFile(\"animations\", {\n *   path: \"./src/styles/animations.css\",\n *   prompt: await alchemy`\n *     Create CSS animations for:\n *     - Fade in/out\n *     - Slide in from different directions\n *     - Pulse effect\n *     - Bounce effect\n *     - Scale in/out\n *     - Rotate\n *\n *     Each animation should be reusable via class names.\n *   `,\n *   system: \"You are an expert CSS animator. Create a single CSS file inside ```css fences with no additional text. Use modern CSS animation techniques and include vendor prefixes where needed for browser compatibility.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const CSSFile = Resource(\n  \"ai::CSSFile\",\n  async function (\n    this: Context<CSSFile>,\n    id: string,\n    props: CSSFileProps\n  ): Promise<CSSFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_CSS_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate CSS code\n    let { code, error } = await extractCSSCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one CSS code block inside \\`\\`\\`css fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractCSSCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid CSS code: ${retryResult.error}\\n${retryText}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticCSSFile to create/update the file\n    const file = await StaticCSSFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts CSS code from between ```css fences\n * Validates that exactly one CSS code block exists\n *\n * @param text The text to extract CSS code from\n * @returns The extracted CSS code or error message\n */\nasync function extractCSSCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const cssCodeRegex = /```css\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(cssCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No CSS code block found in the response. Please include your code within ```css fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple CSS code blocks found in the response. Please provide exactly one code block within ```css fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/data.ts\n```ts\nimport { generateObject, type CoreMessage } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { createModel, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating an AI Object\n */\nexport interface DataProps<T extends Type<any, any>> {\n  /**\n   * The ArkType schema to validate and structure the generated content\n   */\n  schema: T | JsonSchema;\n\n  /**\n   * Prompt for generating the content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a description for:\n   *   ${alchemy.file(\"src/data.ts\")}\n   * `\n   */\n  prompt?: string;\n\n  /**\n   * Message history for the conversation\n   * If provided, this will be used instead of the prompt\n   */\n  messages?: CoreMessage[];\n\n  /**\n   * System prompt to guide the AI's behavior\n   * @example\n   * system: \"You are a technical writer tasked with describing code\"\n   */\n  system?: string;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Whether to freeze the generated object\n   * @default false\n   */\n  freeze?: boolean;\n}\n\n/**\n * A resource that uses AI to generate structured content based on a schema\n */\nexport interface Data<T> extends Resource<\"ai::Object\"> {\n  type: JsonSchema;\n\n  /**\n   * The generated content, typed according to the provided schema\n   */\n  object: T;\n\n  /**\n   * Updated message history with the AI's response appended\n   */\n  messages: CoreMessage[];\n\n  /**\n   * Time at which the content was generated\n   */\n  createdAt: number;\n}\n\n/**\n * Resource for generating structured content using the Vercel AI SDK.\n * Supports powerful context handling through the alchemy template literal tag.\n *\n * @example\n * // Generate a product description with specific fields\n * const productSchema = type({\n *   name: \"string\",\n *   description: \"string\",\n *   features: \"string[]\",\n *   price: \"number\"\n * });\n *\n * const product = await Data(\"new-product\", {\n *   schema: productSchema,\n *   prompt: \"Generate a product description for a new smartphone\",\n *   system: \"You are a product copywriter specializing in tech products\",\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\",\n *     options: {\n *       temperature: 0.7\n *     }\n *   }\n * });\n *\n * console.log(product.object); // Typed as per schema\n *\n * @example\n * // Generate code documentation with context\n * const docSchema = type({\n *   summary: \"string\",\n *   parameters: {\n *     name: \"string\",\n *     type: \"string\",\n *     description: \"string\"\n *   }[],\n *   returns: \"string\"\n * });\n *\n * const docs = await Data(\"function-docs\", {\n *   schema: docSchema,\n *   prompt: await alchemy`\n *     Generate documentation for this function:\n *     ${alchemy.file(\"src/utils/format.ts\")}\n *   `,\n *   system: \"You are a technical documentation writer\",\n *   temperature: 0.2\n * });\n *\n * @example\n * // Using message history for iterative generation\n * const feedbackSchema = type({\n *   rating: \"number\",\n *   positives: \"string[]\",\n *   improvements: \"string[]\",\n *   summary: \"string\"\n * });\n *\n * const feedback = await Data(\"product-feedback\", {\n *   schema: feedbackSchema,\n *   messages: [\n *     { role: \"user\", content: \"I'd like feedback on my product design\" },\n *     { role: \"assistant\", content: \"I'd be happy to provide feedback. What's your product?\" },\n *     { role: \"user\", content: \"It's a new smart home device that...\" }\n *   ],\n *   system: \"You are a product design expert providing structured feedback\",\n *   temperature: 0.3\n * });\n */\nexport const Data = Resource(\"ai::Object\", async function <\n  const T extends Type<any, any>,\n>(this: Context<Data<any>>, id: string, props: DataProps<T>): Promise<\n  Data<type.infer<T>>\n> {\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  // Validate that either prompt or messages is provided\n  if (!props.prompt && !props.messages) {\n    throw new Error(\"Either prompt or messages must be provided\");\n  }\n\n  if (this.phase === \"update\" && props.freeze) {\n    return this(this.output);\n  }\n\n  // Create messages array if only prompt is provided\n  const messages = props.messages || [{ role: \"user\", content: props.prompt! }];\n\n  // Generate structured output using generateObject\n  const { object } = await generateObject({\n    model: createModel(props),\n    // Convert ArkType schema to Zod schema for generateObject\n    // This is needed because generateObject expects a Zod schema\n    schema: ark.schema<type.infer<T>>(props.schema),\n    providerOptions: props.model?.options,\n    system:\n      props.system ||\n      \"You are an AI assistant tasked with generating structured content.\",\n    messages,\n    ...(props.temperature === undefined\n      ? {}\n      : // some models error if you provide it (rather than ignoring it)\n        { temperature: props.temperature }),\n  });\n\n  // Create updated message history with the structured response\n  const responseText = JSON.stringify(object);\n  const updatedMessages = [\n    ...messages,\n    {\n      role: \"assistant\" as const,\n      content: responseText,\n    },\n  ];\n\n  // Return the resource with typed content and updated messages\n  return this({\n    type: props.schema,\n    object: object,\n    messages: updatedMessages,\n    createdAt: Date.now(),\n  });\n});\n\n```\n\n// alchemy/src/ai/document.ts\n```ts\nimport { generateText, type CoreMessage } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticTextFile } from \"../fs/static-text-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createModel, withRateLimitRetry, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating a Document\n */\nexport interface DocumentProps {\n  /**\n   * Title of the document\n   *\n   * @default id\n   */\n  title?: string;\n\n  /**\n   * Optional path to the markdown document\n   * If provided, document will be written to this path\n   */\n  path?: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate docs using:\n   *   ${alchemy.file(\"src/api.ts\")}\n   * `\n   */\n  prompt?: string;\n\n  /**\n   * Message history for conversation-based generation\n   * If provided, this will be used instead of the prompt\n   * @example\n   * messages: [\n   *   { role: \"user\", content: \"Generate API documentation for this file\" },\n   *   { role: \"assistant\", content: \"I'll create detailed API docs. What file should I document?\" },\n   *   { role: \"user\", content: \"Please document src/api.ts\" }\n   * ]\n   */\n  messages?: CoreMessage[];\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return a single markdown document inside ```md fences\n   * @default \"You are a technical documentation writer. Create a single markdown document based on the user's requirements. Your response MUST include only a single markdown document inside ```md fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Maximum number of tokens to generate.\n   * Higher values allow for longer documents but may increase cost and generation time.\n   * @default 10000\n   */\n  maxTokens?: number;\n\n  /**\n   * Freeze the document after creation (do not re-generate on updates)\n   * @default false\n   */\n  freeze?: boolean;\n}\n\n/**\n * A markdown document that can be created, updated, and deleted\n */\nexport interface Document extends DocumentProps, Resource<\"docs::Document\"> {\n  /**\n   * The title of the document\n   */\n  title: string;\n\n  /**\n   * Content of the document\n   */\n  content: string;\n\n  /**\n   * Updated message history with the document response appended\n   */\n  messages: CoreMessage[];\n\n  /**\n   * Time at which the document was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the document was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * File resource if path was provided\n   */\n  file?: StaticTextFile;\n}\n\n/**\n * Default system prompt for markdown document generation\n */\nconst DEFAULT_MD_SYSTEM_PROMPT =\n  \"You are a technical documentation writer. Create a single markdown document based on the user's requirements. Your response MUST include only a single markdown document inside ```md fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for managing AI-generated markdown documents using the Vercel AI SDK.\n * Supports powerful context handling through the alchemy template literal tag.\n *\n * @example\n * // Create an in-memory document (no file created)\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   prompt: await alchemy`\n *     Generate API documentation based on these source files:\n *     ${alchemy.file(\"src/api.ts\")}\n *     ${alchemy.file(\"src/types.ts\")}\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Create a document and write it to disk\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   path: \"./docs/api.md\",\n *   prompt: await alchemy`\n *     Generate API documentation based on these source files:\n *     ${alchemy.file(\"src/api.ts\")}\n *     ${alchemy.file(\"src/types.ts\")}\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Use message history for iterative document generation\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   path: \"./docs/api.md\",\n *   messages: [\n *     { role: \"user\", content: \"Create API documentation for these files\" },\n *     { role: \"assistant\", content: \"I'll help you create API documentation. Please provide the files.\" },\n *     { role: \"user\", content: \"Here are the files: [file contents]\" }\n *   ],\n *   system: \"You are a technical documentation writer. Generate clear and concise API documentation.\",\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Use alchemy template literals with file collections and temperature control\n * const modelDocs = await Document(\"models\", {\n *   title: \"Data Models\",\n *   path: \"./docs/models.md\",\n *   prompt: await alchemy`\n *     Write documentation for these data models:\n *     ${alchemy.files(\"src/models/user.ts\", \"src/models/post.ts\")}\n *   `,\n *   temperature: 0.2 // Lower temperature for more deterministic output\n * });\n *\n * @example\n * // Advanced model configuration with custom provider options and custom system prompt\n * const techDocs = await Document(\"tech-specs\", {\n *   title: \"Technical Specifications\",\n *   path: \"./docs/tech-specs.md\",\n *   prompt: await alchemy`\n *     Create detailed technical specifications based on these requirements:\n *     ${alchemy.file(\"requirements/system.md\")}\n *   `,\n *   system: \"You are an expert technical writer specializing in system specifications. Create a single markdown document inside ```md fences with no additional text.\",\n *   model: {\n *     id: \"o3-mini\",\n *     provider: \"openai\",\n *     options: {\n *       reasoningEffort: \"high\"\n *     }\n *   },\n *   temperature: 0.1\n * });\n */\nexport const Document = Resource(\n  \"docs::Document\",\n  async function (\n    this: Context<Document>,\n    id: string,\n    props: DocumentProps\n  ): Promise<Document> {\n    // Validate that either prompt or messages are provided\n    if (!props.prompt && !props.messages) {\n      throw new Error(\"Either prompt or messages must be provided\");\n    }\n\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    if (this.phase === \"update\" && props.freeze) {\n      if (props.path) {\n        const filePath = props.path;\n        const fileId = `${id}-file`;\n\n        await StaticTextFile(fileId, filePath, this.output!.content);\n      }\n      return this(this.output);\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_MD_SYSTEM_PROMPT;\n\n    // Generate initial content with rate limit retry\n    const { text } = await withRateLimitRetry(async () => {\n      return generateText({\n        model: createModel(props),\n        ...(props.messages\n          ? { messages: props.messages }\n          : { prompt: props.prompt! }),\n        system,\n        maxTokens: props.maxTokens || 8192,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : // some models error if you provide it (rather than ignoring it)\n            { temperature: props.temperature }),\n      });\n    });\n\n    // Extract and validate markdown content\n    let { content, error } = extractMarkdownContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one markdown document inside \\`\\`\\`md fences.`;\n\n      const { text: retryText } = await withRateLimitRetry(async () => {\n        return generateText({\n          model: createModel(props),\n          ...(props.messages\n            ? { messages: props.messages }\n            : { prompt: props.prompt! }),\n          system: errorSystem,\n          providerOptions: props.model?.options,\n          ...(props.temperature === undefined\n            ? {}\n            : { temperature: props.temperature }),\n        });\n      });\n\n      const retryResult = extractMarkdownContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid markdown content: ${retryResult.error}\\n${retryText}`\n        );\n      }\n\n      content = retryResult.content;\n    }\n\n    // Create result object\n    const result: Partial<Document> = {\n      ...props,\n      content,\n      messages: [\n        ...(props.messages || [{ role: \"user\", content: props.prompt! }]),\n        { role: \"assistant\", content },\n      ],\n      createdAt: this.output?.createdAt || Date.now(),\n      updatedAt: Date.now(),\n      title: props.title || id,\n    };\n\n    // Write file if path is provided\n    if (props.path) {\n      const filePath = props.path;\n      const fileId = `${id}-file`;\n\n      result.file = await StaticTextFile(fileId, filePath, content);\n    }\n\n    // Return the resource\n    return this(result as Document);\n  }\n);\n\n/**\n * Extracts markdown content from between ```md fences\n * Validates that exactly one markdown code block exists\n *\n * @param text The text to extract markdown content from\n * @returns The extracted markdown content or error message\n */\nfunction extractMarkdownContent(text: string): {\n  content: string;\n  error?: string;\n} {\n  const lines = text.split(\"\\n\");\n  const startIdx = lines.findIndex((line) => line.trim() === \"```md\");\n\n  if (startIdx === -1) {\n    return {\n      content: \"\",\n      error:\n        \"No markdown code block found in the response. Please include your markdown content within ```md fences.\",\n    };\n  }\n\n  const rest = lines.slice(startIdx + 1);\n  const endRelativeIdx = rest\n    .map((line) => line.trim() === \"```\")\n    .lastIndexOf(true);\n\n  if (endRelativeIdx === -1) {\n    return {\n      content: \"\",\n      error: \"Markdown block was not closed properly.\",\n    };\n  }\n\n  const endIdx = startIdx + 1 + endRelativeIdx;\n\n  const content = lines\n    .slice(startIdx + 1, endIdx)\n    .join(\"\\n\")\n    .trim();\n\n  return { content };\n}\n\n```\n\n// alchemy/src/ai/html-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticHTMLFile } from \"../fs/static-html-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating an HTMLFile\n */\nexport interface HTMLFileProps {\n  /**\n   * Path to the HTML file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate an HTML page using:\n   *   ${alchemy.file(\"src/templates/base.html\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return HTML code inside ```html fences\n   * @default \"You are an HTML code generator. Create HTML code based on the user's requirements. Your response MUST include only HTML code inside ```html fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * An HTML file that can be created, updated, and deleted\n */\nexport interface HTMLFile extends HTMLFileProps, Resource<\"ai::HTMLFile\"> {\n  /**\n   * Content of the HTML file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for HTML file generation\n */\nconst DEFAULT_HTML_SYSTEM_PROMPT =\n  \"You are an HTML code generator. Create HTML code based on the user's requirements. Your response MUST include only HTML code inside ```html fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating HTML files using AI models.\n * Extracts HTML code from between ```html fences and validates the response.\n *\n * @example\n * // Create a simple landing page\n * const landingPage = await HTMLFile(\"landing-page\", {\n *   path: \"./public/index.html\",\n *   prompt: await alchemy`\n *     Generate a modern landing page for a SaaS product with:\n *     - Hero section with headline and call-to-action\n *     - Features section with 3 key features\n *     - Pricing section with 3 tiers\n *     - Testimonials section with 2 customer quotes\n *     - Contact form and footer\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate an HTML email template\n * const emailTemplate = await HTMLFile(\"welcome-email\", {\n *   path: \"./emails/welcome.html\",\n *   prompt: await alchemy`\n *     Create an HTML email template for welcoming new users to our platform.\n *     The email should include:\n *     - Company logo and branding\n *     - Personalized welcome message (use {{name}} placeholder)\n *     - Three steps to get started\n *     - Support contact information\n *     - Unsubscribe footer\n *\n *     Make sure it's responsive and works in all major email clients.\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate an HTML component with custom system prompt\n * const navComponent = await HTMLFile(\"navigation\", {\n *   path: \"./components/nav.html\",\n *   prompt: await alchemy`\n *     Create a responsive navigation component with:\n *     - Logo in the left corner\n *     - Navigation links: Home, Products, Services, About, Contact\n *     - Mobile hamburger menu that expands/collapses\n *     - Login/signup buttons on the right side\n *     - Dark/light mode toggle\n *   `,\n *   system: \"You are an expert HTML/CSS developer specializing in responsive components. Create a single HTML file inside ```html fences with no additional text. Use modern HTML5 semantic elements and inline CSS if needed.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const HTMLFile = Resource(\n  \"ai::HTMLFile\",\n  async function (\n    this: Context<HTMLFile>,\n    id: string,\n    props: HTMLFileProps\n  ): Promise<HTMLFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_HTML_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate HTML code\n    let { code, error } = await extractHTMLCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one HTML code block inside \\`\\`\\`html fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractHTMLCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid HTML code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticHTMLFile to create/update the file\n    const file = await StaticHTMLFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts HTML code from between ```html fences\n * Validates that exactly one HTML code block exists\n *\n * @param text The text to extract HTML code from\n * @returns The extracted HTML code or error message\n */\nasync function extractHTMLCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const htmlCodeRegex = /```html\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(htmlCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No HTML code block found in the response. Please include your code within ```html fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple HTML code blocks found in the response. Please provide exactly one code block within ```html fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/json-file.ts\n```ts\nimport { generateObject, generateText } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { StaticJsonFile } from \"../fs/static-json-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a JSONFile\n */\nexport interface JSONFileProps<\n  T extends Type<any, any> | undefined = undefined,\n> {\n  /**\n   * Path to the JSON file\n   */\n  path: string;\n\n  /**\n   * Optional ArkType schema to validate and structure the generated JSON\n   * When provided, the resource will use generateObject with schema validation\n   * When not provided, it will extract JSON from between ```json fences\n   */\n  schema?: T;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a JSON configuration for:\n   *   ${alchemy.file(\"src/config.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * @default Depends on whether schema is provided\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Whether to pretty-print the JSON with indentation\n   * @default true\n   */\n  pretty?: boolean;\n\n  /**\n   * Number of spaces to use for indentation when pretty-printing\n   * @default 2\n   */\n  indent?: number;\n}\n\n/**\n * A JSON file that can be created, updated, and deleted\n */\nexport interface JSONFile<T = any>\n  extends Omit<JSONFileProps, \"schema\">,\n    Resource<\"ai::JSONFile\"> {\n  /**\n   * Content of the JSON file as a string\n   */\n  content: string;\n\n  /**\n   * Parsed JSON object\n   */\n  json: T;\n\n  /**\n   * Schema used to validate the JSON (if provided)\n   */\n  schema?: JsonSchema;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for JSON file generation without schema\n */\nconst DEFAULT_JSON_SYSTEM_PROMPT =\n  \"You are a JSON generator. Create valid JSON based on the user's requirements. Your response MUST include only JSON inside ```json fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating JSON files using AI models.\n * Can operate in two modes:\n * 1. With schema: Uses generateObject with type validation\n * 2. Without schema: Extracts JSON from between ```json fences\n *\n * @example\n * // Generate a configuration file with freeform JSON\n * const config = await JSONFile(\"app-config\", {\n *   path: \"./config/app.json\",\n *   prompt: await alchemy`\n *     Generate a configuration for a web application with:\n *     - Server settings (port, host, timeout)\n *     - Database connection details (redact any passwords)\n *     - Logging configuration\n *     - Feature flags\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate JSON with schema validation\n * import { type } from \"arktype\";\n *\n * const userSchema = type({\n *   users: [{\n *     id: \"string\",\n *     name: \"string\",\n *     email: \"string\",\n *     role: \"'admin' | 'user' | 'guest'\",\n *     permissions: \"string[]\",\n *     active: \"boolean\"\n *   }]\n * });\n *\n * const userData = await JSONFile(\"user-data\", {\n *   path: \"./data/users.json\",\n *   schema: userSchema,\n *   prompt: \"Generate sample user data for an application with various roles and permissions\",\n *   temperature: 0.2\n * });\n *\n * // Type-safe access to the generated data\n * console.log(userData.json.users[0].role); // Typed as 'admin' | 'user' | 'guest'\n *\n * @example\n * // Generate API mock data with custom system prompt\n * const apiMock = await JSONFile(\"api-mock\", {\n *   path: \"./mocks/products-api.json\",\n *   prompt: await alchemy`\n *     Create mock data for a product catalog API response with:\n *     - 10 products with different categories\n *     - Each product should have id, name, price, category, inventory, and image_url\n *     - Include pagination metadata (total, page, limit)\n *   `,\n *   system: \"You are an API design expert. Create realistic mock JSON data that follows REST API best practices. Your response must be valid JSON inside ```json fences.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   },\n *   pretty: true,\n *   indent: 4\n * });\n */\nexport const JSONFile = Resource(\"ai::JSONFile\", async function <\n  const T extends Type<any, any> | undefined = undefined,\n>(this: Context<JSONFile<T extends Type<any, any> ? type.infer<T> : any>>, id: string, props: JSONFileProps<T>): Promise<\n  JSONFile<T extends Type<any, any> ? type.infer<T> : any>\n> {\n  // Handle deletion phase\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  let jsonContent: string;\n  let jsonObject: any;\n\n  // Check if schema is provided\n  if (props.schema) {\n    // Use schema-based generation\n    const { object } = await generateObject({\n      model: createModel(props),\n      schema: ark.schema<type.infer<typeof props.schema>>(props.schema),\n      providerOptions: props.model?.options,\n      system:\n        props.system ||\n        \"Generate a valid JSON object based on the provided requirements.\",\n      prompt: props.prompt,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    jsonObject = object;\n\n    // Use StaticJsonFile to create the file\n    const file = await StaticJsonFile(\"file\", props.path, jsonObject);\n    jsonContent = file.content;\n  } else {\n    // Use fence-based extraction\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_JSON_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate JSON content\n    let { content, error } = await extractJSONContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one valid JSON block inside \\`\\`\\`json fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractJSONContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(`Failed to generate valid JSON: ${retryResult.error}`);\n      }\n\n      content = retryResult.content;\n    }\n\n    // Parse JSON to get the object representation\n    jsonObject = JSON.parse(content);\n\n    // Use StaticJsonFile to create the file\n    const file = await StaticJsonFile(\"file\", props.path, jsonObject);\n    jsonContent = file.content;\n  }\n\n  // Return the resource\n  return this({\n    ...props,\n    schema: props.schema,\n    content: jsonContent,\n    json: jsonObject,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  });\n});\n\n/**\n * Extracts JSON content from between ```json fences\n * Validates that exactly one JSON code block exists\n *\n * @param text The text to extract JSON from\n * @returns The extracted JSON or error message\n */\nasync function extractJSONContent(\n  text: string\n): Promise<{ content: string; error?: string }> {\n  const jsonCodeRegex = /```json\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(jsonCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      content: \"\",\n      error:\n        \"No JSON code block found in the response. Please include your JSON within ```json fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      content: \"\",\n      error:\n        \"Multiple JSON code blocks found in the response. Please provide exactly one JSON block within ```json fences.\",\n    };\n  }\n\n  const content = matches[0][1].trim();\n\n  // Validate JSON can be parsed\n  try {\n    JSON.parse(content);\n    return { content };\n  } catch (e) {\n    return {\n      content: \"\",\n      error: `Invalid JSON: ${(e as Error).message}. Please provide valid JSON syntax.`,\n    };\n  }\n}\n\n```\n\n// alchemy/src/ai/typescript-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticTypeScriptFile } from \"../fs/static-typescript-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createModel, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating a TypeScriptFile\n */\nexport interface TypeScriptFileProps {\n  /**\n   * Path to the TypeScript file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a TypeScript utility function using:\n   *   ${alchemy.file(\"src/types.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return TypeScript code inside ```ts fences\n   * @default \"You are a TypeScript code generator. Create TypeScript code based on the user's requirements. Your response MUST include only TypeScript code inside ```ts fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Prettier configuration to use for formatting the TypeScript code\n   * If not provided, will use the default Prettier configuration\n   */\n  prettierConfig?: object;\n}\n\n/**\n * A TypeScript file that can be created, updated, and deleted\n */\nexport interface TypeScriptFile\n  extends TypeScriptFileProps,\n    Resource<\"ai::TypeScriptFile\"> {\n  /**\n   * Content of the TypeScript file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for TypeScript file generation\n */\nconst DEFAULT_TS_SYSTEM_PROMPT =\n  \"You are a TypeScript code generator. Create TypeScript code based on the user's requirements. Your response MUST include only TypeScript code inside ```ts fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating TypeScript files using AI models.\n * Extracts TypeScript code from between ```ts fences, validates the response,\n * and formats the code with Prettier.\n *\n * @example\n * // Create a utility function\n * const utils = await TypeScriptFile(\"string-utils\", {\n *   path: \"./src/utils/string-utils.ts\",\n *   prompt: await alchemy`\n *     Generate TypeScript utility functions for string manipulation:\n *     - Capitalize first letter\n *     - Truncate with ellipsis\n *     - Convert to camelCase and kebab-case\n *     - Remove special characters\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate a TypeScript class with custom formatting\n * const userService = await TypeScriptFile(\"user-service\", {\n *   path: \"./src/services/UserService.ts\",\n *   prompt: await alchemy`\n *     Create a UserService class that handles user authentication and profile management.\n *     The service should use the User type from:\n *     ${alchemy.file(\"src/types/User.ts\")}\n *\n *     Include methods for:\n *     - login(email, password)\n *     - register(user)\n *     - updateProfile(userId, profileData)\n *     - deleteAccount(userId)\n *   `,\n *   temperature: 0.2,\n *   prettierConfig: {\n *     semi: false,\n *     singleQuote: true,\n *     printWidth: 120\n *   }\n * });\n *\n * @example\n * // Generate a React hook with custom system prompt\n * const useFormHook = await TypeScriptFile(\"use-form\", {\n *   path: \"./src/hooks/useForm.ts\",\n *   prompt: await alchemy`\n *     Create a custom React hook called useForm that handles form state, validation, and submission.\n *     It should support:\n *     - Initial values\n *     - Validation rules\n *     - Field errors\n *     - Form submission with loading state\n *     - Reset functionality\n *   `,\n *   system: \"You are an expert React developer specializing in TypeScript hooks. Create a single TypeScript file inside ```ts fences with no additional text. Follow React best practices and include proper typing.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const TypeScriptFile = Resource(\n  \"ai::TypeScriptFile\",\n  async function (\n    this: Context<TypeScriptFile>,\n    id: string,\n    props: TypeScriptFileProps\n  ): Promise<TypeScriptFile> {\n    // Handle delete phase\n    if (this.phase === \"delete\") {\n      // StaticTypeScriptFile will handle the deletion\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_TS_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate TypeScript code\n    let { code, error } = await extractTypeScriptCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one TypeScript code block inside \\`\\`\\`ts fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractTypeScriptCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid TypeScript code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticTypeScriptFile to create/update the file\n    const file = await StaticTypeScriptFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts TypeScript code from between ```ts fences\n * Validates that exactly one TypeScript code block exists\n *\n * @param text The text to extract TypeScript code from\n * @returns The extracted TypeScript code or error message\n */\nasync function extractTypeScriptCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const tsCodeRegex = /```ts\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(tsCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No TypeScript code block found in the response. Please include your code within ```ts fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple TypeScript code blocks found in the response. Please provide exactly one code block within ```ts fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/vue-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticVueFile } from \"../fs/static-vue-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a VueFile\n */\nexport interface VueFileProps {\n  /**\n   * Path to the Vue file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a Vue component using:\n   *   ${alchemy.file(\"src/api.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return a single Vue component inside ```vue fences\n   * @default \"You are a Vue component generator. Create a single Vue component based on the user's requirements. Your response MUST include only a single Vue component inside ```vue fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A Vue file that can be created, updated, and deleted\n */\nexport interface VueFile extends VueFileProps, Resource<\"ai::VueFile\"> {\n  /**\n   * Content of the Vue file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for Vue file generation\n */\nconst DEFAULT_VUE_SYSTEM_PROMPT =\n  \"You are a Vue component generator. Create a single Vue component based on the user's requirements. Your response MUST include only a single Vue component inside ```vue fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating Vue files using AI models.\n * Extracts Vue code from between ```vue fences and validates the response.\n *\n * @example\n * // Create a simple Vue component\n * const button = await VueFile(\"button-component\", {\n *   path: \"./src/components/Button.vue\",\n *   prompt: await alchemy`\n *     Generate a customizable button Vue component with:\n *     - Primary, secondary, and outline variants\n *     - Small, medium, and large sizes\n *     - Loading state with spinner\n *     - Disabled state\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate a Vue component using existing files as reference\n * const userCard = await VueFile(\"user-card\", {\n *   path: \"./src/components/UserCard.vue\",\n *   prompt: await alchemy`\n *     Create a UserCard Vue component that displays user information.\n *     Follow the styling patterns from:\n *     ${alchemy.file(\"src/components/Card.vue\")}\n *\n *     Use the user type from:\n *     ${alchemy.file(\"src/types/User.ts\")}\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate a complex form component with validation and custom system prompt\n * const form = await VueFile(\"registration-form\", {\n *   path: \"./src/components/RegistrationForm.vue\",\n *   prompt: await alchemy`\n *     Generate a registration form Vue component with:\n *     - Email, password, and confirm password fields\n *     - Form validation using Vuelidate or similar\n *     - Error messages for each field\n *     - Submit handler that emits form data\n *\n *     Follow these style guidelines:\n *     ${alchemy.file(\"src/styles/guidelines.md\")}\n *   `,\n *   system: \"You are an expert Vue component creator specializing in form components with validation. Create a single Vue component inside ```vue fences with no additional text.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const VueFile = Resource(\n  \"ai::VueFile\",\n  async function (\n    this: Context<VueFile>,\n    id: string,\n    props: VueFileProps\n  ): Promise<VueFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_VUE_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate Vue code\n    let { code, error } = await extractVueCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one Vue component inside \\`\\`\\`vue fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractVueCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid Vue code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticVueFile to create/update the file\n    const file = await StaticVueFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts Vue code from between ```vue fences\n * Validates that exactly one Vue code block exists\n *\n * @param text The text to extract Vue code from\n * @returns The extracted Vue code or error message\n */\nasync function extractVueCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const vueCodeRegex = /```vue\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(vueCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No Vue code block found in the response. Please include your code within ```vue fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple Vue code blocks found in the response. Please provide exactly one code block within ```vue fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/yaml-file.ts\n```ts\nimport { generateObject, generateText } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { StaticYamlFile } from \"../fs/static-yaml-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a YAMLFile\n */\nexport interface YAMLFileProps<\n  T extends Type<any, any> | undefined = undefined,\n> {\n  /**\n   * Path to the YAML file\n   */\n  path: string;\n\n  /**\n   * Optional ArkType schema to validate and structure the generated YAML\n   * When provided, the resource will use generateObject with schema validation\n   * When not provided, it will extract YAML from between ```yaml fences\n   */\n  schema?: T;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a YAML configuration for:\n   *   ${alchemy.file(\"src/serverless.js\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * @default Depends on whether schema is provided\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A YAML file that can be created, updated, and deleted\n */\nexport interface YAMLFile<T = any>\n  extends Omit<YAMLFileProps, \"schema\">,\n    Resource<\"ai::YAMLFile\"> {\n  /**\n   * Content of the YAML file as a string\n   */\n  content: string;\n\n  /**\n   * Parsed YAML object\n   */\n  yaml: T;\n\n  /**\n   * Schema used to validate the YAML (if provided)\n   */\n  schema?: JsonSchema;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for YAML file generation without schema\n */\nconst DEFAULT_YAML_SYSTEM_PROMPT =\n  \"You are a YAML generator. Create valid YAML based on the user's requirements. Your response MUST include only YAML inside ```yaml fences. Do not include any other text, explanations, or multiple code blocks. Use standard YAML syntax with proper indentation. Use quotes around strings that contain special characters when necessary.\";\n\n/**\n * Resource for generating YAML files using AI models.\n * Can operate in two modes:\n * 1. With schema: Uses generateObject with type validation, then converts to YAML\n * 2. Without schema: Extracts YAML from between ```yaml fences\n *\n * @example\n * // Generate a serverless configuration file\n * const serverlessConfig = await YAMLFile(\"serverless-config\", {\n *   path: \"./serverless.yml\",\n *   prompt: await alchemy`\n *     Generate a serverless.yml configuration for an AWS Lambda API with:\n *     - A service name \"user-api\"\n *     - Node.js 16.x runtime\n *     - Three functions: createUser, getUser, and listUsers\n *     - API Gateway endpoints for each function\n *     - DynamoDB table for users\n *     - IAM permissions for DynamoDB access\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate YAML with schema validation\n * import { type } from \"arktype\";\n *\n * const k8sConfigSchema = type({\n *   apiVersion: \"string\",\n *   kind: \"string\",\n *   metadata: {\n *     name: \"string\",\n *     namespace: \"string?\",\n *     labels: \"Record<string, string>?\"\n *   },\n *   spec: {\n *     replicas: \"number\",\n *     selector: {\n *       matchLabels: \"Record<string, string>\"\n *     },\n *     template: {\n *       metadata: {\n *         labels: \"Record<string, string>\"\n *       },\n *       spec: {\n *         containers: [{\n *           name: \"string\",\n *           image: \"string\",\n *           ports: [{\n *             containerPort: \"number\"\n *           }]\n *         }]\n *       }\n *     }\n *   }\n * });\n *\n * const deployment = await YAMLFile(\"k8s-deployment\", {\n *   path: \"./kubernetes/deployment.yaml\",\n *   schema: k8sConfigSchema,\n *   prompt: \"Generate a Kubernetes deployment for a web application named 'frontend' with 3 replicas using the nginx:latest image and exposing port 80\",\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate GitHub Actions workflow with custom system prompt\n * const workflow = await YAMLFile(\"github-workflow\", {\n *   path: \"./.github/workflows/ci.yml\",\n *   prompt: await alchemy`\n *     Create a GitHub Actions workflow for a Node.js project that:\n *     - Runs on push to main and pull requests\n *     - Sets up Node.js 18\n *     - Installs dependencies with npm\n *     - Runs linting and tests\n *     - Builds the project\n *     - Deploys to GitHub Pages on success (main branch only)\n *   `,\n *   system: \"You are a DevOps expert specializing in GitHub Actions workflows. Create a single YAML file inside ```yaml fences with no additional text. Follow GitHub Actions best practices and use proper YAML syntax.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const YAMLFile = Resource(\"ai::YAMLFile\", async function <\n  const T extends Type<any, any> | undefined = undefined,\n>(this: Context<YAMLFile<T extends Type<any, any> ? type.infer<T> : any>>, id: string, props: YAMLFileProps<T>): Promise<\n  YAMLFile<T extends Type<any, any> ? type.infer<T> : any>\n> {\n  // Handle deletion phase\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  let yamlContent: string;\n  let yamlObject: any;\n\n  // Check if schema is provided\n  if (props.schema) {\n    // Use schema-based generation\n    const { object } = await generateObject({\n      model: createModel(props),\n      schema: ark.schema<type.infer<typeof props.schema>>(props.schema),\n      providerOptions: props.model?.options,\n      system:\n        props.system ||\n        \"Generate a valid object based on the provided requirements.\",\n      prompt: props.prompt,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    yamlObject = object;\n\n    // Let StaticYamlFile handle the YAML conversion\n    const file = await StaticYamlFile(\"file\", props.path, yamlObject);\n    yamlContent = file.content;\n  } else {\n    // Use fence-based extraction\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_YAML_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate YAML content\n    let { content, error } = await extractYAMLContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one YAML block inside \\`\\`\\`yaml fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractYAMLContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(`Failed to generate valid YAML: ${retryResult.error}`);\n      }\n\n      content = retryResult.content;\n    }\n\n    yamlContent = content;\n\n    // Create the file with the string content\n    const file = await StaticYamlFile(\"file\", props.path, yamlContent);\n\n    // We need to parse the YAML to get the object representation\n    const yaml = await import(\"yaml\");\n    yamlObject = yaml.parse(yamlContent);\n  }\n\n  // Return the resource\n  return this({\n    ...props,\n    schema: props.schema,\n    content: yamlContent,\n    yaml: yamlObject,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  });\n});\n\n/**\n * Extracts YAML content from between ```yaml fences\n * Validates that exactly one YAML code block exists\n *\n * @param text The text to extract YAML from\n * @returns The extracted YAML or error message\n */\nasync function extractYAMLContent(\n  text: string\n): Promise<{ content: string; error?: string }> {\n  // Check for yaml or yml fence blocks\n  const yamlCodeRegex = /```(yaml|yml)\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(yamlCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      content: \"\",\n      error:\n        \"No YAML code block found in the response. Please include your YAML within ```yaml fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      content: \"\",\n      error:\n        \"Multiple YAML code blocks found in the response. Please provide exactly one YAML block within ```yaml fences.\",\n    };\n  }\n\n  const content = matches[0][2].trim();\n\n  // We don't validate YAML parsing here because js-yaml might not be available\n  // Validation will happen at usage time if needed\n  return { content };\n}\n\n```",
    "content": "# AstroFile\n\nThe AstroFile resource lets you generate [Astro](https://astro.build) components using AI models.\n\n# Minimal Example\n\nCreate a simple Astro component with AI generation:\n\n```ts\nimport { AstroFile } from \"alchemy/ai\";\n\nconst header = await AstroFile(\"header\", {\n  path: \"./src/components/Header.astro\",\n  prompt: \"Generate an Astro header component with a logo, navigation menu, and mobile responsiveness\"\n});\n```\n\n# Generate Component with File Context\n\nUse alchemy template literals to include existing files as context:\n\n```ts\nimport { AstroFile } from \"alchemy/ai\";\n\nconst blogPost = await AstroFile(\"blog-post\", {\n  path: \"./src/pages/blog/[slug].astro\",\n  prompt: await alchemy`\n    Create an Astro blog post page that uses these types:\n    ${alchemy.file(\"src/types/Blog.ts\")}\n  `,\n  temperature: 0.2\n});\n```\n\n# Custom System Prompt\n\nProvide a custom system prompt to guide the AI's output:\n\n```ts\nimport { AstroFile } from \"alchemy/ai\";\n\nconst layout = await AstroFile(\"layout\", {\n  path: \"./src/layouts/MainLayout.astro\",\n  prompt: \"Create a main layout with SEO metadata and content slots\",\n  system: \"You are an expert Astro developer. Create a single Astro layout file inside ```astro fences with no additional text.\",\n  model: {\n    id: \"claude-3-opus-20240229\",\n    provider: \"anthropic\"\n  }\n});\n```",
    "messages": [
      {
        "role": "user",
        "content": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         ai Service:\n[data.ts](alchemy/src/ai/data.ts)\n\n[vue-file.ts](alchemy/src/ai/vue-file.ts)\n\n[astro-file.ts](alchemy/src/ai/astro-file.ts)\n\n[css-file.ts](alchemy/src/ai/css-file.ts)\n\n[html-file.ts](alchemy/src/ai/html-file.ts)\n\n[document.ts](alchemy/src/ai/document.ts)\n\n[yaml-file.ts](alchemy/src/ai/yaml-file.ts)\n\n[client.ts](alchemy/src/ai/client.ts)\n\n[typescript-file.ts](alchemy/src/ai/typescript-file.ts)\n\n[ark.ts](alchemy/src/ai/ark.ts)\n\n[json-file.ts](alchemy/src/ai/json-file.ts)\n\nWrite concise documentation for the \"        AstroFile\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         AstroFile\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         AstroFile } from \"alchemy/        ai\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         AstroFile } from \"alchemy/        ai\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        \n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Creating Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroying Resources\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value ðŸ˜µâ€ðŸ’«\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n// env.d.ts\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n### 4. Scope-Based Destruction\n\n```typescript\n// Destroy all resources in a scope\nimport { destroy } from \"alchemy\";\nconst scope = alchemy.scope(\"temporary\");\nconst tempFile = await File(\"temp.txt\", { ... });\n\nawait destroy(scope);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// Clean up test resources reliably with try/finally\nconst scope = alchemy.scope(\"test\");\ntry {\n  // Create test resources\n} finally {\n  await destroy(scope);\n}\n```\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\nâ”œâ”€â”€ dev (Stage Scope)\nâ”‚   â”œâ”€â”€ api (Nested Scope)\nâ”‚   â””â”€â”€ database (Resource)\nâ””â”€â”€ prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/ai/ark.ts\n```ts\nimport {\n  type Tool as AITool,\n  type Schema,\n  type ToolExecutionOptions,\n  tool as aitool,\n  jsonSchema,\n} from \"ai\";\nimport { ArkErrors, type JsonSchema, type type } from \"arktype\";\n\nexport namespace ark {\n  export function schema<T>(type: JsonSchema): Schema<T>;\n  export function schema<T extends type>(type: T): Schema<type.infer<T>> {\n    const jsonSchemaObj = type.toJsonSchema() as any;\n    const processedSchema = processSchema(jsonSchemaObj);\n\n    return jsonSchema(processedSchema, {\n      validate: (value) => {\n        const out = type(value) as type.infer<T> | type.errors;\n        if (out instanceof ArkErrors) {\n          return {\n            success: false,\n            error: new Error(out.summary),\n          };\n        }\n        return {\n          success: true,\n          value: out,\n        };\n      },\n    });\n  }\n\n  /**\n   * Recursively processes a JSON schema and sets additionalProperties: false\n   * for any object types.\n   *\n   * Structured Outputs requires additionalProperties: false\n   */\n  function processSchema(schema: any): any {\n    if (!schema || typeof schema !== \"object\") return schema;\n\n    // Create a copy to avoid mutating the original\n    const result = { ...schema };\n\n    // Convert anyOf with all const values to enum\n    if (result.anyOf && Array.isArray(result.anyOf)) {\n      const allConst = result.anyOf.every(\n        (item: any) => item && typeof item === \"object\" && \"const\" in item,\n      );\n\n      if (allConst) {\n        // Extract all const values\n        const enumValues = result.anyOf.map((item: any) => item.const);\n\n        // Determine the type based on the first const value\n        // Assuming all const values are of the same type\n        const firstType = typeof enumValues[0];\n\n        // Replace anyOf with enum\n        delete result.anyOf;\n        result.type = firstType;\n        result.enum = enumValues;\n      } else {\n        // Process each item in anyOf\n        result.anyOf = result.anyOf.map(processSchema);\n      }\n    }\n\n    // If this is an object type, set additionalProperties: false\n    if (result.type === \"object\") {\n      result.additionalProperties = false;\n      result.properties ??= {};\n    }\n\n    // Process properties of objects\n    if (result.properties && typeof result.properties === \"object\") {\n      result.properties = Object.fromEntries(\n        Object.entries(result.properties).map(([key, value]) => [\n          key,\n          processSchema(value),\n        ]),\n      );\n    }\n\n    // Process items in arrays\n    if (result.items) {\n      result.items = processSchema(result.items);\n    }\n\n    // Process allOf, oneOf\n    for (const key of [\"allOf\", \"oneOf\"]) {\n      if (Array.isArray(result[key])) {\n        result[key] = result[key].map(processSchema);\n      }\n    }\n\n    return result;\n  }\n\n  export interface Tool<Input extends type, Output>\n    extends Omit<AITool<Schema<type.infer<Input>>>, \"parameters\" | \"execute\"> {\n    description?: string;\n    parameters: Input;\n    execute: (\n      input: type.infer<Input>,\n      options: ToolExecutionOptions,\n    ) => Promise<Output>;\n  }\n\n  export function tool<Input extends type, Output>(\n    tool: Tool<Input, Output>,\n  ): AITool<Schema<type.infer<Input>>, Output> {\n    return aitool({\n      ...tool,\n      parameters: ark.schema<Input>(tool.parameters),\n    } as any);\n  }\n}\n\n```\n\n// alchemy/src/ai/astro-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport prettier from \"prettier\";\nimport type { Context } from \"../context\";\nimport { StaticAstroFile } from \"../fs/static-astro-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating an AstroFile\n */\nexport interface AstroFileProps {\n  /**\n   * Path to the Astro file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate an Astro component using:\n   *   ${alchemy.file(\"src/types.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return Astro code inside ```astro fences\n   * @default \"You are an Astro component generator. Create Astro components based on the user's requirements. Your response MUST include only Astro code inside ```astro fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Prettier configuration to use for formatting the Astro code\n   * If not provided, will use the default Prettier configuration\n   */\n  prettierConfig?: prettier.Options;\n}\n\n/**\n * An Astro file that can be created, updated, and deleted\n */\nexport interface AstroFile extends AstroFileProps, Resource<\"ai::AstroFile\"> {\n  /**\n   * Content of the Astro file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for Astro file generation\n */\nconst DEFAULT_ASTRO_SYSTEM_PROMPT =\n  \"You are an Astro component generator. Create Astro components based on the user's requirements. Your response MUST include only Astro code inside ```astro fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating Astro files using AI models.\n * Extracts Astro code from between ```astro fences, validates the response,\n * and formats the code with Prettier.\n *\n * @example\n * // Create a simple Astro component\n * const header = await AstroFile(\"header\", {\n *   path: \"./src/components/Header.astro\",\n *   prompt: await alchemy`\n *     Generate an Astro header component with:\n *     - Site logo\n *     - Navigation menu with Home, About, Services, Contact links\n *     - Mobile responsive design\n *     - Dark/light mode toggle\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate an Astro page with data fetching\n * const blogPost = await AstroFile(\"blog-post\", {\n *   path: \"./src/pages/blog/[slug].astro\",\n *   prompt: await alchemy`\n *     Create an Astro blog post page that:\n *     - Uses getStaticPaths to generate pages from a CMS\n *     - Renders markdown content\n *     - Includes author info, publication date, and related posts\n *     - Has social sharing buttons\n *\n *     Use the following types:\n *     ${alchemy.file(\"src/types/Blog.ts\")}\n *   `,\n *   temperature: 0.2,\n *   prettierConfig: {\n *     semi: false,\n *     singleQuote: true,\n *     printWidth: 120\n *   }\n * });\n *\n * @example\n * // Generate a layout with custom system prompt\n * const mainLayout = await AstroFile(\"main-layout\", {\n *   path: \"./src/layouts/MainLayout.astro\",\n *   prompt: await alchemy`\n *     Create the main layout for an Astro site that:\n *     - Includes common head metadata and SEO optimization\n *     - Has slots for page content, header, and footer\n *     - Imports and uses the Header and Footer components\n *     - Sets up viewport and responsive configurations\n *   `,\n *   system: \"You are an expert Astro developer. Create a single Astro layout file inside ```astro fences with no additional text. Follow Astro best practices and include proper typing in the frontmatter section.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const AstroFile = Resource(\n  \"ai::AstroFile\",\n  async function (\n    this: Context<AstroFile>,\n    id: string,\n    props: AstroFileProps\n  ): Promise<AstroFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_ASTRO_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate Astro code\n    let { code, error } = await extractAstroCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one Astro code block inside \\`\\`\\`astro fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractAstroCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid Astro code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Format the code with Prettier\n    try {\n      // Set default parser to astro\n      const prettierOptions: prettier.Options = {\n        parser: \"astro\",\n        ...props.prettierConfig,\n      };\n\n      // Format the code\n      code = await prettier.format(code, prettierOptions);\n    } catch (error) {\n      // If Prettier formatting fails, just use the unformatted code\n      console.warn(\"Failed to format Astro code with Prettier:\", error);\n    }\n\n    // Use StaticAstroFile to create/update the file\n    const file = await StaticAstroFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts Astro code from between ```astro fences\n * Validates that exactly one Astro code block exists\n *\n * @param text The text to extract Astro code from\n * @returns The extracted Astro code or error message\n */\nasync function extractAstroCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const astroCodeRegex = /```astro\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(astroCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No Astro code block found in the response. Please include your code within ```astro fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple Astro code blocks found in the response. Please provide exactly one code block within ```astro fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/client.ts\n```ts\nimport { anthropic } from \"@ai-sdk/anthropic\";\nimport { openai } from \"@ai-sdk/openai\";\nimport type { Secret } from \"../secret\";\n\n/**\n * Model configuration for AI operations\n */\nexport interface ModelConfig {\n  /**\n   * Model ID to use\n   * @default 'gpt-4o'\n   */\n  id?: string;\n\n  /**\n   * Model provider name\n   * @default 'openai'\n   */\n  provider?: string;\n\n  /**\n   * Model-specific options\n   */\n  options?: Record<string, any>;\n}\n\n/**\n * Configuration for creating an OpenAI client\n */\nexport interface ClientConfig {\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n}\n\n/**\n * Creates an OpenAI-compatible client with the given configuration\n */\nexport function createModel(config: ClientConfig) {\n  if (config.model?.provider === \"anthropic\") {\n    return anthropic(config.model?.id ?? \"claude-3-7-sonnet-latest\");\n  } else {\n    return openai(config.model?.id ?? \"gpt-4o\");\n  }\n}\n\n/**\n * Maximum time to retry in milliseconds (5 minutes)\n */\nconst MAX_RETRY_TIME = 5 * 60 * 1000;\n\n/**\n * Initial delay between retries in milliseconds\n */\nconst INITIAL_RETRY_DELAY = 1000;\n\n/**\n * Maximum number of retries\n */\nconst MAX_RETRIES = 10;\n\n/**\n * Handles rate limiting with exponential backoff\n * @param fn Function to retry\n * @returns Result of the function\n * @throws Error if max retries or time is exceeded\n */\nexport async function withRateLimitRetry<T>(fn: () => Promise<T>): Promise<T> {\n  let retryCount = 0;\n  let lastError: Error | null = null;\n  let startTime = Date.now();\n\n  while (true) {\n    try {\n      return await fn();\n    } catch (error: any) {\n      lastError = error;\n\n      console.log(\"retry error\", error);\n\n      // Check if we should retry\n      const isRateLimit = error.statusCode === 429;\n      const timeElapsed = Date.now() - startTime;\n      const shouldRetry =\n        isRateLimit && retryCount < MAX_RETRIES && timeElapsed < MAX_RETRY_TIME;\n\n      if (!shouldRetry) {\n        throw error;\n      }\n\n      // Calculate delay with exponential backoff\n      const delay = Math.min(\n        INITIAL_RETRY_DELAY * Math.pow(2, retryCount),\n        MAX_RETRY_TIME - timeElapsed\n      );\n\n      console.log(`Retrying in ${delay}ms`);\n\n      // Wait before retrying\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      retryCount++;\n    }\n  }\n}\n\n```\n\n// alchemy/src/ai/css-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticCSSFile } from \"../fs/static-css-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a CSSFile\n */\nexport interface CSSFileProps {\n  /**\n   * Path to the CSS file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate CSS styles for:\n   *   ${alchemy.file(\"src/components/Button.jsx\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return CSS code inside ```css fences\n   * @default \"You are a CSS code generator. Create CSS code based on the user's requirements. Your response MUST include only CSS code inside ```css fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A CSS file that can be created, updated, and deleted\n */\nexport interface CSSFile extends CSSFileProps, Resource<\"ai::CSSFile\"> {\n  /**\n   * Content of the CSS file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for CSS file generation\n */\nconst DEFAULT_CSS_SYSTEM_PROMPT =\n  \"You are a CSS code generator. Create CSS code based on the user's requirements. Your response MUST include only CSS code inside ```css fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating CSS files using AI models.\n * Extracts CSS code from between ```css fences and validates the response.\n *\n * @example\n * // Create styles for a website\n * const mainStyles = await CSSFile(\"main-styles\", {\n *   path: \"./public/css/main.css\",\n *   prompt: await alchemy`\n *     Generate modern CSS styles for a company website with:\n *     - Clean, minimalist design\n *     - Primary color: #0062ff\n *     - Secondary color: #6c757d\n *     - Light gray background\n *     - Responsive layout for mobile, tablet, and desktop\n *     - Custom styles for buttons, cards, and navigation\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate CSS based on existing HTML\n * const componentStyles = await CSSFile(\"component-styles\", {\n *   path: \"./src/styles/component.css\",\n *   prompt: await alchemy`\n *     Create CSS styles for this HTML component:\n *     ${alchemy.file(\"src/components/Card.html\")}\n *\n *     The styles should be:\n *     - Modern and clean\n *     - Include hover effects and transitions\n *     - Support both light and dark themes\n *     - Use CSS variables for colors and spacing\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate CSS animation with custom system prompt\n * const animationStyles = await CSSFile(\"animations\", {\n *   path: \"./src/styles/animations.css\",\n *   prompt: await alchemy`\n *     Create CSS animations for:\n *     - Fade in/out\n *     - Slide in from different directions\n *     - Pulse effect\n *     - Bounce effect\n *     - Scale in/out\n *     - Rotate\n *\n *     Each animation should be reusable via class names.\n *   `,\n *   system: \"You are an expert CSS animator. Create a single CSS file inside ```css fences with no additional text. Use modern CSS animation techniques and include vendor prefixes where needed for browser compatibility.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const CSSFile = Resource(\n  \"ai::CSSFile\",\n  async function (\n    this: Context<CSSFile>,\n    id: string,\n    props: CSSFileProps\n  ): Promise<CSSFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_CSS_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate CSS code\n    let { code, error } = await extractCSSCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one CSS code block inside \\`\\`\\`css fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractCSSCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid CSS code: ${retryResult.error}\\n${retryText}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticCSSFile to create/update the file\n    const file = await StaticCSSFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts CSS code from between ```css fences\n * Validates that exactly one CSS code block exists\n *\n * @param text The text to extract CSS code from\n * @returns The extracted CSS code or error message\n */\nasync function extractCSSCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const cssCodeRegex = /```css\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(cssCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No CSS code block found in the response. Please include your code within ```css fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple CSS code blocks found in the response. Please provide exactly one code block within ```css fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/data.ts\n```ts\nimport { generateObject, type CoreMessage } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { createModel, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating an AI Object\n */\nexport interface DataProps<T extends Type<any, any>> {\n  /**\n   * The ArkType schema to validate and structure the generated content\n   */\n  schema: T | JsonSchema;\n\n  /**\n   * Prompt for generating the content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a description for:\n   *   ${alchemy.file(\"src/data.ts\")}\n   * `\n   */\n  prompt?: string;\n\n  /**\n   * Message history for the conversation\n   * If provided, this will be used instead of the prompt\n   */\n  messages?: CoreMessage[];\n\n  /**\n   * System prompt to guide the AI's behavior\n   * @example\n   * system: \"You are a technical writer tasked with describing code\"\n   */\n  system?: string;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Whether to freeze the generated object\n   * @default false\n   */\n  freeze?: boolean;\n}\n\n/**\n * A resource that uses AI to generate structured content based on a schema\n */\nexport interface Data<T> extends Resource<\"ai::Object\"> {\n  type: JsonSchema;\n\n  /**\n   * The generated content, typed according to the provided schema\n   */\n  object: T;\n\n  /**\n   * Updated message history with the AI's response appended\n   */\n  messages: CoreMessage[];\n\n  /**\n   * Time at which the content was generated\n   */\n  createdAt: number;\n}\n\n/**\n * Resource for generating structured content using the Vercel AI SDK.\n * Supports powerful context handling through the alchemy template literal tag.\n *\n * @example\n * // Generate a product description with specific fields\n * const productSchema = type({\n *   name: \"string\",\n *   description: \"string\",\n *   features: \"string[]\",\n *   price: \"number\"\n * });\n *\n * const product = await Data(\"new-product\", {\n *   schema: productSchema,\n *   prompt: \"Generate a product description for a new smartphone\",\n *   system: \"You are a product copywriter specializing in tech products\",\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\",\n *     options: {\n *       temperature: 0.7\n *     }\n *   }\n * });\n *\n * console.log(product.object); // Typed as per schema\n *\n * @example\n * // Generate code documentation with context\n * const docSchema = type({\n *   summary: \"string\",\n *   parameters: {\n *     name: \"string\",\n *     type: \"string\",\n *     description: \"string\"\n *   }[],\n *   returns: \"string\"\n * });\n *\n * const docs = await Data(\"function-docs\", {\n *   schema: docSchema,\n *   prompt: await alchemy`\n *     Generate documentation for this function:\n *     ${alchemy.file(\"src/utils/format.ts\")}\n *   `,\n *   system: \"You are a technical documentation writer\",\n *   temperature: 0.2\n * });\n *\n * @example\n * // Using message history for iterative generation\n * const feedbackSchema = type({\n *   rating: \"number\",\n *   positives: \"string[]\",\n *   improvements: \"string[]\",\n *   summary: \"string\"\n * });\n *\n * const feedback = await Data(\"product-feedback\", {\n *   schema: feedbackSchema,\n *   messages: [\n *     { role: \"user\", content: \"I'd like feedback on my product design\" },\n *     { role: \"assistant\", content: \"I'd be happy to provide feedback. What's your product?\" },\n *     { role: \"user\", content: \"It's a new smart home device that...\" }\n *   ],\n *   system: \"You are a product design expert providing structured feedback\",\n *   temperature: 0.3\n * });\n */\nexport const Data = Resource(\"ai::Object\", async function <\n  const T extends Type<any, any>,\n>(this: Context<Data<any>>, id: string, props: DataProps<T>): Promise<\n  Data<type.infer<T>>\n> {\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  // Validate that either prompt or messages is provided\n  if (!props.prompt && !props.messages) {\n    throw new Error(\"Either prompt or messages must be provided\");\n  }\n\n  if (this.phase === \"update\" && props.freeze) {\n    return this(this.output);\n  }\n\n  // Create messages array if only prompt is provided\n  const messages = props.messages || [{ role: \"user\", content: props.prompt! }];\n\n  // Generate structured output using generateObject\n  const { object } = await generateObject({\n    model: createModel(props),\n    // Convert ArkType schema to Zod schema for generateObject\n    // This is needed because generateObject expects a Zod schema\n    schema: ark.schema<type.infer<T>>(props.schema),\n    providerOptions: props.model?.options,\n    system:\n      props.system ||\n      \"You are an AI assistant tasked with generating structured content.\",\n    messages,\n    ...(props.temperature === undefined\n      ? {}\n      : // some models error if you provide it (rather than ignoring it)\n        { temperature: props.temperature }),\n  });\n\n  // Create updated message history with the structured response\n  const responseText = JSON.stringify(object);\n  const updatedMessages = [\n    ...messages,\n    {\n      role: \"assistant\" as const,\n      content: responseText,\n    },\n  ];\n\n  // Return the resource with typed content and updated messages\n  return this({\n    type: props.schema,\n    object: object,\n    messages: updatedMessages,\n    createdAt: Date.now(),\n  });\n});\n\n```\n\n// alchemy/src/ai/document.ts\n```ts\nimport { generateText, type CoreMessage } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticTextFile } from \"../fs/static-text-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createModel, withRateLimitRetry, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating a Document\n */\nexport interface DocumentProps {\n  /**\n   * Title of the document\n   *\n   * @default id\n   */\n  title?: string;\n\n  /**\n   * Optional path to the markdown document\n   * If provided, document will be written to this path\n   */\n  path?: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate docs using:\n   *   ${alchemy.file(\"src/api.ts\")}\n   * `\n   */\n  prompt?: string;\n\n  /**\n   * Message history for conversation-based generation\n   * If provided, this will be used instead of the prompt\n   * @example\n   * messages: [\n   *   { role: \"user\", content: \"Generate API documentation for this file\" },\n   *   { role: \"assistant\", content: \"I'll create detailed API docs. What file should I document?\" },\n   *   { role: \"user\", content: \"Please document src/api.ts\" }\n   * ]\n   */\n  messages?: CoreMessage[];\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return a single markdown document inside ```md fences\n   * @default \"You are a technical documentation writer. Create a single markdown document based on the user's requirements. Your response MUST include only a single markdown document inside ```md fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Maximum number of tokens to generate.\n   * Higher values allow for longer documents but may increase cost and generation time.\n   * @default 10000\n   */\n  maxTokens?: number;\n\n  /**\n   * Freeze the document after creation (do not re-generate on updates)\n   * @default false\n   */\n  freeze?: boolean;\n}\n\n/**\n * A markdown document that can be created, updated, and deleted\n */\nexport interface Document extends DocumentProps, Resource<\"docs::Document\"> {\n  /**\n   * The title of the document\n   */\n  title: string;\n\n  /**\n   * Content of the document\n   */\n  content: string;\n\n  /**\n   * Updated message history with the document response appended\n   */\n  messages: CoreMessage[];\n\n  /**\n   * Time at which the document was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the document was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * File resource if path was provided\n   */\n  file?: StaticTextFile;\n}\n\n/**\n * Default system prompt for markdown document generation\n */\nconst DEFAULT_MD_SYSTEM_PROMPT =\n  \"You are a technical documentation writer. Create a single markdown document based on the user's requirements. Your response MUST include only a single markdown document inside ```md fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for managing AI-generated markdown documents using the Vercel AI SDK.\n * Supports powerful context handling through the alchemy template literal tag.\n *\n * @example\n * // Create an in-memory document (no file created)\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   prompt: await alchemy`\n *     Generate API documentation based on these source files:\n *     ${alchemy.file(\"src/api.ts\")}\n *     ${alchemy.file(\"src/types.ts\")}\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Create a document and write it to disk\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   path: \"./docs/api.md\",\n *   prompt: await alchemy`\n *     Generate API documentation based on these source files:\n *     ${alchemy.file(\"src/api.ts\")}\n *     ${alchemy.file(\"src/types.ts\")}\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Use message history for iterative document generation\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   path: \"./docs/api.md\",\n *   messages: [\n *     { role: \"user\", content: \"Create API documentation for these files\" },\n *     { role: \"assistant\", content: \"I'll help you create API documentation. Please provide the files.\" },\n *     { role: \"user\", content: \"Here are the files: [file contents]\" }\n *   ],\n *   system: \"You are a technical documentation writer. Generate clear and concise API documentation.\",\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Use alchemy template literals with file collections and temperature control\n * const modelDocs = await Document(\"models\", {\n *   title: \"Data Models\",\n *   path: \"./docs/models.md\",\n *   prompt: await alchemy`\n *     Write documentation for these data models:\n *     ${alchemy.files(\"src/models/user.ts\", \"src/models/post.ts\")}\n *   `,\n *   temperature: 0.2 // Lower temperature for more deterministic output\n * });\n *\n * @example\n * // Advanced model configuration with custom provider options and custom system prompt\n * const techDocs = await Document(\"tech-specs\", {\n *   title: \"Technical Specifications\",\n *   path: \"./docs/tech-specs.md\",\n *   prompt: await alchemy`\n *     Create detailed technical specifications based on these requirements:\n *     ${alchemy.file(\"requirements/system.md\")}\n *   `,\n *   system: \"You are an expert technical writer specializing in system specifications. Create a single markdown document inside ```md fences with no additional text.\",\n *   model: {\n *     id: \"o3-mini\",\n *     provider: \"openai\",\n *     options: {\n *       reasoningEffort: \"high\"\n *     }\n *   },\n *   temperature: 0.1\n * });\n */\nexport const Document = Resource(\n  \"docs::Document\",\n  async function (\n    this: Context<Document>,\n    id: string,\n    props: DocumentProps\n  ): Promise<Document> {\n    // Validate that either prompt or messages are provided\n    if (!props.prompt && !props.messages) {\n      throw new Error(\"Either prompt or messages must be provided\");\n    }\n\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    if (this.phase === \"update\" && props.freeze) {\n      if (props.path) {\n        const filePath = props.path;\n        const fileId = `${id}-file`;\n\n        await StaticTextFile(fileId, filePath, this.output!.content);\n      }\n      return this(this.output);\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_MD_SYSTEM_PROMPT;\n\n    // Generate initial content with rate limit retry\n    const { text } = await withRateLimitRetry(async () => {\n      return generateText({\n        model: createModel(props),\n        ...(props.messages\n          ? { messages: props.messages }\n          : { prompt: props.prompt! }),\n        system,\n        maxTokens: props.maxTokens || 8192,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : // some models error if you provide it (rather than ignoring it)\n            { temperature: props.temperature }),\n      });\n    });\n\n    // Extract and validate markdown content\n    let { content, error } = extractMarkdownContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one markdown document inside \\`\\`\\`md fences.`;\n\n      const { text: retryText } = await withRateLimitRetry(async () => {\n        return generateText({\n          model: createModel(props),\n          ...(props.messages\n            ? { messages: props.messages }\n            : { prompt: props.prompt! }),\n          system: errorSystem,\n          providerOptions: props.model?.options,\n          ...(props.temperature === undefined\n            ? {}\n            : { temperature: props.temperature }),\n        });\n      });\n\n      const retryResult = extractMarkdownContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid markdown content: ${retryResult.error}\\n${retryText}`\n        );\n      }\n\n      content = retryResult.content;\n    }\n\n    // Create result object\n    const result: Partial<Document> = {\n      ...props,\n      content,\n      messages: [\n        ...(props.messages || [{ role: \"user\", content: props.prompt! }]),\n        { role: \"assistant\", content },\n      ],\n      createdAt: this.output?.createdAt || Date.now(),\n      updatedAt: Date.now(),\n      title: props.title || id,\n    };\n\n    // Write file if path is provided\n    if (props.path) {\n      const filePath = props.path;\n      const fileId = `${id}-file`;\n\n      result.file = await StaticTextFile(fileId, filePath, content);\n    }\n\n    // Return the resource\n    return this(result as Document);\n  }\n);\n\n/**\n * Extracts markdown content from between ```md fences\n * Validates that exactly one markdown code block exists\n *\n * @param text The text to extract markdown content from\n * @returns The extracted markdown content or error message\n */\nfunction extractMarkdownContent(text: string): {\n  content: string;\n  error?: string;\n} {\n  const lines = text.split(\"\\n\");\n  const startIdx = lines.findIndex((line) => line.trim() === \"```md\");\n\n  if (startIdx === -1) {\n    return {\n      content: \"\",\n      error:\n        \"No markdown code block found in the response. Please include your markdown content within ```md fences.\",\n    };\n  }\n\n  const rest = lines.slice(startIdx + 1);\n  const endRelativeIdx = rest\n    .map((line) => line.trim() === \"```\")\n    .lastIndexOf(true);\n\n  if (endRelativeIdx === -1) {\n    return {\n      content: \"\",\n      error: \"Markdown block was not closed properly.\",\n    };\n  }\n\n  const endIdx = startIdx + 1 + endRelativeIdx;\n\n  const content = lines\n    .slice(startIdx + 1, endIdx)\n    .join(\"\\n\")\n    .trim();\n\n  return { content };\n}\n\n```\n\n// alchemy/src/ai/html-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticHTMLFile } from \"../fs/static-html-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating an HTMLFile\n */\nexport interface HTMLFileProps {\n  /**\n   * Path to the HTML file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate an HTML page using:\n   *   ${alchemy.file(\"src/templates/base.html\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return HTML code inside ```html fences\n   * @default \"You are an HTML code generator. Create HTML code based on the user's requirements. Your response MUST include only HTML code inside ```html fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * An HTML file that can be created, updated, and deleted\n */\nexport interface HTMLFile extends HTMLFileProps, Resource<\"ai::HTMLFile\"> {\n  /**\n   * Content of the HTML file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for HTML file generation\n */\nconst DEFAULT_HTML_SYSTEM_PROMPT =\n  \"You are an HTML code generator. Create HTML code based on the user's requirements. Your response MUST include only HTML code inside ```html fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating HTML files using AI models.\n * Extracts HTML code from between ```html fences and validates the response.\n *\n * @example\n * // Create a simple landing page\n * const landingPage = await HTMLFile(\"landing-page\", {\n *   path: \"./public/index.html\",\n *   prompt: await alchemy`\n *     Generate a modern landing page for a SaaS product with:\n *     - Hero section with headline and call-to-action\n *     - Features section with 3 key features\n *     - Pricing section with 3 tiers\n *     - Testimonials section with 2 customer quotes\n *     - Contact form and footer\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate an HTML email template\n * const emailTemplate = await HTMLFile(\"welcome-email\", {\n *   path: \"./emails/welcome.html\",\n *   prompt: await alchemy`\n *     Create an HTML email template for welcoming new users to our platform.\n *     The email should include:\n *     - Company logo and branding\n *     - Personalized welcome message (use {{name}} placeholder)\n *     - Three steps to get started\n *     - Support contact information\n *     - Unsubscribe footer\n *\n *     Make sure it's responsive and works in all major email clients.\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate an HTML component with custom system prompt\n * const navComponent = await HTMLFile(\"navigation\", {\n *   path: \"./components/nav.html\",\n *   prompt: await alchemy`\n *     Create a responsive navigation component with:\n *     - Logo in the left corner\n *     - Navigation links: Home, Products, Services, About, Contact\n *     - Mobile hamburger menu that expands/collapses\n *     - Login/signup buttons on the right side\n *     - Dark/light mode toggle\n *   `,\n *   system: \"You are an expert HTML/CSS developer specializing in responsive components. Create a single HTML file inside ```html fences with no additional text. Use modern HTML5 semantic elements and inline CSS if needed.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const HTMLFile = Resource(\n  \"ai::HTMLFile\",\n  async function (\n    this: Context<HTMLFile>,\n    id: string,\n    props: HTMLFileProps\n  ): Promise<HTMLFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_HTML_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate HTML code\n    let { code, error } = await extractHTMLCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one HTML code block inside \\`\\`\\`html fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractHTMLCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid HTML code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticHTMLFile to create/update the file\n    const file = await StaticHTMLFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts HTML code from between ```html fences\n * Validates that exactly one HTML code block exists\n *\n * @param text The text to extract HTML code from\n * @returns The extracted HTML code or error message\n */\nasync function extractHTMLCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const htmlCodeRegex = /```html\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(htmlCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No HTML code block found in the response. Please include your code within ```html fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple HTML code blocks found in the response. Please provide exactly one code block within ```html fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/json-file.ts\n```ts\nimport { generateObject, generateText } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { StaticJsonFile } from \"../fs/static-json-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a JSONFile\n */\nexport interface JSONFileProps<\n  T extends Type<any, any> | undefined = undefined,\n> {\n  /**\n   * Path to the JSON file\n   */\n  path: string;\n\n  /**\n   * Optional ArkType schema to validate and structure the generated JSON\n   * When provided, the resource will use generateObject with schema validation\n   * When not provided, it will extract JSON from between ```json fences\n   */\n  schema?: T;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a JSON configuration for:\n   *   ${alchemy.file(\"src/config.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * @default Depends on whether schema is provided\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Whether to pretty-print the JSON with indentation\n   * @default true\n   */\n  pretty?: boolean;\n\n  /**\n   * Number of spaces to use for indentation when pretty-printing\n   * @default 2\n   */\n  indent?: number;\n}\n\n/**\n * A JSON file that can be created, updated, and deleted\n */\nexport interface JSONFile<T = any>\n  extends Omit<JSONFileProps, \"schema\">,\n    Resource<\"ai::JSONFile\"> {\n  /**\n   * Content of the JSON file as a string\n   */\n  content: string;\n\n  /**\n   * Parsed JSON object\n   */\n  json: T;\n\n  /**\n   * Schema used to validate the JSON (if provided)\n   */\n  schema?: JsonSchema;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for JSON file generation without schema\n */\nconst DEFAULT_JSON_SYSTEM_PROMPT =\n  \"You are a JSON generator. Create valid JSON based on the user's requirements. Your response MUST include only JSON inside ```json fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating JSON files using AI models.\n * Can operate in two modes:\n * 1. With schema: Uses generateObject with type validation\n * 2. Without schema: Extracts JSON from between ```json fences\n *\n * @example\n * // Generate a configuration file with freeform JSON\n * const config = await JSONFile(\"app-config\", {\n *   path: \"./config/app.json\",\n *   prompt: await alchemy`\n *     Generate a configuration for a web application with:\n *     - Server settings (port, host, timeout)\n *     - Database connection details (redact any passwords)\n *     - Logging configuration\n *     - Feature flags\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate JSON with schema validation\n * import { type } from \"arktype\";\n *\n * const userSchema = type({\n *   users: [{\n *     id: \"string\",\n *     name: \"string\",\n *     email: \"string\",\n *     role: \"'admin' | 'user' | 'guest'\",\n *     permissions: \"string[]\",\n *     active: \"boolean\"\n *   }]\n * });\n *\n * const userData = await JSONFile(\"user-data\", {\n *   path: \"./data/users.json\",\n *   schema: userSchema,\n *   prompt: \"Generate sample user data for an application with various roles and permissions\",\n *   temperature: 0.2\n * });\n *\n * // Type-safe access to the generated data\n * console.log(userData.json.users[0].role); // Typed as 'admin' | 'user' | 'guest'\n *\n * @example\n * // Generate API mock data with custom system prompt\n * const apiMock = await JSONFile(\"api-mock\", {\n *   path: \"./mocks/products-api.json\",\n *   prompt: await alchemy`\n *     Create mock data for a product catalog API response with:\n *     - 10 products with different categories\n *     - Each product should have id, name, price, category, inventory, and image_url\n *     - Include pagination metadata (total, page, limit)\n *   `,\n *   system: \"You are an API design expert. Create realistic mock JSON data that follows REST API best practices. Your response must be valid JSON inside ```json fences.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   },\n *   pretty: true,\n *   indent: 4\n * });\n */\nexport const JSONFile = Resource(\"ai::JSONFile\", async function <\n  const T extends Type<any, any> | undefined = undefined,\n>(this: Context<JSONFile<T extends Type<any, any> ? type.infer<T> : any>>, id: string, props: JSONFileProps<T>): Promise<\n  JSONFile<T extends Type<any, any> ? type.infer<T> : any>\n> {\n  // Handle deletion phase\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  let jsonContent: string;\n  let jsonObject: any;\n\n  // Check if schema is provided\n  if (props.schema) {\n    // Use schema-based generation\n    const { object } = await generateObject({\n      model: createModel(props),\n      schema: ark.schema<type.infer<typeof props.schema>>(props.schema),\n      providerOptions: props.model?.options,\n      system:\n        props.system ||\n        \"Generate a valid JSON object based on the provided requirements.\",\n      prompt: props.prompt,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    jsonObject = object;\n\n    // Use StaticJsonFile to create the file\n    const file = await StaticJsonFile(\"file\", props.path, jsonObject);\n    jsonContent = file.content;\n  } else {\n    // Use fence-based extraction\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_JSON_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate JSON content\n    let { content, error } = await extractJSONContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one valid JSON block inside \\`\\`\\`json fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractJSONContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(`Failed to generate valid JSON: ${retryResult.error}`);\n      }\n\n      content = retryResult.content;\n    }\n\n    // Parse JSON to get the object representation\n    jsonObject = JSON.parse(content);\n\n    // Use StaticJsonFile to create the file\n    const file = await StaticJsonFile(\"file\", props.path, jsonObject);\n    jsonContent = file.content;\n  }\n\n  // Return the resource\n  return this({\n    ...props,\n    schema: props.schema,\n    content: jsonContent,\n    json: jsonObject,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  });\n});\n\n/**\n * Extracts JSON content from between ```json fences\n * Validates that exactly one JSON code block exists\n *\n * @param text The text to extract JSON from\n * @returns The extracted JSON or error message\n */\nasync function extractJSONContent(\n  text: string\n): Promise<{ content: string; error?: string }> {\n  const jsonCodeRegex = /```json\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(jsonCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      content: \"\",\n      error:\n        \"No JSON code block found in the response. Please include your JSON within ```json fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      content: \"\",\n      error:\n        \"Multiple JSON code blocks found in the response. Please provide exactly one JSON block within ```json fences.\",\n    };\n  }\n\n  const content = matches[0][1].trim();\n\n  // Validate JSON can be parsed\n  try {\n    JSON.parse(content);\n    return { content };\n  } catch (e) {\n    return {\n      content: \"\",\n      error: `Invalid JSON: ${(e as Error).message}. Please provide valid JSON syntax.`,\n    };\n  }\n}\n\n```\n\n// alchemy/src/ai/typescript-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticTypeScriptFile } from \"../fs/static-typescript-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createModel, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating a TypeScriptFile\n */\nexport interface TypeScriptFileProps {\n  /**\n   * Path to the TypeScript file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a TypeScript utility function using:\n   *   ${alchemy.file(\"src/types.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return TypeScript code inside ```ts fences\n   * @default \"You are a TypeScript code generator. Create TypeScript code based on the user's requirements. Your response MUST include only TypeScript code inside ```ts fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Prettier configuration to use for formatting the TypeScript code\n   * If not provided, will use the default Prettier configuration\n   */\n  prettierConfig?: object;\n}\n\n/**\n * A TypeScript file that can be created, updated, and deleted\n */\nexport interface TypeScriptFile\n  extends TypeScriptFileProps,\n    Resource<\"ai::TypeScriptFile\"> {\n  /**\n   * Content of the TypeScript file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for TypeScript file generation\n */\nconst DEFAULT_TS_SYSTEM_PROMPT =\n  \"You are a TypeScript code generator. Create TypeScript code based on the user's requirements. Your response MUST include only TypeScript code inside ```ts fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating TypeScript files using AI models.\n * Extracts TypeScript code from between ```ts fences, validates the response,\n * and formats the code with Prettier.\n *\n * @example\n * // Create a utility function\n * const utils = await TypeScriptFile(\"string-utils\", {\n *   path: \"./src/utils/string-utils.ts\",\n *   prompt: await alchemy`\n *     Generate TypeScript utility functions for string manipulation:\n *     - Capitalize first letter\n *     - Truncate with ellipsis\n *     - Convert to camelCase and kebab-case\n *     - Remove special characters\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate a TypeScript class with custom formatting\n * const userService = await TypeScriptFile(\"user-service\", {\n *   path: \"./src/services/UserService.ts\",\n *   prompt: await alchemy`\n *     Create a UserService class that handles user authentication and profile management.\n *     The service should use the User type from:\n *     ${alchemy.file(\"src/types/User.ts\")}\n *\n *     Include methods for:\n *     - login(email, password)\n *     - register(user)\n *     - updateProfile(userId, profileData)\n *     - deleteAccount(userId)\n *   `,\n *   temperature: 0.2,\n *   prettierConfig: {\n *     semi: false,\n *     singleQuote: true,\n *     printWidth: 120\n *   }\n * });\n *\n * @example\n * // Generate a React hook with custom system prompt\n * const useFormHook = await TypeScriptFile(\"use-form\", {\n *   path: \"./src/hooks/useForm.ts\",\n *   prompt: await alchemy`\n *     Create a custom React hook called useForm that handles form state, validation, and submission.\n *     It should support:\n *     - Initial values\n *     - Validation rules\n *     - Field errors\n *     - Form submission with loading state\n *     - Reset functionality\n *   `,\n *   system: \"You are an expert React developer specializing in TypeScript hooks. Create a single TypeScript file inside ```ts fences with no additional text. Follow React best practices and include proper typing.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const TypeScriptFile = Resource(\n  \"ai::TypeScriptFile\",\n  async function (\n    this: Context<TypeScriptFile>,\n    id: string,\n    props: TypeScriptFileProps\n  ): Promise<TypeScriptFile> {\n    // Handle delete phase\n    if (this.phase === \"delete\") {\n      // StaticTypeScriptFile will handle the deletion\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_TS_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate TypeScript code\n    let { code, error } = await extractTypeScriptCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one TypeScript code block inside \\`\\`\\`ts fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractTypeScriptCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid TypeScript code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticTypeScriptFile to create/update the file\n    const file = await StaticTypeScriptFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts TypeScript code from between ```ts fences\n * Validates that exactly one TypeScript code block exists\n *\n * @param text The text to extract TypeScript code from\n * @returns The extracted TypeScript code or error message\n */\nasync function extractTypeScriptCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const tsCodeRegex = /```ts\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(tsCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No TypeScript code block found in the response. Please include your code within ```ts fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple TypeScript code blocks found in the response. Please provide exactly one code block within ```ts fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/vue-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticVueFile } from \"../fs/static-vue-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a VueFile\n */\nexport interface VueFileProps {\n  /**\n   * Path to the Vue file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a Vue component using:\n   *   ${alchemy.file(\"src/api.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return a single Vue component inside ```vue fences\n   * @default \"You are a Vue component generator. Create a single Vue component based on the user's requirements. Your response MUST include only a single Vue component inside ```vue fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A Vue file that can be created, updated, and deleted\n */\nexport interface VueFile extends VueFileProps, Resource<\"ai::VueFile\"> {\n  /**\n   * Content of the Vue file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for Vue file generation\n */\nconst DEFAULT_VUE_SYSTEM_PROMPT =\n  \"You are a Vue component generator. Create a single Vue component based on the user's requirements. Your response MUST include only a single Vue component inside ```vue fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating Vue files using AI models.\n * Extracts Vue code from between ```vue fences and validates the response.\n *\n * @example\n * // Create a simple Vue component\n * const button = await VueFile(\"button-component\", {\n *   path: \"./src/components/Button.vue\",\n *   prompt: await alchemy`\n *     Generate a customizable button Vue component with:\n *     - Primary, secondary, and outline variants\n *     - Small, medium, and large sizes\n *     - Loading state with spinner\n *     - Disabled state\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate a Vue component using existing files as reference\n * const userCard = await VueFile(\"user-card\", {\n *   path: \"./src/components/UserCard.vue\",\n *   prompt: await alchemy`\n *     Create a UserCard Vue component that displays user information.\n *     Follow the styling patterns from:\n *     ${alchemy.file(\"src/components/Card.vue\")}\n *\n *     Use the user type from:\n *     ${alchemy.file(\"src/types/User.ts\")}\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate a complex form component with validation and custom system prompt\n * const form = await VueFile(\"registration-form\", {\n *   path: \"./src/components/RegistrationForm.vue\",\n *   prompt: await alchemy`\n *     Generate a registration form Vue component with:\n *     - Email, password, and confirm password fields\n *     - Form validation using Vuelidate or similar\n *     - Error messages for each field\n *     - Submit handler that emits form data\n *\n *     Follow these style guidelines:\n *     ${alchemy.file(\"src/styles/guidelines.md\")}\n *   `,\n *   system: \"You are an expert Vue component creator specializing in form components with validation. Create a single Vue component inside ```vue fences with no additional text.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const VueFile = Resource(\n  \"ai::VueFile\",\n  async function (\n    this: Context<VueFile>,\n    id: string,\n    props: VueFileProps\n  ): Promise<VueFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_VUE_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate Vue code\n    let { code, error } = await extractVueCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one Vue component inside \\`\\`\\`vue fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractVueCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid Vue code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticVueFile to create/update the file\n    const file = await StaticVueFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts Vue code from between ```vue fences\n * Validates that exactly one Vue code block exists\n *\n * @param text The text to extract Vue code from\n * @returns The extracted Vue code or error message\n */\nasync function extractVueCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const vueCodeRegex = /```vue\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(vueCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No Vue code block found in the response. Please include your code within ```vue fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple Vue code blocks found in the response. Please provide exactly one code block within ```vue fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/yaml-file.ts\n```ts\nimport { generateObject, generateText } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { StaticYamlFile } from \"../fs/static-yaml-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a YAMLFile\n */\nexport interface YAMLFileProps<\n  T extends Type<any, any> | undefined = undefined,\n> {\n  /**\n   * Path to the YAML file\n   */\n  path: string;\n\n  /**\n   * Optional ArkType schema to validate and structure the generated YAML\n   * When provided, the resource will use generateObject with schema validation\n   * When not provided, it will extract YAML from between ```yaml fences\n   */\n  schema?: T;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a YAML configuration for:\n   *   ${alchemy.file(\"src/serverless.js\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * @default Depends on whether schema is provided\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A YAML file that can be created, updated, and deleted\n */\nexport interface YAMLFile<T = any>\n  extends Omit<YAMLFileProps, \"schema\">,\n    Resource<\"ai::YAMLFile\"> {\n  /**\n   * Content of the YAML file as a string\n   */\n  content: string;\n\n  /**\n   * Parsed YAML object\n   */\n  yaml: T;\n\n  /**\n   * Schema used to validate the YAML (if provided)\n   */\n  schema?: JsonSchema;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for YAML file generation without schema\n */\nconst DEFAULT_YAML_SYSTEM_PROMPT =\n  \"You are a YAML generator. Create valid YAML based on the user's requirements. Your response MUST include only YAML inside ```yaml fences. Do not include any other text, explanations, or multiple code blocks. Use standard YAML syntax with proper indentation. Use quotes around strings that contain special characters when necessary.\";\n\n/**\n * Resource for generating YAML files using AI models.\n * Can operate in two modes:\n * 1. With schema: Uses generateObject with type validation, then converts to YAML\n * 2. Without schema: Extracts YAML from between ```yaml fences\n *\n * @example\n * // Generate a serverless configuration file\n * const serverlessConfig = await YAMLFile(\"serverless-config\", {\n *   path: \"./serverless.yml\",\n *   prompt: await alchemy`\n *     Generate a serverless.yml configuration for an AWS Lambda API with:\n *     - A service name \"user-api\"\n *     - Node.js 16.x runtime\n *     - Three functions: createUser, getUser, and listUsers\n *     - API Gateway endpoints for each function\n *     - DynamoDB table for users\n *     - IAM permissions for DynamoDB access\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate YAML with schema validation\n * import { type } from \"arktype\";\n *\n * const k8sConfigSchema = type({\n *   apiVersion: \"string\",\n *   kind: \"string\",\n *   metadata: {\n *     name: \"string\",\n *     namespace: \"string?\",\n *     labels: \"Record<string, string>?\"\n *   },\n *   spec: {\n *     replicas: \"number\",\n *     selector: {\n *       matchLabels: \"Record<string, string>\"\n *     },\n *     template: {\n *       metadata: {\n *         labels: \"Record<string, string>\"\n *       },\n *       spec: {\n *         containers: [{\n *           name: \"string\",\n *           image: \"string\",\n *           ports: [{\n *             containerPort: \"number\"\n *           }]\n *         }]\n *       }\n *     }\n *   }\n * });\n *\n * const deployment = await YAMLFile(\"k8s-deployment\", {\n *   path: \"./kubernetes/deployment.yaml\",\n *   schema: k8sConfigSchema,\n *   prompt: \"Generate a Kubernetes deployment for a web application named 'frontend' with 3 replicas using the nginx:latest image and exposing port 80\",\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate GitHub Actions workflow with custom system prompt\n * const workflow = await YAMLFile(\"github-workflow\", {\n *   path: \"./.github/workflows/ci.yml\",\n *   prompt: await alchemy`\n *     Create a GitHub Actions workflow for a Node.js project that:\n *     - Runs on push to main and pull requests\n *     - Sets up Node.js 18\n *     - Installs dependencies with npm\n *     - Runs linting and tests\n *     - Builds the project\n *     - Deploys to GitHub Pages on success (main branch only)\n *   `,\n *   system: \"You are a DevOps expert specializing in GitHub Actions workflows. Create a single YAML file inside ```yaml fences with no additional text. Follow GitHub Actions best practices and use proper YAML syntax.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const YAMLFile = Resource(\"ai::YAMLFile\", async function <\n  const T extends Type<any, any> | undefined = undefined,\n>(this: Context<YAMLFile<T extends Type<any, any> ? type.infer<T> : any>>, id: string, props: YAMLFileProps<T>): Promise<\n  YAMLFile<T extends Type<any, any> ? type.infer<T> : any>\n> {\n  // Handle deletion phase\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  let yamlContent: string;\n  let yamlObject: any;\n\n  // Check if schema is provided\n  if (props.schema) {\n    // Use schema-based generation\n    const { object } = await generateObject({\n      model: createModel(props),\n      schema: ark.schema<type.infer<typeof props.schema>>(props.schema),\n      providerOptions: props.model?.options,\n      system:\n        props.system ||\n        \"Generate a valid object based on the provided requirements.\",\n      prompt: props.prompt,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    yamlObject = object;\n\n    // Let StaticYamlFile handle the YAML conversion\n    const file = await StaticYamlFile(\"file\", props.path, yamlObject);\n    yamlContent = file.content;\n  } else {\n    // Use fence-based extraction\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_YAML_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate YAML content\n    let { content, error } = await extractYAMLContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one YAML block inside \\`\\`\\`yaml fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractYAMLContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(`Failed to generate valid YAML: ${retryResult.error}`);\n      }\n\n      content = retryResult.content;\n    }\n\n    yamlContent = content;\n\n    // Create the file with the string content\n    const file = await StaticYamlFile(\"file\", props.path, yamlContent);\n\n    // We need to parse the YAML to get the object representation\n    const yaml = await import(\"yaml\");\n    yamlObject = yaml.parse(yamlContent);\n  }\n\n  // Return the resource\n  return this({\n    ...props,\n    schema: props.schema,\n    content: yamlContent,\n    yaml: yamlObject,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  });\n});\n\n/**\n * Extracts YAML content from between ```yaml fences\n * Validates that exactly one YAML code block exists\n *\n * @param text The text to extract YAML from\n * @returns The extracted YAML or error message\n */\nasync function extractYAMLContent(\n  text: string\n): Promise<{ content: string; error?: string }> {\n  // Check for yaml or yml fence blocks\n  const yamlCodeRegex = /```(yaml|yml)\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(yamlCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      content: \"\",\n      error:\n        \"No YAML code block found in the response. Please include your YAML within ```yaml fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      content: \"\",\n      error:\n        \"Multiple YAML code blocks found in the response. Please provide exactly one YAML block within ```yaml fences.\",\n    };\n  }\n\n  const content = matches[0][2].trim();\n\n  // We don't validate YAML parsing here because js-yaml might not be available\n  // Validation will happen at usage time if needed\n  return { content };\n}\n\n```"
      },
      {
        "role": "assistant",
        "content": "# AstroFile\n\nThe AstroFile resource lets you generate [Astro](https://astro.build) components using AI models.\n\n# Minimal Example\n\nCreate a simple Astro component with AI generation:\n\n```ts\nimport { AstroFile } from \"alchemy/ai\";\n\nconst header = await AstroFile(\"header\", {\n  path: \"./src/components/Header.astro\",\n  prompt: \"Generate an Astro header component with a logo, navigation menu, and mobile responsiveness\"\n});\n```\n\n# Generate Component with File Context\n\nUse alchemy template literals to include existing files as context:\n\n```ts\nimport { AstroFile } from \"alchemy/ai\";\n\nconst blogPost = await AstroFile(\"blog-post\", {\n  path: \"./src/pages/blog/[slug].astro\",\n  prompt: await alchemy`\n    Create an Astro blog post page that uses these types:\n    ${alchemy.file(\"src/types/Blog.ts\")}\n  `,\n  temperature: 0.2\n});\n```\n\n# Custom System Prompt\n\nProvide a custom system prompt to guide the AI's output:\n\n```ts\nimport { AstroFile } from \"alchemy/ai\";\n\nconst layout = await AstroFile(\"layout\", {\n  path: \"./src/layouts/MainLayout.astro\",\n  prompt: \"Create a main layout with SEO metadata and content slots\",\n  system: \"You are an expert Astro developer. Create a single Astro layout file inside ```astro fences with no additional text.\",\n  model: {\n    id: \"claude-3-opus-20240229\",\n    provider: \"anthropic\"\n  }\n});\n```"
      }
    ],
    "createdAt": 1744513174966,
    "updatedAt": 1744513174966,
    "file": {
      "path": "alchemy-web/docs/providers/ai/astro-file.md",
      "content": "# AstroFile\n\nThe AstroFile resource lets you generate [Astro](https://astro.build) components using AI models.\n\n# Minimal Example\n\nCreate a simple Astro component with AI generation:\n\n```ts\nimport { AstroFile } from \"alchemy/ai\";\n\nconst header = await AstroFile(\"header\", {\n  path: \"./src/components/Header.astro\",\n  prompt: \"Generate an Astro header component with a logo, navigation menu, and mobile responsiveness\"\n});\n```\n\n# Generate Component with File Context\n\nUse alchemy template literals to include existing files as context:\n\n```ts\nimport { AstroFile } from \"alchemy/ai\";\n\nconst blogPost = await AstroFile(\"blog-post\", {\n  path: \"./src/pages/blog/[slug].astro\",\n  prompt: await alchemy`\n    Create an Astro blog post page that uses these types:\n    ${alchemy.file(\"src/types/Blog.ts\")}\n  `,\n  temperature: 0.2\n});\n```\n\n# Custom System Prompt\n\nProvide a custom system prompt to guide the AI's output:\n\n```ts\nimport { AstroFile } from \"alchemy/ai\";\n\nconst layout = await AstroFile(\"layout\", {\n  path: \"./src/layouts/MainLayout.astro\",\n  prompt: \"Create a main layout with SEO metadata and content slots\",\n  system: \"You are an expert Astro developer. Create a single Astro layout file inside ```astro fences with no additional text.\",\n  model: {\n    id: \"claude-3-opus-20240229\",\n    provider: \"anthropic\"\n  }\n});\n```",
      "Kind": "fs::File",
      "ID": "docs/ai/AstroFile-file",
      "FQN": "github:alchemy/prod/docs/docs/ai/AstroFile/docs/ai/AstroFile-file",
      "Seq": 0
    },
    "Kind": "docs::Document",
    "ID": "docs/ai/AstroFile",
    "FQN": "github:alchemy/prod/docs/docs/ai/AstroFile",
    "Seq": 31
  },
  "props": {
    "title": "AstroFile",
    "path": "alchemy-web/docs/providers/ai/astro-file.md",
    "freeze": true,
    "model": {
      "id": "claude-3-5-sonnet-latest",
      "provider": "anthropic"
    },
    "prompt": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         ai Service:\n[data.ts](alchemy/src/ai/data.ts)\n\n[vue-file.ts](alchemy/src/ai/vue-file.ts)\n\n[astro-file.ts](alchemy/src/ai/astro-file.ts)\n\n[css-file.ts](alchemy/src/ai/css-file.ts)\n\n[html-file.ts](alchemy/src/ai/html-file.ts)\n\n[document.ts](alchemy/src/ai/document.ts)\n\n[yaml-file.ts](alchemy/src/ai/yaml-file.ts)\n\n[client.ts](alchemy/src/ai/client.ts)\n\n[typescript-file.ts](alchemy/src/ai/typescript-file.ts)\n\n[ark.ts](alchemy/src/ai/ark.ts)\n\n[json-file.ts](alchemy/src/ai/json-file.ts)\n\nWrite concise documentation for the \"        AstroFile\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         AstroFile\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         AstroFile } from \"alchemy/        ai\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         AstroFile } from \"alchemy/        ai\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        \n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Create Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroy the Resource\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\n> [!CAUTION]\n> Now, before we run our script again, you need to first add a \"naked\" impot of `alchemy/fs` at the top of our `alchemy.run.ts` script.\n> ```typescript\n> import \"alchemy/fs\"\n> ```\n> If you forget this, you would get an error\n> `Cannot destroy resource \"my-first-app/dev/hello\" type fs::File - no provider found. You may need to import the provider in your alchemy.config.ts.`\n> \n> This is because IDEs usually remove unused imports. If you don't import the resource, the delete handler won't be registered which Alchemy needs to delete the resource.\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value ðŸ˜µâ€ðŸ’«\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n/// <reference types=\"./env.d.ts\" />\n\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\nâ”œâ”€â”€ dev (Stage Scope)\nâ”‚   â”œâ”€â”€ api (Nested Scope)\nâ”‚   â””â”€â”€ database (Resource)\nâ””â”€â”€ prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/ai/ark.ts\n```ts\nimport {\n  type Tool as AITool,\n  type Schema,\n  type ToolExecutionOptions,\n  tool as aitool,\n  jsonSchema,\n} from \"ai\";\nimport { ArkErrors, type JsonSchema, type type } from \"arktype\";\n\nexport namespace ark {\n  export function schema<T>(type: JsonSchema): Schema<T>;\n  export function schema<T extends type>(type: T): Schema<type.infer<T>> {\n    const jsonSchemaObj = type.toJsonSchema() as any;\n    const processedSchema = processSchema(jsonSchemaObj);\n\n    return jsonSchema(processedSchema, {\n      validate: (value) => {\n        const out = type(value) as type.infer<T> | type.errors;\n        if (out instanceof ArkErrors) {\n          return {\n            success: false,\n            error: new Error(out.summary),\n          };\n        }\n        return {\n          success: true,\n          value: out,\n        };\n      },\n    });\n  }\n\n  /**\n   * Recursively processes a JSON schema and sets additionalProperties: false\n   * for any object types.\n   *\n   * Structured Outputs requires additionalProperties: false\n   */\n  function processSchema(schema: any): any {\n    if (!schema || typeof schema !== \"object\") return schema;\n\n    // Create a copy to avoid mutating the original\n    const result = { ...schema };\n\n    // Convert anyOf with all const values to enum\n    if (result.anyOf && Array.isArray(result.anyOf)) {\n      const allConst = result.anyOf.every(\n        (item: any) => item && typeof item === \"object\" && \"const\" in item,\n      );\n\n      if (allConst) {\n        // Extract all const values\n        const enumValues = result.anyOf.map((item: any) => item.const);\n\n        // Determine the type based on the first const value\n        // Assuming all const values are of the same type\n        const firstType = typeof enumValues[0];\n\n        // Replace anyOf with enum\n        delete result.anyOf;\n        result.type = firstType;\n        result.enum = enumValues;\n      } else {\n        // Process each item in anyOf\n        result.anyOf = result.anyOf.map(processSchema);\n      }\n    }\n\n    // If this is an object type, set additionalProperties: false\n    if (result.type === \"object\") {\n      result.additionalProperties = false;\n      result.properties ??= {};\n    }\n\n    // Process properties of objects\n    if (result.properties && typeof result.properties === \"object\") {\n      result.properties = Object.fromEntries(\n        Object.entries(result.properties).map(([key, value]) => [\n          key,\n          processSchema(value),\n        ]),\n      );\n    }\n\n    // Process items in arrays\n    if (result.items) {\n      result.items = processSchema(result.items);\n    }\n\n    // Process allOf, oneOf\n    for (const key of [\"allOf\", \"oneOf\"]) {\n      if (Array.isArray(result[key])) {\n        result[key] = result[key].map(processSchema);\n      }\n    }\n\n    return result;\n  }\n\n  export interface Tool<Input extends type, Output>\n    extends Omit<AITool<Schema<type.infer<Input>>>, \"parameters\" | \"execute\"> {\n    description?: string;\n    parameters: Input;\n    execute: (\n      input: type.infer<Input>,\n      options: ToolExecutionOptions,\n    ) => Promise<Output>;\n  }\n\n  export function tool<Input extends type, Output>(\n    tool: Tool<Input, Output>,\n  ): AITool<Schema<type.infer<Input>>, Output> {\n    return aitool({\n      ...tool,\n      parameters: ark.schema<Input>(tool.parameters),\n    } as any);\n  }\n}\n\n```\n\n// alchemy/src/ai/astro-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport prettier from \"prettier\";\nimport type { Context } from \"../context\";\nimport { StaticAstroFile } from \"../fs/static-astro-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating an AstroFile\n */\nexport interface AstroFileProps {\n  /**\n   * Path to the Astro file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate an Astro component using:\n   *   ${alchemy.file(\"src/types.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return Astro code inside ```astro fences\n   * @default \"You are an Astro component generator. Create Astro components based on the user's requirements. Your response MUST include only Astro code inside ```astro fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Prettier configuration to use for formatting the Astro code\n   * If not provided, will use the default Prettier configuration\n   */\n  prettierConfig?: prettier.Options;\n}\n\n/**\n * An Astro file that can be created, updated, and deleted\n */\nexport interface AstroFile extends AstroFileProps, Resource<\"ai::AstroFile\"> {\n  /**\n   * Content of the Astro file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for Astro file generation\n */\nconst DEFAULT_ASTRO_SYSTEM_PROMPT =\n  \"You are an Astro component generator. Create Astro components based on the user's requirements. Your response MUST include only Astro code inside ```astro fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating Astro files using AI models.\n * Extracts Astro code from between ```astro fences, validates the response,\n * and formats the code with Prettier.\n *\n * @example\n * // Create a simple Astro component\n * const header = await AstroFile(\"header\", {\n *   path: \"./src/components/Header.astro\",\n *   prompt: await alchemy`\n *     Generate an Astro header component with:\n *     - Site logo\n *     - Navigation menu with Home, About, Services, Contact links\n *     - Mobile responsive design\n *     - Dark/light mode toggle\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate an Astro page with data fetching\n * const blogPost = await AstroFile(\"blog-post\", {\n *   path: \"./src/pages/blog/[slug].astro\",\n *   prompt: await alchemy`\n *     Create an Astro blog post page that:\n *     - Uses getStaticPaths to generate pages from a CMS\n *     - Renders markdown content\n *     - Includes author info, publication date, and related posts\n *     - Has social sharing buttons\n *\n *     Use the following types:\n *     ${alchemy.file(\"src/types/Blog.ts\")}\n *   `,\n *   temperature: 0.2,\n *   prettierConfig: {\n *     semi: false,\n *     singleQuote: true,\n *     printWidth: 120\n *   }\n * });\n *\n * @example\n * // Generate a layout with custom system prompt\n * const mainLayout = await AstroFile(\"main-layout\", {\n *   path: \"./src/layouts/MainLayout.astro\",\n *   prompt: await alchemy`\n *     Create the main layout for an Astro site that:\n *     - Includes common head metadata and SEO optimization\n *     - Has slots for page content, header, and footer\n *     - Imports and uses the Header and Footer components\n *     - Sets up viewport and responsive configurations\n *   `,\n *   system: \"You are an expert Astro developer. Create a single Astro layout file inside ```astro fences with no additional text. Follow Astro best practices and include proper typing in the frontmatter section.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const AstroFile = Resource(\n  \"ai::AstroFile\",\n  async function (\n    this: Context<AstroFile>,\n    id: string,\n    props: AstroFileProps\n  ): Promise<AstroFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_ASTRO_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate Astro code\n    let { code, error } = await extractAstroCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one Astro code block inside \\`\\`\\`astro fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractAstroCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid Astro code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Format the code with Prettier\n    try {\n      // Set default parser to astro\n      const prettierOptions: prettier.Options = {\n        parser: \"astro\",\n        ...props.prettierConfig,\n      };\n\n      // Format the code\n      code = await prettier.format(code, prettierOptions);\n    } catch (error) {\n      // If Prettier formatting fails, just use the unformatted code\n      console.warn(\"Failed to format Astro code with Prettier:\", error);\n    }\n\n    // Use StaticAstroFile to create/update the file\n    const file = await StaticAstroFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts Astro code from between ```astro fences\n * Validates that exactly one Astro code block exists\n *\n * @param text The text to extract Astro code from\n * @returns The extracted Astro code or error message\n */\nasync function extractAstroCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const astroCodeRegex = /```astro\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(astroCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No Astro code block found in the response. Please include your code within ```astro fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple Astro code blocks found in the response. Please provide exactly one code block within ```astro fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/client.ts\n```ts\nimport { anthropic } from \"@ai-sdk/anthropic\";\nimport { openai } from \"@ai-sdk/openai\";\nimport type { Secret } from \"../secret\";\n\n/**\n * Model configuration for AI operations\n */\nexport interface ModelConfig {\n  /**\n   * Model ID to use\n   * @default 'gpt-4o'\n   */\n  id?: string;\n\n  /**\n   * Model provider name\n   * @default 'openai'\n   */\n  provider?: string;\n\n  /**\n   * Model-specific options\n   */\n  options?: Record<string, any>;\n}\n\n/**\n * Configuration for creating an OpenAI client\n */\nexport interface ClientConfig {\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n}\n\n/**\n * Creates an OpenAI-compatible client with the given configuration\n */\nexport function createModel(config: ClientConfig) {\n  if (config.model?.provider === \"anthropic\") {\n    return anthropic(config.model?.id ?? \"claude-3-7-sonnet-latest\");\n  } else {\n    return openai(config.model?.id ?? \"gpt-4o\");\n  }\n}\n\n/**\n * Maximum time to retry in milliseconds (5 minutes)\n */\nconst MAX_RETRY_TIME = 5 * 60 * 1000;\n\n/**\n * Initial delay between retries in milliseconds\n */\nconst INITIAL_RETRY_DELAY = 1000;\n\n/**\n * Maximum number of retries\n */\nconst MAX_RETRIES = 10;\n\n/**\n * Handles rate limiting with exponential backoff\n * @param fn Function to retry\n * @returns Result of the function\n * @throws Error if max retries or time is exceeded\n */\nexport async function withRateLimitRetry<T>(fn: () => Promise<T>): Promise<T> {\n  let retryCount = 0;\n  let lastError: Error | null = null;\n  let startTime = Date.now();\n\n  while (true) {\n    try {\n      return await fn();\n    } catch (error: any) {\n      lastError = error;\n\n      console.log(\"retry error\", error);\n\n      // Check if we should retry\n      const isRateLimit = error.statusCode === 429;\n      const timeElapsed = Date.now() - startTime;\n      const shouldRetry =\n        isRateLimit && retryCount < MAX_RETRIES && timeElapsed < MAX_RETRY_TIME;\n\n      if (!shouldRetry) {\n        throw error;\n      }\n\n      // Calculate delay with exponential backoff\n      const delay = Math.min(\n        INITIAL_RETRY_DELAY * Math.pow(2, retryCount),\n        MAX_RETRY_TIME - timeElapsed\n      );\n\n      console.log(`Retrying in ${delay}ms`);\n\n      // Wait before retrying\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      retryCount++;\n    }\n  }\n}\n\n```\n\n// alchemy/src/ai/css-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticCSSFile } from \"../fs/static-css-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a CSSFile\n */\nexport interface CSSFileProps {\n  /**\n   * Path to the CSS file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate CSS styles for:\n   *   ${alchemy.file(\"src/components/Button.jsx\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return CSS code inside ```css fences\n   * @default \"You are a CSS code generator. Create CSS code based on the user's requirements. Your response MUST include only CSS code inside ```css fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A CSS file that can be created, updated, and deleted\n */\nexport interface CSSFile extends CSSFileProps, Resource<\"ai::CSSFile\"> {\n  /**\n   * Content of the CSS file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for CSS file generation\n */\nconst DEFAULT_CSS_SYSTEM_PROMPT =\n  \"You are a CSS code generator. Create CSS code based on the user's requirements. Your response MUST include only CSS code inside ```css fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating CSS files using AI models.\n * Extracts CSS code from between ```css fences and validates the response.\n *\n * @example\n * // Create styles for a website\n * const mainStyles = await CSSFile(\"main-styles\", {\n *   path: \"./public/css/main.css\",\n *   prompt: await alchemy`\n *     Generate modern CSS styles for a company website with:\n *     - Clean, minimalist design\n *     - Primary color: #0062ff\n *     - Secondary color: #6c757d\n *     - Light gray background\n *     - Responsive layout for mobile, tablet, and desktop\n *     - Custom styles for buttons, cards, and navigation\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate CSS based on existing HTML\n * const componentStyles = await CSSFile(\"component-styles\", {\n *   path: \"./src/styles/component.css\",\n *   prompt: await alchemy`\n *     Create CSS styles for this HTML component:\n *     ${alchemy.file(\"src/components/Card.html\")}\n *\n *     The styles should be:\n *     - Modern and clean\n *     - Include hover effects and transitions\n *     - Support both light and dark themes\n *     - Use CSS variables for colors and spacing\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate CSS animation with custom system prompt\n * const animationStyles = await CSSFile(\"animations\", {\n *   path: \"./src/styles/animations.css\",\n *   prompt: await alchemy`\n *     Create CSS animations for:\n *     - Fade in/out\n *     - Slide in from different directions\n *     - Pulse effect\n *     - Bounce effect\n *     - Scale in/out\n *     - Rotate\n *\n *     Each animation should be reusable via class names.\n *   `,\n *   system: \"You are an expert CSS animator. Create a single CSS file inside ```css fences with no additional text. Use modern CSS animation techniques and include vendor prefixes where needed for browser compatibility.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const CSSFile = Resource(\n  \"ai::CSSFile\",\n  async function (\n    this: Context<CSSFile>,\n    id: string,\n    props: CSSFileProps\n  ): Promise<CSSFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_CSS_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate CSS code\n    let { code, error } = await extractCSSCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one CSS code block inside \\`\\`\\`css fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractCSSCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid CSS code: ${retryResult.error}\\n${retryText}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticCSSFile to create/update the file\n    const file = await StaticCSSFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts CSS code from between ```css fences\n * Validates that exactly one CSS code block exists\n *\n * @param text The text to extract CSS code from\n * @returns The extracted CSS code or error message\n */\nasync function extractCSSCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const cssCodeRegex = /```css\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(cssCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No CSS code block found in the response. Please include your code within ```css fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple CSS code blocks found in the response. Please provide exactly one code block within ```css fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/data.ts\n```ts\nimport { generateObject, type CoreMessage } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { createModel, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating an AI Object\n */\nexport interface DataProps<T extends Type<any, any>> {\n  /**\n   * The ArkType schema to validate and structure the generated content\n   */\n  schema: T | JsonSchema;\n\n  /**\n   * Prompt for generating the content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a description for:\n   *   ${alchemy.file(\"src/data.ts\")}\n   * `\n   */\n  prompt?: string;\n\n  /**\n   * Message history for the conversation\n   * If provided, this will be used instead of the prompt\n   */\n  messages?: CoreMessage[];\n\n  /**\n   * System prompt to guide the AI's behavior\n   * @example\n   * system: \"You are a technical writer tasked with describing code\"\n   */\n  system?: string;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Whether to freeze the generated object\n   * @default false\n   */\n  freeze?: boolean;\n}\n\n/**\n * A resource that uses AI to generate structured content based on a schema\n */\nexport interface Data<T> extends Resource<\"ai::Object\"> {\n  type: JsonSchema;\n\n  /**\n   * The generated content, typed according to the provided schema\n   */\n  object: T;\n\n  /**\n   * Updated message history with the AI's response appended\n   */\n  messages: CoreMessage[];\n\n  /**\n   * Time at which the content was generated\n   */\n  createdAt: number;\n}\n\n/**\n * Resource for generating structured content using the Vercel AI SDK.\n * Supports powerful context handling through the alchemy template literal tag.\n *\n * @example\n * // Generate a product description with specific fields\n * const productSchema = type({\n *   name: \"string\",\n *   description: \"string\",\n *   features: \"string[]\",\n *   price: \"number\"\n * });\n *\n * const product = await Data(\"new-product\", {\n *   schema: productSchema,\n *   prompt: \"Generate a product description for a new smartphone\",\n *   system: \"You are a product copywriter specializing in tech products\",\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\",\n *     options: {\n *       temperature: 0.7\n *     }\n *   }\n * });\n *\n * console.log(product.object); // Typed as per schema\n *\n * @example\n * // Generate code documentation with context\n * const docSchema = type({\n *   summary: \"string\",\n *   parameters: {\n *     name: \"string\",\n *     type: \"string\",\n *     description: \"string\"\n *   }[],\n *   returns: \"string\"\n * });\n *\n * const docs = await Data(\"function-docs\", {\n *   schema: docSchema,\n *   prompt: await alchemy`\n *     Generate documentation for this function:\n *     ${alchemy.file(\"src/utils/format.ts\")}\n *   `,\n *   system: \"You are a technical documentation writer\",\n *   temperature: 0.2\n * });\n *\n * @example\n * // Using message history for iterative generation\n * const feedbackSchema = type({\n *   rating: \"number\",\n *   positives: \"string[]\",\n *   improvements: \"string[]\",\n *   summary: \"string\"\n * });\n *\n * const feedback = await Data(\"product-feedback\", {\n *   schema: feedbackSchema,\n *   messages: [\n *     { role: \"user\", content: \"I'd like feedback on my product design\" },\n *     { role: \"assistant\", content: \"I'd be happy to provide feedback. What's your product?\" },\n *     { role: \"user\", content: \"It's a new smart home device that...\" }\n *   ],\n *   system: \"You are a product design expert providing structured feedback\",\n *   temperature: 0.3\n * });\n */\nexport const Data = Resource(\"ai::Object\", async function <\n  const T extends Type<any, any>,\n>(this: Context<Data<any>>, id: string, props: DataProps<T>): Promise<\n  Data<type.infer<T>>\n> {\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  // Validate that either prompt or messages is provided\n  if (!props.prompt && !props.messages) {\n    throw new Error(\"Either prompt or messages must be provided\");\n  }\n\n  if (this.phase === \"update\" && props.freeze) {\n    return this(this.output);\n  }\n\n  // Create messages array if only prompt is provided\n  const messages = props.messages || [{ role: \"user\", content: props.prompt! }];\n\n  // Generate structured output using generateObject\n  const { object } = await generateObject({\n    model: createModel(props),\n    // Convert ArkType schema to Zod schema for generateObject\n    // This is needed because generateObject expects a Zod schema\n    schema: ark.schema<type.infer<T>>(props.schema),\n    providerOptions: props.model?.options,\n    system:\n      props.system ||\n      \"You are an AI assistant tasked with generating structured content.\",\n    messages,\n    ...(props.temperature === undefined\n      ? {}\n      : // some models error if you provide it (rather than ignoring it)\n        { temperature: props.temperature }),\n  });\n\n  // Create updated message history with the structured response\n  const responseText = JSON.stringify(object);\n  const updatedMessages = [\n    ...messages,\n    {\n      role: \"assistant\" as const,\n      content: responseText,\n    },\n  ];\n\n  // Return the resource with typed content and updated messages\n  return this({\n    type: props.schema,\n    object: object,\n    messages: updatedMessages,\n    createdAt: Date.now(),\n  });\n});\n\n```\n\n// alchemy/src/ai/document.ts\n```ts\nimport { generateText, type CoreMessage } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticTextFile } from \"../fs/static-text-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createModel, withRateLimitRetry, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating a Document\n */\nexport interface DocumentProps {\n  /**\n   * Title of the document\n   *\n   * @default id\n   */\n  title?: string;\n\n  /**\n   * Optional path to the markdown document\n   * If provided, document will be written to this path\n   */\n  path?: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate docs using:\n   *   ${alchemy.file(\"src/api.ts\")}\n   * `\n   */\n  prompt?: string;\n\n  /**\n   * Message history for conversation-based generation\n   * If provided, this will be used instead of the prompt\n   * @example\n   * messages: [\n   *   { role: \"user\", content: \"Generate API documentation for this file\" },\n   *   { role: \"assistant\", content: \"I'll create detailed API docs. What file should I document?\" },\n   *   { role: \"user\", content: \"Please document src/api.ts\" }\n   * ]\n   */\n  messages?: CoreMessage[];\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return a single markdown document inside ```md fences\n   * @default \"You are a technical documentation writer. Create a single markdown document based on the user's requirements. Your response MUST include only a single markdown document inside ```md fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Maximum number of tokens to generate.\n   * Higher values allow for longer documents but may increase cost and generation time.\n   * @default 10000\n   */\n  maxTokens?: number;\n\n  /**\n   * Freeze the document after creation (do not re-generate on updates)\n   * @default false\n   */\n  freeze?: boolean;\n}\n\n/**\n * A markdown document that can be created, updated, and deleted\n */\nexport interface Document extends DocumentProps, Resource<\"docs::Document\"> {\n  /**\n   * The title of the document\n   */\n  title: string;\n\n  /**\n   * Content of the document\n   */\n  content: string;\n\n  /**\n   * Updated message history with the document response appended\n   */\n  messages: CoreMessage[];\n\n  /**\n   * Time at which the document was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the document was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * File resource if path was provided\n   */\n  file?: StaticTextFile;\n}\n\n/**\n * Default system prompt for markdown document generation\n */\nconst DEFAULT_MD_SYSTEM_PROMPT =\n  \"You are a technical documentation writer. Create a single markdown document based on the user's requirements. Your response MUST include only a single markdown document inside ```md fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for managing AI-generated markdown documents using the Vercel AI SDK.\n * Supports powerful context handling through the alchemy template literal tag.\n *\n * @example\n * // Create an in-memory document (no file created)\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   prompt: await alchemy`\n *     Generate API documentation based on these source files:\n *     ${alchemy.file(\"src/api.ts\")}\n *     ${alchemy.file(\"src/types.ts\")}\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Create a document and write it to disk\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   path: \"./docs/api.md\",\n *   prompt: await alchemy`\n *     Generate API documentation based on these source files:\n *     ${alchemy.file(\"src/api.ts\")}\n *     ${alchemy.file(\"src/types.ts\")}\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Use message history for iterative document generation\n * const apiDocs = await Document(\"api-docs\", {\n *   title: \"API Documentation\",\n *   path: \"./docs/api.md\",\n *   messages: [\n *     { role: \"user\", content: \"Create API documentation for these files\" },\n *     { role: \"assistant\", content: \"I'll help you create API documentation. Please provide the files.\" },\n *     { role: \"user\", content: \"Here are the files: [file contents]\" }\n *   ],\n *   system: \"You are a technical documentation writer. Generate clear and concise API documentation.\",\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Use alchemy template literals with file collections and temperature control\n * const modelDocs = await Document(\"models\", {\n *   title: \"Data Models\",\n *   path: \"./docs/models.md\",\n *   prompt: await alchemy`\n *     Write documentation for these data models:\n *     ${alchemy.files(\"src/models/user.ts\", \"src/models/post.ts\")}\n *   `,\n *   temperature: 0.2 // Lower temperature for more deterministic output\n * });\n *\n * @example\n * // Advanced model configuration with custom provider options and custom system prompt\n * const techDocs = await Document(\"tech-specs\", {\n *   title: \"Technical Specifications\",\n *   path: \"./docs/tech-specs.md\",\n *   prompt: await alchemy`\n *     Create detailed technical specifications based on these requirements:\n *     ${alchemy.file(\"requirements/system.md\")}\n *   `,\n *   system: \"You are an expert technical writer specializing in system specifications. Create a single markdown document inside ```md fences with no additional text.\",\n *   model: {\n *     id: \"o3-mini\",\n *     provider: \"openai\",\n *     options: {\n *       reasoningEffort: \"high\"\n *     }\n *   },\n *   temperature: 0.1\n * });\n */\nexport const Document = Resource(\n  \"docs::Document\",\n  async function (\n    this: Context<Document>,\n    id: string,\n    props: DocumentProps\n  ): Promise<Document> {\n    // Validate that either prompt or messages are provided\n    if (!props.prompt && !props.messages) {\n      throw new Error(\"Either prompt or messages must be provided\");\n    }\n\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    if (this.phase === \"update\" && props.freeze) {\n      if (props.path) {\n        const filePath = props.path;\n        const fileId = `${id}-file`;\n\n        await StaticTextFile(fileId, filePath, this.output!.content);\n      }\n      return this(this.output);\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_MD_SYSTEM_PROMPT;\n\n    // Generate initial content with rate limit retry\n    const { text } = await withRateLimitRetry(async () => {\n      return generateText({\n        model: createModel(props),\n        ...(props.messages\n          ? { messages: props.messages }\n          : { prompt: props.prompt! }),\n        system,\n        maxTokens: props.maxTokens || 8192,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : // some models error if you provide it (rather than ignoring it)\n            { temperature: props.temperature }),\n      });\n    });\n\n    // Extract and validate markdown content\n    let { content, error } = extractMarkdownContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one markdown document inside \\`\\`\\`md fences.`;\n\n      const { text: retryText } = await withRateLimitRetry(async () => {\n        return generateText({\n          model: createModel(props),\n          ...(props.messages\n            ? { messages: props.messages }\n            : { prompt: props.prompt! }),\n          system: errorSystem,\n          providerOptions: props.model?.options,\n          ...(props.temperature === undefined\n            ? {}\n            : { temperature: props.temperature }),\n        });\n      });\n\n      const retryResult = extractMarkdownContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid markdown content: ${retryResult.error}\\n${retryText}`\n        );\n      }\n\n      content = retryResult.content;\n    }\n\n    // Create result object\n    const result: Partial<Document> = {\n      ...props,\n      content,\n      messages: [\n        ...(props.messages || [{ role: \"user\", content: props.prompt! }]),\n        { role: \"assistant\", content },\n      ],\n      createdAt: this.output?.createdAt || Date.now(),\n      updatedAt: Date.now(),\n      title: props.title || id,\n    };\n\n    // Write file if path is provided\n    if (props.path) {\n      const filePath = props.path;\n      const fileId = `${id}-file`;\n\n      result.file = await StaticTextFile(fileId, filePath, content);\n    }\n\n    // Return the resource\n    return this(result as Document);\n  }\n);\n\n/**\n * Extracts markdown content from between ```md fences\n * Validates that exactly one markdown code block exists\n *\n * @param text The text to extract markdown content from\n * @returns The extracted markdown content or error message\n */\nfunction extractMarkdownContent(text: string): {\n  content: string;\n  error?: string;\n} {\n  const lines = text.split(\"\\n\");\n  const startIdx = lines.findIndex((line) => line.trim() === \"```md\");\n\n  if (startIdx === -1) {\n    return {\n      content: \"\",\n      error:\n        \"No markdown code block found in the response. Please include your markdown content within ```md fences.\",\n    };\n  }\n\n  const rest = lines.slice(startIdx + 1);\n  const endRelativeIdx = rest\n    .map((line) => line.trim() === \"```\")\n    .lastIndexOf(true);\n\n  if (endRelativeIdx === -1) {\n    return {\n      content: \"\",\n      error: \"Markdown block was not closed properly.\",\n    };\n  }\n\n  const endIdx = startIdx + 1 + endRelativeIdx;\n\n  const content = lines\n    .slice(startIdx + 1, endIdx)\n    .join(\"\\n\")\n    .trim();\n\n  return { content };\n}\n\n```\n\n// alchemy/src/ai/html-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticHTMLFile } from \"../fs/static-html-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating an HTMLFile\n */\nexport interface HTMLFileProps {\n  /**\n   * Path to the HTML file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate an HTML page using:\n   *   ${alchemy.file(\"src/templates/base.html\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return HTML code inside ```html fences\n   * @default \"You are an HTML code generator. Create HTML code based on the user's requirements. Your response MUST include only HTML code inside ```html fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * An HTML file that can be created, updated, and deleted\n */\nexport interface HTMLFile extends HTMLFileProps, Resource<\"ai::HTMLFile\"> {\n  /**\n   * Content of the HTML file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for HTML file generation\n */\nconst DEFAULT_HTML_SYSTEM_PROMPT =\n  \"You are an HTML code generator. Create HTML code based on the user's requirements. Your response MUST include only HTML code inside ```html fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating HTML files using AI models.\n * Extracts HTML code from between ```html fences and validates the response.\n *\n * @example\n * // Create a simple landing page\n * const landingPage = await HTMLFile(\"landing-page\", {\n *   path: \"./public/index.html\",\n *   prompt: await alchemy`\n *     Generate a modern landing page for a SaaS product with:\n *     - Hero section with headline and call-to-action\n *     - Features section with 3 key features\n *     - Pricing section with 3 tiers\n *     - Testimonials section with 2 customer quotes\n *     - Contact form and footer\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate an HTML email template\n * const emailTemplate = await HTMLFile(\"welcome-email\", {\n *   path: \"./emails/welcome.html\",\n *   prompt: await alchemy`\n *     Create an HTML email template for welcoming new users to our platform.\n *     The email should include:\n *     - Company logo and branding\n *     - Personalized welcome message (use {{name}} placeholder)\n *     - Three steps to get started\n *     - Support contact information\n *     - Unsubscribe footer\n *\n *     Make sure it's responsive and works in all major email clients.\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate an HTML component with custom system prompt\n * const navComponent = await HTMLFile(\"navigation\", {\n *   path: \"./components/nav.html\",\n *   prompt: await alchemy`\n *     Create a responsive navigation component with:\n *     - Logo in the left corner\n *     - Navigation links: Home, Products, Services, About, Contact\n *     - Mobile hamburger menu that expands/collapses\n *     - Login/signup buttons on the right side\n *     - Dark/light mode toggle\n *   `,\n *   system: \"You are an expert HTML/CSS developer specializing in responsive components. Create a single HTML file inside ```html fences with no additional text. Use modern HTML5 semantic elements and inline CSS if needed.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const HTMLFile = Resource(\n  \"ai::HTMLFile\",\n  async function (\n    this: Context<HTMLFile>,\n    id: string,\n    props: HTMLFileProps\n  ): Promise<HTMLFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_HTML_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate HTML code\n    let { code, error } = await extractHTMLCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one HTML code block inside \\`\\`\\`html fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractHTMLCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid HTML code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticHTMLFile to create/update the file\n    const file = await StaticHTMLFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts HTML code from between ```html fences\n * Validates that exactly one HTML code block exists\n *\n * @param text The text to extract HTML code from\n * @returns The extracted HTML code or error message\n */\nasync function extractHTMLCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const htmlCodeRegex = /```html\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(htmlCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No HTML code block found in the response. Please include your code within ```html fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple HTML code blocks found in the response. Please provide exactly one code block within ```html fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/json-file.ts\n```ts\nimport { generateObject, generateText } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { StaticJsonFile } from \"../fs/static-json-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a JSONFile\n */\nexport interface JSONFileProps<\n  T extends Type<any, any> | undefined = undefined,\n> {\n  /**\n   * Path to the JSON file\n   */\n  path: string;\n\n  /**\n   * Optional ArkType schema to validate and structure the generated JSON\n   * When provided, the resource will use generateObject with schema validation\n   * When not provided, it will extract JSON from between ```json fences\n   */\n  schema?: T;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a JSON configuration for:\n   *   ${alchemy.file(\"src/config.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * @default Depends on whether schema is provided\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Whether to pretty-print the JSON with indentation\n   * @default true\n   */\n  pretty?: boolean;\n\n  /**\n   * Number of spaces to use for indentation when pretty-printing\n   * @default 2\n   */\n  indent?: number;\n}\n\n/**\n * A JSON file that can be created, updated, and deleted\n */\nexport interface JSONFile<T = any>\n  extends Omit<JSONFileProps, \"schema\">,\n    Resource<\"ai::JSONFile\"> {\n  /**\n   * Content of the JSON file as a string\n   */\n  content: string;\n\n  /**\n   * Parsed JSON object\n   */\n  json: T;\n\n  /**\n   * Schema used to validate the JSON (if provided)\n   */\n  schema?: JsonSchema;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for JSON file generation without schema\n */\nconst DEFAULT_JSON_SYSTEM_PROMPT =\n  \"You are a JSON generator. Create valid JSON based on the user's requirements. Your response MUST include only JSON inside ```json fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating JSON files using AI models.\n * Can operate in two modes:\n * 1. With schema: Uses generateObject with type validation\n * 2. Without schema: Extracts JSON from between ```json fences\n *\n * @example\n * // Generate a configuration file with freeform JSON\n * const config = await JSONFile(\"app-config\", {\n *   path: \"./config/app.json\",\n *   prompt: await alchemy`\n *     Generate a configuration for a web application with:\n *     - Server settings (port, host, timeout)\n *     - Database connection details (redact any passwords)\n *     - Logging configuration\n *     - Feature flags\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate JSON with schema validation\n * import { type } from \"arktype\";\n *\n * const userSchema = type({\n *   users: [{\n *     id: \"string\",\n *     name: \"string\",\n *     email: \"string\",\n *     role: \"'admin' | 'user' | 'guest'\",\n *     permissions: \"string[]\",\n *     active: \"boolean\"\n *   }]\n * });\n *\n * const userData = await JSONFile(\"user-data\", {\n *   path: \"./data/users.json\",\n *   schema: userSchema,\n *   prompt: \"Generate sample user data for an application with various roles and permissions\",\n *   temperature: 0.2\n * });\n *\n * // Type-safe access to the generated data\n * console.log(userData.json.users[0].role); // Typed as 'admin' | 'user' | 'guest'\n *\n * @example\n * // Generate API mock data with custom system prompt\n * const apiMock = await JSONFile(\"api-mock\", {\n *   path: \"./mocks/products-api.json\",\n *   prompt: await alchemy`\n *     Create mock data for a product catalog API response with:\n *     - 10 products with different categories\n *     - Each product should have id, name, price, category, inventory, and image_url\n *     - Include pagination metadata (total, page, limit)\n *   `,\n *   system: \"You are an API design expert. Create realistic mock JSON data that follows REST API best practices. Your response must be valid JSON inside ```json fences.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   },\n *   pretty: true,\n *   indent: 4\n * });\n */\nexport const JSONFile = Resource(\"ai::JSONFile\", async function <\n  const T extends Type<any, any> | undefined = undefined,\n>(this: Context<JSONFile<T extends Type<any, any> ? type.infer<T> : any>>, id: string, props: JSONFileProps<T>): Promise<\n  JSONFile<T extends Type<any, any> ? type.infer<T> : any>\n> {\n  // Handle deletion phase\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  let jsonContent: string;\n  let jsonObject: any;\n\n  // Check if schema is provided\n  if (props.schema) {\n    // Use schema-based generation\n    const { object } = await generateObject({\n      model: createModel(props),\n      schema: ark.schema<type.infer<typeof props.schema>>(props.schema),\n      providerOptions: props.model?.options,\n      system:\n        props.system ||\n        \"Generate a valid JSON object based on the provided requirements.\",\n      prompt: props.prompt,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    jsonObject = object;\n\n    // Use StaticJsonFile to create the file\n    const file = await StaticJsonFile(\"file\", props.path, jsonObject);\n    jsonContent = file.content;\n  } else {\n    // Use fence-based extraction\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_JSON_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate JSON content\n    let { content, error } = await extractJSONContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one valid JSON block inside \\`\\`\\`json fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractJSONContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(`Failed to generate valid JSON: ${retryResult.error}`);\n      }\n\n      content = retryResult.content;\n    }\n\n    // Parse JSON to get the object representation\n    jsonObject = JSON.parse(content);\n\n    // Use StaticJsonFile to create the file\n    const file = await StaticJsonFile(\"file\", props.path, jsonObject);\n    jsonContent = file.content;\n  }\n\n  // Return the resource\n  return this({\n    ...props,\n    schema: props.schema,\n    content: jsonContent,\n    json: jsonObject,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  });\n});\n\n/**\n * Extracts JSON content from between ```json fences\n * Validates that exactly one JSON code block exists\n *\n * @param text The text to extract JSON from\n * @returns The extracted JSON or error message\n */\nasync function extractJSONContent(\n  text: string\n): Promise<{ content: string; error?: string }> {\n  const jsonCodeRegex = /```json\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(jsonCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      content: \"\",\n      error:\n        \"No JSON code block found in the response. Please include your JSON within ```json fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      content: \"\",\n      error:\n        \"Multiple JSON code blocks found in the response. Please provide exactly one JSON block within ```json fences.\",\n    };\n  }\n\n  const content = matches[0][1].trim();\n\n  // Validate JSON can be parsed\n  try {\n    JSON.parse(content);\n    return { content };\n  } catch (e) {\n    return {\n      content: \"\",\n      error: `Invalid JSON: ${(e as Error).message}. Please provide valid JSON syntax.`,\n    };\n  }\n}\n\n```\n\n// alchemy/src/ai/typescript-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticTypeScriptFile } from \"../fs/static-typescript-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createModel, type ModelConfig } from \"./client\";\n\n/**\n * Properties for creating or updating a TypeScriptFile\n */\nexport interface TypeScriptFileProps {\n  /**\n   * Path to the TypeScript file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a TypeScript utility function using:\n   *   ${alchemy.file(\"src/types.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return TypeScript code inside ```ts fences\n   * @default \"You are a TypeScript code generator. Create TypeScript code based on the user's requirements. Your response MUST include only TypeScript code inside ```ts fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * Prettier configuration to use for formatting the TypeScript code\n   * If not provided, will use the default Prettier configuration\n   */\n  prettierConfig?: object;\n}\n\n/**\n * A TypeScript file that can be created, updated, and deleted\n */\nexport interface TypeScriptFile\n  extends TypeScriptFileProps,\n    Resource<\"ai::TypeScriptFile\"> {\n  /**\n   * Content of the TypeScript file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for TypeScript file generation\n */\nconst DEFAULT_TS_SYSTEM_PROMPT =\n  \"You are a TypeScript code generator. Create TypeScript code based on the user's requirements. Your response MUST include only TypeScript code inside ```ts fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating TypeScript files using AI models.\n * Extracts TypeScript code from between ```ts fences, validates the response,\n * and formats the code with Prettier.\n *\n * @example\n * // Create a utility function\n * const utils = await TypeScriptFile(\"string-utils\", {\n *   path: \"./src/utils/string-utils.ts\",\n *   prompt: await alchemy`\n *     Generate TypeScript utility functions for string manipulation:\n *     - Capitalize first letter\n *     - Truncate with ellipsis\n *     - Convert to camelCase and kebab-case\n *     - Remove special characters\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate a TypeScript class with custom formatting\n * const userService = await TypeScriptFile(\"user-service\", {\n *   path: \"./src/services/UserService.ts\",\n *   prompt: await alchemy`\n *     Create a UserService class that handles user authentication and profile management.\n *     The service should use the User type from:\n *     ${alchemy.file(\"src/types/User.ts\")}\n *\n *     Include methods for:\n *     - login(email, password)\n *     - register(user)\n *     - updateProfile(userId, profileData)\n *     - deleteAccount(userId)\n *   `,\n *   temperature: 0.2,\n *   prettierConfig: {\n *     semi: false,\n *     singleQuote: true,\n *     printWidth: 120\n *   }\n * });\n *\n * @example\n * // Generate a React hook with custom system prompt\n * const useFormHook = await TypeScriptFile(\"use-form\", {\n *   path: \"./src/hooks/useForm.ts\",\n *   prompt: await alchemy`\n *     Create a custom React hook called useForm that handles form state, validation, and submission.\n *     It should support:\n *     - Initial values\n *     - Validation rules\n *     - Field errors\n *     - Form submission with loading state\n *     - Reset functionality\n *   `,\n *   system: \"You are an expert React developer specializing in TypeScript hooks. Create a single TypeScript file inside ```ts fences with no additional text. Follow React best practices and include proper typing.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const TypeScriptFile = Resource(\n  \"ai::TypeScriptFile\",\n  async function (\n    this: Context<TypeScriptFile>,\n    id: string,\n    props: TypeScriptFileProps\n  ): Promise<TypeScriptFile> {\n    // Handle delete phase\n    if (this.phase === \"delete\") {\n      // StaticTypeScriptFile will handle the deletion\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_TS_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate TypeScript code\n    let { code, error } = await extractTypeScriptCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one TypeScript code block inside \\`\\`\\`ts fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractTypeScriptCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid TypeScript code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticTypeScriptFile to create/update the file\n    const file = await StaticTypeScriptFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts TypeScript code from between ```ts fences\n * Validates that exactly one TypeScript code block exists\n *\n * @param text The text to extract TypeScript code from\n * @returns The extracted TypeScript code or error message\n */\nasync function extractTypeScriptCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const tsCodeRegex = /```ts\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(tsCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No TypeScript code block found in the response. Please include your code within ```ts fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple TypeScript code blocks found in the response. Please provide exactly one code block within ```ts fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/vue-file.ts\n```ts\nimport { generateText } from \"ai\";\nimport type { Context } from \"../context\";\nimport { StaticVueFile } from \"../fs/static-vue-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a VueFile\n */\nexport interface VueFileProps {\n  /**\n   * Path to the Vue file\n   */\n  path: string;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a Vue component using:\n   *   ${alchemy.file(\"src/api.ts\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * The default system prompt instructs the model to return a single Vue component inside ```vue fences\n   * @default \"You are a Vue component generator. Create a single Vue component based on the user's requirements. Your response MUST include only a single Vue component inside ```vue fences. Do not include any other text, explanations, or multiple code blocks.\"\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A Vue file that can be created, updated, and deleted\n */\nexport interface VueFile extends VueFileProps, Resource<\"ai::VueFile\"> {\n  /**\n   * Content of the Vue file\n   */\n  content: string;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for Vue file generation\n */\nconst DEFAULT_VUE_SYSTEM_PROMPT =\n  \"You are a Vue component generator. Create a single Vue component based on the user's requirements. Your response MUST include only a single Vue component inside ```vue fences. Do not include any other text, explanations, or multiple code blocks.\";\n\n/**\n * Resource for generating Vue files using AI models.\n * Extracts Vue code from between ```vue fences and validates the response.\n *\n * @example\n * // Create a simple Vue component\n * const button = await VueFile(\"button-component\", {\n *   path: \"./src/components/Button.vue\",\n *   prompt: await alchemy`\n *     Generate a customizable button Vue component with:\n *     - Primary, secondary, and outline variants\n *     - Small, medium, and large sizes\n *     - Loading state with spinner\n *     - Disabled state\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate a Vue component using existing files as reference\n * const userCard = await VueFile(\"user-card\", {\n *   path: \"./src/components/UserCard.vue\",\n *   prompt: await alchemy`\n *     Create a UserCard Vue component that displays user information.\n *     Follow the styling patterns from:\n *     ${alchemy.file(\"src/components/Card.vue\")}\n *\n *     Use the user type from:\n *     ${alchemy.file(\"src/types/User.ts\")}\n *   `,\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate a complex form component with validation and custom system prompt\n * const form = await VueFile(\"registration-form\", {\n *   path: \"./src/components/RegistrationForm.vue\",\n *   prompt: await alchemy`\n *     Generate a registration form Vue component with:\n *     - Email, password, and confirm password fields\n *     - Form validation using Vuelidate or similar\n *     - Error messages for each field\n *     - Submit handler that emits form data\n *\n *     Follow these style guidelines:\n *     ${alchemy.file(\"src/styles/guidelines.md\")}\n *   `,\n *   system: \"You are an expert Vue component creator specializing in form components with validation. Create a single Vue component inside ```vue fences with no additional text.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const VueFile = Resource(\n  \"ai::VueFile\",\n  async function (\n    this: Context<VueFile>,\n    id: string,\n    props: VueFileProps\n  ): Promise<VueFile> {\n    // Handle deletion phase\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_VUE_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate Vue code\n    let { code, error } = await extractVueCode(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one Vue component inside \\`\\`\\`vue fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractVueCode(retryText);\n\n      if (retryResult.error) {\n        throw new Error(\n          `Failed to generate valid Vue code: ${retryResult.error}`\n        );\n      }\n\n      code = retryResult.code;\n    }\n\n    // Use StaticVueFile to create/update the file\n    const file = await StaticVueFile(\"file\", props.path, code);\n\n    // Return the resource\n    return this({\n      ...props,\n      content: file.content,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Extracts Vue code from between ```vue fences\n * Validates that exactly one Vue code block exists\n *\n * @param text The text to extract Vue code from\n * @returns The extracted Vue code or error message\n */\nasync function extractVueCode(\n  text: string\n): Promise<{ code: string; error?: string }> {\n  const vueCodeRegex = /```vue\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(vueCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      code: \"\",\n      error:\n        \"No Vue code block found in the response. Please include your code within ```vue fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      code: \"\",\n      error:\n        \"Multiple Vue code blocks found in the response. Please provide exactly one code block within ```vue fences.\",\n    };\n  }\n\n  return { code: matches[0][1].trim() };\n}\n\n```\n\n// alchemy/src/ai/yaml-file.ts\n```ts\nimport { generateObject, generateText } from \"ai\";\nimport type { JsonSchema, Type, type } from \"arktype\";\nimport type { Context } from \"../context\";\nimport { StaticYamlFile } from \"../fs/static-yaml-file\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { ark } from \"./ark\";\nimport { type ModelConfig, createModel } from \"./client\";\n\n/**\n * Properties for creating or updating a YAMLFile\n */\nexport interface YAMLFileProps<\n  T extends Type<any, any> | undefined = undefined,\n> {\n  /**\n   * Path to the YAML file\n   */\n  path: string;\n\n  /**\n   * Optional ArkType schema to validate and structure the generated YAML\n   * When provided, the resource will use generateObject with schema validation\n   * When not provided, it will extract YAML from between ```yaml fences\n   */\n  schema?: T;\n\n  /**\n   * Base URL for the OpenAI API\n   * @default 'https://api.openai.com/v1'\n   */\n  baseURL?: string;\n\n  /**\n   * Prompt for generating content\n   * Use alchemy template literals to include file context:\n   * @example\n   * prompt: await alchemy`\n   *   Generate a YAML configuration for:\n   *   ${alchemy.file(\"src/serverless.js\")}\n   * `\n   */\n  prompt: string;\n\n  /**\n   * System prompt for the model\n   * This is used to provide instructions to the model about how to format the response\n   * @default Depends on whether schema is provided\n   */\n  system?: string;\n\n  /**\n   * OpenAI API key to use for generating content\n   * If not provided, will use OPENAI_API_KEY environment variable\n   */\n  apiKey?: Secret;\n\n  /**\n   * Model configuration\n   */\n  model?: ModelConfig;\n\n  /**\n   * Temperature for controlling randomness in generation.\n   * Higher values (e.g., 0.8) make output more random,\n   * lower values (e.g., 0.2) make it more deterministic.\n   * @default 0.7\n   */\n  temperature?: number;\n}\n\n/**\n * A YAML file that can be created, updated, and deleted\n */\nexport interface YAMLFile<T = any>\n  extends Omit<YAMLFileProps, \"schema\">,\n    Resource<\"ai::YAMLFile\"> {\n  /**\n   * Content of the YAML file as a string\n   */\n  content: string;\n\n  /**\n   * Parsed YAML object\n   */\n  yaml: T;\n\n  /**\n   * Schema used to validate the YAML (if provided)\n   */\n  schema?: JsonSchema;\n\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Default system prompt for YAML file generation without schema\n */\nconst DEFAULT_YAML_SYSTEM_PROMPT =\n  \"You are a YAML generator. Create valid YAML based on the user's requirements. Your response MUST include only YAML inside ```yaml fences. Do not include any other text, explanations, or multiple code blocks. Use standard YAML syntax with proper indentation. Use quotes around strings that contain special characters when necessary.\";\n\n/**\n * Resource for generating YAML files using AI models.\n * Can operate in two modes:\n * 1. With schema: Uses generateObject with type validation, then converts to YAML\n * 2. Without schema: Extracts YAML from between ```yaml fences\n *\n * @example\n * // Generate a serverless configuration file\n * const serverlessConfig = await YAMLFile(\"serverless-config\", {\n *   path: \"./serverless.yml\",\n *   prompt: await alchemy`\n *     Generate a serverless.yml configuration for an AWS Lambda API with:\n *     - A service name \"user-api\"\n *     - Node.js 16.x runtime\n *     - Three functions: createUser, getUser, and listUsers\n *     - API Gateway endpoints for each function\n *     - DynamoDB table for users\n *     - IAM permissions for DynamoDB access\n *   `,\n *   model: {\n *     id: \"gpt-4o\",\n *     provider: \"openai\"\n *   }\n * });\n *\n * @example\n * // Generate YAML with schema validation\n * import { type } from \"arktype\";\n *\n * const k8sConfigSchema = type({\n *   apiVersion: \"string\",\n *   kind: \"string\",\n *   metadata: {\n *     name: \"string\",\n *     namespace: \"string?\",\n *     labels: \"Record<string, string>?\"\n *   },\n *   spec: {\n *     replicas: \"number\",\n *     selector: {\n *       matchLabels: \"Record<string, string>\"\n *     },\n *     template: {\n *       metadata: {\n *         labels: \"Record<string, string>\"\n *       },\n *       spec: {\n *         containers: [{\n *           name: \"string\",\n *           image: \"string\",\n *           ports: [{\n *             containerPort: \"number\"\n *           }]\n *         }]\n *       }\n *     }\n *   }\n * });\n *\n * const deployment = await YAMLFile(\"k8s-deployment\", {\n *   path: \"./kubernetes/deployment.yaml\",\n *   schema: k8sConfigSchema,\n *   prompt: \"Generate a Kubernetes deployment for a web application named 'frontend' with 3 replicas using the nginx:latest image and exposing port 80\",\n *   temperature: 0.2\n * });\n *\n * @example\n * // Generate GitHub Actions workflow with custom system prompt\n * const workflow = await YAMLFile(\"github-workflow\", {\n *   path: \"./.github/workflows/ci.yml\",\n *   prompt: await alchemy`\n *     Create a GitHub Actions workflow for a Node.js project that:\n *     - Runs on push to main and pull requests\n *     - Sets up Node.js 18\n *     - Installs dependencies with npm\n *     - Runs linting and tests\n *     - Builds the project\n *     - Deploys to GitHub Pages on success (main branch only)\n *   `,\n *   system: \"You are a DevOps expert specializing in GitHub Actions workflows. Create a single YAML file inside ```yaml fences with no additional text. Follow GitHub Actions best practices and use proper YAML syntax.\",\n *   model: {\n *     id: \"claude-3-opus-20240229\",\n *     provider: \"anthropic\"\n *   }\n * });\n */\nexport const YAMLFile = Resource(\"ai::YAMLFile\", async function <\n  const T extends Type<any, any> | undefined = undefined,\n>(this: Context<YAMLFile<T extends Type<any, any> ? type.infer<T> : any>>, id: string, props: YAMLFileProps<T>): Promise<\n  YAMLFile<T extends Type<any, any> ? type.infer<T> : any>\n> {\n  // Handle deletion phase\n  if (this.phase === \"delete\") {\n    return this.destroy();\n  }\n\n  let yamlContent: string;\n  let yamlObject: any;\n\n  // Check if schema is provided\n  if (props.schema) {\n    // Use schema-based generation\n    const { object } = await generateObject({\n      model: createModel(props),\n      schema: ark.schema<type.infer<typeof props.schema>>(props.schema),\n      providerOptions: props.model?.options,\n      system:\n        props.system ||\n        \"Generate a valid object based on the provided requirements.\",\n      prompt: props.prompt,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    yamlObject = object;\n\n    // Let StaticYamlFile handle the YAML conversion\n    const file = await StaticYamlFile(\"file\", props.path, yamlObject);\n    yamlContent = file.content;\n  } else {\n    // Use fence-based extraction\n    // Use provided system prompt or default\n    const system = props.system || DEFAULT_YAML_SYSTEM_PROMPT;\n\n    // Generate initial content\n    const { text } = await generateText({\n      model: createModel(props),\n      prompt: props.prompt,\n      system,\n      providerOptions: props.model?.options,\n      ...(props.temperature === undefined\n        ? {}\n        : { temperature: props.temperature }),\n    });\n\n    // Extract and validate YAML content\n    let { content, error } = await extractYAMLContent(text);\n\n    // Re-prompt if there are validation errors\n    if (error) {\n      const errorSystem = `${system}\\n\\nERROR: ${error}\\n\\nPlease try again and ensure your response contains exactly one YAML block inside \\`\\`\\`yaml fences.`;\n\n      const { text: retryText } = await generateText({\n        model: createModel(props),\n        prompt: props.prompt,\n        system: errorSystem,\n        providerOptions: props.model?.options,\n        ...(props.temperature === undefined\n          ? {}\n          : { temperature: props.temperature }),\n      });\n\n      const retryResult = await extractYAMLContent(retryText);\n\n      if (retryResult.error) {\n        throw new Error(`Failed to generate valid YAML: ${retryResult.error}`);\n      }\n\n      content = retryResult.content;\n    }\n\n    yamlContent = content;\n\n    // Create the file with the string content\n    const file = await StaticYamlFile(\"file\", props.path, yamlContent);\n\n    // We need to parse the YAML to get the object representation\n    const yaml = await import(\"yaml\");\n    yamlObject = yaml.parse(yamlContent);\n  }\n\n  // Return the resource\n  return this({\n    ...props,\n    schema: props.schema,\n    content: yamlContent,\n    yaml: yamlObject,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  });\n});\n\n/**\n * Extracts YAML content from between ```yaml fences\n * Validates that exactly one YAML code block exists\n *\n * @param text The text to extract YAML from\n * @returns The extracted YAML or error message\n */\nasync function extractYAMLContent(\n  text: string\n): Promise<{ content: string; error?: string }> {\n  // Check for yaml or yml fence blocks\n  const yamlCodeRegex = /```(yaml|yml)\\s*([\\s\\S]*?)```/g;\n  const matches = Array.from(text.matchAll(yamlCodeRegex));\n\n  if (matches.length === 0) {\n    return {\n      content: \"\",\n      error:\n        \"No YAML code block found in the response. Please include your YAML within ```yaml fences.\",\n    };\n  }\n\n  if (matches.length > 1) {\n    return {\n      content: \"\",\n      error:\n        \"Multiple YAML code blocks found in the response. Please provide exactly one YAML block within ```yaml fences.\",\n    };\n  }\n\n  const content = matches[0][2].trim();\n\n  // We don't validate YAML parsing here because js-yaml might not be available\n  // Validation will happen at usage time if needed\n  return { content };\n}\n\n```"
  }
}