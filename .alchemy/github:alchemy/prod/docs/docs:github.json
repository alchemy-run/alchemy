{
  "kind": "ai::Object",
  "id": "docs/github",
  "fqn": "github:alchemy/prod/docs/docs/github",
  "seq": 24,
  "data": {},
  "status": "updated",
  "output": {
    "type": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "object": {
      "groups": [
        {
          "category": "Resource",
          "filename": "secret.ts",
          "identifier": "GitHubSecret"
        },
        {
          "category": "Client",
          "filename": "client.ts",
          "identifier": "createGitHubClient"
        }
      ]
    },
    "messages": [
      {
        "role": "user",
        "content": "Identify and classify the documents that need to be written for the '      alchemy/src/github' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/github Service has the following resources:\n[secret.ts](alchemy/src/github/secret.ts)\n\n[client.ts](alchemy/src/github/client.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...).\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/github/client.ts\n```ts\nimport { Octokit } from \"@octokit/rest\";\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\n// Convert exec to promise-based\nconst execAsync = promisify(exec);\n\n/**\n * Try to get a GitHub token from the GitHub CLI\n */\nexport async function getGitHubTokenFromCLI(): Promise<string | null> {\n  try {\n    // Check if GitHub CLI is installed\n    const { stdout: ghVersion } = await execAsync(\"gh --version\");\n    if (!ghVersion) return null;\n\n    // Get the auth token\n    const { stdout: token } = await execAsync(\"gh auth token\");\n    return token?.trim() || null;\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Get GitHub authentication token with the following priority:\n * 1. Explicit token provided in props\n * 2. GITHUB_ACCESS_TOKEN environment variable (for actions with admin permissions)\n * 3. GITHUB_TOKEN environment variable\n * 4. GitHub CLI token (if gh is installed and authenticated)\n *\n * @param token Optional token to use\n * @returns The resolved token or null if not available\n */\nexport async function getGitHubToken(token?: string): Promise<string | null> {\n  return (\n    token ||\n    process.env.GITHUB_ACCESS_TOKEN ||\n    process.env.GITHUB_TOKEN ||\n    (await getGitHubTokenFromCLI())\n  );\n}\n\n/**\n * Create an authenticated Octokit client\n *\n * @param options Options for creating the client\n * @returns An authenticated Octokit client\n */\nexport async function createGitHubClient(\n  options: { token?: string } = {},\n): Promise<Octokit> {\n  const token = await getGitHubToken(options.token);\n\n  return new Octokit({\n    auth: token,\n  });\n}\n\n/**\n * Verifies GitHub authentication and provides helpful error messages\n *\n * @param octokit Octokit client\n * @param owner Repository owner\n * @param repo Repository name\n */\nexport async function verifyGitHubAuth(\n  octokit: Octokit,\n  owner: string,\n  repo: string,\n): Promise<void> {\n  try {\n    // Make a test request to check authentication\n    await octokit.rest.repos.get({\n      owner,\n      repo,\n    });\n  } catch (error: any) {\n    if (error.status === 401) {\n      console.error(\n        \"\\n⚠️ GitHub authentication failed. Please try one of the following:\",\n      );\n      console.error(\n        \"1. Run 'gh auth login' to authenticate with the GitHub CLI\",\n      );\n      console.error(\n        \"2. Set the GITHUB_TOKEN environment variable with a personal access token\",\n      );\n      console.error(\"3. Pass a token directly to the constructor\");\n      console.error(\n        \"\\nTo create a token, visit: https://github.com/settings/tokens\",\n      );\n      console.error(\n        \"Required scopes: 'repo' for private repos or 'public_repo' for public repos\\n\",\n      );\n      throw new Error(\"GitHub authentication failed\");\n    } else if (error.status === 403) {\n      console.error(\n        \"\\n⚠️ Insufficient permissions. You need admin access to the repository.\",\n      );\n      console.error(\n        \"Make sure your token has the 'repo' scope for private repos or 'public_repo' for public repos\\n\",\n      );\n      throw new Error(\"Insufficient GitHub permissions\");\n    } else if (error.status === 404) {\n      console.error(`\\n⚠️ Repository not found: ${owner}/${repo}`);\n      console.error(\n        \"Make sure the repository exists and you have access to it\\n\",\n      );\n      throw new Error(\"GitHub repository not found\");\n    } else {\n      throw error;\n    }\n  }\n}\n\n```\n\n// alchemy/src/github/secret.ts\n```ts\nimport sodium from \"libsodium-wrappers\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createGitHubClient, verifyGitHubAuth } from \"./client\";\n/**\n * Properties for creating or updating a GitHub Secret\n */\nexport interface GitHubSecretProps {\n  /**\n   * Repository owner (user or organization)\n   */\n  owner: string;\n\n  /**\n   * Repository name\n   */\n  repository: string;\n\n  /**\n   * Secret name\n   */\n  name: string;\n\n  /**\n   * Secret value (will be stored securely on GitHub)\n   */\n  value: Secret;\n\n  /**\n   * Optional GitHub API token (overrides environment variable)\n   * If not provided, will use GITHUB_TOKEN environment variable\n   * Token must have 'repo' scope for private repositories\n   * or 'public_repo' scope for public repositories\n   */\n  token?: Secret;\n}\n\n/**\n * Output returned after Secret creation/update\n */\nexport interface GitHubSecretOutput\n  extends Resource<\"github::Secret\">,\n    Omit<GitHubSecretProps, \"value\"> {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created/updated\n   */\n  updatedAt: string;\n}\n\n/**\n * Resource for managing GitHub repository secrets\n *\n * Authentication is handled in the following order:\n * 1. `token` parameter in the resource props (if provided)\n * 2. `GITHUB_TOKEN` environment variable\n *\n * The token must have the following permissions:\n * - 'repo' scope for private repositories\n * - 'public_repo' scope for public repositories\n *\n * @example\n * // Create a secret using GITHUB_TOKEN environment variable:\n * const secret = await GitHubSecret(\"my-secret\", {\n *   owner: \"my-github-username\",\n *   repository: \"my-repo\",\n *   name: \"API_KEY\",\n *   value: alchemy.secret(\"my-secret-value\")\n * });\n *\n * @example\n * // Create a secret with a custom GitHub token:\n * const secret = await GitHubSecret(\"my-secret\", {\n *   owner: \"my-github-username\",\n *   repository: \"my-repo\",\n *   name: \"API_KEY\",\n *   value: alchemy.secret(\"my-secret-value\"),\n *   token: alchemy.secret(process.env.CUSTOM_GITHUB_TOKEN)\n * });\n *\n * @example\n * // Create multiple secrets with environment variables:\n * const secrets = await Promise.all([\n *   GitHubSecret(\"aws-secret\", {\n *     owner: \"my-github-username\",\n *     repository: \"cloud-app\",\n *     name: \"AWS_ROLE_ARN\",\n *     value: alchemy.secret(process.env.AWS_ROLE_ARN)\n *   }),\n *   GitHubSecret(\"cf-secret\", {\n *     owner: \"my-github-username\",\n *     repository: \"cloud-app\",\n *     name: \"CLOUDFLARE_API_KEY\",\n *     value: alchemy.secret(process.env.CLOUDFLARE_API_KEY)\n *   })\n * ]);\n *\n * @example\n * // Create a secret in a secure scope with a password:\n * await alchemy.run(\"secure-scope\", {\n *   password: process.env.SECRET_PASSPHRASE\n * }, async () => {\n *   const secret = await GitHubSecret(\"deploy-secret\", {\n *     owner: \"my-github-username\",\n *     repository: \"my-app\",\n *     name: \"DEPLOY_TOKEN\",\n *     value: alchemy.secret(process.env.DEPLOY_TOKEN),\n *     token: alchemy.secret(process.env.GITHUB_TOKEN)\n *   });\n * });\n */\nexport const GitHubSecret = Resource(\n  \"github::Secret\",\n  async function (\n    this: Context<GitHubSecretOutput>,\n    id: string,\n    props: GitHubSecretProps,\n  ): Promise<GitHubSecretOutput> {\n    // Create authenticated Octokit client - will automatically handle token resolution\n    /// TODO: use fetch\n    const octokit = await createGitHubClient({\n      token: props.token?.unencrypted,\n    });\n\n    // Verify authentication and permissions\n    if (!this.quiet) {\n      await verifyGitHubAuth(octokit, props.owner, props.repository);\n    }\n\n    if (this.phase === \"delete\") {\n      if (this.output?.id) {\n        try {\n          // Delete the secret\n          await octokit.rest.actions.deleteRepoSecret({\n            owner: props.owner,\n            repo: props.repository,\n            secret_name: props.name,\n          });\n        } catch (error: any) {\n          // Ignore 404 errors (secret already deleted)\n          if (error.status === 404) {\n            console.log(\"Secret doesn't exist, ignoring\");\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      // Return void (a deleted resource has no content)\n      return this.destroy();\n    } else {\n      try {\n        // Get the repository's public key for encrypting secrets\n        const { data: publicKey } = await octokit.rest.actions.getRepoPublicKey(\n          {\n            owner: props.owner,\n            repo: props.repository,\n          },\n        );\n\n        // Encrypt the secret value using libsodium\n        const encryptedValue = await encryptString(\n          props.value.unencrypted,\n          publicKey.key,\n        );\n\n        // Create or update the secret with the encrypted value and key_id\n        await octokit.rest.actions.createOrUpdateRepoSecret({\n          owner: props.owner,\n          repo: props.repository,\n          secret_name: props.name,\n          encrypted_value: encryptedValue,\n          key_id: publicKey.key_id,\n        });\n\n        // GitHub doesn't return the secret details on create/update, so we need to construct it\n        return this({\n          id: `${props.owner}/${props.repository}/${props.name}`,\n          owner: props.owner,\n          repository: props.repository,\n          name: props.name,\n          token: props.token,\n          updatedAt: new Date().toISOString(),\n        });\n      } catch (error: any) {\n        if (\n          error.status === 403 &&\n          error.message?.includes(\"Must have admin rights\")\n        ) {\n          console.error(\n            \"\\n⚠️ Error creating/updating GitHub secret: You must have admin rights to the repository.\",\n          );\n          console.error(\n            \"Make sure your GitHub token has the required permissions (repo scope for private repos).\\n\",\n          );\n        } else {\n          console.error(\n            \"Error creating/updating GitHub secret:\",\n            error.message,\n          );\n        }\n        throw error;\n      }\n    }\n  },\n);\n\n/**\n * Encrypt a value for GitHub using libsodium\n * Based on GitHub's documentation for encrypting secrets\n *\n * @param value - The secret value to encrypt\n * @param publicKey - The base64-encoded public key from GitHub\n * @returns The base64-encoded encrypted value\n */\nasync function encryptString(\n  value: string,\n  publicKey: string,\n): Promise<string> {\n  // Initialize libsodium\n  await sodium.ready;\n\n  // Convert the public key from base64 to binary\n  const binKey = sodium.from_base64(publicKey, sodium.base64_variants.ORIGINAL);\n\n  // Convert the message to a Uint8Array\n  const binMessage = sodium.from_string(value);\n\n  // Encrypt the message with the public key using libsodium's sealed box\n  const encryptedBin = sodium.crypto_box_seal(binMessage, binKey);\n\n  // Convert the encrypted message to base64\n  return sodium.to_base64(encryptedBin, sodium.base64_variants.ORIGINAL);\n}\n\n```"
      },
      {
        "role": "assistant",
        "content": "{\"groups\":[{\"category\":\"Resource\",\"filename\":\"secret.ts\",\"identifier\":\"GitHubSecret\"},{\"category\":\"Client\",\"filename\":\"client.ts\",\"identifier\":\"createGitHubClient\"}]}"
      }
    ],
    "createdAt": 1744513106213,
    "Kind": "ai::Object",
    "ID": "docs/github",
    "FQN": "github:alchemy/prod/docs/docs/github",
    "Seq": 24
  },
  "props": {
    "model": {
      "id": "o3-mini",
      "provider": "openai",
      "options": {
        "reasoningEffort": "high"
      }
    },
    "freeze": true,
    "temperature": 0.1,
    "schema": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "system": "You are a technical writer tasked with identifying the distinct documents that need to be written for a document group (folder) in a documentation site.\nYou will be provided with a list of documents and instructions on how to classify them.\nEach document has a title, file name, and category.\n    \n",
    "prompt": "Identify and classify the documents that need to be written for the '      alchemy/src/github' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/github Service has the following resources:\n[secret.ts](alchemy/src/github/secret.ts)\n\n[client.ts](alchemy/src/github/client.ts)\n\n[repository-environment.ts](alchemy/src/github/repository-environment.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...), or it is the Workflow or DurableObject classes.\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/github/client.ts\n```ts\nimport { Octokit } from \"@octokit/rest\";\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\n// Convert exec to promise-based\nconst execAsync = promisify(exec);\n\n/**\n * Try to get a GitHub token from the GitHub CLI\n */\nexport async function getGitHubTokenFromCLI(): Promise<string | null> {\n  try {\n    // Check if GitHub CLI is installed\n    const { stdout: ghVersion } = await execAsync(\"gh --version\");\n    if (!ghVersion) return null;\n\n    // Get the auth token\n    const { stdout: token } = await execAsync(\"gh auth token\");\n    return token?.trim() || null;\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Get GitHub authentication token with the following priority:\n * 1. Explicit token provided in props\n * 2. GITHUB_ACCESS_TOKEN environment variable (for actions with admin permissions)\n * 3. GITHUB_TOKEN environment variable\n * 4. GitHub CLI token (if gh is installed and authenticated)\n *\n * @param token Optional token to use\n * @returns The resolved token or null if not available\n */\nexport async function getGitHubToken(token?: string): Promise<string | null> {\n  return (\n    token ||\n    process.env.GITHUB_ACCESS_TOKEN ||\n    process.env.GITHUB_TOKEN ||\n    (await getGitHubTokenFromCLI())\n  );\n}\n\n/**\n * Create an authenticated Octokit client\n *\n * @param options Options for creating the client\n * @returns An authenticated Octokit client\n */\nexport async function createGitHubClient(\n  options: { token?: string } = {},\n): Promise<Octokit> {\n  const token = await getGitHubToken(options.token);\n\n  return new Octokit({\n    auth: token,\n  });\n}\n\n/**\n * Verifies GitHub authentication and provides helpful error messages\n *\n * @param octokit Octokit client\n * @param owner Repository owner\n * @param repo Repository name\n */\nexport async function verifyGitHubAuth(\n  octokit: Octokit,\n  owner: string,\n  repo: string,\n): Promise<void> {\n  try {\n    // Make a test request to check authentication\n    await octokit.rest.repos.get({\n      owner,\n      repo,\n    });\n  } catch (error: any) {\n    if (error.status === 401) {\n      console.error(\n        \"\\n⚠️ GitHub authentication failed. Please try one of the following:\",\n      );\n      console.error(\n        \"1. Run 'gh auth login' to authenticate with the GitHub CLI\",\n      );\n      console.error(\n        \"2. Set the GITHUB_TOKEN environment variable with a personal access token\",\n      );\n      console.error(\"3. Pass a token directly to the constructor\");\n      console.error(\n        \"\\nTo create a token, visit: https://github.com/settings/tokens\",\n      );\n      console.error(\n        \"Required scopes: 'repo' for private repos or 'public_repo' for public repos\\n\",\n      );\n      throw new Error(\"GitHub authentication failed\");\n    } else if (error.status === 403) {\n      console.error(\n        \"\\n⚠️ Insufficient permissions. You need admin access to the repository.\",\n      );\n      console.error(\n        \"Make sure your token has the 'repo' scope for private repos or 'public_repo' for public repos\\n\",\n      );\n      throw new Error(\"Insufficient GitHub permissions\");\n    } else if (error.status === 404) {\n      console.error(`\\n⚠️ Repository not found: ${owner}/${repo}`);\n      console.error(\n        \"Make sure the repository exists and you have access to it\\n\",\n      );\n      throw new Error(\"GitHub repository not found\");\n    } else {\n      throw error;\n    }\n  }\n}\n\n```\n\n// alchemy/src/github/repository-environment.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { createGitHubClient, verifyGitHubAuth } from \"./client\";\n\n/**\n * Properties for creating or updating a GitHub Repository Environment\n */\nexport interface RepositoryEnvironmentProps {\n  /**\n   * Repository owner (user or organization)\n   */\n  owner: string;\n\n  /**\n   * Repository name\n   */\n  repository: string;\n\n  /**\n   * Environment name\n   */\n  name: string;\n\n  /**\n   * Wait timer before allowing deployments to proceed (in minutes)\n   * Must be between 0 and 43200 (30 days)\n   * @default 0\n   */\n  waitTimer?: number;\n\n  /**\n   * Determine whether to prevent self-reviews on pull requests\n   * Note: Requires at least one reviewer when enabled\n   * @default false\n   */\n  preventSelfReview?: boolean;\n\n  /**\n   * Determine whether administrators can bypass deployment protection rules\n   * @default true\n   */\n  adminBypass?: boolean;\n\n  /**\n   * Required reviewers for deployments to this environment\n   */\n  reviewers?: {\n    /**\n     * GitHub usernames or user IDs that can approve deployments\n     * Can be numeric IDs or string usernames (which will be resolved to IDs)\n     */\n    users?: Array<number | string>;\n\n    /**\n     * GitHub team names or team IDs that can approve deployments\n     * Can be numeric IDs or string team names (which will be resolved to IDs)\n     * Note: For team names, should be in the format \"org/team-name\"\n     */\n    teams?: Array<number | string>;\n  };\n\n  /**\n   * Deployment branch policy for the environment\n   */\n  deploymentBranchPolicy?: {\n    /**\n     * Whether to restrict deployments to protected branches\n     * @default false\n     */\n    protectedBranches?: boolean;\n\n    /**\n     * Whether to allow custom branch policies\n     * When true, specific branch patterns can be specified using createDeploymentBranchPolicy\n     * @default false\n     */\n    customBranchPolicies?: boolean;\n  };\n\n  /**\n   * Branch patterns for deployment when customBranchPolicies is true\n   * For example: [\"main\", \"releases/*\"]\n   * @default []\n   */\n  branchPatterns?: string[];\n\n  /**\n   * Optional GitHub API token (overrides environment variable)\n   * If not provided, will use GITHUB_TOKEN environment variable\n   * @default process.env.GITHUB_TOKEN\n   */\n  token?: string;\n}\n\n/**\n * Output returned after Repository Environment creation/update\n */\nexport interface RepositoryEnvironment\n  extends Resource<\"github::RepositoryEnvironment\">,\n    RepositoryEnvironmentProps {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * The numeric ID of the environment in GitHub\n   */\n  environmentId: number;\n\n  /**\n   * Time at which the object was created/updated\n   */\n  updatedAt: string;\n}\n\n/**\n * Resource for managing GitHub repository environments\n *\n * Note: If preventSelfReview is true, at least one reviewer must be specified.\n *\n * Branch policies are efficiently managed with proper diffing:\n * - Only manages branch patterns configured through this resource\n * - Preserves any manually added branch patterns outside this resource\n * - When updating, only modifies patterns that have changed from previous state\n * - Compares against previous resource state, not current environment state\n * - Safely handles policy type changes\n *\n * @example\n * // Create a basic environment with no protection rules\n * const devEnv = await RepositoryEnvironment(\"dev-environment\", {\n *   owner: \"my-org\",\n *   repository: \"my-repo\",\n *   name: \"development\"\n * });\n *\n * @example\n * // Create a production environment with approval requirements\n * const prodEnv = await RepositoryEnvironment(\"prod-environment\", {\n *   owner: \"my-org\",\n *   repository: \"my-repo\",\n *   name: \"production\",\n *   waitTimer: 10, // 10 minute delay\n *   preventSelfReview: true,\n *   reviewers: {\n *     teams: [\"platform-team\"], // team name\n *     users: [\"security-admin\"] // username\n *   },\n *   deploymentBranchPolicy: {\n *     protectedBranches: true,\n *     customBranchPolicies: false\n *   }\n * });\n *\n * @example\n * // Create an environment with reviewer IDs\n * const stagingEnv = await RepositoryEnvironment(\"staging-environment\", {\n *   owner: \"my-org\",\n *   repository: \"my-repo\",\n *   name: \"staging\",\n *   reviewers: {\n *     teams: [1234567], // team ID\n *     users: [7654321]  // user ID\n *   },\n *   deploymentBranchPolicy: {\n *     protectedBranches: false,\n *     customBranchPolicies: true\n *   },\n *   branchPatterns: [\"main\", \"release/*\"]\n * });\n */\nexport const RepositoryEnvironment = Resource(\n  \"github::RepositoryEnvironment\",\n  async function (\n    this: Context<RepositoryEnvironment>,\n    id: string,\n    props: RepositoryEnvironmentProps\n  ): Promise<RepositoryEnvironment> {\n    // Create authenticated Octokit client\n    const octokit = await createGitHubClient({\n      token: props.token,\n    });\n\n    // Verify authentication and permissions\n    if (!this.quiet) {\n      await verifyGitHubAuth(octokit, props.owner, props.repository);\n    }\n\n    if (this.phase === \"delete\") {\n      if (this.output?.id) {\n        try {\n          // Delete the environment\n          await octokit.rest.repos.deleteAnEnvironment({\n            owner: props.owner,\n            repo: props.repository,\n            environment_name: props.name,\n          });\n        } catch (error: any) {\n          // Ignore 404 errors (environment already deleted)\n          if (error.status === 404) {\n            console.log(\"Environment doesn't exist, ignoring\");\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      // Return void (a deleted resource has no content)\n      return this.destroy();\n    } else {\n      try {\n        // Check if the environment already exists\n        let environmentId: number | undefined = undefined; // Use undefined instead of 0\n        try {\n          const { data: environments } =\n            await octokit.rest.repos.getAllEnvironments({\n              owner: props.owner,\n              repo: props.repository,\n            });\n\n          const existingEnv = environments.environments?.find(\n            (env) => env.name.toLowerCase() === props.name.toLowerCase()\n          );\n\n          if (existingEnv?.id) {\n            environmentId = existingEnv.id;\n          }\n        } catch (error: any) {\n          // If it's a 404, the environment doesn't exist, which is fine\n          if (error.status !== 404) {\n            throw error;\n          }\n        }\n\n        // Convert reviewers to API format\n        const reviewers: { type: \"User\" | \"Team\"; id: number }[] = [];\n\n        // Process user reviewers\n        if (props.reviewers?.users && props.reviewers.users.length > 0) {\n          for (const user of props.reviewers.users) {\n            if (typeof user === \"number\") {\n              // If a numeric ID is provided, use it directly\n              reviewers.push({\n                type: \"User\" as const,\n                id: user,\n              });\n            } else {\n              // If a username string is provided, look up the ID\n              const { data: userData } = await octokit.rest.users.getByUsername(\n                {\n                  username: user,\n                }\n              );\n\n              reviewers.push({\n                type: \"User\" as const,\n                id: userData.id,\n              });\n            }\n          }\n        }\n\n        // Process team reviewers\n        if (props.reviewers?.teams && props.reviewers.teams.length > 0) {\n          for (const team of props.reviewers.teams) {\n            if (typeof team === \"number\") {\n              // If a numeric ID is provided, use it directly\n              reviewers.push({\n                type: \"Team\" as const,\n                id: team,\n              });\n            } else {\n              // If a team name string is provided, look up the ID\n              // Check if team name is in the format 'org/team-name'\n              const teamParts = team.includes(\"/\")\n                ? team.split(\"/\")\n                : [props.owner, team];\n\n              if (teamParts.length !== 2) {\n                throw new Error(\n                  `Invalid team format: ${team}. Expected format: \"org/team-slug\" or just \"team-slug\"`\n                );\n              }\n\n              const [org, teamSlug] = teamParts;\n\n              const { data: teamData } = await octokit.rest.teams.getByName({\n                org,\n                team_slug: teamSlug,\n              });\n\n              reviewers.push({\n                type: \"Team\" as const,\n                id: teamData.id,\n              });\n            }\n          }\n        }\n\n        // Create or update the environment\n        if (environmentId === undefined) {\n          // Create the environment\n          const { data: createdEnv } =\n            await octokit.rest.repos.createOrUpdateEnvironment({\n              owner: props.owner,\n              repo: props.repository,\n              environment_name: props.name,\n              wait_timer: props.waitTimer,\n              prevent_self_review: props.preventSelfReview,\n              reviewers: reviewers.length > 0 ? reviewers : undefined,\n              deployment_branch_policy: props.deploymentBranchPolicy\n                ? {\n                    protected_branches:\n                      props.deploymentBranchPolicy.protectedBranches ?? false,\n                    custom_branch_policies:\n                      props.deploymentBranchPolicy.customBranchPolicies ??\n                      false,\n                  }\n                : undefined,\n            });\n\n          environmentId = createdEnv.id;\n\n          // If there are specific branch patterns, set them\n          if (\n            props.deploymentBranchPolicy?.customBranchPolicies === true &&\n            props.branchPatterns &&\n            props.branchPatterns.length > 0\n          ) {\n            // Add branch patterns one by one\n            for (const pattern of props.branchPatterns) {\n              await octokit.rest.repos.createDeploymentBranchPolicy({\n                owner: props.owner,\n                repo: props.repository,\n                environment_name: props.name,\n                name: pattern,\n              });\n            }\n          }\n        } else {\n          // Update the environment\n          await octokit.rest.repos.createOrUpdateEnvironment({\n            owner: props.owner,\n            repo: props.repository,\n            environment_name: props.name,\n            wait_timer: props.waitTimer,\n            prevent_self_review: props.preventSelfReview,\n            reviewers: reviewers.length > 0 ? reviewers : undefined,\n            deployment_branch_policy: props.deploymentBranchPolicy\n              ? {\n                  protected_branches:\n                    props.deploymentBranchPolicy.protectedBranches ?? false,\n                  custom_branch_policies:\n                    props.deploymentBranchPolicy.customBranchPolicies ?? false,\n                }\n              : undefined,\n          });\n\n          // If there are specific branch patterns, update them\n          if (props.deploymentBranchPolicy?.customBranchPolicies === true) {\n            // Get existing branch policies to understand what's currently configured\n            const { data: existingPolicies } =\n              await octokit.rest.repos.listDeploymentBranchPolicies({\n                owner: props.owner,\n                repo: props.repository,\n                environment_name: props.name,\n              });\n\n            const existingPatterns = existingPolicies.branch_policies.map(\n              (policy) => policy.name!\n            );\n\n            const newPatterns: string[] = props.branchPatterns || [];\n\n            // For updates, keep track of which branch policies we should manage\n            // This set identifies patterns that were previously managed by this resource\n            // If we don't have previous props, use an empty set\n            const previouslyManagedPatterns: Set<string> = new Set(\n              this.phase === \"update\" &&\n              this.props?.deploymentBranchPolicy?.customBranchPolicies === true\n                ? this.props.branchPatterns || []\n                : []\n            );\n\n            // Patterns to add (in new config but not in existing)\n            const patternsToAdd = newPatterns.filter(\n              (pattern) => !existingPatterns.includes(pattern)\n            );\n\n            // Patterns to delete (were managed by us previously but not in new config)\n            const patternsToDelete = existingPatterns.filter(\n              (pattern) =>\n                previouslyManagedPatterns.has(pattern) &&\n                !newPatterns.includes(pattern)\n            );\n\n            // Delete policies that are no longer needed\n            for (const patternToDelete of patternsToDelete) {\n              const policy = existingPolicies.branch_policies.find(\n                (p) => p.name === patternToDelete\n              );\n\n              if (policy?.id) {\n                await octokit.rest.repos.deleteDeploymentBranchPolicy({\n                  owner: props.owner,\n                  repo: props.repository,\n                  environment_name: props.name,\n                  branch_policy_id: policy.id,\n                });\n              }\n            }\n\n            // Add new branch patterns\n            for (const pattern of patternsToAdd) {\n              await octokit.rest.repos.createDeploymentBranchPolicy({\n                owner: props.owner,\n                repo: props.repository,\n                environment_name: props.name,\n                name: pattern,\n              });\n            }\n          }\n        }\n\n        // Get the updated environment details\n        const { data: env } = await octokit.rest.repos.getEnvironment({\n          owner: props.owner,\n          repo: props.repository,\n          environment_name: props.name,\n        });\n\n        // Return environment details\n        return this({\n          id: `${props.owner}/${props.repository}/${props.name}`,\n          environmentId: environmentId || env.id,\n          owner: props.owner,\n          repository: props.repository,\n          name: props.name,\n          waitTimer: props.waitTimer,\n          preventSelfReview: props.preventSelfReview,\n          adminBypass: props.adminBypass,\n          reviewers: props.reviewers,\n          deploymentBranchPolicy: props.deploymentBranchPolicy,\n          branchPatterns: props.branchPatterns,\n          token: props.token,\n          updatedAt: new Date().toISOString(),\n        });\n      } catch (error: any) {\n        if (\n          error.status === 403 &&\n          error.message?.includes(\"Must have admin rights\")\n        ) {\n          console.error(\n            \"\\n⚠️ Error creating/updating GitHub environment: You must have admin rights to the repository.\"\n          );\n          console.error(\n            \"Make sure your GitHub token has the required permissions (repo scope for private repos).\\n\"\n          );\n        } else {\n          console.error(\n            \"Error creating/updating GitHub environment:\",\n            error.message\n          );\n        }\n        throw error;\n      }\n    }\n  }\n);\n\n```\n\n// alchemy/src/github/secret.ts\n```ts\nimport sodium from \"libsodium-wrappers\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { createGitHubClient, verifyGitHubAuth } from \"./client\";\n/**\n * Properties for creating or updating a GitHub Secret\n */\nexport interface GitHubSecretProps {\n  /**\n   * Repository owner (user or organization)\n   */\n  owner: string;\n\n  /**\n   * Repository name\n   */\n  repository: string;\n\n  /**\n   * Secret name\n   */\n  name: string;\n\n  /**\n   * Secret value (will be stored securely on GitHub)\n   */\n  value: Secret;\n\n  /**\n   * Optional environment name to create an environment secret\n   * If set, the secret will be created in the specified environment instead of at the repository level\n   */\n  environment?: string;\n\n  /**\n   * Optional GitHub API token (overrides environment variable)\n   * If not provided, will use GITHUB_TOKEN environment variable\n   * Token must have 'repo' scope for private repositories\n   * or 'public_repo' scope for public repositories\n   */\n  token?: Secret;\n}\n\n/**\n * Output returned after Secret creation/update\n */\nexport interface GitHubSecretOutput\n  extends Resource<\"github::Secret\">,\n    Omit<GitHubSecretProps, \"value\"> {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created/updated\n   */\n  updatedAt: string;\n}\n\n/**\n * Resource for managing GitHub repository and environment secrets\n *\n * Authentication is handled in the following order:\n * 1. `token` parameter in the resource props (if provided)\n * 2. `GITHUB_TOKEN` environment variable\n *\n * The token must have the following permissions:\n * - 'repo' scope for private repositories\n * - 'public_repo' scope for public repositories\n *\n * @example\n * // Create a repository secret using GITHUB_TOKEN environment variable:\n * const secret = await GitHubSecret(\"my-secret\", {\n *   owner: \"my-github-username\",\n *   repository: \"my-repo\",\n *   name: \"API_KEY\",\n *   value: alchemy.secret(\"my-secret-value\")\n * });\n *\n * @example\n * // Create an environment secret:\n * const secret = await GitHubSecret(\"my-env-secret\", {\n *   owner: \"my-github-username\",\n *   repository: \"my-repo\",\n *   environmentName: \"production\",\n *   name: \"DEPLOY_KEY\",\n *   value: alchemy.secret(\"my-secret-deploy-key\")\n * });\n *\n * @example\n * // Create a secret with a custom GitHub token:\n * const secret = await GitHubSecret(\"my-secret\", {\n *   owner: \"my-github-username\",\n *   repository: \"my-repo\",\n *   name: \"API_KEY\",\n *   value: alchemy.secret(\"my-secret-value\"),\n *   token: alchemy.secret(process.env.CUSTOM_GITHUB_TOKEN)\n * });\n *\n * @example\n * // Create multiple secrets with environment variables:\n * const secrets = await Promise.all([\n *   GitHubSecret(\"aws-secret\", {\n *     owner: \"my-github-username\",\n *     repository: \"cloud-app\",\n *     name: \"AWS_ROLE_ARN\",\n *     value: alchemy.secret(process.env.AWS_ROLE_ARN)\n *   }),\n *   GitHubSecret(\"cf-secret\", {\n *     owner: \"my-github-username\",\n *     repository: \"cloud-app\",\n *     name: \"CLOUDFLARE_API_KEY\",\n *     value: alchemy.secret(process.env.CLOUDFLARE_API_KEY)\n *   })\n * ]);\n *\n * @example\n * // Create a secret in a secure scope with a password:\n * await alchemy.run(\"secure-scope\", {\n *   password: process.env.SECRET_PASSPHRASE\n * }, async () => {\n *   const secret = await GitHubSecret(\"deploy-secret\", {\n *     owner: \"my-github-username\",\n *     repository: \"my-app\",\n *     name: \"DEPLOY_TOKEN\",\n *     value: alchemy.secret(process.env.DEPLOY_TOKEN),\n *     token: alchemy.secret(process.env.GITHUB_TOKEN)\n *   });\n * });\n */\nexport const GitHubSecret = Resource(\n  \"github::Secret\",\n  async function (\n    this: Context<GitHubSecretOutput>,\n    id: string,\n    props: GitHubSecretProps\n  ): Promise<GitHubSecretOutput> {\n    // Create authenticated Octokit client - will automatically handle token resolution\n    /// TODO: use fetch\n    const octokit = await createGitHubClient({\n      token: props.token?.unencrypted,\n    });\n\n    // Verify authentication and permissions\n    if (!this.quiet) {\n      await verifyGitHubAuth(octokit, props.owner, props.repository);\n    }\n\n    // Determine if we're working with an environment secret or repository secret\n    const isEnvironmentSecret = !!props.environment;\n\n    if (this.phase === \"delete\") {\n      if (this.output?.id) {\n        try {\n          // Delete the secret\n          if (isEnvironmentSecret) {\n            await octokit.rest.actions.deleteEnvironmentSecret({\n              owner: props.owner,\n              repo: props.repository,\n              environment_name: props.environment!,\n              secret_name: props.name,\n            });\n          } else {\n            await octokit.rest.actions.deleteRepoSecret({\n              owner: props.owner,\n              repo: props.repository,\n              secret_name: props.name,\n            });\n          }\n        } catch (error: any) {\n          // Ignore 404 errors (secret already deleted)\n          if (error.status === 404) {\n            console.log(\"Secret doesn't exist, ignoring\");\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      // Return void (a deleted resource has no content)\n      return this.destroy();\n    } else {\n      try {\n        // Check if we're transitioning between secret types (repo <-> environment)\n        if (this.phase === \"update\") {\n          const wasEnvironmentSecret = !!this.output.environment;\n          const secretTypeChanged =\n            isEnvironmentSecret !== wasEnvironmentSecret;\n\n          // If secret type changed, we need to delete the old one first\n          if (secretTypeChanged) {\n            console.log(\n              `Secret type changed from ${wasEnvironmentSecret ? \"environment\" : \"repository\"} to ${isEnvironmentSecret ? \"environment\" : \"repository\"} secret. Deleting the old secret first.`\n            );\n\n            try {\n              if (wasEnvironmentSecret) {\n                // Delete the old environment secret\n                await octokit.rest.actions.deleteEnvironmentSecret({\n                  owner: this.output.owner,\n                  repo: this.output.repository,\n                  environment_name: this.output.environment!,\n                  secret_name: this.output.name,\n                });\n              } else {\n                // Delete the old repository secret\n                await octokit.rest.actions.deleteRepoSecret({\n                  owner: this.output.owner,\n                  repo: this.output.repository,\n                  secret_name: this.output.name,\n                });\n              }\n            } catch (error: any) {\n              // Log but don't fail if the old secret doesn't exist or can't be deleted\n              if (error.status === 404) {\n                console.log(\n                  \"Old secret not found, continuing with creation of new secret\"\n                );\n              } else {\n                throw error;\n              }\n            }\n          }\n        }\n\n        let publicKey;\n\n        // Get the appropriate public key for encrypting secrets\n        if (isEnvironmentSecret) {\n          // Get the environment's public key\n          const { data } = await octokit.rest.actions.getEnvironmentPublicKey({\n            owner: props.owner,\n            repo: props.repository,\n            environment_name: props.environment!,\n          });\n          publicKey = data;\n        } else {\n          // Get the repository's public key\n          const { data } = await octokit.rest.actions.getRepoPublicKey({\n            owner: props.owner,\n            repo: props.repository,\n          });\n          publicKey = data;\n        }\n\n        // Encrypt the secret value using libsodium\n        const encryptedValue = await encryptString(\n          props.value.unencrypted,\n          publicKey.key\n        );\n\n        // Create or update the secret with the encrypted value and key_id\n        if (isEnvironmentSecret) {\n          await octokit.rest.actions.createOrUpdateEnvironmentSecret({\n            owner: props.owner,\n            repo: props.repository,\n            environment_name: props.environment!,\n            secret_name: props.name,\n            encrypted_value: encryptedValue,\n            key_id: publicKey.key_id,\n          });\n        } else {\n          await octokit.rest.actions.createOrUpdateRepoSecret({\n            owner: props.owner,\n            repo: props.repository,\n            secret_name: props.name,\n            encrypted_value: encryptedValue,\n            key_id: publicKey.key_id,\n          });\n        }\n\n        // GitHub doesn't return the secret details on create/update, so we need to construct it\n        const idParts = [props.owner, props.repository];\n        if (isEnvironmentSecret) {\n          idParts.push(props.environment!);\n        }\n        idParts.push(props.name);\n\n        return this({\n          id: idParts.join(\"/\"),\n          owner: props.owner,\n          repository: props.repository,\n          name: props.name,\n          environment: props.environment,\n          token: props.token,\n          updatedAt: new Date().toISOString(),\n        });\n      } catch (error: any) {\n        if (\n          error.status === 403 &&\n          error.message?.includes(\"Must have admin rights\")\n        ) {\n          console.error(\n            \"\\n⚠️ Error creating/updating GitHub secret: You must have admin rights to the repository.\"\n          );\n          console.error(\n            \"Make sure your GitHub token has the required permissions (repo scope for private repos).\\n\"\n          );\n        } else {\n          console.error(\n            \"Error creating/updating GitHub secret:\",\n            error.message\n          );\n        }\n        throw error;\n      }\n    }\n  }\n);\n\n/**\n * Encrypt a value for GitHub using libsodium\n * Based on GitHub's documentation for encrypting secrets\n *\n * @param value - The secret value to encrypt\n * @param publicKey - The base64-encoded public key from GitHub\n * @returns The base64-encoded encrypted value\n */\nasync function encryptString(\n  value: string,\n  publicKey: string\n): Promise<string> {\n  // Initialize libsodium\n  await sodium.ready;\n\n  // Convert the public key from base64 to binary\n  const binKey = sodium.from_base64(publicKey, sodium.base64_variants.ORIGINAL);\n\n  // Convert the message to a Uint8Array\n  const binMessage = sodium.from_string(value);\n\n  // Encrypt the message with the public key using libsodium's sealed box\n  const encryptedBin = sodium.crypto_box_seal(binMessage, binKey);\n\n  // Convert the encrypted message to base64\n  return sodium.to_base64(encryptedBin, sodium.base64_variants.ORIGINAL);\n}\n\n```"
  }
}