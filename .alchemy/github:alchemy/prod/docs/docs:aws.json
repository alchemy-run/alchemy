{
  "kind": "ai::Object",
  "id": "docs/aws",
  "fqn": "github:alchemy/prod/docs/docs/aws",
  "seq": 41,
  "data": {},
  "status": "updated",
  "output": {
    "type": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "object": {
      "groups": [
        {
          "category": "Resource",
          "filename": "function.ts",
          "identifier": "Function"
        },
        {
          "category": "Resource",
          "filename": "table.ts",
          "identifier": "Table"
        },
        {
          "category": "Utility",
          "filename": "account-id.ts",
          "identifier": "AccountId"
        },
        {
          "category": "Resource",
          "filename": "policy-attachment.ts",
          "identifier": "PolicyAttachment"
        },
        {
          "category": "Resource",
          "filename": "role.ts",
          "identifier": "Role"
        },
        {
          "category": "Resource",
          "filename": "policy.ts",
          "identifier": "Policy"
        },
        {
          "category": "Types",
          "filename": "credentials.ts",
          "identifier": "AwsCredentials"
        },
        {
          "category": "Resource",
          "filename": "ses.ts",
          "identifier": "SES"
        },
        {
          "category": "Resource",
          "filename": "bucket.ts",
          "identifier": "Bucket"
        },
        {
          "category": "Resource",
          "filename": "queue.ts",
          "identifier": "Queue"
        }
      ]
    },
    "messages": [
      {
        "role": "user",
        "content": "Identify and classify the documents that need to be written for the '      alchemy/src/aws' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/aws Service has the following resources:\n[function.ts](alchemy/src/aws/function.ts)\n\n[table.ts](alchemy/src/aws/table.ts)\n\n[account-id.ts](alchemy/src/aws/account-id.ts)\n\n[policy-attachment.ts](alchemy/src/aws/policy-attachment.ts)\n\n[role.ts](alchemy/src/aws/role.ts)\n\n[policy.ts](alchemy/src/aws/policy.ts)\n\n[credentials.ts](alchemy/src/aws/credentials.ts)\n\n[ses.ts](alchemy/src/aws/ses.ts)\n\n[bucket.ts](alchemy/src/aws/bucket.ts)\n\n[queue.ts](alchemy/src/aws/queue.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...).\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/aws/account-id.ts\n```ts\nimport { GetCallerIdentityCommand, STSClient } from \"@aws-sdk/client-sts\";\n\nconst sts = new STSClient({});\n\nexport type AccountId = string & {\n  readonly __brand: \"AccountId\";\n};\n\n/**\n * Helper to get the current AWS account ID\n */\nexport async function AccountId(): Promise<AccountId> {\n  const identity = await sts.send(new GetCallerIdentityCommand({}));\n  return identity.Account! as AccountId;\n}\n\n```\n\n// alchemy/src/aws/bucket.ts\n```ts\nimport {\n  CreateBucketCommand,\n  DeleteBucketCommand,\n  GetBucketAclCommand,\n  GetBucketLocationCommand,\n  GetBucketTaggingCommand,\n  GetBucketVersioningCommand,\n  HeadBucketCommand,\n  NoSuchBucket,\n  PutBucketTaggingCommand,\n  S3Client,\n} from \"@aws-sdk/client-s3\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating an S3 bucket\n */\nexport interface BucketProps {\n  /**\n   * The name of the bucket. Must be globally unique across all AWS accounts.\n   * Should be lowercase alphanumeric characters or hyphens.\n   */\n  bucketName: string;\n\n  /**\n   * Optional tags to apply to the bucket for organization and cost tracking.\n   * Each tag is a key-value pair.\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after S3 bucket creation/update\n */\nexport interface Bucket extends Resource<\"s3::Bucket\">, BucketProps {\n  /**\n   * The ARN (Amazon Resource Name) of the bucket\n   * Format: arn:aws:s3:::bucket-name\n   */\n  arn: string;\n\n  /**\n   * The global domain name for the bucket\n   * Format: bucket-name.s3.amazonaws.com\n   */\n  bucketDomainName: string;\n\n  /**\n   * The regional domain name for the bucket\n   * Format: bucket-name.s3.region.amazonaws.com\n   */\n  bucketRegionalDomainName?: string;\n\n  /**\n   * The S3 hosted zone ID for the region where the bucket resides\n   * Used for DNS configuration with Route 53\n   */\n  hostedZoneId?: string;\n\n  /**\n   * The AWS region where the bucket is located\n   */\n  region?: string;\n\n  /**\n   * The website endpoint URL if static website hosting is enabled\n   * Format: http://bucket-name.s3-website-region.amazonaws.com\n   */\n  websiteEndpoint?: string;\n\n  /**\n   * The website domain if static website hosting is enabled\n   * Format: bucket-name.s3-website-region.amazonaws.com\n   */\n  websiteDomain?: string;\n\n  /**\n   * Whether versioning is enabled for the bucket\n   */\n  versioningEnabled?: boolean;\n\n  /**\n   * The canned ACL applied to the bucket\n   * Common values: private, public-read, public-read-write, authenticated-read\n   */\n  acl?: string;\n}\n\n/**\n * AWS S3 Bucket Resource\n *\n * Creates and manages Amazon S3 buckets with support for versioning, tags, and regional configuration.\n * S3 buckets provide scalable object storage for any type of data, with features like versioning,\n * lifecycle policies, and fine-grained access control.\n *\n * @example\n * // Create a basic S3 bucket with default settings\n * const basicBucket = await Bucket(\"my-app-storage\", {\n *   bucketName: \"my-app-storage\",\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"my-app\"\n *   }\n * });\n *\n * @example\n * // Create a bucket with versioning enabled and specific tags\n * const versionedBucket = await Bucket(\"document-archive\", {\n *   bucketName: \"document-archive\",\n *   tags: {\n *     Environment: \"production\",\n *     Purpose: \"document-storage\",\n *     Versioning: \"enabled\"\n *   }\n * });\n *\n * @example\n * // Create a development bucket with minimal configuration\n * const devBucket = await Bucket(\"dev-testing\", {\n *   bucketName: \"dev-testing\",\n *   tags: {\n *     Environment: \"development\",\n *     Temporary: \"true\"\n *   }\n * });\n */\nexport const Bucket = Resource(\n  \"s3::Bucket\",\n  async function (this: Context<Bucket>, id: string, props: BucketProps) {\n    const client = new S3Client({});\n\n    if (this.phase === \"delete\") {\n      await ignore(NoSuchBucket.name, () =>\n        client.send(\n          new DeleteBucketCommand({\n            Bucket: props.bucketName,\n          }),\n        ),\n      );\n      return this.destroy();\n    } else {\n      try {\n        // Check if bucket exists\n        await client.send(\n          new HeadBucketCommand({\n            Bucket: props.bucketName,\n          }),\n        );\n\n        // Update tags if they changed and bucket exists\n        if (this.phase === \"update\" && props.tags) {\n          await client.send(\n            new PutBucketTaggingCommand({\n              Bucket: props.bucketName,\n              Tagging: {\n                TagSet: Object.entries(props.tags).map(([Key, Value]) => ({\n                  Key,\n                  Value,\n                })),\n              },\n            }),\n          );\n        }\n      } catch (error: any) {\n        if (error.name === \"NotFound\") {\n          // Create bucket if it doesn't exist\n          await client.send(\n            new CreateBucketCommand({\n              Bucket: props.bucketName,\n              // Add tags during creation if specified\n              ...(props.tags && {\n                Tagging: {\n                  TagSet: Object.entries(props.tags).map(([Key, Value]) => ({\n                    Key,\n                    Value,\n                  })),\n                },\n              }),\n            }),\n          );\n        } else {\n          throw error;\n        }\n      }\n\n      // Get bucket details\n      const [locationResponse, versioningResponse, aclResponse] =\n        await Promise.all([\n          client.send(\n            new GetBucketLocationCommand({ Bucket: props.bucketName }),\n          ),\n          client.send(\n            new GetBucketVersioningCommand({ Bucket: props.bucketName }),\n          ),\n          client.send(new GetBucketAclCommand({ Bucket: props.bucketName })),\n        ]);\n\n      const region = locationResponse.LocationConstraint || \"us-east-1\";\n\n      // Get tags if they exist\n      let tags = props.tags;\n      if (!tags) {\n        try {\n          const taggingResponse = await client.send(\n            new GetBucketTaggingCommand({ Bucket: props.bucketName }),\n          );\n          tags = Object.fromEntries(\n            taggingResponse.TagSet?.map(({ Key, Value }) => [Key, Value]) || [],\n          );\n        } catch (error: any) {\n          if (error.name !== \"NoSuchTagSet\") {\n            throw error;\n          }\n        }\n      }\n\n      return this({\n        bucketName: props.bucketName,\n        arn: `arn:aws:s3:::${props.bucketName}`,\n        bucketDomainName: `${props.bucketName}.s3.amazonaws.com`,\n        bucketRegionalDomainName: `${props.bucketName}.s3.${region}.amazonaws.com`,\n        region,\n        hostedZoneId: getHostedZoneId(region),\n        versioningEnabled: versioningResponse.Status === \"Enabled\",\n        acl: aclResponse.Grants?.[0]?.Permission?.toLowerCase(),\n        ...(tags && { tags }),\n      });\n    }\n  },\n);\n\n/**\n * Helper function to get S3 hosted zone IDs by region\n *\n * Returns the S3 hosted zone ID for a given AWS region. These IDs are used when\n * configuring Route 53 DNS records that point to S3 buckets. If the region is not\n * found in the mapping, defaults to the us-east-1 hosted zone ID.\n *\n * @param region - The AWS region code (e.g., us-east-1, eu-west-1)\n * @returns The S3 hosted zone ID for the region\n */\nfunction getHostedZoneId(region: string): string {\n  const hostedZoneIds: Record<string, string> = {\n    \"us-east-1\": \"Z3AQBSTGFYJSTF\",\n    \"us-east-2\": \"Z2O1EMRO9K5GLX\",\n    \"us-west-1\": \"Z2F56UZL2M1ACD\",\n    \"us-west-2\": \"Z3BJ6K6RIION7M\",\n    \"af-south-1\": \"Z11KHD8FBVPUYU\",\n    \"ap-east-1\": \"ZNB98KWMFR0R6\",\n    \"ap-south-1\": \"Z11RGJOFQNVJUP\",\n    \"ap-northeast-1\": \"Z2M4EHUR26P7ZW\",\n    \"ap-northeast-2\": \"Z3W03O7B5YMIYP\",\n    \"ap-northeast-3\": \"Z2YQB5RD63NC85\",\n    \"ap-southeast-1\": \"Z3O0J2DXBE1FTB\",\n    \"ap-southeast-2\": \"Z1WCIGYICN2BYD\",\n    \"ca-central-1\": \"Z1QDHH18159H29\",\n    \"eu-central-1\": \"Z21DNDUVLTQW6Q\",\n    \"eu-west-1\": \"Z1BKCTXD74EZPE\",\n    \"eu-west-2\": \"Z3GKZC51ZF0DB4\",\n    \"eu-west-3\": \"Z3R1K369G5AVDG\",\n    \"eu-north-1\": \"Z3BAZG2TWCNX0D\",\n    \"eu-south-1\": \"Z30OZKI7KPW7MI\",\n    \"me-south-1\": \"Z1MPMWCPA7YB62\",\n    \"sa-east-1\": \"Z7KQH4QJS55SO\",\n  };\n  return hostedZoneIds[region] || \"Z3AQBSTGFYJSTF\"; // Default to us-east-1 if region not found\n}\n\n```\n\n// alchemy/src/aws/credentials.ts\n```ts\nimport type { Secret } from \"../secret\";\n\nexport interface AwsCredentials {\n  accessKeyId: Secret;\n  secretAccessKey: Secret;\n}\n\n```\n\n// alchemy/src/aws/function.ts\n```ts\nimport {\n  Architecture,\n  CreateFunctionCommand,\n  DeleteFunctionCommand,\n  GetFunctionCommand,\n  GetFunctionConfigurationCommand,\n  LambdaClient,\n  ResourceNotFoundException,\n  Runtime,\n  UpdateFunctionCodeCommand,\n  UpdateFunctionConfigurationCommand,\n} from \"@aws-sdk/client-lambda\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating a Lambda function\n */\nexport interface FunctionProps {\n  /**\n   * Name of the Lambda function\n   */\n  functionName: string;\n\n  /**\n   * Path to the zip file containing the function code\n   */\n  zipPath: string;\n\n  /**\n   * ARN of the IAM role that Lambda assumes when executing the function\n   */\n  roleArn: string;\n\n  /**\n   * Function handler in the format 'file.function'\n   * For Node.js this is typically 'index.handler' or similar\n   */\n  handler?: string;\n\n  /**\n   * Lambda runtime environment for the function\n   * @default nodejs20.x if not specified\n   */\n  runtime?: Runtime;\n\n  /**\n   * CPU architecture for the function\n   * @default x86_64 if not specified\n   */\n  architecture?: Architecture;\n\n  /**\n   * Description of the function's purpose\n   */\n  description?: string;\n\n  /**\n   * Maximum execution time in seconds\n   * @default 3 seconds if not specified\n   */\n  timeout?: number;\n\n  /**\n   * Amount of memory available to the function in MB\n   * @default 128 MB if not specified\n   */\n  memorySize?: number;\n\n  /**\n   * Environment variables available to the function code\n   */\n  environment?: Record<string, string>;\n\n  /**\n   * Resource tags for the function\n   */\n  tags?: Record<string, string>;\n\n  /**\n   * Function URL configuration for direct HTTP(S) invocation\n   */\n  url?: {\n    /**\n     * Authentication type for the function URL\n     */\n    authType?: \"AWS_IAM\" | \"NONE\";\n\n    /**\n     * CORS configuration for the function URL\n     */\n    cors?: {\n      /**\n       * Whether to allow credentials in CORS requests\n       */\n      allowCredentials?: boolean;\n\n      /**\n       * Allowed headers in CORS requests\n       */\n      allowHeaders?: string[];\n\n      /**\n       * Allowed HTTP methods in CORS requests\n       */\n      allowMethods?: string[];\n\n      /**\n       * Allowed origins in CORS requests\n       */\n      allowOrigins?: string[];\n\n      /**\n       * Headers exposed to the browser\n       */\n      exposeHeaders?: string[];\n\n      /**\n       * CORS preflight cache time in seconds\n       */\n      maxAge?: number;\n    };\n  };\n}\n\n/**\n * Output returned after Lambda function creation/update\n */\nexport interface Function extends Resource<\"lambda::Function\">, FunctionProps {\n  /**\n   * ARN of the Lambda function\n   */\n  arn: string;\n\n  /**\n   * Timestamp of the last function modification\n   */\n  lastModified: string;\n\n  /**\n   * Function version\n   */\n  version: string;\n\n  /**\n   * ARN with version suffix\n   */\n  qualifiedArn: string;\n\n  /**\n   * ARN for invoking the function through API Gateway\n   */\n  invokeArn: string;\n\n  /**\n   * SHA256 hash of the function code\n   */\n  sourceCodeHash: string;\n\n  /**\n   * Size of the function code in bytes\n   */\n  sourceCodeSize: number;\n\n  /**\n   * Size of ephemeral storage (/tmp) in MB\n   */\n  ephemeralStorageSize?: number;\n\n  /**\n   * List of supported CPU architectures\n   */\n  architectures: string[];\n\n  /**\n   * ARN of the master function (Lambda@Edge only)\n   */\n  masterArn?: string;\n\n  /**\n   * Unique identifier for the current function code/config\n   */\n  revisionId: string;\n\n  /**\n   * Current state of the function\n   */\n  state?: string;\n\n  /**\n   * Reason for the current state\n   */\n  stateReason?: string;\n\n  /**\n   * Code for the current state reason\n   */\n  stateReasonCode?: string;\n\n  /**\n   * Status of the last update operation\n   */\n  lastUpdateStatus?: string;\n\n  /**\n   * Reason for the last update status\n   */\n  lastUpdateStatusReason?: string;\n\n  /**\n   * Code for the last update status reason\n   */\n  lastUpdateStatusReasonCode?: string;\n\n  /**\n   * Function package type (Zip or Image)\n   */\n  packageType: string;\n\n  /**\n   * ARN of the signing profile version\n   */\n  signingProfileVersionArn?: string;\n\n  /**\n   * ARN of the signing job\n   */\n  signingJobArn?: string;\n}\n\n/**\n * AWS Lambda Function Resource\n *\n * Creates and manages AWS Lambda functions with support for Node.js runtimes, custom handlers,\n * environment variables, and function URLs. Handles deployment packaging, IAM role\n * stabilization, and function updates.\n *\n * @example\n * // Create a basic Lambda function with minimal configuration\n * const basicFunction = await Function(\"api-handler\", {\n *   functionName: \"api-handler\",\n *   zipPath: \"./dist/api.zip\",\n *   roleArn: role.arn,\n *   runtime: Runtime.nodejs20x,\n *   handler: \"index.handler\",\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a function with environment variables and custom memory/timeout\n * const configuredFunction = await Function(\"worker\", {\n *   functionName: \"worker\",\n *   zipPath: \"./dist/worker.zip\",\n *   roleArn: role.arn,\n *   runtime: Runtime.nodejs20x,\n *   handler: \"worker.process\",\n *   memorySize: 512,\n *   timeout: 30,\n *   environment: {\n *     QUEUE_URL: queue.url,\n *     LOG_LEVEL: \"info\"\n *   }\n * });\n *\n * @example\n * // Create a function with a public URL endpoint and CORS\n * const apiFunction = await Function(\"public-api\", {\n *   functionName: \"public-api\",\n *   zipPath: \"./dist/api.zip\",\n *   roleArn: role.arn,\n *   handler: \"api.handler\",\n *   url: {\n *     authType: \"NONE\",\n *     cors: {\n *       allowOrigins: [\"*\"],\n *       allowMethods: [\"GET\", \"POST\"],\n *       allowHeaders: [\"content-type\"],\n *       maxAge: 86400\n *     }\n *   }\n * });\n */\nexport const Function = Resource(\n  \"lambda::Function\",\n  async function (this: Context<Function>, id: string, props: FunctionProps) {\n    const client = new LambdaClient({});\n    const region = await resolveRegion(client);\n\n    const code = await zipCode(props.zipPath);\n\n    if (this.phase === \"delete\") {\n      await ignore(ResourceNotFoundException.name, () =>\n        client.send(\n          new DeleteFunctionCommand({\n            FunctionName: props.functionName,\n          }),\n        ),\n      );\n\n      return this.destroy();\n    } else {\n      try {\n        // Check if function exists\n        await client.send(\n          new GetFunctionCommand({\n            FunctionName: props.functionName,\n          }),\n        );\n\n        if (this.phase === \"update\") {\n          // Wait for function to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Update function code\n          await client.send(\n            new UpdateFunctionCodeCommand({\n              FunctionName: props.functionName,\n              ZipFile: code,\n            }),\n          );\n\n          // Wait for code update to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Update function configuration\n          await client.send(\n            new UpdateFunctionConfigurationCommand({\n              FunctionName: props.functionName,\n              Handler: props.handler,\n              Runtime: props.runtime,\n              Role: props.roleArn,\n              Description: props.description,\n              Timeout: props.timeout,\n              MemorySize: props.memorySize,\n              Environment: props.environment\n                ? { Variables: props.environment }\n                : undefined,\n            }),\n          );\n\n          // Wait for configuration update to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n        }\n      } catch (error: any) {\n        if (error.name === \"ResourceNotFoundException\") {\n          // Create function if it doesn't exist\n          const startTime = Date.now();\n          let delay = 100; // Start with 100ms delay\n\n          while (true) {\n            try {\n              await client.send(\n                new CreateFunctionCommand({\n                  FunctionName: props.functionName,\n                  Code: { ZipFile: code },\n                  Handler: props.handler || \"index.handler\",\n                  Runtime: props.runtime || Runtime.nodejs20x,\n                  Role: props.roleArn,\n                  Description: props.description,\n                  Timeout: props.timeout || 3,\n                  MemorySize: props.memorySize || 128,\n                  Environment: props.environment\n                    ? { Variables: props.environment }\n                    : undefined,\n                  Architectures: props.architecture\n                    ? [props.architecture]\n                    : [Architecture.x86_64],\n                  Tags: props.tags,\n                }),\n              );\n              break; // Success - exit retry loop\n            } catch (createError: any) {\n              if (\n                createError.name !== \"InvalidParameterValueException\" ||\n                !createError.message?.includes(\"cannot be assumed by Lambda\")\n              ) {\n                throw createError; // Different error - rethrow\n              }\n\n              if (Date.now() - startTime > 10000) {\n                throw new Error(\n                  \"Timeout waiting for IAM role to be assumable by Lambda after 10s\",\n                );\n              }\n\n              await new Promise((resolve) => setTimeout(resolve, delay));\n              delay = Math.min(delay * 2, 1000); // Exponential backoff capped at 1s\n            }\n          }\n\n          // Wait for function to be active\n          let isCreating = true;\n          while (isCreating) {\n            const config = await client.send(\n              new GetFunctionConfigurationCommand({\n                FunctionName: props.functionName,\n              }),\n            );\n            isCreating = config.State === \"Pending\";\n            if (isCreating) {\n              await new Promise((resolve) => setTimeout(resolve, 1000));\n            }\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      // Get complete function details\n      const [func, config] = await Promise.all([\n        client.send(\n          new GetFunctionCommand({\n            FunctionName: props.functionName,\n          }),\n        ),\n        client.send(\n          new GetFunctionConfigurationCommand({\n            FunctionName: props.functionName,\n          }),\n        ),\n      ]);\n\n      return this({\n        ...props,\n        arn: config.FunctionArn!,\n        lastModified: config.LastModified!,\n        version: config.Version!,\n        qualifiedArn: `${config.FunctionArn}:${config.Version}`,\n        invokeArn: `arn:aws:apigateway:${region}:lambda:path/2015-03-31/functions/${config.FunctionArn}/invocations`,\n        sourceCodeHash: config.CodeSha256!,\n        sourceCodeSize: config.CodeSize!,\n        ephemeralStorageSize: config.EphemeralStorage?.Size,\n        architectures: config.Architectures || [],\n        masterArn: config.MasterArn,\n        revisionId: config.RevisionId!,\n        state: config.State,\n        stateReason: config.StateReason,\n        stateReasonCode: config.StateReasonCode,\n        lastUpdateStatus: config.LastUpdateStatus,\n        lastUpdateStatusReason: config.LastUpdateStatusReason,\n        lastUpdateStatusReasonCode: config.LastUpdateStatusReasonCode,\n        packageType: config.PackageType!,\n        signingProfileVersionArn: config.SigningProfileVersionArn,\n        signingJobArn: config.SigningJobArn,\n      });\n    }\n  },\n);\n\n// Helper to wait for function to stabilize\nasync function waitForFunctionStabilization(\n  client: LambdaClient,\n  functionName: string,\n) {\n  while (true) {\n    const config = await client.send(\n      new GetFunctionConfigurationCommand({\n        FunctionName: functionName,\n      }),\n    );\n\n    // Check if function is in a stable state\n    if (config.State === \"Active\" && config.LastUpdateStatus === \"Successful\") {\n      break;\n    }\n\n    // If there's a failure, throw an error\n    if (config.State === \"Failed\" || config.LastUpdateStatus === \"Failed\") {\n      throw new Error(\n        `Function failed to stabilize: ${config.StateReason || config.LastUpdateStatusReason}`,\n      );\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n  }\n}\n\n// Helper to zip the code\nasync function zipCode(filePath: string): Promise<Buffer> {\n  const fileContent = await fs.promises.readFile(filePath);\n  const fileName = path.basename(filePath);\n\n  // Create a zip buffer in memory\n  const zip = new (await import(\"jszip\")).default();\n  zip.file(fileName, fileContent);\n  return zip.generateAsync({\n    type: \"nodebuffer\",\n    compression: \"DEFLATE\",\n    platform: \"UNIX\",\n  });\n}\n\nasync function resolveRegion(client: LambdaClient): Promise<string> {\n  const region = client.config.region;\n  if (typeof region === \"string\") return region;\n  if (typeof region === \"function\") return region();\n  throw new Error(\"Could not resolve AWS region\");\n}\n\n```\n\n// alchemy/src/aws/policy-attachment.ts\n```ts\nimport {\n  AttachRolePolicyCommand,\n  DetachRolePolicyCommand,\n  IAMClient,\n  NoSuchEntityException,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating a policy attachment\n */\nexport interface PolicyAttachmentProps {\n  /**\n   * ARN of the IAM policy to attach\n   */\n  policyArn: string;\n\n  /**\n   * Name of the IAM role to attach the policy to\n   */\n  roleName: string;\n}\n\n/**\n * Output returned after policy attachment creation/update\n */\nexport interface PolicyAttachment\n  extends Resource<\"iam::PolicyAttachment\">,\n    PolicyAttachmentProps {}\n\n/**\n * AWS IAM Policy Attachment Resource\n *\n * Attaches an IAM policy to a role, enabling the role to use the permissions defined in the policy.\n *\n * @example\n * // Attach an AWS managed policy to a role\n * const adminAccess = await PolicyAttachment(\"admin-policy\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AdministratorAccess\",\n *   roleName: role.name\n * });\n *\n * @example\n * // Attach a custom policy to a role\n * const customPolicy = await PolicyAttachment(\"custom-policy\", {\n *   policyArn: policy.arn,\n *   roleName: role.name\n * });\n *\n * @example\n * // Attach multiple policies to a role\n * const s3Access = await PolicyAttachment(\"s3-access\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AmazonS3FullAccess\",\n *   roleName: role.name\n * });\n *\n * const sqsAccess = await PolicyAttachment(\"sqs-access\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AmazonSQSFullAccess\",\n *   roleName: role.name\n * });\n */\nexport const PolicyAttachment = Resource(\n  \"iam::PolicyAttachment\",\n  async function (\n    this: Context<PolicyAttachment>,\n    id: string,\n    props: PolicyAttachmentProps,\n  ) {\n    const client = new IAMClient({});\n\n    if (this.phase === \"delete\") {\n      await ignore(NoSuchEntityException.name, () =>\n        client.send(\n          new DetachRolePolicyCommand({\n            PolicyArn: props.policyArn,\n            RoleName: props.roleName,\n          }),\n        ),\n      );\n      return this.destroy();\n    } else {\n      await client.send(\n        new AttachRolePolicyCommand({\n          PolicyArn: props.policyArn,\n          RoleName: props.roleName,\n        }),\n      );\n    }\n\n    return this(props);\n  },\n);\n\n```\n\n// alchemy/src/aws/policy.ts\n```ts\nimport {\n  CreatePolicyCommand,\n  CreatePolicyVersionCommand,\n  DeletePolicyCommand,\n  DeletePolicyVersionCommand,\n  GetPolicyCommand,\n  GetPolicyVersionCommand,\n  IAMClient,\n  ListPolicyVersionsCommand,\n  NoSuchEntityException,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Type of effect for a policy statement\n */\nexport type Effect = \"Allow\" | \"Deny\";\n\n/**\n * A single statement within an IAM policy document\n */\nexport interface PolicyStatement {\n  /**\n   * Optional identifier for the statement\n   */\n  Sid?: string;\n\n  /**\n   * Whether to allow or deny the specified actions\n   */\n  Effect: Effect;\n\n  /**\n   * Actions that the policy allows or denies\n   */\n  Action: string | string[];\n\n  /**\n   * Resources that the policy applies to\n   */\n  Resource?: string | string[];\n\n  /**\n   * Additional conditions for when the policy applies\n   */\n  Condition?: Record<string, Record<string, string | string[]>>;\n\n  /**\n   * AWS principals that the policy applies to\n   */\n  Principal?: Record<string, string | string[]>;\n\n  /**\n   * AWS principals that the policy explicitly does not apply to\n   */\n  NotPrincipal?: Record<string, string | string[]>;\n\n  /**\n   * Actions that are explicitly not included in this statement\n   */\n  NotAction?: string | string[];\n\n  /**\n   * Resources that are explicitly not included in this statement\n   */\n  NotResource?: string | string[];\n}\n\n/**\n * An IAM policy document containing one or more statements\n */\nexport interface PolicyDocument {\n  /**\n   * Policy language version (must be \"2012-10-17\")\n   */\n  Version: \"2012-10-17\";\n\n  /**\n   * List of policy statements\n   */\n  Statement: PolicyStatement[];\n}\n\n/**\n * Properties for creating or updating an IAM policy\n */\nexport interface PolicyProps {\n  /**\n   * Name of the policy\n   */\n  policyName: string;\n\n  /**\n   * Policy document defining the permissions\n   */\n  document: PolicyDocument;\n\n  /**\n   * Optional description of the policy's purpose\n   */\n  description?: string;\n\n  /**\n   * Optional path prefix for the policy\n   */\n  path?: string;\n\n  /**\n   * Optional resource tags\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after IAM policy creation/update\n */\nexport interface Policy extends Resource<\"iam::Policy\">, PolicyProps {\n  /**\n   * ARN of the policy\n   */\n  arn: string;\n\n  /**\n   * ID of the default policy version\n   */\n  defaultVersionId: string;\n\n  /**\n   * Number of entities the policy is attached to\n   */\n  attachmentCount: number;\n\n  /**\n   * When the policy was created\n   */\n  createDate: Date;\n\n  /**\n   * When the policy was last updated\n   */\n  updateDate: Date;\n\n  /**\n   * Whether the policy can be attached to IAM users/roles\n   */\n  isAttachable: boolean;\n}\n\n/**\n * AWS IAM Policy Resource\n *\n * Creates and manages IAM policies that define permissions for AWS services and resources.\n * Supports automatic versioning and updates when policy content changes.\n *\n * @example\n * // Create a basic S3 bucket access policy\n * const s3Policy = await Policy(\"bucket-access\", {\n *   policyName: \"s3-bucket-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Action: [\n *         \"s3:GetObject\",\n *         \"s3:PutObject\"\n *       ],\n *       Resource: `${bucket.arn}/*`\n *     }]\n *   }\n * });\n *\n * @example\n * // Create a policy with multiple statements and conditions\n * const apiPolicy = await Policy(\"api-access\", {\n *   policyName: \"api-gateway-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [\n *       {\n *         Sid: \"InvokeAPI\",\n *         Effect: \"Allow\",\n *         Action: \"execute-api:Invoke\",\n *         Resource: `${api.executionArn}/*`,\n *         Condition: {\n *           StringEquals: {\n *             \"aws:SourceVpc\": vpc.id\n *           }\n *         }\n *       },\n *       {\n *         Sid: \"ReadLogs\",\n *         Effect: \"Allow\",\n *         Action: [\n *           \"logs:GetLogEvents\",\n *           \"logs:FilterLogEvents\"\n *         ],\n *         Resource: `${api.logGroupArn}:*`\n *       }\n *     ]\n *   },\n *   description: \"Allows invoking API Gateway endpoints and reading logs\",\n *   tags: {\n *     Service: \"API Gateway\",\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a policy that denies access based on tags\n * const denyPolicy = await Policy(\"deny-production\", {\n *   policyName: \"deny-production-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Deny\",\n *       Action: \"*\",\n *       Resource: \"*\",\n *       Condition: {\n *         StringEquals: {\n *           \"aws:ResourceTag/Environment\": \"production\"\n *         }\n *       }\n *     }]\n *   }\n * });\n */\nexport const Policy = Resource(\n  \"iam::Policy\",\n  async function (\n    this: Context<Policy>,\n    id: string,\n    props: PolicyProps,\n  ): Promise<Policy> {\n    const client = new IAMClient({});\n    const policyArn = `arn:aws:iam::${process.env.AWS_ACCOUNT_ID}:policy${props.path || \"/\"}${props.policyName}`;\n\n    if (this.phase === \"delete\") {\n      try {\n        // List and delete all non-default versions first\n        const versions = await client.send(\n          new ListPolicyVersionsCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        for (const version of versions.Versions || []) {\n          if (!version.IsDefaultVersion) {\n            await client.send(\n              new DeletePolicyVersionCommand({\n                PolicyArn: policyArn,\n                VersionId: version.VersionId,\n              }),\n            );\n          }\n        }\n\n        // Delete the policy\n        await client.send(\n          new DeletePolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n      } catch (error: any) {\n        if (error.name !== NoSuchEntityException.name) {\n          throw error;\n        }\n      }\n      return this.destroy();\n    } else {\n      try {\n        // Check if policy exists\n        const existingPolicy = await client.send(\n          new GetPolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        // Get current policy version\n        const currentVersion = await client.send(\n          new GetPolicyVersionCommand({\n            PolicyArn: policyArn,\n            VersionId: existingPolicy.Policy!.DefaultVersionId!,\n          }),\n        );\n\n        const currentDocument = JSON.parse(\n          decodeURIComponent(currentVersion.PolicyVersion!.Document!),\n        );\n\n        // If policy document changed, create new version\n        if (\n          JSON.stringify(currentDocument) !== JSON.stringify(props.document)\n        ) {\n          // List versions to check if we need to delete old ones\n          const versions = await client.send(\n            new ListPolicyVersionsCommand({\n              PolicyArn: policyArn,\n            }),\n          );\n\n          // Delete oldest version if we have 5 versions (maximum allowed)\n          if (versions.Versions?.length === 5) {\n            const oldestVersion = versions.Versions.sort(\n              (a, b) => a.CreateDate!.getTime() - b.CreateDate!.getTime(),\n            )[0];\n\n            if (!oldestVersion.IsDefaultVersion) {\n              await client.send(\n                new DeletePolicyVersionCommand({\n                  PolicyArn: policyArn,\n                  VersionId: oldestVersion.VersionId!,\n                }),\n              );\n            }\n          }\n\n          // Create new version\n          await client.send(\n            new CreatePolicyVersionCommand({\n              PolicyArn: policyArn,\n              PolicyDocument: JSON.stringify(props.document),\n              SetAsDefault: true,\n            }),\n          );\n        }\n\n        const policy = await client.send(\n          new GetPolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        return this({\n          ...props,\n          arn: policy.Policy!.Arn!,\n          defaultVersionId: policy.Policy!.DefaultVersionId!,\n          attachmentCount: policy.Policy!.AttachmentCount!,\n          createDate: policy.Policy!.CreateDate!,\n          updateDate: policy.Policy!.UpdateDate!,\n          isAttachable: policy.Policy!.IsAttachable!,\n        });\n      } catch (error: any) {\n        if (error.name === \"NoSuchEntity\") {\n          // Create new policy\n          const newPolicy = await client.send(\n            new CreatePolicyCommand({\n              PolicyName: props.policyName,\n              PolicyDocument: JSON.stringify(props.document),\n              Description: props.description,\n              Path: props.path,\n              Tags: props.tags\n                ? Object.entries(props.tags).map(([Key, Value]) => ({\n                    Key,\n                    Value,\n                  }))\n                : undefined,\n            }),\n          );\n\n          return this({\n            ...props,\n            arn: newPolicy.Policy!.Arn!,\n            defaultVersionId: newPolicy.Policy!.DefaultVersionId!,\n            attachmentCount: newPolicy.Policy!.AttachmentCount!,\n            createDate: newPolicy.Policy!.CreateDate!,\n            updateDate: newPolicy.Policy!.UpdateDate!,\n            isAttachable: newPolicy.Policy!.IsAttachable!,\n          });\n        }\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/aws/queue.ts\n```ts\nimport {\n  CreateQueueCommand,\n  DeleteQueueCommand,\n  GetQueueAttributesCommand,\n  GetQueueUrlCommand,\n  SQSClient,\n} from \"@aws-sdk/client-sqs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating an SQS queue\n */\nexport interface QueueProps {\n  /**\n   * Name of the queue\n   * For FIFO queues, the name must end with the .fifo suffix\n   */\n  queueName: string;\n\n  /**\n   * Whether this is a FIFO queue.\n   * If true, the queueName must end with .fifo suffix\n   */\n  fifo?: boolean;\n\n  /**\n   * The length of time (in seconds) that a message received from a queue will be invisible to other receiving components\n   * Default: 30 seconds\n   */\n  visibilityTimeout?: number;\n\n  /**\n   * The length of time (in seconds) for which Amazon SQS retains a message\n   * Default: 345600 seconds (4 days)\n   */\n  messageRetentionPeriod?: number;\n\n  /**\n   * The limit of how many bytes a message can contain before Amazon SQS rejects it\n   * Default: 262144 bytes (256 KB)\n   */\n  maximumMessageSize?: number;\n\n  /**\n   * The time in seconds that the delivery of all messages in the queue will be delayed\n   * Default: 0 seconds\n   */\n  delaySeconds?: number;\n\n  /**\n   * The length of time (in seconds) for which a ReceiveMessage action waits for a message to arrive\n   * Default: 0 seconds\n   */\n  receiveMessageWaitTimeSeconds?: number;\n\n  /**\n   * Enables content-based deduplication for FIFO queues.\n   * Only applicable when fifo is true.\n   */\n  contentBasedDeduplication?: boolean;\n\n  /**\n   * Specifies whether message deduplication occurs at the message group or queue level\n   * Only applicable when fifo is true\n   */\n  deduplicationScope?: \"messageGroup\" | \"queue\";\n\n  /**\n   * Specifies whether the FIFO queue throughput quota applies to the entire queue or per message group\n   * Only applicable when fifo is true\n   */\n  fifoThroughputLimit?: \"perQueue\" | \"perMessageGroupId\";\n\n  /**\n   * Resource tags for the queue\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after SQS queue creation/update\n */\nexport interface Queue extends Resource<\"sqs::Queue\">, QueueProps {\n  /**\n   * ARN of the queue\n   */\n  arn: string;\n\n  /**\n   * URL of the queue\n   */\n  url: string;\n}\n\n/**\n * AWS SQS Queue Resource\n *\n * Creates and manages Amazon SQS queues with support for both standard and FIFO queues.\n * Handles queue creation, attribute configuration, and automatic cleanup of deleted queues.\n *\n * @example\n * // Create a standard queue with custom visibility timeout\n * const standardQueue = await Queue(\"my-queue\", {\n *   queueName: \"my-queue\",\n *   visibilityTimeout: 30,\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a FIFO queue with content-based deduplication\n * const fifoQueue = await Queue(\"orders-queue\", {\n *   queueName: \"orders-queue.fifo\",\n *   fifo: true,\n *   contentBasedDeduplication: true,\n *   visibilityTimeout: 30,\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a queue with custom message retention and size\n * const customQueue = await Queue(\"large-messages\", {\n *   queueName: \"large-messages\",\n *   messageRetentionPeriod: 345600,  // 4 days\n *   maximumMessageSize: 262144,      // 256 KB\n *   visibilityTimeout: 60,\n *   delaySeconds: 5,\n *   receiveMessageWaitTimeSeconds: 20\n * });\n */\nexport const Queue = Resource(\n  \"sqs::Queue\",\n  async function (\n    this: Context<Queue>,\n    id: string,\n    props: QueueProps,\n  ): Promise<Queue> {\n    const client = new SQSClient({});\n    // Don't automatically add .fifo suffix - user must include it in queueName\n    const queueName = props.queueName;\n\n    // Validate that FIFO queues have .fifo suffix\n    if (props.fifo && !queueName.endsWith(\".fifo\")) {\n      throw new Error(\"FIFO queue names must end with .fifo suffix\");\n    }\n\n    if (this.phase === \"delete\") {\n      try {\n        // Get queue URL first\n        const urlResponse = await client.send(\n          new GetQueueUrlCommand({\n            QueueName: queueName,\n          }),\n        );\n\n        // Delete the queue\n        await client.send(\n          new DeleteQueueCommand({\n            QueueUrl: urlResponse.QueueUrl,\n          }),\n        );\n\n        // Wait for queue to be deleted\n        let queueDeleted = false;\n        while (!queueDeleted) {\n          try {\n            await client.send(\n              new GetQueueUrlCommand({\n                QueueName: queueName,\n              }),\n            );\n            // If we get here, queue still exists\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n          } catch (error: any) {\n            if (error.name === \"QueueDoesNotExist\") {\n              queueDeleted = true;\n            } else {\n              throw error;\n            }\n          }\n        }\n      } catch (error: any) {\n        if (error.name !== \"QueueDoesNotExist\") {\n          throw error;\n        }\n      }\n\n      return this.destroy();\n    } else {\n      // Create queue with attributes\n      const attributes: Record<string, string> = {};\n\n      if (props.visibilityTimeout !== undefined) {\n        attributes[\"VisibilityTimeout\"] = props.visibilityTimeout.toString();\n      }\n      if (props.messageRetentionPeriod !== undefined) {\n        attributes[\"MessageRetentionPeriod\"] =\n          props.messageRetentionPeriod.toString();\n      }\n      if (props.maximumMessageSize !== undefined) {\n        attributes[\"MaximumMessageSize\"] = props.maximumMessageSize.toString();\n      }\n      if (props.delaySeconds !== undefined) {\n        attributes[\"DelaySeconds\"] = props.delaySeconds.toString();\n      }\n      if (props.receiveMessageWaitTimeSeconds !== undefined) {\n        attributes[\"ReceiveMessageWaitTimeSeconds\"] =\n          props.receiveMessageWaitTimeSeconds.toString();\n      }\n\n      // FIFO specific attributes\n      if (props.fifo) {\n        attributes[\"FifoQueue\"] = \"true\";\n        if (props.contentBasedDeduplication) {\n          attributes[\"ContentBasedDeduplication\"] = \"true\";\n        }\n        if (props.deduplicationScope) {\n          attributes[\"DeduplicationScope\"] = props.deduplicationScope;\n        }\n        if (props.fifoThroughputLimit) {\n          attributes[\"FifoThroughputLimit\"] = props.fifoThroughputLimit;\n        }\n      }\n\n      // Convert tags to AWS format\n      const tags = props.tags\n        ? Object.entries(props.tags).reduce(\n            (acc, [key, value]) => ({ ...acc, [key]: value }),\n            {},\n          )\n        : undefined;\n\n      try {\n        // Create the queue\n        const createResponse = await client.send(\n          new CreateQueueCommand({\n            QueueName: queueName,\n            Attributes: attributes,\n            tags,\n          }),\n        );\n\n        // Get queue attributes\n        const attributesResponse = await client.send(\n          new GetQueueAttributesCommand({\n            QueueUrl: createResponse.QueueUrl,\n            AttributeNames: [\"QueueArn\"],\n          }),\n        );\n\n        return this({\n          ...props,\n          arn: attributesResponse.Attributes!.QueueArn!,\n          url: createResponse.QueueUrl!,\n        });\n      } catch (error: any) {\n        if (error.name === \"QueueAlreadyExists\") {\n          // Get existing queue URL\n          const urlResponse = await client.send(\n            new GetQueueUrlCommand({\n              QueueName: queueName,\n            }),\n          );\n\n          // Get queue attributes\n          const attributesResponse = await client.send(\n            new GetQueueAttributesCommand({\n              QueueUrl: urlResponse.QueueUrl,\n              AttributeNames: [\"QueueArn\"],\n            }),\n          );\n\n          return this({\n            ...props,\n            arn: attributesResponse.Attributes!.QueueArn!,\n            url: urlResponse.QueueUrl!,\n          });\n        } else if (error.name === \"QueueDeletedRecently\") {\n          // Queue was recently deleted, wait and retry\n          const maxRetries = 3;\n          let retryCount = 0;\n\n          while (retryCount < maxRetries) {\n            try {\n              // Wait for 60 seconds before retrying\n              await new Promise((resolve) => setTimeout(resolve, 61000));\n\n              // Retry creating the queue\n              const createResponse = await client.send(\n                new CreateQueueCommand({\n                  QueueName: queueName,\n                  Attributes: attributes,\n                  tags,\n                }),\n              );\n\n              // Get queue attributes\n              const attributesResponse = await client.send(\n                new GetQueueAttributesCommand({\n                  QueueUrl: createResponse.QueueUrl,\n                  AttributeNames: [\"QueueArn\"],\n                }),\n              );\n\n              return this({\n                ...props,\n                arn: attributesResponse.Attributes!.QueueArn!,\n                url: createResponse.QueueUrl!,\n              });\n            } catch (retryError: any) {\n              if (\n                retryError.name !== \"QueueDeletedRecently\" ||\n                retryCount === maxRetries - 1\n              ) {\n                throw retryError;\n              }\n              retryCount++;\n            }\n          }\n        }\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/aws/role.ts\n```ts\nimport {\n  AttachRolePolicyCommand,\n  CreateRoleCommand,\n  DeleteRoleCommand,\n  DeleteRolePolicyCommand,\n  DetachRolePolicyCommand,\n  EntityAlreadyExistsException,\n  GetRoleCommand,\n  IAMClient,\n  ListAttachedRolePoliciesCommand,\n  NoSuchEntityException,\n  PutRolePolicyCommand,\n  type Tag,\n  TagRoleCommand,\n  UpdateAssumeRolePolicyCommand,\n  UpdateRoleCommand,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\nimport type { PolicyDocument } from \"./policy\";\n\n/**\n * Properties for creating or updating an IAM role\n */\nexport interface RoleProps {\n  /**\n   * Name of the IAM role\n   */\n  roleName: string;\n\n  /**\n   * Policy that defines which entities can assume this role\n   */\n  assumeRolePolicy: PolicyDocument;\n\n  /**\n   * Optional description of the role's purpose\n   */\n  description?: string;\n\n  /**\n   * Optional path prefix for the role\n   */\n  path?: string;\n\n  /**\n   * Maximum session duration in seconds when assumed\n   * Default: 3600 seconds (1 hour)\n   */\n  maxSessionDuration?: number;\n\n  /**\n   * ARN of the policy used to set the permissions boundary\n   */\n  permissionsBoundary?: string;\n\n  /**\n   * Inline policies to embed in the role\n   * Each policy must have a unique name and policy document\n   */\n  policies?: Array<{\n    policyName: string;\n    policyDocument: PolicyDocument;\n  }>;\n\n  /**\n   * List of managed policy ARNs to attach to the role\n   */\n  managedPolicyArns?: string[];\n\n  /**\n   * Resource tags for the role\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after IAM role creation/update\n */\nexport interface Role extends Resource<\"iam::Role\">, RoleProps {\n  /**\n   * ARN of the role\n   */\n  arn: string;\n\n  /**\n   * Unique identifier for the role\n   */\n  uniqueId: string;\n\n  /**\n   * The stable and unique string identifying the role\n   */\n  roleId: string;\n\n  /**\n   * When the role was created\n   */\n  createDate: Date;\n}\n\n/**\n * AWS IAM Role Resource\n *\n * Creates and manages IAM roles with support for inline policies, managed policies,\n * and automatic cleanup of attached policies during deletion.\n *\n * @example\n * // Create a basic Lambda execution role with inline policy\n * const basicRole = await Role(\"lambda-role\", {\n *   roleName: \"lambda-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Basic Lambda execution role\",\n *   tags: {\n *     Environment: \"production\"\n *   },\n *   policies: [{\n *     policyName: \"logs\",\n *     policyDocument: {\n *       Version: \"2012-10-17\",\n *       Statement: [{\n *         Effect: \"Allow\",\n *         Action: [\n *           \"logs:CreateLogGroup\",\n *           \"logs:CreateLogStream\",\n *           \"logs:PutLogEvents\"\n *         ],\n *         Resource: \"*\"\n *       }]\n *     }\n *   }]\n * });\n *\n * @example\n * // Create a role with AWS managed policies\n * const managedRole = await Role(\"readonly-role\", {\n *   roleName: \"readonly-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Role with managed policies\",\n *   managedPolicyArns: [\n *     \"arn:aws:iam::aws:policy/ReadOnlyAccess\"\n *   ],\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a role with multiple inline policies and custom session duration\n * const customRole = await Role(\"custom-role\", {\n *   roleName: \"custom-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Role with multiple policies\",\n *   maxSessionDuration: 7200,\n *   policies: [\n *     {\n *       policyName: \"logs\",\n *       policyDocument: {\n *         Version: \"2012-10-17\",\n *         Statement: [{\n *           Effect: \"Allow\",\n *           Action: [\n *             \"logs:CreateLogGroup\",\n *             \"logs:CreateLogStream\",\n *             \"logs:PutLogEvents\"\n *           ],\n *           Resource: \"*\"\n *         }]\n *       }\n *     },\n *     {\n *       policyName: \"s3\",\n *       policyDocument: {\n *         Version: \"2012-10-17\",\n *         Statement: [{\n *           Effect: \"Allow\",\n *           Action: \"s3:ListBucket\",\n *           Resource: \"*\"\n *         }]\n *       }\n *     }\n *   ],\n *   tags: {\n *     Environment: \"production\",\n *     Updated: \"true\"\n *   }\n * });\n */\nexport const Role = Resource(\n  \"iam::Role\",\n  async function (\n    this: Context<Role>,\n    id: string,\n    props: RoleProps\n  ): Promise<Role> {\n    const client = new IAMClient({});\n\n    if (this.phase === \"delete\") {\n      try {\n        // Delete any inline policies first\n        if (props.policies) {\n          for (const policy of props.policies) {\n            await ignore(NoSuchEntityException.name, () =>\n              client.send(\n                new DeleteRolePolicyCommand({\n                  RoleName: props.roleName,\n                  PolicyName: policy.policyName,\n                })\n              )\n            );\n          }\n        }\n\n        // We need to detach managed policies before deleting the role\n        // First, get all attached policies\n        try {\n          const attachedPoliciesResponse = await client.send(\n            new ListAttachedRolePoliciesCommand({\n              RoleName: props.roleName,\n            })\n          );\n\n          // Detach all managed policies\n          const attachedPolicies =\n            attachedPoliciesResponse.AttachedPolicies || [];\n          for (const policy of attachedPolicies) {\n            await ignore(NoSuchEntityException.name, () =>\n              client.send(\n                new DetachRolePolicyCommand({\n                  RoleName: props.roleName,\n                  PolicyArn: policy.PolicyArn!,\n                })\n              )\n            );\n          }\n        } catch (error: any) {\n          if (error.name !== NoSuchEntityException.name) {\n            throw error;\n          }\n          // Role doesn't exist, no need to continue with detaching policies\n        }\n\n        // Try to delete the role, ignoring if it doesn't exist\n        await ignore(NoSuchEntityException.name, () =>\n          client.send(\n            new DeleteRoleCommand({\n              RoleName: props.roleName,\n            })\n          )\n        );\n      } catch (error: any) {\n        // If we get any other error besides NoSuchEntityException, log it but don't fail\n        // This ensures the resource is still marked as destroyed\n        if (error.name !== NoSuchEntityException.name) {\n          console.error(`Error deleting role ${props.roleName}:`, error);\n        }\n      }\n\n      // Always return destroyed state regardless of any errors\n      return this.destroy();\n    }\n\n    const assumeRolePolicyDocument = JSON.stringify(props.assumeRolePolicy);\n    let role;\n\n    try {\n      if (this.phase === \"create\") {\n        // Try to create the role\n        await client.send(\n          new CreateRoleCommand({\n            RoleName: props.roleName,\n            AssumeRolePolicyDocument: assumeRolePolicyDocument,\n            Description: props.description,\n            Path: props.path,\n            MaxSessionDuration: props.maxSessionDuration,\n            PermissionsBoundary: props.permissionsBoundary,\n            Tags: [\n              ...Object.entries(props.tags || {}).map(([Key, Value]) => ({\n                Key,\n                Value,\n              })),\n              {\n                Key: \"alchemy_stage\",\n                Value: this.stage,\n              },\n              {\n                Key: \"alchemy_resource\",\n                Value: this.id,\n              },\n            ],\n          })\n        );\n      }\n    } catch (error: any) {\n      if (\n        error instanceof EntityAlreadyExistsException &&\n        this.phase === \"create\"\n      ) {\n        // Check if we were the ones who created it\n        const existingRole = await client.send(\n          new GetRoleCommand({\n            RoleName: props.roleName,\n          })\n        );\n        const roleTags =\n          existingRole.Role?.Tags?.reduce(\n            (acc, tag) => {\n              acc[tag.Key!] = tag.Value!;\n              return acc;\n            },\n            {} as Record<string, string>\n          ) || {};\n\n        if (\n          roleTags.alchemy_stage !== this.stage ||\n          roleTags.alchemy_resource !== this.id\n        ) {\n          throw error;\n        }\n      } else if (error.name !== NoSuchEntityException.name) {\n        throw error;\n      }\n    }\n\n    // Get or update the role\n    role = await client.send(\n      new GetRoleCommand({\n        RoleName: props.roleName,\n      })\n    );\n\n    // Update assume role policy if it changed\n    if (role.Role?.AssumeRolePolicyDocument !== assumeRolePolicyDocument) {\n      await client.send(\n        new UpdateAssumeRolePolicyCommand({\n          RoleName: props.roleName,\n          PolicyDocument: assumeRolePolicyDocument,\n        })\n      );\n    }\n\n    // Update role description and max session duration if they changed\n    if (\n      role.Role?.Description !== props.description ||\n      role.Role?.MaxSessionDuration !== props.maxSessionDuration\n    ) {\n      await client.send(\n        new UpdateRoleCommand({\n          RoleName: props.roleName,\n          Description: props.description,\n          MaxSessionDuration: props.maxSessionDuration,\n        })\n      );\n    }\n\n    // Update tags\n    const newTags = {\n      ...props.tags,\n      alchemy_stage: this.stage,\n      alchemy_resource: this.id,\n    };\n    const tags: Tag[] = Object.entries(newTags).map(([Key, Value]) => ({\n      Key,\n      Value,\n    }));\n    await client.send(\n      new TagRoleCommand({\n        RoleName: props.roleName,\n        Tags: tags,\n      })\n    );\n\n    // Handle policy changes\n    const previousPolicies =\n      this.phase === \"update\" ? this.output!.policies || [] : [];\n    const currentPolicies = props.policies || [];\n\n    // Delete policies that were removed\n    for (const oldPolicy of previousPolicies) {\n      if (\n        !currentPolicies.some(\n          (p: { policyName: string }) => p.policyName === oldPolicy.policyName\n        )\n      ) {\n        await ignore(NoSuchEntityException.name, () =>\n          client.send(\n            new DeleteRolePolicyCommand({\n              RoleName: props.roleName,\n              PolicyName: oldPolicy.policyName,\n            })\n          )\n        );\n      }\n    }\n\n    // Update or create policies\n    for (const policy of currentPolicies) {\n      const oldPolicy = previousPolicies.find(\n        (p) => p.policyName === policy.policyName\n      );\n      if (\n        !oldPolicy ||\n        JSON.stringify(oldPolicy.policyDocument) !==\n          JSON.stringify(policy.policyDocument)\n      ) {\n        await client.send(\n          new PutRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyName: policy.policyName,\n            PolicyDocument: JSON.stringify(policy.policyDocument),\n          })\n        );\n      }\n    }\n\n    // Handle managed policy attachments\n    // Get currently attached policies\n    const attachedPoliciesResponse = await client.send(\n      new ListAttachedRolePoliciesCommand({\n        RoleName: props.roleName,\n      })\n    );\n\n    const currentAttachedPolicies =\n      attachedPoliciesResponse.AttachedPolicies || [];\n    const currentPolicyArns = currentAttachedPolicies.map((p) => p.PolicyArn!);\n\n    // If we're updating, use an empty array as default when managedPolicyArns is undefined\n    // to ensure we detach all managed policies\n    const desiredPolicyArns = props.managedPolicyArns || [];\n\n    // Detach policies that are no longer needed\n    for (const policyArn of currentPolicyArns) {\n      if (!desiredPolicyArns.includes(policyArn)) {\n        await client.send(\n          new DetachRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyArn: policyArn,\n          })\n        );\n      }\n    }\n\n    // Attach new policies that weren't attached before\n    for (const policyArn of desiredPolicyArns) {\n      if (!currentPolicyArns.includes(policyArn)) {\n        await client.send(\n          new AttachRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyArn: policyArn,\n          })\n        );\n      }\n    }\n\n    if (!role?.Role) {\n      throw new Error(`Failed to create or update role ${props.roleName}`);\n    }\n\n    return this({\n      ...props,\n      arn: role.Role.Arn!,\n      uniqueId: role.Role.RoleId!,\n      roleId: role.Role.RoleId!,\n      roleName: role.Role.RoleName ?? props.roleName,\n      createDate: role.Role.CreateDate!,\n    });\n  }\n);\n\n```\n\n// alchemy/src/aws/ses.ts\n```ts\nimport {\n  CreateConfigurationSetCommand,\n  CreateEmailIdentityCommand,\n  DeleteConfigurationSetCommand,\n  DeleteEmailIdentityCommand,\n  type DeliveryOptions,\n  GetConfigurationSetCommand,\n  GetEmailIdentityCommand,\n  NotFoundException,\n  PutConfigurationSetDeliveryOptionsCommand,\n  PutConfigurationSetReputationOptionsCommand,\n  PutConfigurationSetSendingOptionsCommand,\n  PutConfigurationSetSuppressionOptionsCommand,\n  PutConfigurationSetTrackingOptionsCommand,\n  PutEmailIdentityDkimAttributesCommand,\n  type ReputationOptions,\n  SESv2Client,\n  type SendingOptions,\n  type SuppressionOptions,\n  type TrackingOptions,\n} from \"@aws-sdk/client-sesv2\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for configuring AWS SES resources\n */\nexport interface SESProps {\n  /**\n   * Name of the configuration set\n   * Used to group email sending and tracking settings\n   */\n  configurationSetName?: string;\n\n  /**\n   * Email identity to verify (email address or domain)\n   * For domains, use the format \"example.com\"\n   * For email addresses, use the format \"user@example.com\"\n   */\n  emailIdentity?: string;\n\n  /**\n   * Whether to enable DKIM signing for the email identity\n   * DKIM helps prevent email spoofing by verifying sender authenticity\n   */\n  enableDkim?: boolean;\n\n  /**\n   * Sending options for the configuration set\n   * Controls whether email sending is enabled and related settings\n   */\n  sendingOptions?: SendingOptions;\n\n  /**\n   * Reputation options for the configuration set\n   * Controls reputation tracking and metrics collection\n   */\n  reputationOptions?: ReputationOptions;\n\n  /**\n   * Tracking options for the configuration set\n   * Controls open and click tracking with optional custom domains\n   */\n  trackingOptions?: TrackingOptions;\n\n  /**\n   * Suppression options for the configuration set\n   * Controls how bounces and complaints are handled\n   */\n  suppressionOptions?: SuppressionOptions;\n\n  /**\n   * Delivery options for the configuration set\n   * Controls TLS settings and sending pool configuration\n   */\n  deliveryOptions?: DeliveryOptions;\n\n  /**\n   * Tags to apply to the SES resources\n   * Key-value pairs for resource organization\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after SES resource creation/update\n */\nexport interface SES extends Resource<\"aws::SES\">, SESProps {\n  /**\n   * ARN of the configuration set if created\n   * Format: arn:aws:ses:region:account-id:configuration-set/name\n   */\n  configurationSetArn?: string;\n\n  /**\n   * Email identity verification status if an identity was created\n   * Can be \"PENDING\" or \"VERIFIED\"\n   */\n  emailIdentityVerificationStatus?: string;\n\n  /**\n   * DKIM verification status if DKIM was enabled\n   * Can be \"PENDING\", \"SUCCESS\", \"FAILED\", \"TEMPORARY_FAILURE\", or \"NOT_STARTED\"\n   */\n  dkimVerificationStatus?: string;\n\n  /**\n   * Email identity ARN if an identity was created\n   * Format: arn:aws:ses:region:account-id:identity/name\n   */\n  emailIdentityArn?: string;\n}\n\n/**\n * AWS SES Resource\n *\n * Creates and manages Amazon Simple Email Service (SES) configuration sets and email identities.\n * Supports email sending configuration, DKIM signing, and identity verification.\n *\n * @example\n * // Create a configuration set with sending options\n * const configSet = await SES(\"email-config\", {\n *   configurationSetName: \"my-email-config\",\n *   sendingOptions: {\n *     SendingEnabled: true\n *   },\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"notifications\"\n *   }\n * });\n *\n * @example\n * // Create and verify a domain identity with DKIM\n * const domainIdentity = await SES(\"domain-identity\", {\n *   emailIdentity: \"example.com\",\n *   enableDkim: true,\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"transactional-emails\"\n *   }\n * });\n *\n * @example\n * // Update configuration set sending options\n * const updatedConfig = await SES(\"email-config\", {\n *   configurationSetName: \"my-email-config\",\n *   sendingOptions: {\n *     SendingEnabled: false\n *   },\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"notifications\",\n *     Updated: \"true\"\n *   }\n * });\n */\nexport const SES = Resource(\n  \"aws::SES\",\n  async function (\n    this: Context<SES>,\n    id: string,\n    props: SESProps,\n  ): Promise<SES> {\n    // Create SES client\n    const client = new SESv2Client({});\n\n    // Resource ID is either based on the configuration set name or email identity\n    // const id =\n    //   props.configurationSetName || props.emailIdentity || this.resourceID;\n\n    // Handle deletion\n    if (this.phase === \"delete\") {\n      const output = this.output;\n\n      // Delete configuration set if it exists\n      if (output?.configurationSetName) {\n        await ignore(NotFoundException.name, () =>\n          client.send(\n            new DeleteConfigurationSetCommand({\n              ConfigurationSetName: output.configurationSetName,\n            }),\n          ),\n        );\n      }\n\n      // Delete email identity if it exists\n      if (output?.emailIdentity) {\n        await ignore(NotFoundException.name, () =>\n          client.send(\n            new DeleteEmailIdentityCommand({\n              EmailIdentity: output.emailIdentity,\n            }),\n          ),\n        );\n      }\n\n      // Return empty output for delete\n      return this.destroy();\n    }\n\n    // Created resources\n    let configurationSetArn: string | undefined;\n    let emailIdentityArn: string | undefined;\n    let emailIdentityVerificationStatus: string | undefined;\n    let dkimVerificationStatus: string | undefined;\n\n    // Create or update configuration set if specified\n    if (props.configurationSetName) {\n      // Check if configuration set exists\n      let configSetExists = false;\n      try {\n        await client.send(\n          new GetConfigurationSetCommand({\n            ConfigurationSetName: props.configurationSetName,\n          }),\n        );\n        configSetExists = true;\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          configSetExists = false;\n        } else {\n          throw error;\n        }\n      }\n\n      if (configSetExists) {\n        // Update existing configuration set using appropriate update commands\n        if (props.sendingOptions) {\n          await client.send(\n            new PutConfigurationSetSendingOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              SendingEnabled: props.sendingOptions.SendingEnabled,\n            }),\n          );\n        }\n\n        if (props.reputationOptions) {\n          await client.send(\n            new PutConfigurationSetReputationOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              ReputationMetricsEnabled:\n                props.reputationOptions.ReputationMetricsEnabled,\n            }),\n          );\n        }\n\n        if (props.trackingOptions) {\n          await client.send(\n            new PutConfigurationSetTrackingOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              CustomRedirectDomain: props.trackingOptions.CustomRedirectDomain,\n            }),\n          );\n        }\n\n        if (props.suppressionOptions) {\n          await client.send(\n            new PutConfigurationSetSuppressionOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              SuppressedReasons: props.suppressionOptions.SuppressedReasons,\n            }),\n          );\n        }\n\n        if (props.deliveryOptions) {\n          await client.send(\n            new PutConfigurationSetDeliveryOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              TlsPolicy: props.deliveryOptions.TlsPolicy,\n              SendingPoolName: props.deliveryOptions.SendingPoolName,\n            }),\n          );\n        }\n\n        // In SESv2, the ARN isn't directly returned in the response\n        configurationSetArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:configuration-set/${props.configurationSetName}`;\n      } else {\n        // Create new configuration set\n        await client.send(\n          new CreateConfigurationSetCommand({\n            ConfigurationSetName: props.configurationSetName,\n            SendingOptions: props.sendingOptions,\n            ReputationOptions: props.reputationOptions,\n            TrackingOptions: props.trackingOptions,\n            SuppressionOptions: props.suppressionOptions,\n            DeliveryOptions: props.deliveryOptions,\n            Tags: Object.entries(props.tags || {}).map(([Key, Value]) => ({\n              Key,\n              Value,\n            })),\n          }),\n        );\n\n        // In SESv2, the ARN isn't directly returned in the response\n        configurationSetArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:configuration-set/${props.configurationSetName}`;\n      }\n    }\n\n    // Create or verify email identity if specified\n    if (props.emailIdentity) {\n      // Check if identity exists\n      let getIdentityResult;\n      try {\n        getIdentityResult = await client.send(\n          new GetEmailIdentityCommand({\n            EmailIdentity: props.emailIdentity,\n          }),\n        );\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          getIdentityResult = null;\n        } else {\n          throw error;\n        }\n      }\n\n      if (!getIdentityResult) {\n        // Create new email identity\n        const createIdentityResult = await client.send(\n          new CreateEmailIdentityCommand({\n            EmailIdentity: props.emailIdentity,\n            Tags: Object.entries(props.tags || {}).map(([Key, Value]) => ({\n              Key,\n              Value,\n            })),\n          }),\n        );\n\n        // If it's an email address, we don't need to explicitly verify in v2\n        // The verification email is automatically sent by SES in v2\n\n        // Store the identity information\n        emailIdentityArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:identity/${props.emailIdentity}`;\n        emailIdentityVerificationStatus =\n          createIdentityResult.VerifiedForSendingStatus\n            ? \"VERIFIED\"\n            : \"PENDING\";\n      } else {\n        // Store the identity information\n        emailIdentityArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:identity/${props.emailIdentity}`;\n        emailIdentityVerificationStatus =\n          getIdentityResult.VerifiedForSendingStatus ? \"VERIFIED\" : \"PENDING\";\n\n        // Update DKIM settings if requested\n        if (props.enableDkim !== undefined) {\n          if (props.enableDkim) {\n            await client.send(\n              new PutEmailIdentityDkimAttributesCommand({\n                EmailIdentity: props.emailIdentity,\n                SigningEnabled: true,\n              }),\n            );\n\n            // We can check the current status of DKIM\n            dkimVerificationStatus = \"PENDING\"; // Default to pending\n\n            // Get the updated identity to check DKIM status\n            const updatedIdentity = await client.send(\n              new GetEmailIdentityCommand({\n                EmailIdentity: props.emailIdentity,\n              }),\n            );\n\n            if (updatedIdentity.DkimAttributes?.Status) {\n              dkimVerificationStatus = updatedIdentity.DkimAttributes.Status;\n            }\n          }\n        }\n      }\n    }\n\n    // Return the resource output\n    return this({\n      ...props,\n      configurationSetArn,\n      emailIdentityArn,\n      emailIdentityVerificationStatus,\n      dkimVerificationStatus,\n    });\n  },\n);\n\n```\n\n// alchemy/src/aws/table.ts\n```ts\nimport {\n  CreateTableCommand,\n  DeleteTableCommand,\n  DescribeTableCommand,\n  DynamoDBClient,\n  InternalServerError,\n  type KeySchemaElement,\n  ResourceInUseException,\n  ResourceNotFoundException,\n} from \"@aws-sdk/client-dynamodb\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\nimport { withExponentialBackoff } from \"../util/retry\";\n\n/**\n * Properties for creating or updating a DynamoDB table\n */\nexport interface TableProps {\n  /**\n   * Name of the DynamoDB table\n   */\n  tableName: string;\n\n  /**\n   * Primary partition key (hash key) configuration\n   * Defines the main identifier for items in the table\n   */\n  partitionKey: {\n    /**\n     * Name of the partition key attribute\n     */\n    name: string;\n    /**\n     * Data type of the partition key\n     * S: String, N: Number, B: Binary\n     */\n    type: \"S\" | \"N\" | \"B\";\n  };\n\n  /**\n   * Optional sort key (range key) configuration\n   * Used to sort items with the same partition key\n   */\n  sortKey?: {\n    /**\n     * Name of the sort key attribute\n     */\n    name: string;\n    /**\n     * Data type of the sort key\n     * S: String, N: Number, B: Binary\n     */\n    type: \"S\" | \"N\" | \"B\";\n  };\n\n  /**\n   * Billing mode for the table\n   * PROVISIONED: Set read/write capacity units\n   * PAY_PER_REQUEST: Pay per request pricing\n   */\n  billingMode?: \"PROVISIONED\" | \"PAY_PER_REQUEST\";\n\n  /**\n   * Read capacity units when using PROVISIONED billing mode\n   * Default: 5\n   */\n  readCapacity?: number;\n\n  /**\n   * Write capacity units when using PROVISIONED billing mode\n   * Default: 5\n   */\n  writeCapacity?: number;\n\n  /**\n   * Tags to apply to the table\n   * Key-value pairs for resource organization\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after DynamoDB table creation/update\n */\nexport interface Table extends Resource<\"dynamo::Table\">, TableProps {\n  /**\n   * ARN of the table\n   * Format: arn:aws:dynamodb:region:account-id:table/table-name\n   */\n  arn: string;\n\n  /**\n   * ARN of the table's stream if enabled\n   * Format: arn:aws:dynamodb:region:account-id:table/table-name/stream/timestamp\n   */\n  streamArn?: string;\n\n  /**\n   * Unique identifier for the table\n   */\n  tableId: string;\n}\n\n/**\n * AWS DynamoDB Table Resource\n *\n * Creates and manages DynamoDB tables with support for partition and sort keys,\n * flexible billing modes, and automatic table status monitoring.\n *\n * @example\n * // Create a table with partition and sort key\n * const table = await Table(\"user-events\", {\n *   tableName: \"user-events\",\n *   partitionKey: {\n *     name: \"id\",\n *     type: \"S\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"N\"\n *   },\n *   tags: {\n *     Environment: \"test\"\n *   }\n * });\n *\n * @example\n * // Create a table with provisioned capacity\n * const table = await Table(\"high-throughput\", {\n *   tableName: \"high-throughput\",\n *   partitionKey: {\n *     name: \"userId\",\n *     type: \"S\"\n *   },\n *   billingMode: \"PROVISIONED\",\n *   readCapacity: 100,\n *   writeCapacity: 50\n * });\n */\nexport const Table = Resource(\n  \"dynamo::Table\",\n  async function (\n    this: Context<Table>,\n    id: string,\n    props: TableProps,\n  ): Promise<Table> {\n    const client = new DynamoDBClient({});\n\n    if (this.phase === \"delete\") {\n      await withExponentialBackoff(\n        async () => {\n          await ignore(ResourceNotFoundException.name, () =>\n            client.send(\n              new DeleteTableCommand({\n                TableName: props.tableName,\n              }),\n            ),\n          );\n        },\n        (error) =>\n          error instanceof ResourceInUseException ||\n          error instanceof InternalServerError,\n        10, // Max attempts\n        200, // Initial delay in ms\n      );\n\n      // Wait for table to be deleted\n      let tableDeleted = false;\n      let retryCount = 0;\n      const maxRetries = 60; // Wait up to 60 seconds\n\n      while (!tableDeleted && retryCount < maxRetries) {\n        try {\n          await client.send(\n            new DescribeTableCommand({\n              TableName: props.tableName,\n            }),\n          );\n          // If we get here, table still exists\n          retryCount++;\n          // Increasing delay for each retry with some jitter\n          const delay = Math.min(1000 * (1 + 0.1 * Math.random()), 5000);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        } catch (error) {\n          if (error instanceof ResourceNotFoundException) {\n            tableDeleted = true;\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      if (!tableDeleted) {\n        throw new Error(\n          `Timed out waiting for table ${props.tableName} to be deleted`,\n        );\n      }\n\n      return this.destroy();\n    } else {\n      // Setup for table creation\n      const attributeDefinitions = [\n        {\n          AttributeName: props.partitionKey.name,\n          AttributeType: props.partitionKey.type,\n        },\n      ];\n\n      const keySchema: KeySchemaElement[] = [\n        {\n          AttributeName: props.partitionKey.name,\n          KeyType: \"HASH\",\n        },\n      ];\n\n      if (props.sortKey) {\n        attributeDefinitions.push({\n          AttributeName: props.sortKey.name,\n          AttributeType: props.sortKey.type,\n        });\n        keySchema.push({\n          AttributeName: props.sortKey.name,\n          KeyType: \"RANGE\",\n        });\n      }\n\n      // Attempt to create the table with exponential backoff for ResourceInUseException\n      await withExponentialBackoff(\n        async () => {\n          try {\n            // First check if table already exists\n            const describeResponse = await client.send(\n              new DescribeTableCommand({\n                TableName: props.tableName,\n              }),\n            );\n\n            // If table exists and is ACTIVE, no need to create it\n            if (describeResponse.Table?.TableStatus === \"ACTIVE\") {\n              return;\n            }\n\n            // If table exists but not ACTIVE, wait for it in the polling loop below\n            if (describeResponse.Table) {\n              return;\n            }\n          } catch (error) {\n            if (error instanceof ResourceNotFoundException) {\n              // Table doesn't exist, try to create it\n              await client.send(\n                new CreateTableCommand({\n                  TableName: props.tableName,\n                  AttributeDefinitions: attributeDefinitions,\n                  KeySchema: keySchema,\n                  BillingMode: props.billingMode || \"PAY_PER_REQUEST\",\n                  ProvisionedThroughput:\n                    props.billingMode === \"PROVISIONED\"\n                      ? {\n                          ReadCapacityUnits: props.readCapacity || 5,\n                          WriteCapacityUnits: props.writeCapacity || 5,\n                        }\n                      : undefined,\n                  Tags: props.tags\n                    ? Object.entries(props.tags).map(([Key, Value]) => ({\n                        Key,\n                        Value,\n                      }))\n                    : undefined,\n                }),\n              );\n            } else {\n              throw error;\n            }\n          }\n        },\n        (error) => error instanceof ResourceInUseException,\n        10, // Max attempts\n        200, // Initial delay in ms\n      );\n\n      // Wait for table to be active with timeout\n      let tableActive = false;\n      let tableDescription;\n      let retryCount = 0;\n      const maxRetries = 60; // Wait up to 60 seconds\n\n      while (!tableActive && retryCount < maxRetries) {\n        try {\n          const response = await client.send(\n            new DescribeTableCommand({\n              TableName: props.tableName,\n            }),\n          );\n\n          tableActive = response.Table?.TableStatus === \"ACTIVE\";\n          if (tableActive) {\n            tableDescription = response.Table;\n          } else {\n            retryCount++;\n            // Increasing delay for each retry with some jitter\n            const delay = Math.min(1000 * (1 + 0.1 * Math.random()), 5000);\n            await new Promise((resolve) => setTimeout(resolve, delay));\n          }\n        } catch (error) {\n          retryCount++;\n          if (!(error instanceof ResourceNotFoundException)) {\n            throw error;\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1000));\n        }\n      }\n\n      if (!tableActive) {\n        throw new Error(\n          `Timed out waiting for table ${props.tableName} to become active`,\n        );\n      }\n\n      return this({\n        ...props,\n        arn: tableDescription!.TableArn!,\n        streamArn: tableDescription!.LatestStreamArn,\n        tableId: tableDescription!.TableId!,\n      });\n    }\n  },\n);\n\n```"
      },
      {
        "role": "assistant",
        "content": "{\"groups\":[{\"category\":\"Resource\",\"filename\":\"function.ts\",\"identifier\":\"Function\"},{\"category\":\"Resource\",\"filename\":\"table.ts\",\"identifier\":\"Table\"},{\"category\":\"Utility\",\"filename\":\"account-id.ts\",\"identifier\":\"AccountId\"},{\"category\":\"Resource\",\"filename\":\"policy-attachment.ts\",\"identifier\":\"PolicyAttachment\"},{\"category\":\"Resource\",\"filename\":\"role.ts\",\"identifier\":\"Role\"},{\"category\":\"Resource\",\"filename\":\"policy.ts\",\"identifier\":\"Policy\"},{\"category\":\"Types\",\"filename\":\"credentials.ts\",\"identifier\":\"AwsCredentials\"},{\"category\":\"Resource\",\"filename\":\"ses.ts\",\"identifier\":\"SES\"},{\"category\":\"Resource\",\"filename\":\"bucket.ts\",\"identifier\":\"Bucket\"},{\"category\":\"Resource\",\"filename\":\"queue.ts\",\"identifier\":\"Queue\"}]}"
      }
    ],
    "createdAt": 1744513281044,
    "Kind": "ai::Object",
    "ID": "docs/aws",
    "FQN": "github:alchemy/prod/docs/docs/aws",
    "Seq": 41
  },
  "props": {
    "model": {
      "id": "o3-mini",
      "provider": "openai",
      "options": {
        "reasoningEffort": "high"
      }
    },
    "freeze": true,
    "temperature": 0.1,
    "schema": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "system": "You are a technical writer tasked with identifying the distinct documents that need to be written for a document group (folder) in a documentation site.\nYou will be provided with a list of documents and instructions on how to classify them.\nEach document has a title, file name, and category.\n    \n",
    "prompt": "Identify and classify the documents that need to be written for the '      alchemy/src/aws' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/aws Service has the following resources:\n[function.ts](alchemy/src/aws/function.ts)\n\n[table.ts](alchemy/src/aws/table.ts)\n\n[account-id.ts](alchemy/src/aws/account-id.ts)\n\n[policy-attachment.ts](alchemy/src/aws/policy-attachment.ts)\n\n[role.ts](alchemy/src/aws/role.ts)\n\n[policy.ts](alchemy/src/aws/policy.ts)\n\n[credentials.ts](alchemy/src/aws/credentials.ts)\n\n[ses.ts](alchemy/src/aws/ses.ts)\n\n[bucket.ts](alchemy/src/aws/bucket.ts)\n\n[queue.ts](alchemy/src/aws/queue.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...), or it is the Workflow or DurableObject classes.\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/aws/account-id.ts\n```ts\nimport { GetCallerIdentityCommand, STSClient } from \"@aws-sdk/client-sts\";\n\nconst sts = new STSClient({});\n\nexport type AccountId = string & {\n  readonly __brand: \"AccountId\";\n};\n\n/**\n * Helper to get the current AWS account ID\n */\nexport async function AccountId(): Promise<AccountId> {\n  const identity = await sts.send(new GetCallerIdentityCommand({}));\n  return identity.Account! as AccountId;\n}\n\n```\n\n// alchemy/src/aws/bucket.ts\n```ts\nimport {\n  CreateBucketCommand,\n  DeleteBucketCommand,\n  GetBucketAclCommand,\n  GetBucketLocationCommand,\n  GetBucketTaggingCommand,\n  GetBucketVersioningCommand,\n  HeadBucketCommand,\n  NoSuchBucket,\n  PutBucketTaggingCommand,\n  S3Client,\n} from \"@aws-sdk/client-s3\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating an S3 bucket\n */\nexport interface BucketProps {\n  /**\n   * The name of the bucket. Must be globally unique across all AWS accounts.\n   * Should be lowercase alphanumeric characters or hyphens.\n   */\n  bucketName: string;\n\n  /**\n   * Optional tags to apply to the bucket for organization and cost tracking.\n   * Each tag is a key-value pair.\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after S3 bucket creation/update\n */\nexport interface Bucket extends Resource<\"s3::Bucket\">, BucketProps {\n  /**\n   * The ARN (Amazon Resource Name) of the bucket\n   * Format: arn:aws:s3:::bucket-name\n   */\n  arn: string;\n\n  /**\n   * The global domain name for the bucket\n   * Format: bucket-name.s3.amazonaws.com\n   */\n  bucketDomainName: string;\n\n  /**\n   * The regional domain name for the bucket\n   * Format: bucket-name.s3.region.amazonaws.com\n   */\n  bucketRegionalDomainName?: string;\n\n  /**\n   * The S3 hosted zone ID for the region where the bucket resides\n   * Used for DNS configuration with Route 53\n   */\n  hostedZoneId?: string;\n\n  /**\n   * The AWS region where the bucket is located\n   */\n  region?: string;\n\n  /**\n   * The website endpoint URL if static website hosting is enabled\n   * Format: http://bucket-name.s3-website-region.amazonaws.com\n   */\n  websiteEndpoint?: string;\n\n  /**\n   * The website domain if static website hosting is enabled\n   * Format: bucket-name.s3-website-region.amazonaws.com\n   */\n  websiteDomain?: string;\n\n  /**\n   * Whether versioning is enabled for the bucket\n   */\n  versioningEnabled?: boolean;\n\n  /**\n   * The canned ACL applied to the bucket\n   * Common values: private, public-read, public-read-write, authenticated-read\n   */\n  acl?: string;\n}\n\n/**\n * AWS S3 Bucket Resource\n *\n * Creates and manages Amazon S3 buckets with support for versioning, tags, and regional configuration.\n * S3 buckets provide scalable object storage for any type of data, with features like versioning,\n * lifecycle policies, and fine-grained access control.\n *\n * @example\n * // Create a basic S3 bucket with default settings\n * const basicBucket = await Bucket(\"my-app-storage\", {\n *   bucketName: \"my-app-storage\",\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"my-app\"\n *   }\n * });\n *\n * @example\n * // Create a bucket with versioning enabled and specific tags\n * const versionedBucket = await Bucket(\"document-archive\", {\n *   bucketName: \"document-archive\",\n *   tags: {\n *     Environment: \"production\",\n *     Purpose: \"document-storage\",\n *     Versioning: \"enabled\"\n *   }\n * });\n *\n * @example\n * // Create a development bucket with minimal configuration\n * const devBucket = await Bucket(\"dev-testing\", {\n *   bucketName: \"dev-testing\",\n *   tags: {\n *     Environment: \"development\",\n *     Temporary: \"true\"\n *   }\n * });\n */\nexport const Bucket = Resource(\n  \"s3::Bucket\",\n  async function (this: Context<Bucket>, id: string, props: BucketProps) {\n    const client = new S3Client({});\n\n    if (this.phase === \"delete\") {\n      await ignore(NoSuchBucket.name, () =>\n        client.send(\n          new DeleteBucketCommand({\n            Bucket: props.bucketName,\n          }),\n        ),\n      );\n      return this.destroy();\n    } else {\n      try {\n        // Check if bucket exists\n        await client.send(\n          new HeadBucketCommand({\n            Bucket: props.bucketName,\n          }),\n        );\n\n        // Update tags if they changed and bucket exists\n        if (this.phase === \"update\" && props.tags) {\n          await client.send(\n            new PutBucketTaggingCommand({\n              Bucket: props.bucketName,\n              Tagging: {\n                TagSet: Object.entries(props.tags).map(([Key, Value]) => ({\n                  Key,\n                  Value,\n                })),\n              },\n            }),\n          );\n        }\n      } catch (error: any) {\n        if (error.name === \"NotFound\") {\n          // Create bucket if it doesn't exist\n          await client.send(\n            new CreateBucketCommand({\n              Bucket: props.bucketName,\n              // Add tags during creation if specified\n              ...(props.tags && {\n                Tagging: {\n                  TagSet: Object.entries(props.tags).map(([Key, Value]) => ({\n                    Key,\n                    Value,\n                  })),\n                },\n              }),\n            }),\n          );\n        } else {\n          throw error;\n        }\n      }\n\n      // Get bucket details\n      const [locationResponse, versioningResponse, aclResponse] =\n        await Promise.all([\n          client.send(\n            new GetBucketLocationCommand({ Bucket: props.bucketName }),\n          ),\n          client.send(\n            new GetBucketVersioningCommand({ Bucket: props.bucketName }),\n          ),\n          client.send(new GetBucketAclCommand({ Bucket: props.bucketName })),\n        ]);\n\n      const region = locationResponse.LocationConstraint || \"us-east-1\";\n\n      // Get tags if they exist\n      let tags = props.tags;\n      if (!tags) {\n        try {\n          const taggingResponse = await client.send(\n            new GetBucketTaggingCommand({ Bucket: props.bucketName }),\n          );\n          tags = Object.fromEntries(\n            taggingResponse.TagSet?.map(({ Key, Value }) => [Key, Value]) || [],\n          );\n        } catch (error: any) {\n          if (error.name !== \"NoSuchTagSet\") {\n            throw error;\n          }\n        }\n      }\n\n      return this({\n        bucketName: props.bucketName,\n        arn: `arn:aws:s3:::${props.bucketName}`,\n        bucketDomainName: `${props.bucketName}.s3.amazonaws.com`,\n        bucketRegionalDomainName: `${props.bucketName}.s3.${region}.amazonaws.com`,\n        region,\n        hostedZoneId: getHostedZoneId(region),\n        versioningEnabled: versioningResponse.Status === \"Enabled\",\n        acl: aclResponse.Grants?.[0]?.Permission?.toLowerCase(),\n        ...(tags && { tags }),\n      });\n    }\n  },\n);\n\n/**\n * Helper function to get S3 hosted zone IDs by region\n *\n * Returns the S3 hosted zone ID for a given AWS region. These IDs are used when\n * configuring Route 53 DNS records that point to S3 buckets. If the region is not\n * found in the mapping, defaults to the us-east-1 hosted zone ID.\n *\n * @param region - The AWS region code (e.g., us-east-1, eu-west-1)\n * @returns The S3 hosted zone ID for the region\n */\nfunction getHostedZoneId(region: string): string {\n  const hostedZoneIds: Record<string, string> = {\n    \"us-east-1\": \"Z3AQBSTGFYJSTF\",\n    \"us-east-2\": \"Z2O1EMRO9K5GLX\",\n    \"us-west-1\": \"Z2F56UZL2M1ACD\",\n    \"us-west-2\": \"Z3BJ6K6RIION7M\",\n    \"af-south-1\": \"Z11KHD8FBVPUYU\",\n    \"ap-east-1\": \"ZNB98KWMFR0R6\",\n    \"ap-south-1\": \"Z11RGJOFQNVJUP\",\n    \"ap-northeast-1\": \"Z2M4EHUR26P7ZW\",\n    \"ap-northeast-2\": \"Z3W03O7B5YMIYP\",\n    \"ap-northeast-3\": \"Z2YQB5RD63NC85\",\n    \"ap-southeast-1\": \"Z3O0J2DXBE1FTB\",\n    \"ap-southeast-2\": \"Z1WCIGYICN2BYD\",\n    \"ca-central-1\": \"Z1QDHH18159H29\",\n    \"eu-central-1\": \"Z21DNDUVLTQW6Q\",\n    \"eu-west-1\": \"Z1BKCTXD74EZPE\",\n    \"eu-west-2\": \"Z3GKZC51ZF0DB4\",\n    \"eu-west-3\": \"Z3R1K369G5AVDG\",\n    \"eu-north-1\": \"Z3BAZG2TWCNX0D\",\n    \"eu-south-1\": \"Z30OZKI7KPW7MI\",\n    \"me-south-1\": \"Z1MPMWCPA7YB62\",\n    \"sa-east-1\": \"Z7KQH4QJS55SO\",\n  };\n  return hostedZoneIds[region] || \"Z3AQBSTGFYJSTF\"; // Default to us-east-1 if region not found\n}\n\n```\n\n// alchemy/src/aws/credentials.ts\n```ts\nimport type { Secret } from \"../secret\";\n\nexport interface AwsCredentials {\n  accessKeyId: Secret;\n  secretAccessKey: Secret;\n}\n\n```\n\n// alchemy/src/aws/function.ts\n```ts\nimport {\n  AddPermissionCommand,\n  Architecture,\n  CreateFunctionCommand,\n  CreateFunctionUrlConfigCommand,\n  DeleteFunctionCommand,\n  DeleteFunctionUrlConfigCommand,\n  GetFunctionCommand,\n  GetFunctionConfigurationCommand,\n  GetFunctionUrlConfigCommand,\n  LambdaClient,\n  ResourceNotFoundException,\n  Runtime,\n  UpdateFunctionCodeCommand,\n  UpdateFunctionConfigurationCommand,\n  UpdateFunctionUrlConfigCommand,\n} from \"@aws-sdk/client-lambda\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating a Lambda function\n */\nexport interface FunctionProps {\n  /**\n   * Name of the Lambda function\n   */\n  functionName: string;\n\n  /**\n   * Path to the zip file containing the function code\n   */\n  zipPath: string;\n\n  /**\n   * ARN of the IAM role that Lambda assumes when executing the function\n   */\n  roleArn: string;\n\n  /**\n   * Function handler in the format 'file.function'\n   * For Node.js this is typically 'index.handler' or similar\n   */\n  handler?: string;\n\n  /**\n   * Lambda runtime environment for the function\n   * @default nodejs20.x if not specified\n   */\n  runtime?: Runtime;\n\n  /**\n   * CPU architecture for the function\n   * @default x86_64 if not specified\n   */\n  architecture?: Architecture;\n\n  /**\n   * Description of the function's purpose\n   */\n  description?: string;\n\n  /**\n   * Maximum execution time in seconds\n   * @default 3 seconds if not specified\n   */\n  timeout?: number;\n\n  /**\n   * Amount of memory available to the function in MB\n   * @default 128 MB if not specified\n   */\n  memorySize?: number;\n\n  /**\n   * Environment variables available to the function code\n   */\n  environment?: Record<string, string>;\n\n  /**\n   * Resource tags for the function\n   */\n  tags?: Record<string, string>;\n\n  /**\n   * Function URL configuration for direct HTTP(S) invocation\n   */\n  url?: {\n    /**\n     * Authentication type for the function URL\n     */\n    authType?: \"AWS_IAM\" | \"NONE\";\n\n    /**\n     * CORS configuration for the function URL\n     */\n    cors?: {\n      /**\n       * Whether to allow credentials in CORS requests\n       */\n      allowCredentials?: boolean;\n\n      /**\n       * Allowed headers in CORS requests\n       */\n      allowHeaders?: string[];\n\n      /**\n       * Allowed HTTP methods in CORS requests\n       */\n      allowMethods?: string[];\n\n      /**\n       * Allowed origins in CORS requests\n       */\n      allowOrigins?: string[];\n\n      /**\n       * Headers exposed to the browser\n       */\n      exposeHeaders?: string[];\n\n      /**\n       * CORS preflight cache time in seconds\n       */\n      maxAge?: number;\n    };\n  };\n}\n\n/**\n * Output returned after Lambda function creation/update\n */\nexport interface Function extends Resource<\"lambda::Function\">, FunctionProps {\n  /**\n   * ARN of the Lambda function\n   */\n  arn: string;\n\n  /**\n   * Timestamp of the last function modification\n   */\n  lastModified: string;\n\n  /**\n   * Function version\n   */\n  version: string;\n\n  /**\n   * ARN with version suffix\n   */\n  qualifiedArn: string;\n\n  /**\n   * ARN for invoking the function through API Gateway\n   */\n  invokeArn: string;\n\n  /**\n   * SHA256 hash of the function code\n   */\n  sourceCodeHash: string;\n\n  /**\n   * Size of the function code in bytes\n   */\n  sourceCodeSize: number;\n\n  /**\n   * Size of ephemeral storage (/tmp) in MB\n   */\n  ephemeralStorageSize?: number;\n\n  /**\n   * List of supported CPU architectures\n   */\n  architectures: string[];\n\n  /**\n   * ARN of the master function (Lambda@Edge only)\n   */\n  masterArn?: string;\n\n  /**\n   * Unique identifier for the current function code/config\n   */\n  revisionId: string;\n\n  /**\n   * Current state of the function\n   */\n  state?: string;\n\n  /**\n   * Reason for the current state\n   */\n  stateReason?: string;\n\n  /**\n   * Code for the current state reason\n   */\n  stateReasonCode?: string;\n\n  /**\n   * Status of the last update operation\n   */\n  lastUpdateStatus?: string;\n\n  /**\n   * Reason for the last update status\n   */\n  lastUpdateStatusReason?: string;\n\n  /**\n   * Code for the last update status reason\n   */\n  lastUpdateStatusReasonCode?: string;\n\n  /**\n   * Function package type (Zip or Image)\n   */\n  packageType: string;\n\n  /**\n   * ARN of the signing profile version\n   */\n  signingProfileVersionArn?: string;\n\n  /**\n   * ARN of the signing job\n   */\n  signingJobArn?: string;\n\n  /**\n   * Function URL if configured\n   */\n  functionUrl?: string;\n}\n\n/**\n * AWS Lambda Function Resource\n *\n * Creates and manages AWS Lambda functions with support for Node.js runtimes, custom handlers,\n * environment variables, and function URLs. Handles deployment packaging, IAM role\n * stabilization, and function updates.\n *\n * @example\n * // Create a basic Lambda function with minimal configuration\n * const basicFunction = await Function(\"api-handler\", {\n *   functionName: \"api-handler\",\n *   zipPath: \"./dist/api.zip\",\n *   roleArn: role.arn,\n *   runtime: Runtime.nodejs20x,\n *   handler: \"index.handler\",\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a function with environment variables and custom memory/timeout\n * const configuredFunction = await Function(\"worker\", {\n *   functionName: \"worker\",\n *   zipPath: \"./dist/worker.zip\",\n *   roleArn: role.arn,\n *   runtime: Runtime.nodejs20x,\n *   handler: \"worker.process\",\n *   memorySize: 512,\n *   timeout: 30,\n *   environment: {\n *     QUEUE_URL: queue.url,\n *     LOG_LEVEL: \"info\"\n *   }\n * });\n *\n * @example\n * // Create a function with a public URL endpoint and CORS\n * const apiFunction = await Function(\"public-api\", {\n *   functionName: \"public-api\",\n *   zipPath: \"./dist/api.zip\",\n *   roleArn: role.arn,\n *   handler: \"api.handler\",\n *   url: {\n *     authType: \"NONE\",\n *     cors: {\n *       allowOrigins: [\"*\"],\n *       allowMethods: [\"GET\", \"POST\"],\n *       allowHeaders: [\"content-type\"],\n *       maxAge: 86400\n *     }\n *   }\n * });\n */\nexport const Function = Resource(\n  \"lambda::Function\",\n  async function (this: Context<Function>, id: string, props: FunctionProps) {\n    const client = new LambdaClient({});\n    const region = await resolveRegion(client);\n\n    const code = await zipCode(props.zipPath);\n\n    if (this.phase === \"delete\") {\n      // Delete function URL if it exists\n      if (this.output?.url) {\n        try {\n          await client.send(\n            new DeleteFunctionUrlConfigCommand({\n              FunctionName: props.functionName,\n            })\n          );\n        } catch (error: any) {\n          if (error.name !== \"ResourceNotFoundException\") {\n            console.warn(\"Failed to delete function URL:\", error);\n          }\n        }\n      }\n\n      await ignore(ResourceNotFoundException.name, () =>\n        client.send(\n          new DeleteFunctionCommand({\n            FunctionName: props.functionName,\n          })\n        )\n      );\n\n      return this.destroy();\n    } else {\n      let functionUrl: string | undefined;\n      try {\n        // Check if function exists\n        await client.send(\n          new GetFunctionCommand({\n            FunctionName: props.functionName,\n          })\n        );\n\n        if (this.phase === \"update\") {\n          // Wait for function to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Update function code\n          await client.send(\n            new UpdateFunctionCodeCommand({\n              FunctionName: props.functionName,\n              ZipFile: code,\n            })\n          );\n\n          // Wait for code update to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Update function configuration\n          await client.send(\n            new UpdateFunctionConfigurationCommand({\n              FunctionName: props.functionName,\n              Handler: props.handler,\n              Runtime: props.runtime,\n              Role: props.roleArn,\n              Description: props.description,\n              Timeout: props.timeout,\n              MemorySize: props.memorySize,\n              Environment: props.environment\n                ? { Variables: props.environment }\n                : undefined,\n            })\n          );\n\n          // Wait for configuration update to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Handle URL configuration\n          if (props.url) {\n            try {\n              // Check if URL config exists already\n              const urlConfig = await client.send(\n                new GetFunctionUrlConfigCommand({\n                  FunctionName: props.functionName,\n                })\n              );\n\n              // Update URL configuration if it exists\n              if (urlConfig) {\n                const updateResult = await client.send(\n                  new UpdateFunctionUrlConfigCommand({\n                    FunctionName: props.functionName,\n                    AuthType: props.url.authType || \"NONE\",\n                    Cors: props.url.cors\n                      ? {\n                          AllowCredentials: props.url.cors.allowCredentials,\n                          AllowHeaders: props.url.cors.allowHeaders,\n                          AllowMethods: props.url.cors.allowMethods,\n                          AllowOrigins: props.url.cors.allowOrigins,\n                          ExposeHeaders: props.url.cors.exposeHeaders,\n                          MaxAge: props.url.cors.maxAge,\n                        }\n                      : undefined,\n                  })\n                );\n                functionUrl = updateResult.FunctionUrl;\n\n                // Add public access permission for function URL\n                if (props.url.authType === \"NONE\") {\n                  try {\n                    await client.send(\n                      new AddPermissionCommand({\n                        FunctionName: props.functionName,\n                        StatementId: \"FunctionURLAllowPublicAccess\",\n                        Action: \"lambda:InvokeFunctionUrl\",\n                        Principal: \"*\",\n                        FunctionUrlAuthType: \"NONE\",\n                      })\n                    );\n                  } catch (permError: any) {\n                    if (!permError.message?.includes(\"already exists\")) {\n                      console.warn(\"Error adding URL permission:\", permError);\n                    }\n                  }\n                }\n              } else {\n                // Create URL configuration if it doesn't exist\n                const createResult = await client.send(\n                  new CreateFunctionUrlConfigCommand({\n                    FunctionName: props.functionName,\n                    AuthType: props.url.authType || \"NONE\",\n                    Cors: props.url.cors\n                      ? {\n                          AllowCredentials: props.url.cors.allowCredentials,\n                          AllowHeaders: props.url.cors.allowHeaders,\n                          AllowMethods: props.url.cors.allowMethods,\n                          AllowOrigins: props.url.cors.allowOrigins,\n                          ExposeHeaders: props.url.cors.exposeHeaders,\n                          MaxAge: props.url.cors.maxAge,\n                        }\n                      : undefined,\n                  })\n                );\n                functionUrl = createResult.FunctionUrl;\n\n                // Add public access permission for function URL\n                if (props.url.authType === \"NONE\") {\n                  try {\n                    await client.send(\n                      new AddPermissionCommand({\n                        FunctionName: props.functionName,\n                        StatementId: \"FunctionURLAllowPublicAccess\",\n                        Action: \"lambda:InvokeFunctionUrl\",\n                        Principal: \"*\",\n                        FunctionUrlAuthType: \"NONE\",\n                      })\n                    );\n                  } catch (permError: any) {\n                    if (!permError.message?.includes(\"already exists\")) {\n                      console.warn(\"Error adding URL permission:\", permError);\n                    }\n                  }\n                }\n              }\n            } catch (error: any) {\n              if (error.name === \"ResourceNotFoundException\") {\n                // Create URL configuration if it doesn't exist\n                const createResult = await client.send(\n                  new CreateFunctionUrlConfigCommand({\n                    FunctionName: props.functionName,\n                    AuthType: props.url.authType || \"NONE\",\n                    Cors: props.url.cors\n                      ? {\n                          AllowCredentials: props.url.cors.allowCredentials,\n                          AllowHeaders: props.url.cors.allowHeaders,\n                          AllowMethods: props.url.cors.allowMethods,\n                          AllowOrigins: props.url.cors.allowOrigins,\n                          ExposeHeaders: props.url.cors.exposeHeaders,\n                          MaxAge: props.url.cors.maxAge,\n                        }\n                      : undefined,\n                  })\n                );\n                functionUrl = createResult.FunctionUrl;\n\n                // Add public access permission for function URL\n                if (props.url.authType === \"NONE\") {\n                  try {\n                    await client.send(\n                      new AddPermissionCommand({\n                        FunctionName: props.functionName,\n                        StatementId: \"FunctionURLAllowPublicAccess\",\n                        Action: \"lambda:InvokeFunctionUrl\",\n                        Principal: \"*\",\n                        FunctionUrlAuthType: \"NONE\",\n                      })\n                    );\n                  } catch (permError: any) {\n                    if (!permError.message?.includes(\"already exists\")) {\n                      console.warn(\"Error adding URL permission:\", permError);\n                    }\n                  }\n                }\n              } else {\n                throw error;\n              }\n            }\n          } else if (this.output?.url) {\n            // Remove URL config if it was previously set but not in current props\n            try {\n              await client.send(\n                new DeleteFunctionUrlConfigCommand({\n                  FunctionName: props.functionName,\n                })\n              );\n              functionUrl = undefined;\n            } catch (error: any) {\n              if (error.name !== \"ResourceNotFoundException\") {\n                console.warn(\"Failed to delete function URL:\", error);\n              }\n            }\n          }\n        }\n      } catch (error: any) {\n        if (error.name === \"ResourceNotFoundException\") {\n          // Create function if it doesn't exist\n          const startTime = Date.now();\n          let delay = 100; // Start with 100ms delay\n\n          while (true) {\n            try {\n              await client.send(\n                new CreateFunctionCommand({\n                  FunctionName: props.functionName,\n                  Code: { ZipFile: code },\n                  Handler: props.handler || \"index.handler\",\n                  Runtime: props.runtime || Runtime.nodejs20x,\n                  Role: props.roleArn,\n                  Description: props.description,\n                  Timeout: props.timeout || 3,\n                  MemorySize: props.memorySize || 128,\n                  Environment: props.environment\n                    ? { Variables: props.environment }\n                    : undefined,\n                  Architectures: props.architecture\n                    ? [props.architecture]\n                    : [Architecture.x86_64],\n                  Tags: props.tags,\n                })\n              );\n              break; // Success - exit retry loop\n            } catch (createError: any) {\n              if (\n                createError.name !== \"InvalidParameterValueException\" ||\n                !createError.message?.includes(\"cannot be assumed by Lambda\")\n              ) {\n                throw createError; // Different error - rethrow\n              }\n\n              if (Date.now() - startTime > 10000) {\n                throw new Error(\n                  \"Timeout waiting for IAM role to be assumable by Lambda after 10s\"\n                );\n              }\n\n              await new Promise((resolve) => setTimeout(resolve, delay));\n              delay = Math.min(delay * 2, 1000); // Exponential backoff capped at 1s\n            }\n          }\n\n          // Wait for function to be active\n          let isCreating = true;\n          while (isCreating) {\n            const config = await client.send(\n              new GetFunctionConfigurationCommand({\n                FunctionName: props.functionName,\n              })\n            );\n            isCreating = config.State === \"Pending\";\n            if (isCreating) {\n              await new Promise((resolve) => setTimeout(resolve, 1000));\n            }\n          }\n\n          // Create URL configuration if needed\n          if (props.url) {\n            try {\n              const createResult = await client.send(\n                new CreateFunctionUrlConfigCommand({\n                  FunctionName: props.functionName,\n                  AuthType: props.url.authType || \"NONE\",\n                  Cors: props.url.cors\n                    ? {\n                        AllowCredentials: props.url.cors.allowCredentials,\n                        AllowHeaders: props.url.cors.allowHeaders,\n                        AllowMethods: props.url.cors.allowMethods,\n                        AllowOrigins: props.url.cors.allowOrigins,\n                        ExposeHeaders: props.url.cors.exposeHeaders,\n                        MaxAge: props.url.cors.maxAge,\n                      }\n                    : undefined,\n                })\n              );\n              functionUrl = createResult.FunctionUrl;\n\n              // Add public access permission for function URL\n              if (props.url.authType === \"NONE\") {\n                try {\n                  await client.send(\n                    new AddPermissionCommand({\n                      FunctionName: props.functionName,\n                      StatementId: \"FunctionURLAllowPublicAccess\",\n                      Action: \"lambda:InvokeFunctionUrl\",\n                      Principal: \"*\",\n                      FunctionUrlAuthType: \"NONE\",\n                    })\n                  );\n                } catch (permError: any) {\n                  if (!permError.message?.includes(\"already exists\")) {\n                    console.warn(\"Error adding URL permission:\", permError);\n                  }\n                }\n              }\n            } catch (error) {\n              console.warn(\"Failed to create function URL:\", error);\n            }\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      // Get complete function details\n      const [func, config] = await Promise.all([\n        client.send(\n          new GetFunctionCommand({\n            FunctionName: props.functionName,\n          })\n        ),\n        client.send(\n          new GetFunctionConfigurationCommand({\n            FunctionName: props.functionName,\n          })\n        ),\n      ]);\n\n      // Try to get function URL if it wasn't already retrieved and URL is configured\n      if (!functionUrl && (props.url || this.output?.url)) {\n        try {\n          const urlConfig = await client.send(\n            new GetFunctionUrlConfigCommand({\n              FunctionName: props.functionName,\n            })\n          );\n          functionUrl = urlConfig.FunctionUrl;\n        } catch (error: any) {\n          if (error.name !== \"ResourceNotFoundException\") {\n            console.warn(\"Failed to get function URL:\", error);\n          }\n        }\n      }\n\n      return this({\n        ...props,\n        arn: config.FunctionArn!,\n        lastModified: config.LastModified!,\n        version: config.Version!,\n        qualifiedArn: `${config.FunctionArn}:${config.Version}`,\n        invokeArn: `arn:aws:apigateway:${region}:lambda:path/2015-03-31/functions/${config.FunctionArn}/invocations`,\n        sourceCodeHash: config.CodeSha256!,\n        sourceCodeSize: config.CodeSize!,\n        ephemeralStorageSize: config.EphemeralStorage?.Size,\n        architectures: config.Architectures || [],\n        masterArn: config.MasterArn,\n        revisionId: config.RevisionId!,\n        state: config.State,\n        stateReason: config.StateReason,\n        stateReasonCode: config.StateReasonCode,\n        lastUpdateStatus: config.LastUpdateStatus,\n        lastUpdateStatusReason: config.LastUpdateStatusReason,\n        lastUpdateStatusReasonCode: config.LastUpdateStatusReasonCode,\n        packageType: config.PackageType!,\n        signingProfileVersionArn: config.SigningProfileVersionArn,\n        signingJobArn: config.SigningJobArn,\n        functionUrl: functionUrl,\n      });\n    }\n  }\n);\n\n// Helper to wait for function to stabilize\nasync function waitForFunctionStabilization(\n  client: LambdaClient,\n  functionName: string\n) {\n  while (true) {\n    const config = await client.send(\n      new GetFunctionConfigurationCommand({\n        FunctionName: functionName,\n      })\n    );\n\n    // Check if function is in a stable state\n    if (config.State === \"Active\" && config.LastUpdateStatus === \"Successful\") {\n      break;\n    }\n\n    // If there's a failure, throw an error\n    if (config.State === \"Failed\" || config.LastUpdateStatus === \"Failed\") {\n      throw new Error(\n        `Function failed to stabilize: ${config.StateReason || config.LastUpdateStatusReason}`\n      );\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n  }\n}\n\n// Helper to zip the code\nasync function zipCode(filePath: string): Promise<Buffer> {\n  const fileContent = await fs.promises.readFile(filePath);\n  const fileName = path.basename(filePath);\n\n  // Create a zip buffer in memory\n  const zip = new (await import(\"jszip\")).default();\n  zip.file(fileName, fileContent);\n  return zip.generateAsync({\n    type: \"nodebuffer\",\n    compression: \"DEFLATE\",\n    platform: \"UNIX\",\n  });\n}\n\nasync function resolveRegion(client: LambdaClient): Promise<string> {\n  const region = client.config.region;\n  if (typeof region === \"string\") return region;\n  if (typeof region === \"function\") return region();\n  throw new Error(\"Could not resolve AWS region\");\n}\n\n```\n\n// alchemy/src/aws/policy-attachment.ts\n```ts\nimport {\n  AttachRolePolicyCommand,\n  DetachRolePolicyCommand,\n  IAMClient,\n  NoSuchEntityException,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating a policy attachment\n */\nexport interface PolicyAttachmentProps {\n  /**\n   * ARN of the IAM policy to attach\n   */\n  policyArn: string;\n\n  /**\n   * Name of the IAM role to attach the policy to\n   */\n  roleName: string;\n}\n\n/**\n * Output returned after policy attachment creation/update\n */\nexport interface PolicyAttachment\n  extends Resource<\"iam::PolicyAttachment\">,\n    PolicyAttachmentProps {}\n\n/**\n * AWS IAM Policy Attachment Resource\n *\n * Attaches an IAM policy to a role, enabling the role to use the permissions defined in the policy.\n *\n * @example\n * // Attach an AWS managed policy to a role\n * const adminAccess = await PolicyAttachment(\"admin-policy\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AdministratorAccess\",\n *   roleName: role.name\n * });\n *\n * @example\n * // Attach a custom policy to a role\n * const customPolicy = await PolicyAttachment(\"custom-policy\", {\n *   policyArn: policy.arn,\n *   roleName: role.name\n * });\n *\n * @example\n * // Attach multiple policies to a role\n * const s3Access = await PolicyAttachment(\"s3-access\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AmazonS3FullAccess\",\n *   roleName: role.name\n * });\n *\n * const sqsAccess = await PolicyAttachment(\"sqs-access\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AmazonSQSFullAccess\",\n *   roleName: role.name\n * });\n */\nexport const PolicyAttachment = Resource(\n  \"iam::PolicyAttachment\",\n  async function (\n    this: Context<PolicyAttachment>,\n    id: string,\n    props: PolicyAttachmentProps,\n  ) {\n    const client = new IAMClient({});\n\n    if (this.phase === \"delete\") {\n      await ignore(NoSuchEntityException.name, () =>\n        client.send(\n          new DetachRolePolicyCommand({\n            PolicyArn: props.policyArn,\n            RoleName: props.roleName,\n          }),\n        ),\n      );\n      return this.destroy();\n    } else {\n      await client.send(\n        new AttachRolePolicyCommand({\n          PolicyArn: props.policyArn,\n          RoleName: props.roleName,\n        }),\n      );\n    }\n\n    return this(props);\n  },\n);\n\n```\n\n// alchemy/src/aws/policy.ts\n```ts\nimport {\n  CreatePolicyCommand,\n  CreatePolicyVersionCommand,\n  DeletePolicyCommand,\n  DeletePolicyVersionCommand,\n  GetPolicyCommand,\n  GetPolicyVersionCommand,\n  IAMClient,\n  ListPolicyVersionsCommand,\n  NoSuchEntityException,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Type of effect for a policy statement\n */\nexport type Effect = \"Allow\" | \"Deny\";\n\n/**\n * A single statement within an IAM policy document\n */\nexport interface PolicyStatement {\n  /**\n   * Optional identifier for the statement\n   */\n  Sid?: string;\n\n  /**\n   * Whether to allow or deny the specified actions\n   */\n  Effect: Effect;\n\n  /**\n   * Actions that the policy allows or denies\n   */\n  Action: string | string[];\n\n  /**\n   * Resources that the policy applies to\n   */\n  Resource?: string | string[];\n\n  /**\n   * Additional conditions for when the policy applies\n   */\n  Condition?: Record<string, Record<string, string | string[]>>;\n\n  /**\n   * AWS principals that the policy applies to\n   */\n  Principal?: Record<string, string | string[]>;\n\n  /**\n   * AWS principals that the policy explicitly does not apply to\n   */\n  NotPrincipal?: Record<string, string | string[]>;\n\n  /**\n   * Actions that are explicitly not included in this statement\n   */\n  NotAction?: string | string[];\n\n  /**\n   * Resources that are explicitly not included in this statement\n   */\n  NotResource?: string | string[];\n}\n\n/**\n * An IAM policy document containing one or more statements\n */\nexport interface PolicyDocument {\n  /**\n   * Policy language version (must be \"2012-10-17\")\n   */\n  Version: \"2012-10-17\";\n\n  /**\n   * List of policy statements\n   */\n  Statement: PolicyStatement[];\n}\n\n/**\n * Properties for creating or updating an IAM policy\n */\nexport interface PolicyProps {\n  /**\n   * Name of the policy\n   */\n  policyName: string;\n\n  /**\n   * Policy document defining the permissions\n   */\n  document: PolicyDocument;\n\n  /**\n   * Optional description of the policy's purpose\n   */\n  description?: string;\n\n  /**\n   * Optional path prefix for the policy\n   */\n  path?: string;\n\n  /**\n   * Optional resource tags\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after IAM policy creation/update\n */\nexport interface Policy extends Resource<\"iam::Policy\">, PolicyProps {\n  /**\n   * ARN of the policy\n   */\n  arn: string;\n\n  /**\n   * ID of the default policy version\n   */\n  defaultVersionId: string;\n\n  /**\n   * Number of entities the policy is attached to\n   */\n  attachmentCount: number;\n\n  /**\n   * When the policy was created\n   */\n  createDate: Date;\n\n  /**\n   * When the policy was last updated\n   */\n  updateDate: Date;\n\n  /**\n   * Whether the policy can be attached to IAM users/roles\n   */\n  isAttachable: boolean;\n}\n\n/**\n * AWS IAM Policy Resource\n *\n * Creates and manages IAM policies that define permissions for AWS services and resources.\n * Supports automatic versioning and updates when policy content changes.\n *\n * @example\n * // Create a basic S3 bucket access policy\n * const s3Policy = await Policy(\"bucket-access\", {\n *   policyName: \"s3-bucket-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Action: [\n *         \"s3:GetObject\",\n *         \"s3:PutObject\"\n *       ],\n *       Resource: `${bucket.arn}/*`\n *     }]\n *   }\n * });\n *\n * @example\n * // Create a policy with multiple statements and conditions\n * const apiPolicy = await Policy(\"api-access\", {\n *   policyName: \"api-gateway-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [\n *       {\n *         Sid: \"InvokeAPI\",\n *         Effect: \"Allow\",\n *         Action: \"execute-api:Invoke\",\n *         Resource: `${api.executionArn}/*`,\n *         Condition: {\n *           StringEquals: {\n *             \"aws:SourceVpc\": vpc.id\n *           }\n *         }\n *       },\n *       {\n *         Sid: \"ReadLogs\",\n *         Effect: \"Allow\",\n *         Action: [\n *           \"logs:GetLogEvents\",\n *           \"logs:FilterLogEvents\"\n *         ],\n *         Resource: `${api.logGroupArn}:*`\n *       }\n *     ]\n *   },\n *   description: \"Allows invoking API Gateway endpoints and reading logs\",\n *   tags: {\n *     Service: \"API Gateway\",\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a policy that denies access based on tags\n * const denyPolicy = await Policy(\"deny-production\", {\n *   policyName: \"deny-production-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Deny\",\n *       Action: \"*\",\n *       Resource: \"*\",\n *       Condition: {\n *         StringEquals: {\n *           \"aws:ResourceTag/Environment\": \"production\"\n *         }\n *       }\n *     }]\n *   }\n * });\n */\nexport const Policy = Resource(\n  \"iam::Policy\",\n  async function (\n    this: Context<Policy>,\n    id: string,\n    props: PolicyProps,\n  ): Promise<Policy> {\n    const client = new IAMClient({});\n    const policyArn = `arn:aws:iam::${process.env.AWS_ACCOUNT_ID}:policy${props.path || \"/\"}${props.policyName}`;\n\n    if (this.phase === \"delete\") {\n      try {\n        // List and delete all non-default versions first\n        const versions = await client.send(\n          new ListPolicyVersionsCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        for (const version of versions.Versions || []) {\n          if (!version.IsDefaultVersion) {\n            await client.send(\n              new DeletePolicyVersionCommand({\n                PolicyArn: policyArn,\n                VersionId: version.VersionId,\n              }),\n            );\n          }\n        }\n\n        // Delete the policy\n        await client.send(\n          new DeletePolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n      } catch (error: any) {\n        if (error.name !== NoSuchEntityException.name) {\n          throw error;\n        }\n      }\n      return this.destroy();\n    } else {\n      try {\n        // Check if policy exists\n        const existingPolicy = await client.send(\n          new GetPolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        // Get current policy version\n        const currentVersion = await client.send(\n          new GetPolicyVersionCommand({\n            PolicyArn: policyArn,\n            VersionId: existingPolicy.Policy!.DefaultVersionId!,\n          }),\n        );\n\n        const currentDocument = JSON.parse(\n          decodeURIComponent(currentVersion.PolicyVersion!.Document!),\n        );\n\n        // If policy document changed, create new version\n        if (\n          JSON.stringify(currentDocument) !== JSON.stringify(props.document)\n        ) {\n          // List versions to check if we need to delete old ones\n          const versions = await client.send(\n            new ListPolicyVersionsCommand({\n              PolicyArn: policyArn,\n            }),\n          );\n\n          // Delete oldest version if we have 5 versions (maximum allowed)\n          if (versions.Versions?.length === 5) {\n            const oldestVersion = versions.Versions.sort(\n              (a, b) => a.CreateDate!.getTime() - b.CreateDate!.getTime(),\n            )[0];\n\n            if (!oldestVersion.IsDefaultVersion) {\n              await client.send(\n                new DeletePolicyVersionCommand({\n                  PolicyArn: policyArn,\n                  VersionId: oldestVersion.VersionId!,\n                }),\n              );\n            }\n          }\n\n          // Create new version\n          await client.send(\n            new CreatePolicyVersionCommand({\n              PolicyArn: policyArn,\n              PolicyDocument: JSON.stringify(props.document),\n              SetAsDefault: true,\n            }),\n          );\n        }\n\n        const policy = await client.send(\n          new GetPolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        return this({\n          ...props,\n          arn: policy.Policy!.Arn!,\n          defaultVersionId: policy.Policy!.DefaultVersionId!,\n          attachmentCount: policy.Policy!.AttachmentCount!,\n          createDate: policy.Policy!.CreateDate!,\n          updateDate: policy.Policy!.UpdateDate!,\n          isAttachable: policy.Policy!.IsAttachable!,\n        });\n      } catch (error: any) {\n        if (error.name === \"NoSuchEntity\") {\n          // Create new policy\n          const newPolicy = await client.send(\n            new CreatePolicyCommand({\n              PolicyName: props.policyName,\n              PolicyDocument: JSON.stringify(props.document),\n              Description: props.description,\n              Path: props.path,\n              Tags: props.tags\n                ? Object.entries(props.tags).map(([Key, Value]) => ({\n                    Key,\n                    Value,\n                  }))\n                : undefined,\n            }),\n          );\n\n          return this({\n            ...props,\n            arn: newPolicy.Policy!.Arn!,\n            defaultVersionId: newPolicy.Policy!.DefaultVersionId!,\n            attachmentCount: newPolicy.Policy!.AttachmentCount!,\n            createDate: newPolicy.Policy!.CreateDate!,\n            updateDate: newPolicy.Policy!.UpdateDate!,\n            isAttachable: newPolicy.Policy!.IsAttachable!,\n          });\n        }\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/aws/queue.ts\n```ts\nimport {\n  CreateQueueCommand,\n  DeleteQueueCommand,\n  GetQueueAttributesCommand,\n  GetQueueUrlCommand,\n  SQSClient,\n} from \"@aws-sdk/client-sqs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating an SQS queue\n */\nexport interface QueueProps {\n  /**\n   * Name of the queue\n   * For FIFO queues, the name must end with the .fifo suffix\n   */\n  queueName: string;\n\n  /**\n   * Whether this is a FIFO queue.\n   * If true, the queueName must end with .fifo suffix\n   */\n  fifo?: boolean;\n\n  /**\n   * The length of time (in seconds) that a message received from a queue will be invisible to other receiving components\n   * Default: 30 seconds\n   */\n  visibilityTimeout?: number;\n\n  /**\n   * The length of time (in seconds) for which Amazon SQS retains a message\n   * Default: 345600 seconds (4 days)\n   */\n  messageRetentionPeriod?: number;\n\n  /**\n   * The limit of how many bytes a message can contain before Amazon SQS rejects it\n   * Default: 262144 bytes (256 KB)\n   */\n  maximumMessageSize?: number;\n\n  /**\n   * The time in seconds that the delivery of all messages in the queue will be delayed\n   * Default: 0 seconds\n   */\n  delaySeconds?: number;\n\n  /**\n   * The length of time (in seconds) for which a ReceiveMessage action waits for a message to arrive\n   * Default: 0 seconds\n   */\n  receiveMessageWaitTimeSeconds?: number;\n\n  /**\n   * Enables content-based deduplication for FIFO queues.\n   * Only applicable when fifo is true.\n   */\n  contentBasedDeduplication?: boolean;\n\n  /**\n   * Specifies whether message deduplication occurs at the message group or queue level\n   * Only applicable when fifo is true\n   */\n  deduplicationScope?: \"messageGroup\" | \"queue\";\n\n  /**\n   * Specifies whether the FIFO queue throughput quota applies to the entire queue or per message group\n   * Only applicable when fifo is true\n   */\n  fifoThroughputLimit?: \"perQueue\" | \"perMessageGroupId\";\n\n  /**\n   * Resource tags for the queue\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after SQS queue creation/update\n */\nexport interface Queue extends Resource<\"sqs::Queue\">, QueueProps {\n  /**\n   * ARN of the queue\n   */\n  arn: string;\n\n  /**\n   * URL of the queue\n   */\n  url: string;\n}\n\n/**\n * AWS SQS Queue Resource\n *\n * Creates and manages Amazon SQS queues with support for both standard and FIFO queues.\n * Handles queue creation, attribute configuration, and automatic cleanup of deleted queues.\n *\n * @example\n * // Create a standard queue with custom visibility timeout\n * const standardQueue = await Queue(\"my-queue\", {\n *   queueName: \"my-queue\",\n *   visibilityTimeout: 30,\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a FIFO queue with content-based deduplication\n * const fifoQueue = await Queue(\"orders-queue\", {\n *   queueName: \"orders-queue.fifo\",\n *   fifo: true,\n *   contentBasedDeduplication: true,\n *   visibilityTimeout: 30,\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a queue with custom message retention and size\n * const customQueue = await Queue(\"large-messages\", {\n *   queueName: \"large-messages\",\n *   messageRetentionPeriod: 345600,  // 4 days\n *   maximumMessageSize: 262144,      // 256 KB\n *   visibilityTimeout: 60,\n *   delaySeconds: 5,\n *   receiveMessageWaitTimeSeconds: 20\n * });\n */\nexport const Queue = Resource(\n  \"sqs::Queue\",\n  async function (\n    this: Context<Queue>,\n    id: string,\n    props: QueueProps,\n  ): Promise<Queue> {\n    const client = new SQSClient({});\n    // Don't automatically add .fifo suffix - user must include it in queueName\n    const queueName = props.queueName;\n\n    // Validate that FIFO queues have .fifo suffix\n    if (props.fifo && !queueName.endsWith(\".fifo\")) {\n      throw new Error(\"FIFO queue names must end with .fifo suffix\");\n    }\n\n    if (this.phase === \"delete\") {\n      try {\n        // Get queue URL first\n        const urlResponse = await client.send(\n          new GetQueueUrlCommand({\n            QueueName: queueName,\n          }),\n        );\n\n        // Delete the queue\n        await client.send(\n          new DeleteQueueCommand({\n            QueueUrl: urlResponse.QueueUrl,\n          }),\n        );\n\n        // Wait for queue to be deleted\n        let queueDeleted = false;\n        while (!queueDeleted) {\n          try {\n            await client.send(\n              new GetQueueUrlCommand({\n                QueueName: queueName,\n              }),\n            );\n            // If we get here, queue still exists\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n          } catch (error: any) {\n            if (error.name === \"QueueDoesNotExist\") {\n              queueDeleted = true;\n            } else {\n              throw error;\n            }\n          }\n        }\n      } catch (error: any) {\n        if (error.name !== \"QueueDoesNotExist\") {\n          throw error;\n        }\n      }\n\n      return this.destroy();\n    } else {\n      // Create queue with attributes\n      const attributes: Record<string, string> = {};\n\n      if (props.visibilityTimeout !== undefined) {\n        attributes[\"VisibilityTimeout\"] = props.visibilityTimeout.toString();\n      }\n      if (props.messageRetentionPeriod !== undefined) {\n        attributes[\"MessageRetentionPeriod\"] =\n          props.messageRetentionPeriod.toString();\n      }\n      if (props.maximumMessageSize !== undefined) {\n        attributes[\"MaximumMessageSize\"] = props.maximumMessageSize.toString();\n      }\n      if (props.delaySeconds !== undefined) {\n        attributes[\"DelaySeconds\"] = props.delaySeconds.toString();\n      }\n      if (props.receiveMessageWaitTimeSeconds !== undefined) {\n        attributes[\"ReceiveMessageWaitTimeSeconds\"] =\n          props.receiveMessageWaitTimeSeconds.toString();\n      }\n\n      // FIFO specific attributes\n      if (props.fifo) {\n        attributes[\"FifoQueue\"] = \"true\";\n        if (props.contentBasedDeduplication) {\n          attributes[\"ContentBasedDeduplication\"] = \"true\";\n        }\n        if (props.deduplicationScope) {\n          attributes[\"DeduplicationScope\"] = props.deduplicationScope;\n        }\n        if (props.fifoThroughputLimit) {\n          attributes[\"FifoThroughputLimit\"] = props.fifoThroughputLimit;\n        }\n      }\n\n      // Convert tags to AWS format\n      const tags = props.tags\n        ? Object.entries(props.tags).reduce(\n            (acc, [key, value]) => ({ ...acc, [key]: value }),\n            {},\n          )\n        : undefined;\n\n      try {\n        // Create the queue\n        const createResponse = await client.send(\n          new CreateQueueCommand({\n            QueueName: queueName,\n            Attributes: attributes,\n            tags,\n          }),\n        );\n\n        // Get queue attributes\n        const attributesResponse = await client.send(\n          new GetQueueAttributesCommand({\n            QueueUrl: createResponse.QueueUrl,\n            AttributeNames: [\"QueueArn\"],\n          }),\n        );\n\n        return this({\n          ...props,\n          arn: attributesResponse.Attributes!.QueueArn!,\n          url: createResponse.QueueUrl!,\n        });\n      } catch (error: any) {\n        if (error.name === \"QueueAlreadyExists\") {\n          // Get existing queue URL\n          const urlResponse = await client.send(\n            new GetQueueUrlCommand({\n              QueueName: queueName,\n            }),\n          );\n\n          // Get queue attributes\n          const attributesResponse = await client.send(\n            new GetQueueAttributesCommand({\n              QueueUrl: urlResponse.QueueUrl,\n              AttributeNames: [\"QueueArn\"],\n            }),\n          );\n\n          return this({\n            ...props,\n            arn: attributesResponse.Attributes!.QueueArn!,\n            url: urlResponse.QueueUrl!,\n          });\n        } else if (error.name === \"QueueDeletedRecently\") {\n          // Queue was recently deleted, wait and retry\n          const maxRetries = 3;\n          let retryCount = 0;\n\n          while (retryCount < maxRetries) {\n            try {\n              // Wait for 60 seconds before retrying\n              await new Promise((resolve) => setTimeout(resolve, 61000));\n\n              // Retry creating the queue\n              const createResponse = await client.send(\n                new CreateQueueCommand({\n                  QueueName: queueName,\n                  Attributes: attributes,\n                  tags,\n                }),\n              );\n\n              // Get queue attributes\n              const attributesResponse = await client.send(\n                new GetQueueAttributesCommand({\n                  QueueUrl: createResponse.QueueUrl,\n                  AttributeNames: [\"QueueArn\"],\n                }),\n              );\n\n              return this({\n                ...props,\n                arn: attributesResponse.Attributes!.QueueArn!,\n                url: createResponse.QueueUrl!,\n              });\n            } catch (retryError: any) {\n              if (\n                retryError.name !== \"QueueDeletedRecently\" ||\n                retryCount === maxRetries - 1\n              ) {\n                throw retryError;\n              }\n              retryCount++;\n            }\n          }\n        }\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/aws/role.ts\n```ts\nimport {\n  AttachRolePolicyCommand,\n  CreateRoleCommand,\n  DeleteRoleCommand,\n  DeleteRolePolicyCommand,\n  DetachRolePolicyCommand,\n  EntityAlreadyExistsException,\n  GetRoleCommand,\n  IAMClient,\n  ListAttachedRolePoliciesCommand,\n  NoSuchEntityException,\n  PutRolePolicyCommand,\n  type Tag,\n  TagRoleCommand,\n  UpdateAssumeRolePolicyCommand,\n  UpdateRoleCommand,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\nimport type { PolicyDocument } from \"./policy\";\n\n/**\n * Properties for creating or updating an IAM role\n */\nexport interface RoleProps {\n  /**\n   * Name of the IAM role\n   */\n  roleName: string;\n\n  /**\n   * Policy that defines which entities can assume this role\n   */\n  assumeRolePolicy: PolicyDocument;\n\n  /**\n   * Optional description of the role's purpose\n   */\n  description?: string;\n\n  /**\n   * Optional path prefix for the role\n   */\n  path?: string;\n\n  /**\n   * Maximum session duration in seconds when assumed\n   * Default: 3600 seconds (1 hour)\n   */\n  maxSessionDuration?: number;\n\n  /**\n   * ARN of the policy used to set the permissions boundary\n   */\n  permissionsBoundary?: string;\n\n  /**\n   * Inline policies to embed in the role\n   * Each policy must have a unique name and policy document\n   */\n  policies?: Array<{\n    policyName: string;\n    policyDocument: PolicyDocument;\n  }>;\n\n  /**\n   * List of managed policy ARNs to attach to the role\n   */\n  managedPolicyArns?: string[];\n\n  /**\n   * Resource tags for the role\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after IAM role creation/update\n */\nexport interface Role extends Resource<\"iam::Role\">, RoleProps {\n  /**\n   * ARN of the role\n   */\n  arn: string;\n\n  /**\n   * Unique identifier for the role\n   */\n  uniqueId: string;\n\n  /**\n   * The stable and unique string identifying the role\n   */\n  roleId: string;\n\n  /**\n   * When the role was created\n   */\n  createDate: Date;\n}\n\n/**\n * AWS IAM Role Resource\n *\n * Creates and manages IAM roles with support for inline policies, managed policies,\n * and automatic cleanup of attached policies during deletion.\n *\n * @example\n * // Create a basic Lambda execution role with inline policy\n * const basicRole = await Role(\"lambda-role\", {\n *   roleName: \"lambda-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Basic Lambda execution role\",\n *   tags: {\n *     Environment: \"production\"\n *   },\n *   policies: [{\n *     policyName: \"logs\",\n *     policyDocument: {\n *       Version: \"2012-10-17\",\n *       Statement: [{\n *         Effect: \"Allow\",\n *         Action: [\n *           \"logs:CreateLogGroup\",\n *           \"logs:CreateLogStream\",\n *           \"logs:PutLogEvents\"\n *         ],\n *         Resource: \"*\"\n *       }]\n *     }\n *   }]\n * });\n *\n * @example\n * // Create a role with AWS managed policies\n * const managedRole = await Role(\"readonly-role\", {\n *   roleName: \"readonly-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Role with managed policies\",\n *   managedPolicyArns: [\n *     \"arn:aws:iam::aws:policy/ReadOnlyAccess\"\n *   ],\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a role with multiple inline policies and custom session duration\n * const customRole = await Role(\"custom-role\", {\n *   roleName: \"custom-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Role with multiple policies\",\n *   maxSessionDuration: 7200,\n *   policies: [\n *     {\n *       policyName: \"logs\",\n *       policyDocument: {\n *         Version: \"2012-10-17\",\n *         Statement: [{\n *           Effect: \"Allow\",\n *           Action: [\n *             \"logs:CreateLogGroup\",\n *             \"logs:CreateLogStream\",\n *             \"logs:PutLogEvents\"\n *           ],\n *           Resource: \"*\"\n *         }]\n *       }\n *     },\n *     {\n *       policyName: \"s3\",\n *       policyDocument: {\n *         Version: \"2012-10-17\",\n *         Statement: [{\n *           Effect: \"Allow\",\n *           Action: \"s3:ListBucket\",\n *           Resource: \"*\"\n *         }]\n *       }\n *     }\n *   ],\n *   tags: {\n *     Environment: \"production\",\n *     Updated: \"true\"\n *   }\n * });\n */\nexport const Role = Resource(\n  \"iam::Role\",\n  async function (\n    this: Context<Role>,\n    id: string,\n    props: RoleProps\n  ): Promise<Role> {\n    const client = new IAMClient({});\n\n    if (this.phase === \"delete\") {\n      try {\n        // Delete any inline policies first\n        if (props.policies) {\n          for (const policy of props.policies) {\n            await ignore(NoSuchEntityException.name, () =>\n              client.send(\n                new DeleteRolePolicyCommand({\n                  RoleName: props.roleName,\n                  PolicyName: policy.policyName,\n                })\n              )\n            );\n          }\n        }\n\n        // We need to detach managed policies before deleting the role\n        // First, get all attached policies\n        try {\n          const attachedPoliciesResponse = await client.send(\n            new ListAttachedRolePoliciesCommand({\n              RoleName: props.roleName,\n            })\n          );\n\n          // Detach all managed policies\n          const attachedPolicies =\n            attachedPoliciesResponse.AttachedPolicies || [];\n          for (const policy of attachedPolicies) {\n            await ignore(NoSuchEntityException.name, () =>\n              client.send(\n                new DetachRolePolicyCommand({\n                  RoleName: props.roleName,\n                  PolicyArn: policy.PolicyArn!,\n                })\n              )\n            );\n          }\n        } catch (error: any) {\n          if (error.name !== NoSuchEntityException.name) {\n            throw error;\n          }\n          // Role doesn't exist, no need to continue with detaching policies\n        }\n\n        // Try to delete the role, ignoring if it doesn't exist\n        await ignore(NoSuchEntityException.name, () =>\n          client.send(\n            new DeleteRoleCommand({\n              RoleName: props.roleName,\n            })\n          )\n        );\n      } catch (error: any) {\n        // If we get any other error besides NoSuchEntityException, log it but don't fail\n        // This ensures the resource is still marked as destroyed\n        if (error.name !== NoSuchEntityException.name) {\n          console.error(`Error deleting role ${props.roleName}:`, error);\n        }\n      }\n\n      // Always return destroyed state regardless of any errors\n      return this.destroy();\n    }\n\n    const assumeRolePolicyDocument = JSON.stringify(props.assumeRolePolicy);\n    let role;\n\n    try {\n      if (this.phase === \"create\") {\n        // Try to create the role\n        await client.send(\n          new CreateRoleCommand({\n            RoleName: props.roleName,\n            AssumeRolePolicyDocument: assumeRolePolicyDocument,\n            Description: props.description,\n            Path: props.path,\n            MaxSessionDuration: props.maxSessionDuration,\n            PermissionsBoundary: props.permissionsBoundary,\n            Tags: [\n              ...Object.entries(props.tags || {}).map(([Key, Value]) => ({\n                Key,\n                Value,\n              })),\n              {\n                Key: \"alchemy_stage\",\n                Value: this.stage,\n              },\n              {\n                Key: \"alchemy_resource\",\n                Value: this.id,\n              },\n            ],\n          })\n        );\n      }\n    } catch (error: any) {\n      if (\n        error instanceof EntityAlreadyExistsException &&\n        this.phase === \"create\"\n      ) {\n        // Check if we were the ones who created it\n        const existingRole = await client.send(\n          new GetRoleCommand({\n            RoleName: props.roleName,\n          })\n        );\n        const roleTags =\n          existingRole.Role?.Tags?.reduce(\n            (acc, tag) => {\n              acc[tag.Key!] = tag.Value!;\n              return acc;\n            },\n            {} as Record<string, string>\n          ) || {};\n\n        if (\n          roleTags.alchemy_stage !== this.stage ||\n          roleTags.alchemy_resource !== this.id\n        ) {\n          throw error;\n        }\n      } else if (error.name !== NoSuchEntityException.name) {\n        throw error;\n      }\n    }\n\n    // Get or update the role\n    role = await client.send(\n      new GetRoleCommand({\n        RoleName: props.roleName,\n      })\n    );\n\n    // Update assume role policy if it changed\n    if (role.Role?.AssumeRolePolicyDocument !== assumeRolePolicyDocument) {\n      await client.send(\n        new UpdateAssumeRolePolicyCommand({\n          RoleName: props.roleName,\n          PolicyDocument: assumeRolePolicyDocument,\n        })\n      );\n    }\n\n    // Update role description and max session duration if they changed\n    if (\n      role.Role?.Description !== props.description ||\n      role.Role?.MaxSessionDuration !== props.maxSessionDuration\n    ) {\n      await client.send(\n        new UpdateRoleCommand({\n          RoleName: props.roleName,\n          Description: props.description,\n          MaxSessionDuration: props.maxSessionDuration,\n        })\n      );\n    }\n\n    // Update tags\n    const newTags = {\n      ...props.tags,\n      alchemy_stage: this.stage,\n      alchemy_resource: this.id,\n    };\n    const tags: Tag[] = Object.entries(newTags).map(([Key, Value]) => ({\n      Key,\n      Value,\n    }));\n    await client.send(\n      new TagRoleCommand({\n        RoleName: props.roleName,\n        Tags: tags,\n      })\n    );\n\n    // Handle policy changes\n    const previousPolicies =\n      this.phase === \"update\" ? this.output!.policies || [] : [];\n    const currentPolicies = props.policies || [];\n\n    // Delete policies that were removed\n    for (const oldPolicy of previousPolicies) {\n      if (\n        !currentPolicies.some(\n          (p: { policyName: string }) => p.policyName === oldPolicy.policyName\n        )\n      ) {\n        await ignore(NoSuchEntityException.name, () =>\n          client.send(\n            new DeleteRolePolicyCommand({\n              RoleName: props.roleName,\n              PolicyName: oldPolicy.policyName,\n            })\n          )\n        );\n      }\n    }\n\n    // Update or create policies\n    for (const policy of currentPolicies) {\n      const oldPolicy = previousPolicies.find(\n        (p) => p.policyName === policy.policyName\n      );\n      if (\n        !oldPolicy ||\n        JSON.stringify(oldPolicy.policyDocument) !==\n          JSON.stringify(policy.policyDocument)\n      ) {\n        await client.send(\n          new PutRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyName: policy.policyName,\n            PolicyDocument: JSON.stringify(policy.policyDocument),\n          })\n        );\n      }\n    }\n\n    // Handle managed policy attachments\n    // Get currently attached policies\n    const attachedPoliciesResponse = await client.send(\n      new ListAttachedRolePoliciesCommand({\n        RoleName: props.roleName,\n      })\n    );\n\n    const currentAttachedPolicies =\n      attachedPoliciesResponse.AttachedPolicies || [];\n    const currentPolicyArns = currentAttachedPolicies.map((p) => p.PolicyArn!);\n\n    // If we're updating, use an empty array as default when managedPolicyArns is undefined\n    // to ensure we detach all managed policies\n    const desiredPolicyArns = props.managedPolicyArns || [];\n\n    // Detach policies that are no longer needed\n    for (const policyArn of currentPolicyArns) {\n      if (!desiredPolicyArns.includes(policyArn)) {\n        await client.send(\n          new DetachRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyArn: policyArn,\n          })\n        );\n      }\n    }\n\n    // Attach new policies that weren't attached before\n    for (const policyArn of desiredPolicyArns) {\n      if (!currentPolicyArns.includes(policyArn)) {\n        await client.send(\n          new AttachRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyArn: policyArn,\n          })\n        );\n      }\n    }\n\n    if (!role?.Role) {\n      throw new Error(`Failed to create or update role ${props.roleName}`);\n    }\n\n    return this({\n      ...props,\n      arn: role.Role.Arn!,\n      uniqueId: role.Role.RoleId!,\n      roleId: role.Role.RoleId!,\n      roleName: role.Role.RoleName ?? props.roleName,\n      createDate: role.Role.CreateDate!,\n    });\n  }\n);\n\n```\n\n// alchemy/src/aws/ses.ts\n```ts\nimport {\n  CreateConfigurationSetCommand,\n  CreateEmailIdentityCommand,\n  DeleteConfigurationSetCommand,\n  DeleteEmailIdentityCommand,\n  type DeliveryOptions,\n  GetConfigurationSetCommand,\n  GetEmailIdentityCommand,\n  NotFoundException,\n  PutConfigurationSetDeliveryOptionsCommand,\n  PutConfigurationSetReputationOptionsCommand,\n  PutConfigurationSetSendingOptionsCommand,\n  PutConfigurationSetSuppressionOptionsCommand,\n  PutConfigurationSetTrackingOptionsCommand,\n  PutEmailIdentityDkimAttributesCommand,\n  type ReputationOptions,\n  SESv2Client,\n  type SendingOptions,\n  type SuppressionOptions,\n  type TrackingOptions,\n} from \"@aws-sdk/client-sesv2\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for configuring AWS SES resources\n */\nexport interface SESProps {\n  /**\n   * Name of the configuration set\n   * Used to group email sending and tracking settings\n   */\n  configurationSetName?: string;\n\n  /**\n   * Email identity to verify (email address or domain)\n   * For domains, use the format \"example.com\"\n   * For email addresses, use the format \"user@example.com\"\n   */\n  emailIdentity?: string;\n\n  /**\n   * Whether to enable DKIM signing for the email identity\n   * DKIM helps prevent email spoofing by verifying sender authenticity\n   */\n  enableDkim?: boolean;\n\n  /**\n   * Sending options for the configuration set\n   * Controls whether email sending is enabled and related settings\n   */\n  sendingOptions?: SendingOptions;\n\n  /**\n   * Reputation options for the configuration set\n   * Controls reputation tracking and metrics collection\n   */\n  reputationOptions?: ReputationOptions;\n\n  /**\n   * Tracking options for the configuration set\n   * Controls open and click tracking with optional custom domains\n   */\n  trackingOptions?: TrackingOptions;\n\n  /**\n   * Suppression options for the configuration set\n   * Controls how bounces and complaints are handled\n   */\n  suppressionOptions?: SuppressionOptions;\n\n  /**\n   * Delivery options for the configuration set\n   * Controls TLS settings and sending pool configuration\n   */\n  deliveryOptions?: DeliveryOptions;\n\n  /**\n   * Tags to apply to the SES resources\n   * Key-value pairs for resource organization\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after SES resource creation/update\n */\nexport interface SES extends Resource<\"aws::SES\">, SESProps {\n  /**\n   * ARN of the configuration set if created\n   * Format: arn:aws:ses:region:account-id:configuration-set/name\n   */\n  configurationSetArn?: string;\n\n  /**\n   * Email identity verification status if an identity was created\n   * Can be \"PENDING\" or \"VERIFIED\"\n   */\n  emailIdentityVerificationStatus?: string;\n\n  /**\n   * DKIM verification status if DKIM was enabled\n   * Can be \"PENDING\", \"SUCCESS\", \"FAILED\", \"TEMPORARY_FAILURE\", or \"NOT_STARTED\"\n   */\n  dkimVerificationStatus?: string;\n\n  /**\n   * Email identity ARN if an identity was created\n   * Format: arn:aws:ses:region:account-id:identity/name\n   */\n  emailIdentityArn?: string;\n}\n\n/**\n * AWS SES Resource\n *\n * Creates and manages Amazon Simple Email Service (SES) configuration sets and email identities.\n * Supports email sending configuration, DKIM signing, and identity verification.\n *\n * @example\n * // Create a configuration set with sending options\n * const configSet = await SES(\"email-config\", {\n *   configurationSetName: \"my-email-config\",\n *   sendingOptions: {\n *     SendingEnabled: true\n *   },\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"notifications\"\n *   }\n * });\n *\n * @example\n * // Create and verify a domain identity with DKIM\n * const domainIdentity = await SES(\"domain-identity\", {\n *   emailIdentity: \"example.com\",\n *   enableDkim: true,\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"transactional-emails\"\n *   }\n * });\n *\n * @example\n * // Update configuration set sending options\n * const updatedConfig = await SES(\"email-config\", {\n *   configurationSetName: \"my-email-config\",\n *   sendingOptions: {\n *     SendingEnabled: false\n *   },\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"notifications\",\n *     Updated: \"true\"\n *   }\n * });\n */\nexport const SES = Resource(\n  \"aws::SES\",\n  async function (\n    this: Context<SES>,\n    id: string,\n    props: SESProps,\n  ): Promise<SES> {\n    // Create SES client\n    const client = new SESv2Client({});\n\n    // Resource ID is either based on the configuration set name or email identity\n    // const id =\n    //   props.configurationSetName || props.emailIdentity || this.resourceID;\n\n    // Handle deletion\n    if (this.phase === \"delete\") {\n      const output = this.output;\n\n      // Delete configuration set if it exists\n      if (output?.configurationSetName) {\n        await ignore(NotFoundException.name, () =>\n          client.send(\n            new DeleteConfigurationSetCommand({\n              ConfigurationSetName: output.configurationSetName,\n            }),\n          ),\n        );\n      }\n\n      // Delete email identity if it exists\n      if (output?.emailIdentity) {\n        await ignore(NotFoundException.name, () =>\n          client.send(\n            new DeleteEmailIdentityCommand({\n              EmailIdentity: output.emailIdentity,\n            }),\n          ),\n        );\n      }\n\n      // Return empty output for delete\n      return this.destroy();\n    }\n\n    // Created resources\n    let configurationSetArn: string | undefined;\n    let emailIdentityArn: string | undefined;\n    let emailIdentityVerificationStatus: string | undefined;\n    let dkimVerificationStatus: string | undefined;\n\n    // Create or update configuration set if specified\n    if (props.configurationSetName) {\n      // Check if configuration set exists\n      let configSetExists = false;\n      try {\n        await client.send(\n          new GetConfigurationSetCommand({\n            ConfigurationSetName: props.configurationSetName,\n          }),\n        );\n        configSetExists = true;\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          configSetExists = false;\n        } else {\n          throw error;\n        }\n      }\n\n      if (configSetExists) {\n        // Update existing configuration set using appropriate update commands\n        if (props.sendingOptions) {\n          await client.send(\n            new PutConfigurationSetSendingOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              SendingEnabled: props.sendingOptions.SendingEnabled,\n            }),\n          );\n        }\n\n        if (props.reputationOptions) {\n          await client.send(\n            new PutConfigurationSetReputationOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              ReputationMetricsEnabled:\n                props.reputationOptions.ReputationMetricsEnabled,\n            }),\n          );\n        }\n\n        if (props.trackingOptions) {\n          await client.send(\n            new PutConfigurationSetTrackingOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              CustomRedirectDomain: props.trackingOptions.CustomRedirectDomain,\n            }),\n          );\n        }\n\n        if (props.suppressionOptions) {\n          await client.send(\n            new PutConfigurationSetSuppressionOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              SuppressedReasons: props.suppressionOptions.SuppressedReasons,\n            }),\n          );\n        }\n\n        if (props.deliveryOptions) {\n          await client.send(\n            new PutConfigurationSetDeliveryOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              TlsPolicy: props.deliveryOptions.TlsPolicy,\n              SendingPoolName: props.deliveryOptions.SendingPoolName,\n            }),\n          );\n        }\n\n        // In SESv2, the ARN isn't directly returned in the response\n        configurationSetArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:configuration-set/${props.configurationSetName}`;\n      } else {\n        // Create new configuration set\n        await client.send(\n          new CreateConfigurationSetCommand({\n            ConfigurationSetName: props.configurationSetName,\n            SendingOptions: props.sendingOptions,\n            ReputationOptions: props.reputationOptions,\n            TrackingOptions: props.trackingOptions,\n            SuppressionOptions: props.suppressionOptions,\n            DeliveryOptions: props.deliveryOptions,\n            Tags: Object.entries(props.tags || {}).map(([Key, Value]) => ({\n              Key,\n              Value,\n            })),\n          }),\n        );\n\n        // In SESv2, the ARN isn't directly returned in the response\n        configurationSetArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:configuration-set/${props.configurationSetName}`;\n      }\n    }\n\n    // Create or verify email identity if specified\n    if (props.emailIdentity) {\n      // Check if identity exists\n      let getIdentityResult;\n      try {\n        getIdentityResult = await client.send(\n          new GetEmailIdentityCommand({\n            EmailIdentity: props.emailIdentity,\n          }),\n        );\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          getIdentityResult = null;\n        } else {\n          throw error;\n        }\n      }\n\n      if (!getIdentityResult) {\n        // Create new email identity\n        const createIdentityResult = await client.send(\n          new CreateEmailIdentityCommand({\n            EmailIdentity: props.emailIdentity,\n            Tags: Object.entries(props.tags || {}).map(([Key, Value]) => ({\n              Key,\n              Value,\n            })),\n          }),\n        );\n\n        // If it's an email address, we don't need to explicitly verify in v2\n        // The verification email is automatically sent by SES in v2\n\n        // Store the identity information\n        emailIdentityArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:identity/${props.emailIdentity}`;\n        emailIdentityVerificationStatus =\n          createIdentityResult.VerifiedForSendingStatus\n            ? \"VERIFIED\"\n            : \"PENDING\";\n      } else {\n        // Store the identity information\n        emailIdentityArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:identity/${props.emailIdentity}`;\n        emailIdentityVerificationStatus =\n          getIdentityResult.VerifiedForSendingStatus ? \"VERIFIED\" : \"PENDING\";\n\n        // Update DKIM settings if requested\n        if (props.enableDkim !== undefined) {\n          if (props.enableDkim) {\n            await client.send(\n              new PutEmailIdentityDkimAttributesCommand({\n                EmailIdentity: props.emailIdentity,\n                SigningEnabled: true,\n              }),\n            );\n\n            // We can check the current status of DKIM\n            dkimVerificationStatus = \"PENDING\"; // Default to pending\n\n            // Get the updated identity to check DKIM status\n            const updatedIdentity = await client.send(\n              new GetEmailIdentityCommand({\n                EmailIdentity: props.emailIdentity,\n              }),\n            );\n\n            if (updatedIdentity.DkimAttributes?.Status) {\n              dkimVerificationStatus = updatedIdentity.DkimAttributes.Status;\n            }\n          }\n        }\n      }\n    }\n\n    // Return the resource output\n    return this({\n      ...props,\n      configurationSetArn,\n      emailIdentityArn,\n      emailIdentityVerificationStatus,\n      dkimVerificationStatus,\n    });\n  },\n);\n\n```\n\n// alchemy/src/aws/table.ts\n```ts\nimport {\n  CreateTableCommand,\n  DeleteTableCommand,\n  DescribeTableCommand,\n  DynamoDBClient,\n  InternalServerError,\n  type KeySchemaElement,\n  ResourceInUseException,\n  ResourceNotFoundException,\n} from \"@aws-sdk/client-dynamodb\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\nimport { withExponentialBackoff } from \"../util/retry\";\n\n/**\n * Properties for creating or updating a DynamoDB table\n */\nexport interface TableProps {\n  /**\n   * Name of the DynamoDB table\n   */\n  tableName: string;\n\n  /**\n   * Primary partition key (hash key) configuration\n   * Defines the main identifier for items in the table\n   */\n  partitionKey: {\n    /**\n     * Name of the partition key attribute\n     */\n    name: string;\n    /**\n     * Data type of the partition key\n     * S: String, N: Number, B: Binary\n     */\n    type: \"S\" | \"N\" | \"B\";\n  };\n\n  /**\n   * Optional sort key (range key) configuration\n   * Used to sort items with the same partition key\n   */\n  sortKey?: {\n    /**\n     * Name of the sort key attribute\n     */\n    name: string;\n    /**\n     * Data type of the sort key\n     * S: String, N: Number, B: Binary\n     */\n    type: \"S\" | \"N\" | \"B\";\n  };\n\n  /**\n   * Billing mode for the table\n   * PROVISIONED: Set read/write capacity units\n   * PAY_PER_REQUEST: Pay per request pricing\n   */\n  billingMode?: \"PROVISIONED\" | \"PAY_PER_REQUEST\";\n\n  /**\n   * Read capacity units when using PROVISIONED billing mode\n   * Default: 5\n   */\n  readCapacity?: number;\n\n  /**\n   * Write capacity units when using PROVISIONED billing mode\n   * Default: 5\n   */\n  writeCapacity?: number;\n\n  /**\n   * Tags to apply to the table\n   * Key-value pairs for resource organization\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after DynamoDB table creation/update\n */\nexport interface Table extends Resource<\"dynamo::Table\">, TableProps {\n  /**\n   * ARN of the table\n   * Format: arn:aws:dynamodb:region:account-id:table/table-name\n   */\n  arn: string;\n\n  /**\n   * ARN of the table's stream if enabled\n   * Format: arn:aws:dynamodb:region:account-id:table/table-name/stream/timestamp\n   */\n  streamArn?: string;\n\n  /**\n   * Unique identifier for the table\n   */\n  tableId: string;\n}\n\n/**\n * AWS DynamoDB Table Resource\n *\n * Creates and manages DynamoDB tables with support for partition and sort keys,\n * flexible billing modes, and automatic table status monitoring.\n *\n * @example\n * // Create a table with partition and sort key\n * const table = await Table(\"user-events\", {\n *   tableName: \"user-events\",\n *   partitionKey: {\n *     name: \"id\",\n *     type: \"S\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"N\"\n *   },\n *   tags: {\n *     Environment: \"test\"\n *   }\n * });\n *\n * @example\n * // Create a table with provisioned capacity\n * const table = await Table(\"high-throughput\", {\n *   tableName: \"high-throughput\",\n *   partitionKey: {\n *     name: \"userId\",\n *     type: \"S\"\n *   },\n *   billingMode: \"PROVISIONED\",\n *   readCapacity: 100,\n *   writeCapacity: 50\n * });\n */\nexport const Table = Resource(\n  \"dynamo::Table\",\n  async function (\n    this: Context<Table>,\n    id: string,\n    props: TableProps\n  ): Promise<Table> {\n    const client = new DynamoDBClient({});\n\n    (\"foo\");\n\n    if (this.phase === \"delete\") {\n      await withExponentialBackoff(\n        async () => {\n          await ignore(ResourceNotFoundException.name, () =>\n            client.send(\n              new DeleteTableCommand({\n                TableName: props.tableName,\n              })\n            )\n          );\n        },\n        isRetryableError,\n        10, // Max attempts\n        200 // Initial delay in ms\n      );\n\n      // Wait for table to be deleted\n      let tableDeleted = false;\n      let retryCount = 0;\n      const maxRetries = 60; // Wait up to 60 seconds\n\n      while (!tableDeleted && retryCount < maxRetries) {\n        try {\n          await client.send(\n            new DescribeTableCommand({\n              TableName: props.tableName,\n            })\n          );\n          // If we get here, table still exists\n          retryCount++;\n          // Increasing delay for each retry with some jitter\n          const delay = Math.min(1000 * (1 + 0.1 * Math.random()), 5000);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        } catch (error) {\n          if (error instanceof ResourceNotFoundException) {\n            tableDeleted = true;\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      if (!tableDeleted) {\n        throw new Error(\n          `Timed out waiting for table ${props.tableName} to be deleted`\n        );\n      }\n\n      return this.destroy();\n    } else {\n      // Setup for table creation\n      const attributeDefinitions = [\n        {\n          AttributeName: props.partitionKey.name,\n          AttributeType: props.partitionKey.type,\n        },\n      ];\n\n      const keySchema: KeySchemaElement[] = [\n        {\n          AttributeName: props.partitionKey.name,\n          KeyType: \"HASH\",\n        },\n      ];\n\n      if (props.sortKey) {\n        attributeDefinitions.push({\n          AttributeName: props.sortKey.name,\n          AttributeType: props.sortKey.type,\n        });\n        keySchema.push({\n          AttributeName: props.sortKey.name,\n          KeyType: \"RANGE\",\n        });\n      }\n\n      // Attempt to create the table with exponential backoff for ResourceInUseException\n      await withExponentialBackoff(\n        async () => {\n          try {\n            // First check if table already exists\n            const describeResponse = await client.send(\n              new DescribeTableCommand({\n                TableName: props.tableName,\n              })\n            );\n\n            // If table exists and is ACTIVE, no need to create it\n            if (describeResponse.Table?.TableStatus === \"ACTIVE\") {\n              return;\n            }\n\n            // If table exists but not ACTIVE, wait for it in the polling loop below\n            if (describeResponse.Table) {\n              return;\n            }\n          } catch (error) {\n            if (error instanceof ResourceNotFoundException) {\n              // Table doesn't exist, try to create it\n              await client.send(\n                new CreateTableCommand({\n                  TableName: props.tableName,\n                  AttributeDefinitions: attributeDefinitions,\n                  KeySchema: keySchema,\n                  BillingMode: props.billingMode || \"PAY_PER_REQUEST\",\n                  ProvisionedThroughput:\n                    props.billingMode === \"PROVISIONED\"\n                      ? {\n                          ReadCapacityUnits: props.readCapacity || 5,\n                          WriteCapacityUnits: props.writeCapacity || 5,\n                        }\n                      : undefined,\n                  Tags: props.tags\n                    ? Object.entries(props.tags).map(([Key, Value]) => ({\n                        Key,\n                        Value,\n                      }))\n                    : undefined,\n                })\n              );\n            } else {\n              throw error;\n            }\n          }\n        },\n        isRetryableError,\n        10, // Max attempts\n        200 // Initial delay in ms\n      );\n\n      // Wait for table to be active with timeout\n      let tableActive = false;\n      let tableDescription;\n      let retryCount = 0;\n      const maxRetries = 60; // Wait up to 60 seconds\n\n      while (!tableActive && retryCount < maxRetries) {\n        try {\n          const response = await client.send(\n            new DescribeTableCommand({\n              TableName: props.tableName,\n            })\n          );\n\n          tableActive = response.Table?.TableStatus === \"ACTIVE\";\n          if (tableActive) {\n            tableDescription = response.Table;\n          } else {\n            retryCount++;\n            // Increasing delay for each retry with some jitter\n            const delay = Math.min(1000 * (1 + 0.1 * Math.random()), 5000);\n            await new Promise((resolve) => setTimeout(resolve, delay));\n          }\n        } catch (error) {\n          retryCount++;\n          if (!(error instanceof ResourceNotFoundException)) {\n            throw error;\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1000));\n        }\n      }\n\n      if (!tableActive) {\n        throw new Error(\n          `Timed out waiting for table ${props.tableName} to become active`\n        );\n      }\n\n      return this({\n        ...props,\n        arn: tableDescription!.TableArn!,\n        streamArn: tableDescription!.LatestStreamArn,\n        tableId: tableDescription!.TableId!,\n      });\n    }\n  }\n);\n\nconst retryableErrors = [\n  \"ResourceInUseException\",\n  \"ResourceNotFoundException\",\n  \"InternalServerError\",\n  \"ThrottlingException\",\n  \"ProvisionedThroughputExceededException\",\n  \"LimitExceededException\",\n  \"RequestLimitExceeded\",\n];\n\nfunction isRetryableError(error: any) {\n  return (\n    error instanceof ResourceInUseException ||\n    error instanceof InternalServerError ||\n    retryableErrors.includes(error?.name) ||\n    retryableErrors.includes(error?.code) ||\n    error?.$metadata?.httpStatusCode === 500\n  );\n}\n\n```"
  }
}