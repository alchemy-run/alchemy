{
  "kind": "ai::Object",
  "id": "docs/fs",
  "fqn": "github:alchemy/prod/docs/docs/fs",
  "seq": 57,
  "data": {},
  "status": "updated",
  "output": {
    "type": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "object": {
      "groups": [
        {
          "category": "Resource",
          "filename": "static-css-file.ts",
          "identifier": "StaticCSSFile"
        },
        {
          "category": "Types",
          "filename": "file-ref.ts",
          "identifier": "FileRef"
        },
        {
          "category": "Types",
          "filename": "file-collection.ts",
          "identifier": "FileCollection"
        },
        {
          "category": "Resource",
          "filename": "static-text-file.ts",
          "identifier": "StaticTextFile"
        },
        {
          "category": "Utility",
          "filename": "file-system-state-store.ts",
          "identifier": "FileSystemStateStore"
        },
        {
          "category": "Resource",
          "filename": "static-html-file.ts",
          "identifier": "StaticHTMLFile"
        },
        {
          "category": "Resource",
          "filename": "static-vue-file.ts",
          "identifier": "StaticVueFile"
        },
        {
          "category": "Resource",
          "filename": "static-yaml-file.ts",
          "identifier": "StaticYamlFile"
        },
        {
          "category": "Resource",
          "filename": "file.ts",
          "identifier": "File"
        },
        {
          "category": "Resource",
          "filename": "static-typescript-file.ts",
          "identifier": "StaticTypeScriptFile"
        },
        {
          "category": "Resource",
          "filename": "static-astro-file.ts",
          "identifier": "StaticAstroFile"
        },
        {
          "category": "Resource",
          "filename": "copy-file.ts",
          "identifier": "CopyFile"
        },
        {
          "category": "Resource",
          "filename": "folder.ts",
          "identifier": "Folder"
        },
        {
          "category": "Resource",
          "filename": "static-json-file.ts",
          "identifier": "StaticJsonFile"
        }
      ]
    },
    "messages": [
      {
        "role": "user",
        "content": "Identify and classify the documents that need to be written for the '      alchemy/src/fs' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/fs Service has the following resources:\n[static-css-file.ts](alchemy/src/fs/static-css-file.ts)\n\n[file-ref.ts](alchemy/src/fs/file-ref.ts)\n\n[file-collection.ts](alchemy/src/fs/file-collection.ts)\n\n[static-text-file.ts](alchemy/src/fs/static-text-file.ts)\n\n[file-system-state-store.ts](alchemy/src/fs/file-system-state-store.ts)\n\n[static-html-file.ts](alchemy/src/fs/static-html-file.ts)\n\n[static-vue-file.ts](alchemy/src/fs/static-vue-file.ts)\n\n[static-yaml-file.ts](alchemy/src/fs/static-yaml-file.ts)\n\n[file.ts](alchemy/src/fs/file.ts)\n\n[static-typescript-file.ts](alchemy/src/fs/static-typescript-file.ts)\n\n[static-astro-file.ts](alchemy/src/fs/static-astro-file.ts)\n\n[copy-file.ts](alchemy/src/fs/copy-file.ts)\n\n[folder.ts](alchemy/src/fs/folder.ts)\n\n[static-json-file.ts](alchemy/src/fs/static-json-file.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...).\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/fs/copy-file.ts\n```ts\nimport fs from \"node:fs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating a CopyFile resource\n */\nexport interface CopyFileProps {\n  /**\n   * Source path of the file to copy\n   */\n  src: string;\n\n  /**\n   * Destination path where the file should be copied to\n   */\n  dest: string;\n\n  /**\n   * Whether to overwrite the destination file if it already exists\n   * @default true\n   */\n  overwrite?: boolean;\n}\n\n/**\n * Output returned after CopyFile creation/update\n */\nexport interface CopyFile extends Resource<\"fs::CopyFile\">, CopyFileProps {\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  /**\n   * Whether the file was successfully copied\n   */\n  copied: boolean;\n}\n\n/**\n * CopyFile Resource\n *\n * Copies a file from a source location to a destination location.\n *\n * @example\n * // Copy a file to a new location\n * const copiedFile = await CopyFile(\"config-copy\", {\n *   src: \"config.json\",\n *   dest: \"backup/config.json\"\n * });\n *\n * @example\n * // Copy a file without overwriting if destination exists\n * const safeCopy = await CopyFile(\"safe-copy\", {\n *   src: \"data.json\",\n *   dest: \"backup/data.json\",\n *   overwrite: false\n * });\n */\nexport const CopyFile = Resource(\n  \"fs::CopyFile\",\n  async function (\n    this: Context<CopyFile>,\n    id: string,\n    props: CopyFileProps\n  ): Promise<CopyFile> {\n    const { src, dest, overwrite = true } = props;\n\n    if (this.phase === \"delete\") {\n      // When deleting, remove the destination file\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(dest));\n      return this.destroy();\n    } else {\n      try {\n        // Check if source file exists\n        await fs.promises.access(src, fs.constants.F_OK);\n\n        // If this is an update and the destination has changed, delete the old file\n        if (\n          this.phase === \"update\" &&\n          this.output?.dest &&\n          this.output.dest !== dest\n        ) {\n          await ignore(\"ENOENT\", async () =>\n            fs.promises.unlink(this.output.dest)\n          );\n        }\n\n        // Check if destination file exists\n        const destinationExists = await fs.promises\n          .access(dest, fs.constants.F_OK)\n          .then(() => true)\n          .catch(() => false);\n\n        // Copy file if destination doesn't exist or overwrite is true\n        if (!destinationExists || overwrite) {\n          await fs.promises.copyFile(src, dest);\n        }\n\n        return this({\n          src,\n          dest,\n          overwrite,\n          copied: true,\n          createdAt: Date.now(),\n        });\n      } catch (error) {\n        console.error(`Error copying file from ${src} to ${dest}:`, error);\n        throw error;\n      }\n    }\n  }\n);\n\n```\n\n// alchemy/src/fs/file-collection.ts\n```ts\n/**\n * Collection of files with their contents\n */\nexport type FileCollection = {\n  /**\n   * Type identifier for FileCollection\n   */\n  type: \"fs::FileCollection\";\n  /**\n   * Map of relative paths to file contents\n   */\n  files: {\n    [relativePath: string]: string;\n  };\n};\n\nexport function isFileCollection(value: unknown): value is FileCollection {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"type\" in value &&\n    value.type === \"fs::FileCollection\"\n  );\n}\n\n```\n\n// alchemy/src/fs/file-ref.ts\n```ts\n/**\n * Reference to a file in the filesystem\n */\nexport type FileRef = {\n  /**\n   * Type identifier for FileRef\n   */\n  kind: \"fs::FileRef\";\n  /**\n   * Path to the file\n   */\n  path: string;\n};\n\nexport function isFileRef(value: unknown): value is FileRef {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"kind\" in value &&\n    value.kind === \"fs::FileRef\"\n  );\n}\n\n```\n\n// alchemy/src/fs/file-system-state-store.ts\n```ts\nimport fs from \"node:fs/promises\";\nimport path from \"node:path\";\nimport type { Scope } from \"../scope\";\nimport { deserialize, serialize } from \"../serde\";\nimport type { State, StateStore } from \"../state\";\nimport { ignore } from \"../util/ignore\";\n\nconst stateRootDir = path.join(process.cwd(), \".alchemy\");\n\nexport class FileSystemStateStore implements StateStore {\n  public readonly dir: string;\n  constructor(public readonly scope: Scope) {\n    this.dir = path.join(stateRootDir, ...scope.chain);\n  }\n\n  async init(): Promise<void> {\n    await fs.mkdir(stateRootDir, { recursive: true });\n    await fs.mkdir(this.dir, { recursive: true });\n  }\n\n  async deinit(): Promise<void> {\n    await ignore(\"ENOENT\", () => fs.rmdir(this.dir));\n  }\n\n  async count(): Promise<number> {\n    return Object.keys(await this.list()).length;\n  }\n\n  async list(): Promise<string[]> {\n    try {\n      const files = await fs.readdir(this.dir, {\n        withFileTypes: true,\n      });\n      return files\n        .filter((dirent) => dirent.isFile() && dirent.name.endsWith(\".json\"))\n        .map((dirent) => dirent.name.replace(/\\.json$/, \"\"))\n        .map((key) => key.replaceAll(\":\", \"/\"));\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  async get(key: string): Promise<State | undefined> {\n    try {\n      const content = await fs.readFile(await this.getPath(key), \"utf8\");\n      const state = (await deserialize(\n        this.scope,\n        JSON.parse(content)\n      )) as State;\n      if (state.output === undefined) {\n        state.output = {} as any;\n      }\n      state.output.Scope = this.scope;\n      return state;\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  async set(key: string, value: State): Promise<void> {\n    return fs.writeFile(\n      await this.getPath(key),\n      JSON.stringify(await serialize(this.scope, value), null, 2)\n    );\n  }\n\n  async delete(key: string): Promise<void> {\n    return fs.unlink(await this.getPath(key));\n  }\n\n  async all(): Promise<Record<string, State>> {\n    return this.getBatch(await this.list());\n  }\n\n  async getBatch(ids: string[]): Promise<Record<string, State>> {\n    return Object.fromEntries(\n      (\n        await Promise.all(\n          Array.from(ids).flatMap(async (id) => {\n            const s = await this.get(id);\n            if (s === undefined) {\n              return [] as const;\n            }\n            return [[id, s]] as const;\n          })\n        )\n      ).flat()\n    );\n  }\n\n  private async getPath(key: string): Promise<string> {\n    if (key.includes(\":\")) {\n      throw new Error(`ID cannot include colons: ${key}`);\n    }\n    if (key.includes(\"/\")) {\n      key = key.replaceAll(\"/\", \":\");\n    }\n    const file = path.join(this.dir, `${key}.json`);\n    const dir = path.dirname(file);\n    await fs.mkdir(dir, { recursive: true });\n    return file;\n  }\n}\n\n```\n\n// alchemy/src/fs/file.ts\n```ts\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\nimport { alchemy } from \"../alchemy\";\nimport type { FileCollection } from \"./file-collection\";\nimport type { FileRef } from \"./file-ref\";\n\ndeclare module \"../alchemy\" {\n  interface Alchemy {\n    /**\n     * Creates a reference to a file in the filesystem.\n     * Used in template string interpolation to include file contents,\n     * commonly for documentation generation.\n     *\n     * @param path Path to the file\n     * @returns Promise resolving to a FileRef\n     *\n     * @example\n     * // Include a file in documentation generation\n     * await Document(\"api-docs\", {\n     *   prompt: await alchemy`\n     *     Generate docs using the contents of:\n     *     ${alchemy.file(\"./README.md\")}\n     *   `\n     * });\n     */\n    file(path: string): Promise<FileRef>;\n\n    /**\n     * Creates a collection of files with their contents.\n     * Used in template string interpolation to include multiple file contents,\n     * commonly for bulk documentation generation.\n     *\n     * @param paths Array of file paths to include in collection\n     * @returns Promise resolving to a FileCollection\n     *\n     * @example\n     * // Include multiple source files in documentation generation\n     * await Document(\"provider-docs\", {\n     *   prompt: await alchemy`\n     *     Generate comprehensive docs for these files:\n     *     ${alchemy.files([\n     *       \"src/types.ts\",\n     *       \"src/resource.ts\",\n     *       \"src/provider.ts\"\n     *     ])}\n     *   `\n     * });\n     */\n    files(paths: string[]): Promise<FileCollection>;\n    files(path: string, ...paths: string[]): Promise<FileCollection>;\n\n    /**\n     * Gets all of the files in a directory.\n     * @param path Path to the directory\n     * @param props Optional properties\n     * @returns Promise resolving to a FileCollection\n     *\n     * @example\n     * // Get all files in a directory\n     * const files = await alchemy.folder(\"./docs\");\n     *\n     */\n    folder(\n      path: string,\n      props?: {\n        /**\n         * Whether to recursively get all files in the directory\n         * @default false\n         */\n        recursive?: boolean;\n      }\n    ): Promise<FileCollection>;\n  }\n}\n\nalchemy.file = async (path: string) => ({\n  kind: \"fs::FileRef\",\n  path,\n});\n\nalchemy.files = async (\n  ...args: [paths: string[]] | [...paths: string[]]\n): Promise<FileCollection> => {\n  const paths: string[] =\n    typeof args[0] === \"string\" ? (args as string[]) : args[0];\n  return {\n    type: \"fs::FileCollection\",\n    files: Object.fromEntries(\n      await Promise.all(\n        paths.map(async (path) => [\n          path,\n          await fs.promises.readFile(path, \"utf-8\"),\n        ])\n      )\n    ),\n  };\n};\n\nalchemy.folder = async (dir: string, props?: { recursive?: boolean }) => {\n  const files = await fs.promises.readdir(dir, {\n    recursive: props?.recursive ?? false,\n  });\n  return alchemy.files(files.map((file) => path.join(dir, file)));\n};\n\n/**\n * Base file resource type\n */\nexport interface File extends Resource<\"fs::File\"> {\n  /**\n   * Path to the file\n   */\n  path: string;\n  /**\n   * Content of the file\n   */\n  content: string;\n}\n\n/**\n * File Resource\n *\n * Creates and manages files in the filesystem with automatic directory creation\n * and proper cleanup on deletion.\n *\n * @example\n * // Create a simple text file\n * const config = await File(\"config.txt\", {\n *   path: \"config.txt\",\n *   content: \"some configuration data\"\n * });\n *\n * @example\n * // Create a file in a nested directory\n * const log = await File(\"logs/app.log\", {\n *   path: \"logs/app.log\",\n *   content: \"application log entry\"\n * });\n *\n * @example\n * // Update file content and path\n * let file = await File(\"config.json\", {\n *   path: \"config.json\",\n *   content: '{ \"version\": \"1.0.0\" }'\n * });\n *\n * // Later, update the path and content (old file will be removed)\n * file = await File(\"config.json\", {\n *   path: \"config/config.json\",\n *   content: '{ \"version\": \"1.0.1\" }'\n * });\n */\nexport const File = Resource(\n  \"fs::File\",\n  async function (\n    this: Context<File>,\n    id: string,\n    props: {\n      path: string;\n      content: string;\n    }\n  ): Promise<File> {\n    const filePath = props?.path ?? id;\n\n    if (this.phase === \"delete\") {\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(filePath));\n      return this.destroy();\n    } else if (\n      this.phase === \"update\" &&\n      this.output &&\n      this.output.path !== filePath\n    ) {\n      // If path has changed, delete the old file\n      console.log(\n        `File: Path changed from ${this.output.path} to ${filePath}, removing old file`\n      );\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(this.output.path));\n    }\n\n    // Create directory and write file\n    await fs.promises.mkdir(path.dirname(filePath), {\n      recursive: true,\n    });\n    await fs.promises.writeFile(filePath, props.content);\n\n    return this({\n      path: filePath,\n      content: props.content,\n    });\n  }\n);\n\n```\n\n// alchemy/src/fs/folder.ts\n```ts\nimport fs from \"node:fs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\nexport interface FolderProps {\n  /**\n   * The path of the folder\n   */\n  path?: string;\n  /**\n   * Whether to delete the folder during the delete phase\n   * @default true\n   */\n  delete?: boolean;\n\n  /**\n   * Whether to clean the folder during the deletion phase (even if it contains existing files)\n   * @default false\n   */\n  clean?: boolean;\n\n  /**\n   * Whether to create the folder recursively\n   * @default true\n   */\n  recursive?: boolean;\n}\n\n/**\n * Base folder resource type\n */\nexport interface Folder extends Resource<\"fs::Folder\"> {\n  path: string;\n}\n\n/**\n * Folder Resource\n *\n * Creates and manages directories in the filesystem with automatic parent\n * directory creation and cleanup on deletion.\n *\n * @example\n * // Create a directory using id as path\n * const dir = await Folder(\"uploads\");\n *\n * @example\n * // Create a directory with explicit path\n * const dir = await Folder(\"uploads\", {\n *   path: \"uploads\"\n * });\n *\n * @example\n * // Create a nested directory structure\n * const logs = await Folder(\"var/log/app\", {\n *   path: \"var/log/app\"\n * });\n */\nexport const Folder = Resource(\n  \"fs::Folder\",\n  async function (\n    this: Context<Folder>,\n    id: string,\n    props?: FolderProps,\n  ): Promise<Folder> {\n    const dirPath = props?.path ?? id;\n    if (this.phase === \"delete\") {\n      if (props?.delete !== false) {\n        // we just do a best effort attempt\n        await ignore([\"ENOENT\", \"ENOTEMPTY\"], async () =>\n          fs.promises.rmdir(dirPath, { recursive: props?.clean ?? false }),\n        );\n      }\n      return this.destroy();\n    } else {\n      await ignore(\"EEXIST\", async () =>\n        fs.promises.mkdir(dirPath, { recursive: props?.recursive ?? true }),\n      );\n    }\n    return this({\n      path: dirPath,\n    });\n  },\n);\n\n```\n\n// alchemy/src/fs/static-astro-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticAstroFile = File;\n\n/**\n * Creates a static Astro component file\n *\n * @example\n * // Create an Astro component file with content\n * const header = await StaticAstroFile(\"Header.astro\",\n *   `---\n *   import Logo from '../components/Logo.astro';\n *   const navItems = ['Home', 'About', 'Contact'];\n *   ---\n *\n *   <header class=\"header\">\n *     <Logo />\n *     <nav>\n *       <ul>\n *         {navItems.map(item => (\n *           <li><a href={`/${item.toLowerCase()}`}>{item}</a></li>\n *         ))}\n *       </ul>\n *     </nav>\n *   </header>\n *\n *   <style>\n *     .header {\n *       display: flex;\n *       justify-content: space-between;\n *       padding: 1rem;\n *     }\n *   </style>`\n * );\n */\nexport function StaticAstroFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticAstroFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-css-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticCSSFile = File;\n\n/**\n * Creates a static CSS file\n *\n * @example\n * // Create a CSS file with styles\n * const styles = await StaticCSSFile(\"styles.css\",\n *   `.container {\n *     max-width: 1200px;\n *     margin: 0 auto;\n *     padding: 0 1rem;\n *   }\n *\n *   .button {\n *     background-color: #0062ff;\n *     color: white;\n *     border: none;\n *     padding: 0.5rem 1rem;\n *     border-radius: 4px;\n *   }`\n * );\n */\nexport function StaticCSSFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticCSSFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-html-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticHTMLFile = File;\n\n/**\n * Creates a static HTML file\n *\n * @example\n * // Create an HTML file with content\n * const page = await StaticHTMLFile(\"index.html\",\n *   `<!DOCTYPE html>\n *   <html lang=\"en\">\n *   <head>\n *     <meta charset=\"UTF-8\">\n *     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n *     <title>My Website</title>\n *     <link rel=\"stylesheet\" href=\"styles.css\">\n *   </head>\n *   <body>\n *     <header>\n *       <h1>Welcome to My Website</h1>\n *     </header>\n *     <main>\n *       <p>This is the main content of the page.</p>\n *     </main>\n *     <footer>\n *       <p>&copy; 2024 My Company</p>\n *     </footer>\n *   </body>\n *   </html>`\n * );\n */\nexport function StaticHTMLFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticHTMLFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-json-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a JSON file with formatted content\n *\n * @example\n * // Create a JSON configuration file\n * const config = await StaticJsonFile(\"config.json\", {\n *   api: {\n *     endpoint: \"https://api.example.com\",\n *     version: \"v1\"\n *   },\n *   features: [\"auth\", \"logging\"]\n * });\n */\nexport type StaticJsonFile = File;\n\nexport async function StaticJsonFile(\n  id: string,\n  ...args: [content: any] | [path: string, content: any]\n): Promise<StaticJsonFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const prettier = await import(\"prettier\");\n  return File(id, {\n    path,\n    content: await prettier.format(JSON.stringify(content), {\n      parser: \"json\",\n      editor: {\n        tabWidth: 2,\n        indentWidth: 2,\n      },\n    }),\n  });\n}\n\n```\n\n// alchemy/src/fs/static-text-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a plain text file\n *\n * @example\n * // Create a text file with content\n * const readme = await TextFile(\"README.md\",\n *   \"# Project Name\\n\\nProject description goes here.\"\n * );\n */\nexport type StaticTextFile = File;\n\nexport function StaticTextFile(\n  id: string,\n  ...args: \n  | [content: string]\n  | [path: string, content: string]\n): Promise<StaticTextFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-typescript-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a TypeScript file with formatted content using prettier\n *\n * @example\n * // Create a TypeScript file\n * const component = await StaticTypeScriptFile(\"Component.ts\", `\n *   interface Props {\n *     name: string;\n *     age: number;\n *   }\n *\n *   export function Component({ name, age }: Props) {\n *     return <div>Hello {name}, you are {age} years old</div>;\n *   }\n * `);\n */\nexport type StaticTypeScriptFile = File;\n\nexport async function StaticTypeScriptFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticTypeScriptFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const prettier = await import(\"prettier\");\n  return File(id, {\n    path,\n    content: await prettier.format(content, {\n      parser: \"typescript\",\n      editor: {\n        tabWidth: 2,\n        indentWidth: 2,\n      },\n    }),\n  });\n}\n\n```\n\n// alchemy/src/fs/static-vue-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticVueFile = File;\n\n/**\n * Creates a static Vue component file\n *\n * @example\n * // Create a Vue component file with content\n * const button = await StaticVueFile(\"Button.vue\",\n *   `<template>\n *     <button class=\"btn\">{{ text }}</button>\n *   </template>\n *\n *   <script>\n *   export default {\n *     props: {\n *       text: String\n *     }\n *   }\n *   </script>\n *\n *   <style>\n *   .btn {\n *     padding: 0.5rem 1rem;\n *   }\n *   </style>`\n * );\n */\nexport function StaticVueFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticVueFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-yaml-file.ts\n```ts\nimport { File } from \"./file\";\n/**\n * Creates a YAML file with formatted content\n *\n * @example\n * // Create a YAML configuration file\n * const config = await StaticYamlFile(\"config.yaml\", {\n *   server: {\n *     host: \"localhost\",\n *     port: 3000\n *   },\n *   database: {\n *     url: \"postgresql://localhost:5432/db\",\n *     pool: {\n *       min: 1,\n *       max: 10\n *     }\n *   }\n * });\n */\nexport type StaticYamlFile = File;\n\nexport async function StaticYamlFile(\n  id: string,\n  ...args: [content: any] | [path: string, content: any]\n): Promise<StaticYamlFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const yaml = await import(\"yaml\");\n  return File(id, {\n    path,\n    content: yaml.stringify(content),\n  });\n}\n\n```"
      },
      {
        "role": "assistant",
        "content": "{\"groups\":[{\"category\":\"Resource\",\"filename\":\"static-css-file.ts\",\"identifier\":\"StaticCSSFile\"},{\"category\":\"Types\",\"filename\":\"file-ref.ts\",\"identifier\":\"FileRef\"},{\"category\":\"Types\",\"filename\":\"file-collection.ts\",\"identifier\":\"FileCollection\"},{\"category\":\"Resource\",\"filename\":\"static-text-file.ts\",\"identifier\":\"StaticTextFile\"},{\"category\":\"Utility\",\"filename\":\"file-system-state-store.ts\",\"identifier\":\"FileSystemStateStore\"},{\"category\":\"Resource\",\"filename\":\"static-html-file.ts\",\"identifier\":\"StaticHTMLFile\"},{\"category\":\"Resource\",\"filename\":\"static-vue-file.ts\",\"identifier\":\"StaticVueFile\"},{\"category\":\"Resource\",\"filename\":\"static-yaml-file.ts\",\"identifier\":\"StaticYamlFile\"},{\"category\":\"Resource\",\"filename\":\"file.ts\",\"identifier\":\"File\"},{\"category\":\"Resource\",\"filename\":\"static-typescript-file.ts\",\"identifier\":\"StaticTypeScriptFile\"},{\"category\":\"Resource\",\"filename\":\"static-astro-file.ts\",\"identifier\":\"StaticAstroFile\"},{\"category\":\"Resource\",\"filename\":\"copy-file.ts\",\"identifier\":\"CopyFile\"},{\"category\":\"Resource\",\"filename\":\"folder.ts\",\"identifier\":\"Folder\"},{\"category\":\"Resource\",\"filename\":\"static-json-file.ts\",\"identifier\":\"StaticJsonFile\"}]}"
      }
    ],
    "createdAt": 1744513424074,
    "Kind": "ai::Object",
    "ID": "docs/fs",
    "FQN": "github:alchemy/prod/docs/docs/fs",
    "Seq": 57
  },
  "props": {
    "model": {
      "id": "o3-mini",
      "provider": "openai",
      "options": {
        "reasoningEffort": "high"
      }
    },
    "freeze": true,
    "temperature": 0.1,
    "schema": {
      "required": [
        {
          "key": "groups",
          "value": {
            "sequence": {
              "required": [
                {
                  "key": "category",
                  "value": {
                    "branches": [
                      {
                        "unit": "Client",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Resource",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Types",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      },
                      {
                        "unit": "Utility",
                        "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                      }
                    ],
                    "meta": "The classification of the Resource's Document, one of: Resource, Client, Utility, or Types."
                  }
                },
                {
                  "key": "filename",
                  "value": {
                    "domain": "string",
                    "meta": "The filename of the Resource's Document, e.g. bucket.md or static-site.md"
                  }
                },
                {
                  "key": "identifier",
                  "value": {
                    "domain": "string",
                    "meta": "The identifier of the file's primary exported Resource/Function/Type, e.g. Bucket or StaticSite, AstroFile, TypeScriptFile"
                  }
                }
              ],
              "domain": "object"
            },
            "proto": "Array"
          }
        }
      ],
      "domain": "object"
    },
    "system": "You are a technical writer tasked with identifying the distinct documents that need to be written for a document group (folder) in a documentation site.\nYou will be provided with a list of documents and instructions on how to classify them.\nEach document has a title, file name, and category.\n    \n",
    "prompt": "Identify and classify the documents that need to be written for the '      alchemy/src/fs' Service's Alchemy Resources.\nFor background knowledge on Alchemy, see [README.md](./README.md).\nFor background knowledge on the structure of an Alchemy Resource, see [.cursorrules](./.cursorrules).\n\nThe       alchemy/src/fs Service has the following resources:\n[static-css-file.ts](alchemy/src/fs/static-css-file.ts)\n\n[file-ref.ts](alchemy/src/fs/file-ref.ts)\n\n[file-collection.ts](alchemy/src/fs/file-collection.ts)\n\n[static-text-file.ts](alchemy/src/fs/static-text-file.ts)\n\n[file-system-state-store.ts](alchemy/src/fs/file-system-state-store.ts)\n\n[static-html-file.ts](alchemy/src/fs/static-html-file.ts)\n\n[static-vue-file.ts](alchemy/src/fs/static-vue-file.ts)\n\n[static-yaml-file.ts](alchemy/src/fs/static-yaml-file.ts)\n\n[file.ts](alchemy/src/fs/file.ts)\n\n[static-typescript-file.ts](alchemy/src/fs/static-typescript-file.ts)\n\n[static-astro-file.ts](alchemy/src/fs/static-astro-file.ts)\n\n[copy-file.ts](alchemy/src/fs/copy-file.ts)\n\n[folder.ts](alchemy/src/fs/folder.ts)\n\n[static-json-file.ts](alchemy/src/fs/static-json-file.ts)\n\nA file is considered a \"Resource\" if it contains a const <ResourceName> = Resource(...) call or if it is a function that calls a Resource function, e.g. const TypeScriptFile = () => File(...), or it is the Workflow or DurableObject classes.\nA file is considered a \"Client\" if it exposes a wrapper around creating a SDK client or fetch.\nA file is considered a \"Utility\" if it contains utility functions that are not resources or clients.\nA file is considered a \"Types\" if it contains just type definitions and maybe helpers around working with those types.\n\nThe title should be simply the name of the resource's const in code (with spaces added in between each word), e.g. \"Bucket\" or \"Function\", except with spaces, e.g. \"StaticSite\" for \"const StaticSite\". Maintain all other casing.\n\n// \"Resource Name\"\nconst ResourceName = Resource(...)\n    \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy/src/fs/copy-file.ts\n```ts\nimport fs from \"node:fs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating a CopyFile resource\n */\nexport interface CopyFileProps {\n  /**\n   * Source path of the file to copy\n   */\n  src: string;\n\n  /**\n   * Destination path where the file should be copied to\n   */\n  dest: string;\n\n  /**\n   * Whether to overwrite the destination file if it already exists\n   * @default true\n   */\n  overwrite?: boolean;\n}\n\n/**\n * Output returned after CopyFile creation/update\n */\nexport interface CopyFile extends Resource<\"fs::CopyFile\">, CopyFileProps {\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  /**\n   * Whether the file was successfully copied\n   */\n  copied: boolean;\n}\n\n/**\n * CopyFile Resource\n *\n * Copies a file from a source location to a destination location.\n *\n * @example\n * // Copy a file to a new location\n * const copiedFile = await CopyFile(\"config-copy\", {\n *   src: \"config.json\",\n *   dest: \"backup/config.json\"\n * });\n *\n * @example\n * // Copy a file without overwriting if destination exists\n * const safeCopy = await CopyFile(\"safe-copy\", {\n *   src: \"data.json\",\n *   dest: \"backup/data.json\",\n *   overwrite: false\n * });\n */\nexport const CopyFile = Resource(\n  \"fs::CopyFile\",\n  async function (\n    this: Context<CopyFile>,\n    id: string,\n    props: CopyFileProps\n  ): Promise<CopyFile> {\n    const { src, dest, overwrite = true } = props;\n\n    if (this.phase === \"delete\") {\n      // When deleting, remove the destination file\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(dest));\n      return this.destroy();\n    } else {\n      try {\n        // Check if source file exists\n        await fs.promises.access(src, fs.constants.F_OK);\n\n        // If this is an update and the destination has changed, delete the old file\n        if (\n          this.phase === \"update\" &&\n          this.output?.dest &&\n          this.output.dest !== dest\n        ) {\n          await ignore(\"ENOENT\", async () =>\n            fs.promises.unlink(this.output.dest)\n          );\n        }\n\n        // Check if destination file exists\n        const destinationExists = await fs.promises\n          .access(dest, fs.constants.F_OK)\n          .then(() => true)\n          .catch(() => false);\n\n        // Copy file if destination doesn't exist or overwrite is true\n        if (!destinationExists || overwrite) {\n          await fs.promises.copyFile(src, dest);\n        }\n\n        return this({\n          src,\n          dest,\n          overwrite,\n          copied: true,\n          createdAt: Date.now(),\n        });\n      } catch (error) {\n        console.error(`Error copying file from ${src} to ${dest}:`, error);\n        throw error;\n      }\n    }\n  }\n);\n\n```\n\n// alchemy/src/fs/file-collection.ts\n```ts\n/**\n * Collection of files with their contents\n */\nexport type FileCollection = {\n  /**\n   * Type identifier for FileCollection\n   */\n  type: \"fs::FileCollection\";\n  /**\n   * Map of relative paths to file contents\n   */\n  files: {\n    [relativePath: string]: string;\n  };\n};\n\nexport function isFileCollection(value: unknown): value is FileCollection {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"type\" in value &&\n    value.type === \"fs::FileCollection\"\n  );\n}\n\n```\n\n// alchemy/src/fs/file-ref.ts\n```ts\n/**\n * Reference to a file in the filesystem\n */\nexport type FileRef = {\n  /**\n   * Type identifier for FileRef\n   */\n  kind: \"fs::FileRef\";\n  /**\n   * Path to the file\n   */\n  path: string;\n};\n\nexport function isFileRef(value: unknown): value is FileRef {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"kind\" in value &&\n    value.kind === \"fs::FileRef\"\n  );\n}\n\n```\n\n// alchemy/src/fs/file-system-state-store.ts\n```ts\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Scope } from \"../scope\";\nimport { deserialize, serialize } from \"../serde\";\nimport type { State, StateStore } from \"../state\";\nimport { ignore } from \"../util/ignore\";\n\nconst stateRootDir = path.join(process.cwd(), \".alchemy\");\n\nexport class FileSystemStateStore implements StateStore {\n  public readonly dir: string;\n  private initialized = false;\n  constructor(public readonly scope: Scope) {\n    this.dir = path.join(stateRootDir, ...scope.chain);\n  }\n\n  async init(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n    this.initialized = true;\n    await fs.promises.mkdir(this.dir, { recursive: true });\n  }\n\n  async deinit(): Promise<void> {\n    await ignore(\"ENOENT\", () => fs.promises.rmdir(this.dir));\n  }\n\n  async count(): Promise<number> {\n    return Object.keys(await this.list()).length;\n  }\n\n  async list(): Promise<string[]> {\n    try {\n      const files = await fs.promises.readdir(this.dir, {\n        withFileTypes: true,\n      });\n      return files\n        .filter((dirent) => dirent.isFile() && dirent.name.endsWith(\".json\"))\n        .map((dirent) => dirent.name.replace(/\\.json$/, \"\"))\n        .map((key) => key.replaceAll(\":\", \"/\"));\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  async get(key: string): Promise<State | undefined> {\n    try {\n      const content = await fs.promises.readFile(this.getPath(key), \"utf8\");\n      const state = (await deserialize(\n        this.scope,\n        JSON.parse(content)\n      )) as State;\n      if (state.output === undefined) {\n        state.output = {} as any;\n      }\n      state.output.Scope = this.scope;\n      return state;\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  async set(key: string, value: State): Promise<void> {\n    await this.init();\n    await fs.promises.writeFile(\n      this.getPath(key),\n      JSON.stringify(await serialize(this.scope, value), null, 2)\n    );\n  }\n\n  async delete(key: string): Promise<void> {\n    try {\n      return await fs.promises.unlink(this.getPath(key));\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return;\n      }\n      throw error;\n    }\n  }\n\n  async all(): Promise<Record<string, State>> {\n    return this.getBatch(await this.list());\n  }\n\n  async getBatch(ids: string[]): Promise<Record<string, State>> {\n    return Object.fromEntries(\n      (\n        await Promise.all(\n          Array.from(ids).flatMap(async (id) => {\n            const s = await this.get(id);\n            if (s === undefined) {\n              return [] as const;\n            }\n            return [[id, s]] as const;\n          })\n        )\n      ).flat()\n    );\n  }\n\n  private getPath(key: string): string {\n    if (key.includes(\":\")) {\n      throw new Error(`ID cannot include colons: ${key}`);\n    }\n    if (key.includes(\"/\")) {\n      key = key.replaceAll(\"/\", \":\");\n    }\n    return path.join(this.dir, `${key}.json`);\n  }\n}\n\n```\n\n// alchemy/src/fs/file.ts\n```ts\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\nimport { alchemy } from \"../alchemy\";\nimport type { FileCollection } from \"./file-collection\";\nimport type { FileRef } from \"./file-ref\";\n\ndeclare module \"../alchemy\" {\n  interface Alchemy {\n    /**\n     * Creates a reference to a file in the filesystem.\n     * Used in template string interpolation to include file contents,\n     * commonly for documentation generation.\n     *\n     * @param path Path to the file\n     * @returns Promise resolving to a FileRef\n     *\n     * @example\n     * // Include a file in documentation generation\n     * await Document(\"api-docs\", {\n     *   prompt: await alchemy`\n     *     Generate docs using the contents of:\n     *     ${alchemy.file(\"./README.md\")}\n     *   `\n     * });\n     */\n    file(path: string): Promise<FileRef>;\n\n    /**\n     * Creates a collection of files with their contents.\n     * Used in template string interpolation to include multiple file contents,\n     * commonly for bulk documentation generation.\n     *\n     * @param paths Array of file paths to include in collection\n     * @returns Promise resolving to a FileCollection\n     *\n     * @example\n     * // Include multiple source files in documentation generation\n     * await Document(\"provider-docs\", {\n     *   prompt: await alchemy`\n     *     Generate comprehensive docs for these files:\n     *     ${alchemy.files([\n     *       \"src/types.ts\",\n     *       \"src/resource.ts\",\n     *       \"src/provider.ts\"\n     *     ])}\n     *   `\n     * });\n     */\n    files(paths: string[]): Promise<FileCollection>;\n    files(path: string, ...paths: string[]): Promise<FileCollection>;\n\n    /**\n     * Gets all of the files in a directory.\n     * @param path Path to the directory\n     * @param props Optional properties\n     * @returns Promise resolving to a FileCollection\n     *\n     * @example\n     * // Get all files in a directory\n     * const files = await alchemy.folder(\"./docs\");\n     *\n     */\n    folder(\n      path: string,\n      props?: {\n        /**\n         * Whether to recursively get all files in the directory\n         * @default false\n         */\n        recursive?: boolean;\n      }\n    ): Promise<FileCollection>;\n  }\n}\n\nalchemy.file = async (path: string) => ({\n  kind: \"fs::FileRef\",\n  path,\n});\n\nalchemy.files = async (\n  ...args: [paths: string[]] | [...paths: string[]]\n): Promise<FileCollection> => {\n  const paths: string[] =\n    typeof args[0] === \"string\" ? (args as string[]) : args[0];\n  return {\n    type: \"fs::FileCollection\",\n    files: Object.fromEntries(\n      await Promise.all(\n        paths.map(async (path) => [\n          path,\n          await fs.promises.readFile(path, \"utf-8\"),\n        ])\n      )\n    ),\n  };\n};\n\nalchemy.folder = async (dir: string, props?: { recursive?: boolean }) => {\n  const files = await fs.promises.readdir(dir, {\n    recursive: props?.recursive ?? false,\n  });\n  return alchemy.files(files.map((file) => path.join(dir, file)));\n};\n\n/**\n * Base file resource type\n */\nexport interface File extends Resource<\"fs::File\"> {\n  /**\n   * Path to the file\n   */\n  path: string;\n  /**\n   * Content of the file\n   */\n  content: string;\n}\n\n/**\n * File Resource\n *\n * Creates and manages files in the filesystem with automatic directory creation\n * and proper cleanup on deletion.\n *\n * @example\n * // Create a simple text file\n * const config = await File(\"config.txt\", {\n *   path: \"config.txt\",\n *   content: \"some configuration data\"\n * });\n *\n * @example\n * // Create a file in a nested directory\n * const log = await File(\"logs/app.log\", {\n *   path: \"logs/app.log\",\n *   content: \"application log entry\"\n * });\n *\n * @example\n * // Update file content and path\n * let file = await File(\"config.json\", {\n *   path: \"config.json\",\n *   content: '{ \"version\": \"1.0.0\" }'\n * });\n *\n * // Later, update the path and content (old file will be removed)\n * file = await File(\"config.json\", {\n *   path: \"config/config.json\",\n *   content: '{ \"version\": \"1.0.1\" }'\n * });\n */\nexport const File = Resource(\n  \"fs::File\",\n  async function (\n    this: Context<File>,\n    id: string,\n    props: {\n      path: string;\n      content: string;\n    }\n  ): Promise<File> {\n    const filePath = props?.path ?? id;\n\n    if (this.phase === \"delete\") {\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(filePath));\n      return this.destroy();\n    } else if (\n      this.phase === \"update\" &&\n      this.output &&\n      this.output.path !== filePath\n    ) {\n      // If path has changed, delete the old file\n      console.log(\n        `File: Path changed from ${this.output.path} to ${filePath}, removing old file`\n      );\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(this.output.path));\n    }\n\n    // Create directory and write file\n    await fs.promises.mkdir(path.dirname(filePath), {\n      recursive: true,\n    });\n    await fs.promises.writeFile(filePath, props.content);\n\n    return this({\n      path: filePath,\n      content: props.content,\n    });\n  }\n);\n\n```\n\n// alchemy/src/fs/folder.ts\n```ts\nimport fs from \"node:fs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\nexport interface FolderProps {\n  /**\n   * The path of the folder\n   */\n  path?: string;\n  /**\n   * Whether to delete the folder during the delete phase\n   * @default true\n   */\n  delete?: boolean;\n\n  /**\n   * Whether to clean the folder during the deletion phase (even if it contains existing files)\n   * @default false\n   */\n  clean?: boolean;\n\n  /**\n   * Whether to create the folder recursively\n   * @default true\n   */\n  recursive?: boolean;\n}\n\n/**\n * Base folder resource type\n */\nexport interface Folder extends Resource<\"fs::Folder\"> {\n  path: string;\n}\n\n/**\n * Folder Resource\n *\n * Creates and manages directories in the filesystem with automatic parent\n * directory creation and cleanup on deletion.\n *\n * @example\n * // Create a directory using id as path\n * const dir = await Folder(\"uploads\");\n *\n * @example\n * // Create a directory with explicit path\n * const dir = await Folder(\"uploads\", {\n *   path: \"uploads\"\n * });\n *\n * @example\n * // Create a nested directory structure\n * const logs = await Folder(\"var/log/app\", {\n *   path: \"var/log/app\"\n * });\n */\nexport const Folder = Resource(\n  \"fs::Folder\",\n  async function (\n    this: Context<Folder>,\n    id: string,\n    props?: FolderProps,\n  ): Promise<Folder> {\n    const dirPath = props?.path ?? id;\n    if (this.phase === \"delete\") {\n      if (props?.delete !== false) {\n        // we just do a best effort attempt\n        await ignore([\"ENOENT\", \"ENOTEMPTY\"], async () =>\n          fs.promises.rmdir(dirPath, { recursive: props?.clean ?? false }),\n        );\n      }\n      return this.destroy();\n    } else {\n      await ignore(\"EEXIST\", async () =>\n        fs.promises.mkdir(dirPath, { recursive: props?.recursive ?? true }),\n      );\n    }\n    return this({\n      path: dirPath,\n    });\n  },\n);\n\n```\n\n// alchemy/src/fs/static-astro-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticAstroFile = File;\n\n/**\n * Creates a static Astro component file\n *\n * @example\n * // Create an Astro component file with content\n * const header = await StaticAstroFile(\"Header.astro\",\n *   `---\n *   import Logo from '../components/Logo.astro';\n *   const navItems = ['Home', 'About', 'Contact'];\n *   ---\n *\n *   <header class=\"header\">\n *     <Logo />\n *     <nav>\n *       <ul>\n *         {navItems.map(item => (\n *           <li><a href={`/${item.toLowerCase()}`}>{item}</a></li>\n *         ))}\n *       </ul>\n *     </nav>\n *   </header>\n *\n *   <style>\n *     .header {\n *       display: flex;\n *       justify-content: space-between;\n *       padding: 1rem;\n *     }\n *   </style>`\n * );\n */\nexport function StaticAstroFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticAstroFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-css-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticCSSFile = File;\n\n/**\n * Creates a static CSS file\n *\n * @example\n * // Create a CSS file with styles\n * const styles = await StaticCSSFile(\"styles.css\",\n *   `.container {\n *     max-width: 1200px;\n *     margin: 0 auto;\n *     padding: 0 1rem;\n *   }\n *\n *   .button {\n *     background-color: #0062ff;\n *     color: white;\n *     border: none;\n *     padding: 0.5rem 1rem;\n *     border-radius: 4px;\n *   }`\n * );\n */\nexport function StaticCSSFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticCSSFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-html-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticHTMLFile = File;\n\n/**\n * Creates a static HTML file\n *\n * @example\n * // Create an HTML file with content\n * const page = await StaticHTMLFile(\"index.html\",\n *   `<!DOCTYPE html>\n *   <html lang=\"en\">\n *   <head>\n *     <meta charset=\"UTF-8\">\n *     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n *     <title>My Website</title>\n *     <link rel=\"stylesheet\" href=\"styles.css\">\n *   </head>\n *   <body>\n *     <header>\n *       <h1>Welcome to My Website</h1>\n *     </header>\n *     <main>\n *       <p>This is the main content of the page.</p>\n *     </main>\n *     <footer>\n *       <p>&copy; 2024 My Company</p>\n *     </footer>\n *   </body>\n *   </html>`\n * );\n */\nexport function StaticHTMLFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticHTMLFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-json-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a JSON file with formatted content\n *\n * @example\n * // Create a JSON configuration file\n * const config = await StaticJsonFile(\"config.json\", {\n *   api: {\n *     endpoint: \"https://api.example.com\",\n *     version: \"v1\"\n *   },\n *   features: [\"auth\", \"logging\"]\n * });\n */\nexport type StaticJsonFile = File;\n\nexport async function StaticJsonFile(\n  id: string,\n  ...args: [content: any] | [path: string, content: any]\n): Promise<StaticJsonFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const prettier = await import(\"prettier\");\n  return File(id, {\n    path,\n    content: await prettier.format(JSON.stringify(content), {\n      parser: \"json\",\n      editor: {\n        tabWidth: 2,\n        indentWidth: 2,\n      },\n    }),\n  });\n}\n\n```\n\n// alchemy/src/fs/static-text-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a plain text file\n *\n * @example\n * // Create a text file with content\n * const readme = await TextFile(\"README.md\",\n *   \"# Project Name\\n\\nProject description goes here.\"\n * );\n */\nexport type StaticTextFile = File;\n\nexport function StaticTextFile(\n  id: string,\n  ...args: \n  | [content: string]\n  | [path: string, content: string]\n): Promise<StaticTextFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-typescript-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a TypeScript file with formatted content using prettier\n *\n * @example\n * // Create a TypeScript file\n * const component = await StaticTypeScriptFile(\"Component.ts\", `\n *   interface Props {\n *     name: string;\n *     age: number;\n *   }\n *\n *   export function Component({ name, age }: Props) {\n *     return <div>Hello {name}, you are {age} years old</div>;\n *   }\n * `);\n */\nexport type StaticTypeScriptFile = File;\n\nexport async function StaticTypeScriptFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticTypeScriptFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const prettier = await import(\"prettier\");\n  return File(id, {\n    path,\n    content: await prettier.format(content, {\n      parser: \"typescript\",\n      editor: {\n        tabWidth: 2,\n        indentWidth: 2,\n      },\n    }),\n  });\n}\n\n```\n\n// alchemy/src/fs/static-vue-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticVueFile = File;\n\n/**\n * Creates a static Vue component file\n *\n * @example\n * // Create a Vue component file with content\n * const button = await StaticVueFile(\"Button.vue\",\n *   `<template>\n *     <button class=\"btn\">{{ text }}</button>\n *   </template>\n *\n *   <script>\n *   export default {\n *     props: {\n *       text: String\n *     }\n *   }\n *   </script>\n *\n *   <style>\n *   .btn {\n *     padding: 0.5rem 1rem;\n *   }\n *   </style>`\n * );\n */\nexport function StaticVueFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticVueFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-yaml-file.ts\n```ts\nimport { File } from \"./file\";\n/**\n * Creates a YAML file with formatted content\n *\n * @example\n * // Create a YAML configuration file\n * const config = await StaticYamlFile(\"config.yaml\", {\n *   server: {\n *     host: \"localhost\",\n *     port: 3000\n *   },\n *   database: {\n *     url: \"postgresql://localhost:5432/db\",\n *     pool: {\n *       min: 1,\n *       max: 10\n *     }\n *   }\n * });\n */\nexport type StaticYamlFile = File;\n\nexport async function StaticYamlFile(\n  id: string,\n  ...args: [content: any] | [path: string, content: any]\n): Promise<StaticYamlFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const yaml = await import(\"yaml\");\n  return File(id, {\n    path,\n    content: yaml.stringify(content),\n  });\n}\n\n```"
  }
}