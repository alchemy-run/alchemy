{
  "kind": "docs::Document",
  "id": "docs/fs/CopyFile",
  "fqn": "github:alchemy/prod/docs/docs/fs/CopyFile",
  "seq": 67,
  "data": {},
  "status": "updated",
  "output": {
    "title": "CopyFile",
    "path": "alchemy-web/docs/providers/fs/copy-file.md",
    "freeze": true,
    "model": {
      "id": "claude-3-5-sonnet-latest",
      "provider": "anthropic"
    },
    "prompt": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         fs Service:\n[static-css-file.ts](alchemy/src/fs/static-css-file.ts)\n\n[file-ref.ts](alchemy/src/fs/file-ref.ts)\n\n[file-collection.ts](alchemy/src/fs/file-collection.ts)\n\n[static-text-file.ts](alchemy/src/fs/static-text-file.ts)\n\n[file-system-state-store.ts](alchemy/src/fs/file-system-state-store.ts)\n\n[static-html-file.ts](alchemy/src/fs/static-html-file.ts)\n\n[static-vue-file.ts](alchemy/src/fs/static-vue-file.ts)\n\n[static-yaml-file.ts](alchemy/src/fs/static-yaml-file.ts)\n\n[file.ts](alchemy/src/fs/file.ts)\n\n[static-typescript-file.ts](alchemy/src/fs/static-typescript-file.ts)\n\n[static-astro-file.ts](alchemy/src/fs/static-astro-file.ts)\n\n[copy-file.ts](alchemy/src/fs/copy-file.ts)\n\n[folder.ts](alchemy/src/fs/folder.ts)\n\n[static-json-file.ts](alchemy/src/fs/static-json-file.ts)\n\nWrite concise documentation for the \"        CopyFile\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         CopyFile\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         CopyFile } from \"alchemy/        fs\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         CopyFile } from \"alchemy/        fs\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        \n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Creating Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroying Resources\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value 😵‍💫\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n// env.d.ts\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n### 4. Scope-Based Destruction\n\n```typescript\n// Destroy all resources in a scope\nimport { destroy } from \"alchemy\";\nconst scope = alchemy.scope(\"temporary\");\nconst tempFile = await File(\"temp.txt\", { ... });\n\nawait destroy(scope);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// Clean up test resources reliably with try/finally\nconst scope = alchemy.scope(\"test\");\ntry {\n  // Create test resources\n} finally {\n  await destroy(scope);\n}\n```\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\n├── dev (Stage Scope)\n│   ├── api (Nested Scope)\n│   └── database (Resource)\n└── prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/fs/copy-file.ts\n```ts\nimport fs from \"node:fs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating a CopyFile resource\n */\nexport interface CopyFileProps {\n  /**\n   * Source path of the file to copy\n   */\n  src: string;\n\n  /**\n   * Destination path where the file should be copied to\n   */\n  dest: string;\n\n  /**\n   * Whether to overwrite the destination file if it already exists\n   * @default true\n   */\n  overwrite?: boolean;\n}\n\n/**\n * Output returned after CopyFile creation/update\n */\nexport interface CopyFile extends Resource<\"fs::CopyFile\">, CopyFileProps {\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  /**\n   * Whether the file was successfully copied\n   */\n  copied: boolean;\n}\n\n/**\n * CopyFile Resource\n *\n * Copies a file from a source location to a destination location.\n *\n * @example\n * // Copy a file to a new location\n * const copiedFile = await CopyFile(\"config-copy\", {\n *   src: \"config.json\",\n *   dest: \"backup/config.json\"\n * });\n *\n * @example\n * // Copy a file without overwriting if destination exists\n * const safeCopy = await CopyFile(\"safe-copy\", {\n *   src: \"data.json\",\n *   dest: \"backup/data.json\",\n *   overwrite: false\n * });\n */\nexport const CopyFile = Resource(\n  \"fs::CopyFile\",\n  async function (\n    this: Context<CopyFile>,\n    id: string,\n    props: CopyFileProps\n  ): Promise<CopyFile> {\n    const { src, dest, overwrite = true } = props;\n\n    if (this.phase === \"delete\") {\n      // When deleting, remove the destination file\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(dest));\n      return this.destroy();\n    } else {\n      try {\n        // Check if source file exists\n        await fs.promises.access(src, fs.constants.F_OK);\n\n        // If this is an update and the destination has changed, delete the old file\n        if (\n          this.phase === \"update\" &&\n          this.output?.dest &&\n          this.output.dest !== dest\n        ) {\n          await ignore(\"ENOENT\", async () =>\n            fs.promises.unlink(this.output.dest)\n          );\n        }\n\n        // Check if destination file exists\n        const destinationExists = await fs.promises\n          .access(dest, fs.constants.F_OK)\n          .then(() => true)\n          .catch(() => false);\n\n        // Copy file if destination doesn't exist or overwrite is true\n        if (!destinationExists || overwrite) {\n          await fs.promises.copyFile(src, dest);\n        }\n\n        return this({\n          src,\n          dest,\n          overwrite,\n          copied: true,\n          createdAt: Date.now(),\n        });\n      } catch (error) {\n        console.error(`Error copying file from ${src} to ${dest}:`, error);\n        throw error;\n      }\n    }\n  }\n);\n\n```\n\n// alchemy/src/fs/file-collection.ts\n```ts\n/**\n * Collection of files with their contents\n */\nexport type FileCollection = {\n  /**\n   * Type identifier for FileCollection\n   */\n  type: \"fs::FileCollection\";\n  /**\n   * Map of relative paths to file contents\n   */\n  files: {\n    [relativePath: string]: string;\n  };\n};\n\nexport function isFileCollection(value: unknown): value is FileCollection {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"type\" in value &&\n    value.type === \"fs::FileCollection\"\n  );\n}\n\n```\n\n// alchemy/src/fs/file-ref.ts\n```ts\n/**\n * Reference to a file in the filesystem\n */\nexport type FileRef = {\n  /**\n   * Type identifier for FileRef\n   */\n  kind: \"fs::FileRef\";\n  /**\n   * Path to the file\n   */\n  path: string;\n};\n\nexport function isFileRef(value: unknown): value is FileRef {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"kind\" in value &&\n    value.kind === \"fs::FileRef\"\n  );\n}\n\n```\n\n// alchemy/src/fs/file-system-state-store.ts\n```ts\nimport fs from \"node:fs/promises\";\nimport path from \"node:path\";\nimport type { Scope } from \"../scope\";\nimport { deserialize, serialize } from \"../serde\";\nimport type { State, StateStore } from \"../state\";\nimport { ignore } from \"../util/ignore\";\n\nconst stateRootDir = path.join(process.cwd(), \".alchemy\");\n\nexport class FileSystemStateStore implements StateStore {\n  public readonly dir: string;\n  constructor(public readonly scope: Scope) {\n    this.dir = path.join(stateRootDir, ...scope.chain);\n  }\n\n  async init(): Promise<void> {\n    await fs.mkdir(stateRootDir, { recursive: true });\n    await fs.mkdir(this.dir, { recursive: true });\n  }\n\n  async deinit(): Promise<void> {\n    await ignore(\"ENOENT\", () => fs.rmdir(this.dir));\n  }\n\n  async count(): Promise<number> {\n    return Object.keys(await this.list()).length;\n  }\n\n  async list(): Promise<string[]> {\n    try {\n      const files = await fs.readdir(this.dir, {\n        withFileTypes: true,\n      });\n      return files\n        .filter((dirent) => dirent.isFile() && dirent.name.endsWith(\".json\"))\n        .map((dirent) => dirent.name.replace(/\\.json$/, \"\"))\n        .map((key) => key.replaceAll(\":\", \"/\"));\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  async get(key: string): Promise<State | undefined> {\n    try {\n      const content = await fs.readFile(await this.getPath(key), \"utf8\");\n      const state = (await deserialize(\n        this.scope,\n        JSON.parse(content)\n      )) as State;\n      if (state.output === undefined) {\n        state.output = {} as any;\n      }\n      state.output.Scope = this.scope;\n      return state;\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  async set(key: string, value: State): Promise<void> {\n    return fs.writeFile(\n      await this.getPath(key),\n      JSON.stringify(await serialize(this.scope, value), null, 2)\n    );\n  }\n\n  async delete(key: string): Promise<void> {\n    return fs.unlink(await this.getPath(key));\n  }\n\n  async all(): Promise<Record<string, State>> {\n    return this.getBatch(await this.list());\n  }\n\n  async getBatch(ids: string[]): Promise<Record<string, State>> {\n    return Object.fromEntries(\n      (\n        await Promise.all(\n          Array.from(ids).flatMap(async (id) => {\n            const s = await this.get(id);\n            if (s === undefined) {\n              return [] as const;\n            }\n            return [[id, s]] as const;\n          })\n        )\n      ).flat()\n    );\n  }\n\n  private async getPath(key: string): Promise<string> {\n    if (key.includes(\":\")) {\n      throw new Error(`ID cannot include colons: ${key}`);\n    }\n    if (key.includes(\"/\")) {\n      key = key.replaceAll(\"/\", \":\");\n    }\n    const file = path.join(this.dir, `${key}.json`);\n    const dir = path.dirname(file);\n    await fs.mkdir(dir, { recursive: true });\n    return file;\n  }\n}\n\n```\n\n// alchemy/src/fs/file.ts\n```ts\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\nimport { alchemy } from \"../alchemy\";\nimport type { FileCollection } from \"./file-collection\";\nimport type { FileRef } from \"./file-ref\";\n\ndeclare module \"../alchemy\" {\n  interface Alchemy {\n    /**\n     * Creates a reference to a file in the filesystem.\n     * Used in template string interpolation to include file contents,\n     * commonly for documentation generation.\n     *\n     * @param path Path to the file\n     * @returns Promise resolving to a FileRef\n     *\n     * @example\n     * // Include a file in documentation generation\n     * await Document(\"api-docs\", {\n     *   prompt: await alchemy`\n     *     Generate docs using the contents of:\n     *     ${alchemy.file(\"./README.md\")}\n     *   `\n     * });\n     */\n    file(path: string): Promise<FileRef>;\n\n    /**\n     * Creates a collection of files with their contents.\n     * Used in template string interpolation to include multiple file contents,\n     * commonly for bulk documentation generation.\n     *\n     * @param paths Array of file paths to include in collection\n     * @returns Promise resolving to a FileCollection\n     *\n     * @example\n     * // Include multiple source files in documentation generation\n     * await Document(\"provider-docs\", {\n     *   prompt: await alchemy`\n     *     Generate comprehensive docs for these files:\n     *     ${alchemy.files([\n     *       \"src/types.ts\",\n     *       \"src/resource.ts\",\n     *       \"src/provider.ts\"\n     *     ])}\n     *   `\n     * });\n     */\n    files(paths: string[]): Promise<FileCollection>;\n    files(path: string, ...paths: string[]): Promise<FileCollection>;\n\n    /**\n     * Gets all of the files in a directory.\n     * @param path Path to the directory\n     * @param props Optional properties\n     * @returns Promise resolving to a FileCollection\n     *\n     * @example\n     * // Get all files in a directory\n     * const files = await alchemy.folder(\"./docs\");\n     *\n     */\n    folder(\n      path: string,\n      props?: {\n        /**\n         * Whether to recursively get all files in the directory\n         * @default false\n         */\n        recursive?: boolean;\n      }\n    ): Promise<FileCollection>;\n  }\n}\n\nalchemy.file = async (path: string) => ({\n  kind: \"fs::FileRef\",\n  path,\n});\n\nalchemy.files = async (\n  ...args: [paths: string[]] | [...paths: string[]]\n): Promise<FileCollection> => {\n  const paths: string[] =\n    typeof args[0] === \"string\" ? (args as string[]) : args[0];\n  return {\n    type: \"fs::FileCollection\",\n    files: Object.fromEntries(\n      await Promise.all(\n        paths.map(async (path) => [\n          path,\n          await fs.promises.readFile(path, \"utf-8\"),\n        ])\n      )\n    ),\n  };\n};\n\nalchemy.folder = async (dir: string, props?: { recursive?: boolean }) => {\n  const files = await fs.promises.readdir(dir, {\n    recursive: props?.recursive ?? false,\n  });\n  return alchemy.files(files.map((file) => path.join(dir, file)));\n};\n\n/**\n * Base file resource type\n */\nexport interface File extends Resource<\"fs::File\"> {\n  /**\n   * Path to the file\n   */\n  path: string;\n  /**\n   * Content of the file\n   */\n  content: string;\n}\n\n/**\n * File Resource\n *\n * Creates and manages files in the filesystem with automatic directory creation\n * and proper cleanup on deletion.\n *\n * @example\n * // Create a simple text file\n * const config = await File(\"config.txt\", {\n *   path: \"config.txt\",\n *   content: \"some configuration data\"\n * });\n *\n * @example\n * // Create a file in a nested directory\n * const log = await File(\"logs/app.log\", {\n *   path: \"logs/app.log\",\n *   content: \"application log entry\"\n * });\n *\n * @example\n * // Update file content and path\n * let file = await File(\"config.json\", {\n *   path: \"config.json\",\n *   content: '{ \"version\": \"1.0.0\" }'\n * });\n *\n * // Later, update the path and content (old file will be removed)\n * file = await File(\"config.json\", {\n *   path: \"config/config.json\",\n *   content: '{ \"version\": \"1.0.1\" }'\n * });\n */\nexport const File = Resource(\n  \"fs::File\",\n  async function (\n    this: Context<File>,\n    id: string,\n    props: {\n      path: string;\n      content: string;\n    }\n  ): Promise<File> {\n    const filePath = props?.path ?? id;\n\n    if (this.phase === \"delete\") {\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(filePath));\n      return this.destroy();\n    } else if (\n      this.phase === \"update\" &&\n      this.output &&\n      this.output.path !== filePath\n    ) {\n      // If path has changed, delete the old file\n      console.log(\n        `File: Path changed from ${this.output.path} to ${filePath}, removing old file`\n      );\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(this.output.path));\n    }\n\n    // Create directory and write file\n    await fs.promises.mkdir(path.dirname(filePath), {\n      recursive: true,\n    });\n    await fs.promises.writeFile(filePath, props.content);\n\n    return this({\n      path: filePath,\n      content: props.content,\n    });\n  }\n);\n\n```\n\n// alchemy/src/fs/folder.ts\n```ts\nimport fs from \"node:fs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\nexport interface FolderProps {\n  /**\n   * The path of the folder\n   */\n  path?: string;\n  /**\n   * Whether to delete the folder during the delete phase\n   * @default true\n   */\n  delete?: boolean;\n\n  /**\n   * Whether to clean the folder during the deletion phase (even if it contains existing files)\n   * @default false\n   */\n  clean?: boolean;\n\n  /**\n   * Whether to create the folder recursively\n   * @default true\n   */\n  recursive?: boolean;\n}\n\n/**\n * Base folder resource type\n */\nexport interface Folder extends Resource<\"fs::Folder\"> {\n  path: string;\n}\n\n/**\n * Folder Resource\n *\n * Creates and manages directories in the filesystem with automatic parent\n * directory creation and cleanup on deletion.\n *\n * @example\n * // Create a directory using id as path\n * const dir = await Folder(\"uploads\");\n *\n * @example\n * // Create a directory with explicit path\n * const dir = await Folder(\"uploads\", {\n *   path: \"uploads\"\n * });\n *\n * @example\n * // Create a nested directory structure\n * const logs = await Folder(\"var/log/app\", {\n *   path: \"var/log/app\"\n * });\n */\nexport const Folder = Resource(\n  \"fs::Folder\",\n  async function (\n    this: Context<Folder>,\n    id: string,\n    props?: FolderProps,\n  ): Promise<Folder> {\n    const dirPath = props?.path ?? id;\n    if (this.phase === \"delete\") {\n      if (props?.delete !== false) {\n        // we just do a best effort attempt\n        await ignore([\"ENOENT\", \"ENOTEMPTY\"], async () =>\n          fs.promises.rmdir(dirPath, { recursive: props?.clean ?? false }),\n        );\n      }\n      return this.destroy();\n    } else {\n      await ignore(\"EEXIST\", async () =>\n        fs.promises.mkdir(dirPath, { recursive: props?.recursive ?? true }),\n      );\n    }\n    return this({\n      path: dirPath,\n    });\n  },\n);\n\n```\n\n// alchemy/src/fs/static-astro-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticAstroFile = File;\n\n/**\n * Creates a static Astro component file\n *\n * @example\n * // Create an Astro component file with content\n * const header = await StaticAstroFile(\"Header.astro\",\n *   `---\n *   import Logo from '../components/Logo.astro';\n *   const navItems = ['Home', 'About', 'Contact'];\n *   ---\n *\n *   <header class=\"header\">\n *     <Logo />\n *     <nav>\n *       <ul>\n *         {navItems.map(item => (\n *           <li><a href={`/${item.toLowerCase()}`}>{item}</a></li>\n *         ))}\n *       </ul>\n *     </nav>\n *   </header>\n *\n *   <style>\n *     .header {\n *       display: flex;\n *       justify-content: space-between;\n *       padding: 1rem;\n *     }\n *   </style>`\n * );\n */\nexport function StaticAstroFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticAstroFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-css-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticCSSFile = File;\n\n/**\n * Creates a static CSS file\n *\n * @example\n * // Create a CSS file with styles\n * const styles = await StaticCSSFile(\"styles.css\",\n *   `.container {\n *     max-width: 1200px;\n *     margin: 0 auto;\n *     padding: 0 1rem;\n *   }\n *\n *   .button {\n *     background-color: #0062ff;\n *     color: white;\n *     border: none;\n *     padding: 0.5rem 1rem;\n *     border-radius: 4px;\n *   }`\n * );\n */\nexport function StaticCSSFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticCSSFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-html-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticHTMLFile = File;\n\n/**\n * Creates a static HTML file\n *\n * @example\n * // Create an HTML file with content\n * const page = await StaticHTMLFile(\"index.html\",\n *   `<!DOCTYPE html>\n *   <html lang=\"en\">\n *   <head>\n *     <meta charset=\"UTF-8\">\n *     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n *     <title>My Website</title>\n *     <link rel=\"stylesheet\" href=\"styles.css\">\n *   </head>\n *   <body>\n *     <header>\n *       <h1>Welcome to My Website</h1>\n *     </header>\n *     <main>\n *       <p>This is the main content of the page.</p>\n *     </main>\n *     <footer>\n *       <p>&copy; 2024 My Company</p>\n *     </footer>\n *   </body>\n *   </html>`\n * );\n */\nexport function StaticHTMLFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticHTMLFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-json-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a JSON file with formatted content\n *\n * @example\n * // Create a JSON configuration file\n * const config = await StaticJsonFile(\"config.json\", {\n *   api: {\n *     endpoint: \"https://api.example.com\",\n *     version: \"v1\"\n *   },\n *   features: [\"auth\", \"logging\"]\n * });\n */\nexport type StaticJsonFile = File;\n\nexport async function StaticJsonFile(\n  id: string,\n  ...args: [content: any] | [path: string, content: any]\n): Promise<StaticJsonFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const prettier = await import(\"prettier\");\n  return File(id, {\n    path,\n    content: await prettier.format(JSON.stringify(content), {\n      parser: \"json\",\n      editor: {\n        tabWidth: 2,\n        indentWidth: 2,\n      },\n    }),\n  });\n}\n\n```\n\n// alchemy/src/fs/static-text-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a plain text file\n *\n * @example\n * // Create a text file with content\n * const readme = await TextFile(\"README.md\",\n *   \"# Project Name\\n\\nProject description goes here.\"\n * );\n */\nexport type StaticTextFile = File;\n\nexport function StaticTextFile(\n  id: string,\n  ...args: \n  | [content: string]\n  | [path: string, content: string]\n): Promise<StaticTextFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-typescript-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a TypeScript file with formatted content using prettier\n *\n * @example\n * // Create a TypeScript file\n * const component = await StaticTypeScriptFile(\"Component.ts\", `\n *   interface Props {\n *     name: string;\n *     age: number;\n *   }\n *\n *   export function Component({ name, age }: Props) {\n *     return <div>Hello {name}, you are {age} years old</div>;\n *   }\n * `);\n */\nexport type StaticTypeScriptFile = File;\n\nexport async function StaticTypeScriptFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticTypeScriptFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const prettier = await import(\"prettier\");\n  return File(id, {\n    path,\n    content: await prettier.format(content, {\n      parser: \"typescript\",\n      editor: {\n        tabWidth: 2,\n        indentWidth: 2,\n      },\n    }),\n  });\n}\n\n```\n\n// alchemy/src/fs/static-vue-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticVueFile = File;\n\n/**\n * Creates a static Vue component file\n *\n * @example\n * // Create a Vue component file with content\n * const button = await StaticVueFile(\"Button.vue\",\n *   `<template>\n *     <button class=\"btn\">{{ text }}</button>\n *   </template>\n *\n *   <script>\n *   export default {\n *     props: {\n *       text: String\n *     }\n *   }\n *   </script>\n *\n *   <style>\n *   .btn {\n *     padding: 0.5rem 1rem;\n *   }\n *   </style>`\n * );\n */\nexport function StaticVueFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticVueFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-yaml-file.ts\n```ts\nimport { File } from \"./file\";\n/**\n * Creates a YAML file with formatted content\n *\n * @example\n * // Create a YAML configuration file\n * const config = await StaticYamlFile(\"config.yaml\", {\n *   server: {\n *     host: \"localhost\",\n *     port: 3000\n *   },\n *   database: {\n *     url: \"postgresql://localhost:5432/db\",\n *     pool: {\n *       min: 1,\n *       max: 10\n *     }\n *   }\n * });\n */\nexport type StaticYamlFile = File;\n\nexport async function StaticYamlFile(\n  id: string,\n  ...args: [content: any] | [path: string, content: any]\n): Promise<StaticYamlFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const yaml = await import(\"yaml\");\n  return File(id, {\n    path,\n    content: yaml.stringify(content),\n  });\n}\n\n```",
    "content": "# CopyFile\n\nThe CopyFile resource lets you copy files from one location to another in your filesystem.\n\n## Minimal Example\n\nCopy a file to a new location:\n\n```ts\nimport { CopyFile } from \"alchemy/fs\";\n\nconst copy = await CopyFile(\"config-copy\", {\n  src: \"config.json\", \n  dest: \"backup/config.json\"\n});\n```\n\n## Copy Without Overwriting\n\nCopy a file only if the destination doesn't already exist:\n\n```ts\nimport { CopyFile } from \"alchemy/fs\";\n\nconst safeCopy = await CopyFile(\"safe-copy\", {\n  src: \"data.json\",\n  dest: \"backup/data.json\",\n  overwrite: false \n});\n```",
    "messages": [
      {
        "role": "user",
        "content": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         fs Service:\n[static-css-file.ts](alchemy/src/fs/static-css-file.ts)\n\n[file-ref.ts](alchemy/src/fs/file-ref.ts)\n\n[file-collection.ts](alchemy/src/fs/file-collection.ts)\n\n[static-text-file.ts](alchemy/src/fs/static-text-file.ts)\n\n[file-system-state-store.ts](alchemy/src/fs/file-system-state-store.ts)\n\n[static-html-file.ts](alchemy/src/fs/static-html-file.ts)\n\n[static-vue-file.ts](alchemy/src/fs/static-vue-file.ts)\n\n[static-yaml-file.ts](alchemy/src/fs/static-yaml-file.ts)\n\n[file.ts](alchemy/src/fs/file.ts)\n\n[static-typescript-file.ts](alchemy/src/fs/static-typescript-file.ts)\n\n[static-astro-file.ts](alchemy/src/fs/static-astro-file.ts)\n\n[copy-file.ts](alchemy/src/fs/copy-file.ts)\n\n[folder.ts](alchemy/src/fs/folder.ts)\n\n[static-json-file.ts](alchemy/src/fs/static-json-file.ts)\n\nWrite concise documentation for the \"        CopyFile\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         CopyFile\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         CopyFile } from \"alchemy/        fs\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         CopyFile } from \"alchemy/        fs\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        \n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Creating Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroying Resources\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value 😵‍💫\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n// env.d.ts\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n### 4. Scope-Based Destruction\n\n```typescript\n// Destroy all resources in a scope\nimport { destroy } from \"alchemy\";\nconst scope = alchemy.scope(\"temporary\");\nconst tempFile = await File(\"temp.txt\", { ... });\n\nawait destroy(scope);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// Clean up test resources reliably with try/finally\nconst scope = alchemy.scope(\"test\");\ntry {\n  // Create test resources\n} finally {\n  await destroy(scope);\n}\n```\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\n├── dev (Stage Scope)\n│   ├── api (Nested Scope)\n│   └── database (Resource)\n└── prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/fs/copy-file.ts\n```ts\nimport fs from \"node:fs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating a CopyFile resource\n */\nexport interface CopyFileProps {\n  /**\n   * Source path of the file to copy\n   */\n  src: string;\n\n  /**\n   * Destination path where the file should be copied to\n   */\n  dest: string;\n\n  /**\n   * Whether to overwrite the destination file if it already exists\n   * @default true\n   */\n  overwrite?: boolean;\n}\n\n/**\n * Output returned after CopyFile creation/update\n */\nexport interface CopyFile extends Resource<\"fs::CopyFile\">, CopyFileProps {\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  /**\n   * Whether the file was successfully copied\n   */\n  copied: boolean;\n}\n\n/**\n * CopyFile Resource\n *\n * Copies a file from a source location to a destination location.\n *\n * @example\n * // Copy a file to a new location\n * const copiedFile = await CopyFile(\"config-copy\", {\n *   src: \"config.json\",\n *   dest: \"backup/config.json\"\n * });\n *\n * @example\n * // Copy a file without overwriting if destination exists\n * const safeCopy = await CopyFile(\"safe-copy\", {\n *   src: \"data.json\",\n *   dest: \"backup/data.json\",\n *   overwrite: false\n * });\n */\nexport const CopyFile = Resource(\n  \"fs::CopyFile\",\n  async function (\n    this: Context<CopyFile>,\n    id: string,\n    props: CopyFileProps\n  ): Promise<CopyFile> {\n    const { src, dest, overwrite = true } = props;\n\n    if (this.phase === \"delete\") {\n      // When deleting, remove the destination file\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(dest));\n      return this.destroy();\n    } else {\n      try {\n        // Check if source file exists\n        await fs.promises.access(src, fs.constants.F_OK);\n\n        // If this is an update and the destination has changed, delete the old file\n        if (\n          this.phase === \"update\" &&\n          this.output?.dest &&\n          this.output.dest !== dest\n        ) {\n          await ignore(\"ENOENT\", async () =>\n            fs.promises.unlink(this.output.dest)\n          );\n        }\n\n        // Check if destination file exists\n        const destinationExists = await fs.promises\n          .access(dest, fs.constants.F_OK)\n          .then(() => true)\n          .catch(() => false);\n\n        // Copy file if destination doesn't exist or overwrite is true\n        if (!destinationExists || overwrite) {\n          await fs.promises.copyFile(src, dest);\n        }\n\n        return this({\n          src,\n          dest,\n          overwrite,\n          copied: true,\n          createdAt: Date.now(),\n        });\n      } catch (error) {\n        console.error(`Error copying file from ${src} to ${dest}:`, error);\n        throw error;\n      }\n    }\n  }\n);\n\n```\n\n// alchemy/src/fs/file-collection.ts\n```ts\n/**\n * Collection of files with their contents\n */\nexport type FileCollection = {\n  /**\n   * Type identifier for FileCollection\n   */\n  type: \"fs::FileCollection\";\n  /**\n   * Map of relative paths to file contents\n   */\n  files: {\n    [relativePath: string]: string;\n  };\n};\n\nexport function isFileCollection(value: unknown): value is FileCollection {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"type\" in value &&\n    value.type === \"fs::FileCollection\"\n  );\n}\n\n```\n\n// alchemy/src/fs/file-ref.ts\n```ts\n/**\n * Reference to a file in the filesystem\n */\nexport type FileRef = {\n  /**\n   * Type identifier for FileRef\n   */\n  kind: \"fs::FileRef\";\n  /**\n   * Path to the file\n   */\n  path: string;\n};\n\nexport function isFileRef(value: unknown): value is FileRef {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"kind\" in value &&\n    value.kind === \"fs::FileRef\"\n  );\n}\n\n```\n\n// alchemy/src/fs/file-system-state-store.ts\n```ts\nimport fs from \"node:fs/promises\";\nimport path from \"node:path\";\nimport type { Scope } from \"../scope\";\nimport { deserialize, serialize } from \"../serde\";\nimport type { State, StateStore } from \"../state\";\nimport { ignore } from \"../util/ignore\";\n\nconst stateRootDir = path.join(process.cwd(), \".alchemy\");\n\nexport class FileSystemStateStore implements StateStore {\n  public readonly dir: string;\n  constructor(public readonly scope: Scope) {\n    this.dir = path.join(stateRootDir, ...scope.chain);\n  }\n\n  async init(): Promise<void> {\n    await fs.mkdir(stateRootDir, { recursive: true });\n    await fs.mkdir(this.dir, { recursive: true });\n  }\n\n  async deinit(): Promise<void> {\n    await ignore(\"ENOENT\", () => fs.rmdir(this.dir));\n  }\n\n  async count(): Promise<number> {\n    return Object.keys(await this.list()).length;\n  }\n\n  async list(): Promise<string[]> {\n    try {\n      const files = await fs.readdir(this.dir, {\n        withFileTypes: true,\n      });\n      return files\n        .filter((dirent) => dirent.isFile() && dirent.name.endsWith(\".json\"))\n        .map((dirent) => dirent.name.replace(/\\.json$/, \"\"))\n        .map((key) => key.replaceAll(\":\", \"/\"));\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  async get(key: string): Promise<State | undefined> {\n    try {\n      const content = await fs.readFile(await this.getPath(key), \"utf8\");\n      const state = (await deserialize(\n        this.scope,\n        JSON.parse(content)\n      )) as State;\n      if (state.output === undefined) {\n        state.output = {} as any;\n      }\n      state.output.Scope = this.scope;\n      return state;\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  async set(key: string, value: State): Promise<void> {\n    return fs.writeFile(\n      await this.getPath(key),\n      JSON.stringify(await serialize(this.scope, value), null, 2)\n    );\n  }\n\n  async delete(key: string): Promise<void> {\n    return fs.unlink(await this.getPath(key));\n  }\n\n  async all(): Promise<Record<string, State>> {\n    return this.getBatch(await this.list());\n  }\n\n  async getBatch(ids: string[]): Promise<Record<string, State>> {\n    return Object.fromEntries(\n      (\n        await Promise.all(\n          Array.from(ids).flatMap(async (id) => {\n            const s = await this.get(id);\n            if (s === undefined) {\n              return [] as const;\n            }\n            return [[id, s]] as const;\n          })\n        )\n      ).flat()\n    );\n  }\n\n  private async getPath(key: string): Promise<string> {\n    if (key.includes(\":\")) {\n      throw new Error(`ID cannot include colons: ${key}`);\n    }\n    if (key.includes(\"/\")) {\n      key = key.replaceAll(\"/\", \":\");\n    }\n    const file = path.join(this.dir, `${key}.json`);\n    const dir = path.dirname(file);\n    await fs.mkdir(dir, { recursive: true });\n    return file;\n  }\n}\n\n```\n\n// alchemy/src/fs/file.ts\n```ts\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\nimport { alchemy } from \"../alchemy\";\nimport type { FileCollection } from \"./file-collection\";\nimport type { FileRef } from \"./file-ref\";\n\ndeclare module \"../alchemy\" {\n  interface Alchemy {\n    /**\n     * Creates a reference to a file in the filesystem.\n     * Used in template string interpolation to include file contents,\n     * commonly for documentation generation.\n     *\n     * @param path Path to the file\n     * @returns Promise resolving to a FileRef\n     *\n     * @example\n     * // Include a file in documentation generation\n     * await Document(\"api-docs\", {\n     *   prompt: await alchemy`\n     *     Generate docs using the contents of:\n     *     ${alchemy.file(\"./README.md\")}\n     *   `\n     * });\n     */\n    file(path: string): Promise<FileRef>;\n\n    /**\n     * Creates a collection of files with their contents.\n     * Used in template string interpolation to include multiple file contents,\n     * commonly for bulk documentation generation.\n     *\n     * @param paths Array of file paths to include in collection\n     * @returns Promise resolving to a FileCollection\n     *\n     * @example\n     * // Include multiple source files in documentation generation\n     * await Document(\"provider-docs\", {\n     *   prompt: await alchemy`\n     *     Generate comprehensive docs for these files:\n     *     ${alchemy.files([\n     *       \"src/types.ts\",\n     *       \"src/resource.ts\",\n     *       \"src/provider.ts\"\n     *     ])}\n     *   `\n     * });\n     */\n    files(paths: string[]): Promise<FileCollection>;\n    files(path: string, ...paths: string[]): Promise<FileCollection>;\n\n    /**\n     * Gets all of the files in a directory.\n     * @param path Path to the directory\n     * @param props Optional properties\n     * @returns Promise resolving to a FileCollection\n     *\n     * @example\n     * // Get all files in a directory\n     * const files = await alchemy.folder(\"./docs\");\n     *\n     */\n    folder(\n      path: string,\n      props?: {\n        /**\n         * Whether to recursively get all files in the directory\n         * @default false\n         */\n        recursive?: boolean;\n      }\n    ): Promise<FileCollection>;\n  }\n}\n\nalchemy.file = async (path: string) => ({\n  kind: \"fs::FileRef\",\n  path,\n});\n\nalchemy.files = async (\n  ...args: [paths: string[]] | [...paths: string[]]\n): Promise<FileCollection> => {\n  const paths: string[] =\n    typeof args[0] === \"string\" ? (args as string[]) : args[0];\n  return {\n    type: \"fs::FileCollection\",\n    files: Object.fromEntries(\n      await Promise.all(\n        paths.map(async (path) => [\n          path,\n          await fs.promises.readFile(path, \"utf-8\"),\n        ])\n      )\n    ),\n  };\n};\n\nalchemy.folder = async (dir: string, props?: { recursive?: boolean }) => {\n  const files = await fs.promises.readdir(dir, {\n    recursive: props?.recursive ?? false,\n  });\n  return alchemy.files(files.map((file) => path.join(dir, file)));\n};\n\n/**\n * Base file resource type\n */\nexport interface File extends Resource<\"fs::File\"> {\n  /**\n   * Path to the file\n   */\n  path: string;\n  /**\n   * Content of the file\n   */\n  content: string;\n}\n\n/**\n * File Resource\n *\n * Creates and manages files in the filesystem with automatic directory creation\n * and proper cleanup on deletion.\n *\n * @example\n * // Create a simple text file\n * const config = await File(\"config.txt\", {\n *   path: \"config.txt\",\n *   content: \"some configuration data\"\n * });\n *\n * @example\n * // Create a file in a nested directory\n * const log = await File(\"logs/app.log\", {\n *   path: \"logs/app.log\",\n *   content: \"application log entry\"\n * });\n *\n * @example\n * // Update file content and path\n * let file = await File(\"config.json\", {\n *   path: \"config.json\",\n *   content: '{ \"version\": \"1.0.0\" }'\n * });\n *\n * // Later, update the path and content (old file will be removed)\n * file = await File(\"config.json\", {\n *   path: \"config/config.json\",\n *   content: '{ \"version\": \"1.0.1\" }'\n * });\n */\nexport const File = Resource(\n  \"fs::File\",\n  async function (\n    this: Context<File>,\n    id: string,\n    props: {\n      path: string;\n      content: string;\n    }\n  ): Promise<File> {\n    const filePath = props?.path ?? id;\n\n    if (this.phase === \"delete\") {\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(filePath));\n      return this.destroy();\n    } else if (\n      this.phase === \"update\" &&\n      this.output &&\n      this.output.path !== filePath\n    ) {\n      // If path has changed, delete the old file\n      console.log(\n        `File: Path changed from ${this.output.path} to ${filePath}, removing old file`\n      );\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(this.output.path));\n    }\n\n    // Create directory and write file\n    await fs.promises.mkdir(path.dirname(filePath), {\n      recursive: true,\n    });\n    await fs.promises.writeFile(filePath, props.content);\n\n    return this({\n      path: filePath,\n      content: props.content,\n    });\n  }\n);\n\n```\n\n// alchemy/src/fs/folder.ts\n```ts\nimport fs from \"node:fs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\nexport interface FolderProps {\n  /**\n   * The path of the folder\n   */\n  path?: string;\n  /**\n   * Whether to delete the folder during the delete phase\n   * @default true\n   */\n  delete?: boolean;\n\n  /**\n   * Whether to clean the folder during the deletion phase (even if it contains existing files)\n   * @default false\n   */\n  clean?: boolean;\n\n  /**\n   * Whether to create the folder recursively\n   * @default true\n   */\n  recursive?: boolean;\n}\n\n/**\n * Base folder resource type\n */\nexport interface Folder extends Resource<\"fs::Folder\"> {\n  path: string;\n}\n\n/**\n * Folder Resource\n *\n * Creates and manages directories in the filesystem with automatic parent\n * directory creation and cleanup on deletion.\n *\n * @example\n * // Create a directory using id as path\n * const dir = await Folder(\"uploads\");\n *\n * @example\n * // Create a directory with explicit path\n * const dir = await Folder(\"uploads\", {\n *   path: \"uploads\"\n * });\n *\n * @example\n * // Create a nested directory structure\n * const logs = await Folder(\"var/log/app\", {\n *   path: \"var/log/app\"\n * });\n */\nexport const Folder = Resource(\n  \"fs::Folder\",\n  async function (\n    this: Context<Folder>,\n    id: string,\n    props?: FolderProps,\n  ): Promise<Folder> {\n    const dirPath = props?.path ?? id;\n    if (this.phase === \"delete\") {\n      if (props?.delete !== false) {\n        // we just do a best effort attempt\n        await ignore([\"ENOENT\", \"ENOTEMPTY\"], async () =>\n          fs.promises.rmdir(dirPath, { recursive: props?.clean ?? false }),\n        );\n      }\n      return this.destroy();\n    } else {\n      await ignore(\"EEXIST\", async () =>\n        fs.promises.mkdir(dirPath, { recursive: props?.recursive ?? true }),\n      );\n    }\n    return this({\n      path: dirPath,\n    });\n  },\n);\n\n```\n\n// alchemy/src/fs/static-astro-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticAstroFile = File;\n\n/**\n * Creates a static Astro component file\n *\n * @example\n * // Create an Astro component file with content\n * const header = await StaticAstroFile(\"Header.astro\",\n *   `---\n *   import Logo from '../components/Logo.astro';\n *   const navItems = ['Home', 'About', 'Contact'];\n *   ---\n *\n *   <header class=\"header\">\n *     <Logo />\n *     <nav>\n *       <ul>\n *         {navItems.map(item => (\n *           <li><a href={`/${item.toLowerCase()}`}>{item}</a></li>\n *         ))}\n *       </ul>\n *     </nav>\n *   </header>\n *\n *   <style>\n *     .header {\n *       display: flex;\n *       justify-content: space-between;\n *       padding: 1rem;\n *     }\n *   </style>`\n * );\n */\nexport function StaticAstroFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticAstroFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-css-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticCSSFile = File;\n\n/**\n * Creates a static CSS file\n *\n * @example\n * // Create a CSS file with styles\n * const styles = await StaticCSSFile(\"styles.css\",\n *   `.container {\n *     max-width: 1200px;\n *     margin: 0 auto;\n *     padding: 0 1rem;\n *   }\n *\n *   .button {\n *     background-color: #0062ff;\n *     color: white;\n *     border: none;\n *     padding: 0.5rem 1rem;\n *     border-radius: 4px;\n *   }`\n * );\n */\nexport function StaticCSSFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticCSSFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-html-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticHTMLFile = File;\n\n/**\n * Creates a static HTML file\n *\n * @example\n * // Create an HTML file with content\n * const page = await StaticHTMLFile(\"index.html\",\n *   `<!DOCTYPE html>\n *   <html lang=\"en\">\n *   <head>\n *     <meta charset=\"UTF-8\">\n *     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n *     <title>My Website</title>\n *     <link rel=\"stylesheet\" href=\"styles.css\">\n *   </head>\n *   <body>\n *     <header>\n *       <h1>Welcome to My Website</h1>\n *     </header>\n *     <main>\n *       <p>This is the main content of the page.</p>\n *     </main>\n *     <footer>\n *       <p>&copy; 2024 My Company</p>\n *     </footer>\n *   </body>\n *   </html>`\n * );\n */\nexport function StaticHTMLFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticHTMLFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-json-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a JSON file with formatted content\n *\n * @example\n * // Create a JSON configuration file\n * const config = await StaticJsonFile(\"config.json\", {\n *   api: {\n *     endpoint: \"https://api.example.com\",\n *     version: \"v1\"\n *   },\n *   features: [\"auth\", \"logging\"]\n * });\n */\nexport type StaticJsonFile = File;\n\nexport async function StaticJsonFile(\n  id: string,\n  ...args: [content: any] | [path: string, content: any]\n): Promise<StaticJsonFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const prettier = await import(\"prettier\");\n  return File(id, {\n    path,\n    content: await prettier.format(JSON.stringify(content), {\n      parser: \"json\",\n      editor: {\n        tabWidth: 2,\n        indentWidth: 2,\n      },\n    }),\n  });\n}\n\n```\n\n// alchemy/src/fs/static-text-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a plain text file\n *\n * @example\n * // Create a text file with content\n * const readme = await TextFile(\"README.md\",\n *   \"# Project Name\\n\\nProject description goes here.\"\n * );\n */\nexport type StaticTextFile = File;\n\nexport function StaticTextFile(\n  id: string,\n  ...args: \n  | [content: string]\n  | [path: string, content: string]\n): Promise<StaticTextFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-typescript-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a TypeScript file with formatted content using prettier\n *\n * @example\n * // Create a TypeScript file\n * const component = await StaticTypeScriptFile(\"Component.ts\", `\n *   interface Props {\n *     name: string;\n *     age: number;\n *   }\n *\n *   export function Component({ name, age }: Props) {\n *     return <div>Hello {name}, you are {age} years old</div>;\n *   }\n * `);\n */\nexport type StaticTypeScriptFile = File;\n\nexport async function StaticTypeScriptFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticTypeScriptFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const prettier = await import(\"prettier\");\n  return File(id, {\n    path,\n    content: await prettier.format(content, {\n      parser: \"typescript\",\n      editor: {\n        tabWidth: 2,\n        indentWidth: 2,\n      },\n    }),\n  });\n}\n\n```\n\n// alchemy/src/fs/static-vue-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticVueFile = File;\n\n/**\n * Creates a static Vue component file\n *\n * @example\n * // Create a Vue component file with content\n * const button = await StaticVueFile(\"Button.vue\",\n *   `<template>\n *     <button class=\"btn\">{{ text }}</button>\n *   </template>\n *\n *   <script>\n *   export default {\n *     props: {\n *       text: String\n *     }\n *   }\n *   </script>\n *\n *   <style>\n *   .btn {\n *     padding: 0.5rem 1rem;\n *   }\n *   </style>`\n * );\n */\nexport function StaticVueFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticVueFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-yaml-file.ts\n```ts\nimport { File } from \"./file\";\n/**\n * Creates a YAML file with formatted content\n *\n * @example\n * // Create a YAML configuration file\n * const config = await StaticYamlFile(\"config.yaml\", {\n *   server: {\n *     host: \"localhost\",\n *     port: 3000\n *   },\n *   database: {\n *     url: \"postgresql://localhost:5432/db\",\n *     pool: {\n *       min: 1,\n *       max: 10\n *     }\n *   }\n * });\n */\nexport type StaticYamlFile = File;\n\nexport async function StaticYamlFile(\n  id: string,\n  ...args: [content: any] | [path: string, content: any]\n): Promise<StaticYamlFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const yaml = await import(\"yaml\");\n  return File(id, {\n    path,\n    content: yaml.stringify(content),\n  });\n}\n\n```"
      },
      {
        "role": "assistant",
        "content": "# CopyFile\n\nThe CopyFile resource lets you copy files from one location to another in your filesystem.\n\n## Minimal Example\n\nCopy a file to a new location:\n\n```ts\nimport { CopyFile } from \"alchemy/fs\";\n\nconst copy = await CopyFile(\"config-copy\", {\n  src: \"config.json\", \n  dest: \"backup/config.json\"\n});\n```\n\n## Copy Without Overwriting\n\nCopy a file only if the destination doesn't already exist:\n\n```ts\nimport { CopyFile } from \"alchemy/fs\";\n\nconst safeCopy = await CopyFile(\"safe-copy\", {\n  src: \"data.json\",\n  dest: \"backup/data.json\",\n  overwrite: false \n});\n```"
      }
    ],
    "createdAt": 1744513495488,
    "updatedAt": 1744513495488,
    "file": {
      "path": "alchemy-web/docs/providers/fs/copy-file.md",
      "content": "# CopyFile\n\nThe CopyFile resource lets you copy files from one location to another in your filesystem.\n\n## Minimal Example\n\nCopy a file to a new location:\n\n```ts\nimport { CopyFile } from \"alchemy/fs\";\n\nconst copy = await CopyFile(\"config-copy\", {\n  src: \"config.json\", \n  dest: \"backup/config.json\"\n});\n```\n\n## Copy Without Overwriting\n\nCopy a file only if the destination doesn't already exist:\n\n```ts\nimport { CopyFile } from \"alchemy/fs\";\n\nconst safeCopy = await CopyFile(\"safe-copy\", {\n  src: \"data.json\",\n  dest: \"backup/data.json\",\n  overwrite: false \n});\n```",
      "Kind": "fs::File",
      "ID": "docs/fs/CopyFile-file",
      "FQN": "github:alchemy/prod/docs/docs/fs/CopyFile/docs/fs/CopyFile-file",
      "Seq": 0
    },
    "Kind": "docs::Document",
    "ID": "docs/fs/CopyFile",
    "FQN": "github:alchemy/prod/docs/docs/fs/CopyFile",
    "Seq": 67
  },
  "props": {
    "title": "CopyFile",
    "path": "alchemy-web/docs/providers/fs/copy-file.md",
    "freeze": true,
    "model": {
      "id": "claude-3-5-sonnet-latest",
      "provider": "anthropic"
    },
    "prompt": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         fs Service:\n[static-css-file.ts](alchemy/src/fs/static-css-file.ts)\n\n[file-ref.ts](alchemy/src/fs/file-ref.ts)\n\n[file-collection.ts](alchemy/src/fs/file-collection.ts)\n\n[static-text-file.ts](alchemy/src/fs/static-text-file.ts)\n\n[file-system-state-store.ts](alchemy/src/fs/file-system-state-store.ts)\n\n[static-html-file.ts](alchemy/src/fs/static-html-file.ts)\n\n[static-vue-file.ts](alchemy/src/fs/static-vue-file.ts)\n\n[static-yaml-file.ts](alchemy/src/fs/static-yaml-file.ts)\n\n[file.ts](alchemy/src/fs/file.ts)\n\n[static-typescript-file.ts](alchemy/src/fs/static-typescript-file.ts)\n\n[static-astro-file.ts](alchemy/src/fs/static-astro-file.ts)\n\n[copy-file.ts](alchemy/src/fs/copy-file.ts)\n\n[folder.ts](alchemy/src/fs/folder.ts)\n\n[static-json-file.ts](alchemy/src/fs/static-json-file.ts)\n\nWrite concise documentation for the \"        CopyFile\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         CopyFile\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         CopyFile } from \"alchemy/        fs\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         CopyFile } from \"alchemy/        fs\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        \n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Create Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroy the Resource\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\n> [!CAUTION]\n> Now, before we run our script again, you need to first add a \"naked\" impot of `alchemy/fs` at the top of our `alchemy.run.ts` script.\n> ```typescript\n> import \"alchemy/fs\"\n> ```\n> If you forget this, you would get an error\n> `Cannot destroy resource \"my-first-app/dev/hello\" type fs::File - no provider found. You may need to import the provider in your alchemy.config.ts.`\n> \n> This is because IDEs usually remove unused imports. If you don't import the resource, the delete handler won't be registered which Alchemy needs to delete the resource.\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value 😵‍💫\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n/// <reference types=\"./env.d.ts\" />\n\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\n├── dev (Stage Scope)\n│   ├── api (Nested Scope)\n│   └── database (Resource)\n└── prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/fs/copy-file.ts\n```ts\nimport fs from \"node:fs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating a CopyFile resource\n */\nexport interface CopyFileProps {\n  /**\n   * Source path of the file to copy\n   */\n  src: string;\n\n  /**\n   * Destination path where the file should be copied to\n   */\n  dest: string;\n\n  /**\n   * Whether to overwrite the destination file if it already exists\n   * @default true\n   */\n  overwrite?: boolean;\n}\n\n/**\n * Output returned after CopyFile creation/update\n */\nexport interface CopyFile extends Resource<\"fs::CopyFile\">, CopyFileProps {\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  /**\n   * Whether the file was successfully copied\n   */\n  copied: boolean;\n}\n\n/**\n * CopyFile Resource\n *\n * Copies a file from a source location to a destination location.\n *\n * @example\n * // Copy a file to a new location\n * const copiedFile = await CopyFile(\"config-copy\", {\n *   src: \"config.json\",\n *   dest: \"backup/config.json\"\n * });\n *\n * @example\n * // Copy a file without overwriting if destination exists\n * const safeCopy = await CopyFile(\"safe-copy\", {\n *   src: \"data.json\",\n *   dest: \"backup/data.json\",\n *   overwrite: false\n * });\n */\nexport const CopyFile = Resource(\n  \"fs::CopyFile\",\n  async function (\n    this: Context<CopyFile>,\n    id: string,\n    props: CopyFileProps\n  ): Promise<CopyFile> {\n    const { src, dest, overwrite = true } = props;\n\n    if (this.phase === \"delete\") {\n      // When deleting, remove the destination file\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(dest));\n      return this.destroy();\n    } else {\n      try {\n        // Check if source file exists\n        await fs.promises.access(src, fs.constants.F_OK);\n\n        // If this is an update and the destination has changed, delete the old file\n        if (\n          this.phase === \"update\" &&\n          this.output?.dest &&\n          this.output.dest !== dest\n        ) {\n          await ignore(\"ENOENT\", async () =>\n            fs.promises.unlink(this.output.dest)\n          );\n        }\n\n        // Check if destination file exists\n        const destinationExists = await fs.promises\n          .access(dest, fs.constants.F_OK)\n          .then(() => true)\n          .catch(() => false);\n\n        // Copy file if destination doesn't exist or overwrite is true\n        if (!destinationExists || overwrite) {\n          await fs.promises.copyFile(src, dest);\n        }\n\n        return this({\n          src,\n          dest,\n          overwrite,\n          copied: true,\n          createdAt: Date.now(),\n        });\n      } catch (error) {\n        console.error(`Error copying file from ${src} to ${dest}:`, error);\n        throw error;\n      }\n    }\n  }\n);\n\n```\n\n// alchemy/src/fs/file-collection.ts\n```ts\n/**\n * Collection of files with their contents\n */\nexport type FileCollection = {\n  /**\n   * Type identifier for FileCollection\n   */\n  type: \"fs::FileCollection\";\n  /**\n   * Map of relative paths to file contents\n   */\n  files: {\n    [relativePath: string]: string;\n  };\n};\n\nexport function isFileCollection(value: unknown): value is FileCollection {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"type\" in value &&\n    value.type === \"fs::FileCollection\"\n  );\n}\n\n```\n\n// alchemy/src/fs/file-ref.ts\n```ts\n/**\n * Reference to a file in the filesystem\n */\nexport type FileRef = {\n  /**\n   * Type identifier for FileRef\n   */\n  kind: \"fs::FileRef\";\n  /**\n   * Path to the file\n   */\n  path: string;\n};\n\nexport function isFileRef(value: unknown): value is FileRef {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"kind\" in value &&\n    value.kind === \"fs::FileRef\"\n  );\n}\n\n```\n\n// alchemy/src/fs/file-system-state-store.ts\n```ts\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Scope } from \"../scope\";\nimport { deserialize, serialize } from \"../serde\";\nimport type { State, StateStore } from \"../state\";\nimport { ignore } from \"../util/ignore\";\n\nconst stateRootDir = path.join(process.cwd(), \".alchemy\");\n\nexport class FileSystemStateStore implements StateStore {\n  public readonly dir: string;\n  private initialized = false;\n  constructor(public readonly scope: Scope) {\n    this.dir = path.join(stateRootDir, ...scope.chain);\n  }\n\n  async init(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n    this.initialized = true;\n    await fs.promises.mkdir(this.dir, { recursive: true });\n  }\n\n  async deinit(): Promise<void> {\n    await ignore(\"ENOENT\", () => fs.promises.rmdir(this.dir));\n  }\n\n  async count(): Promise<number> {\n    return Object.keys(await this.list()).length;\n  }\n\n  async list(): Promise<string[]> {\n    try {\n      const files = await fs.promises.readdir(this.dir, {\n        withFileTypes: true,\n      });\n      return files\n        .filter((dirent) => dirent.isFile() && dirent.name.endsWith(\".json\"))\n        .map((dirent) => dirent.name.replace(/\\.json$/, \"\"))\n        .map((key) => key.replaceAll(\":\", \"/\"));\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  async get(key: string): Promise<State | undefined> {\n    try {\n      const content = await fs.promises.readFile(this.getPath(key), \"utf8\");\n      const state = (await deserialize(\n        this.scope,\n        JSON.parse(content)\n      )) as State;\n      if (state.output === undefined) {\n        state.output = {} as any;\n      }\n      state.output.Scope = this.scope;\n      return state;\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  async set(key: string, value: State): Promise<void> {\n    await this.init();\n    await fs.promises.writeFile(\n      this.getPath(key),\n      JSON.stringify(await serialize(this.scope, value), null, 2)\n    );\n  }\n\n  async delete(key: string): Promise<void> {\n    try {\n      return await fs.promises.unlink(this.getPath(key));\n    } catch (error: any) {\n      if (error.code === \"ENOENT\") {\n        return;\n      }\n      throw error;\n    }\n  }\n\n  async all(): Promise<Record<string, State>> {\n    return this.getBatch(await this.list());\n  }\n\n  async getBatch(ids: string[]): Promise<Record<string, State>> {\n    return Object.fromEntries(\n      (\n        await Promise.all(\n          Array.from(ids).flatMap(async (id) => {\n            const s = await this.get(id);\n            if (s === undefined) {\n              return [] as const;\n            }\n            return [[id, s]] as const;\n          })\n        )\n      ).flat()\n    );\n  }\n\n  private getPath(key: string): string {\n    if (key.includes(\":\")) {\n      throw new Error(`ID cannot include colons: ${key}`);\n    }\n    if (key.includes(\"/\")) {\n      key = key.replaceAll(\"/\", \":\");\n    }\n    return path.join(this.dir, `${key}.json`);\n  }\n}\n\n```\n\n// alchemy/src/fs/file.ts\n```ts\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\nimport { alchemy } from \"../alchemy\";\nimport type { FileCollection } from \"./file-collection\";\nimport type { FileRef } from \"./file-ref\";\n\ndeclare module \"../alchemy\" {\n  interface Alchemy {\n    /**\n     * Creates a reference to a file in the filesystem.\n     * Used in template string interpolation to include file contents,\n     * commonly for documentation generation.\n     *\n     * @param path Path to the file\n     * @returns Promise resolving to a FileRef\n     *\n     * @example\n     * // Include a file in documentation generation\n     * await Document(\"api-docs\", {\n     *   prompt: await alchemy`\n     *     Generate docs using the contents of:\n     *     ${alchemy.file(\"./README.md\")}\n     *   `\n     * });\n     */\n    file(path: string): Promise<FileRef>;\n\n    /**\n     * Creates a collection of files with their contents.\n     * Used in template string interpolation to include multiple file contents,\n     * commonly for bulk documentation generation.\n     *\n     * @param paths Array of file paths to include in collection\n     * @returns Promise resolving to a FileCollection\n     *\n     * @example\n     * // Include multiple source files in documentation generation\n     * await Document(\"provider-docs\", {\n     *   prompt: await alchemy`\n     *     Generate comprehensive docs for these files:\n     *     ${alchemy.files([\n     *       \"src/types.ts\",\n     *       \"src/resource.ts\",\n     *       \"src/provider.ts\"\n     *     ])}\n     *   `\n     * });\n     */\n    files(paths: string[]): Promise<FileCollection>;\n    files(path: string, ...paths: string[]): Promise<FileCollection>;\n\n    /**\n     * Gets all of the files in a directory.\n     * @param path Path to the directory\n     * @param props Optional properties\n     * @returns Promise resolving to a FileCollection\n     *\n     * @example\n     * // Get all files in a directory\n     * const files = await alchemy.folder(\"./docs\");\n     *\n     */\n    folder(\n      path: string,\n      props?: {\n        /**\n         * Whether to recursively get all files in the directory\n         * @default false\n         */\n        recursive?: boolean;\n      }\n    ): Promise<FileCollection>;\n  }\n}\n\nalchemy.file = async (path: string) => ({\n  kind: \"fs::FileRef\",\n  path,\n});\n\nalchemy.files = async (\n  ...args: [paths: string[]] | [...paths: string[]]\n): Promise<FileCollection> => {\n  const paths: string[] =\n    typeof args[0] === \"string\" ? (args as string[]) : args[0];\n  return {\n    type: \"fs::FileCollection\",\n    files: Object.fromEntries(\n      await Promise.all(\n        paths.map(async (path) => [\n          path,\n          await fs.promises.readFile(path, \"utf-8\"),\n        ])\n      )\n    ),\n  };\n};\n\nalchemy.folder = async (dir: string, props?: { recursive?: boolean }) => {\n  const files = await fs.promises.readdir(dir, {\n    recursive: props?.recursive ?? false,\n  });\n  return alchemy.files(files.map((file) => path.join(dir, file)));\n};\n\n/**\n * Base file resource type\n */\nexport interface File extends Resource<\"fs::File\"> {\n  /**\n   * Path to the file\n   */\n  path: string;\n  /**\n   * Content of the file\n   */\n  content: string;\n}\n\n/**\n * File Resource\n *\n * Creates and manages files in the filesystem with automatic directory creation\n * and proper cleanup on deletion.\n *\n * @example\n * // Create a simple text file\n * const config = await File(\"config.txt\", {\n *   path: \"config.txt\",\n *   content: \"some configuration data\"\n * });\n *\n * @example\n * // Create a file in a nested directory\n * const log = await File(\"logs/app.log\", {\n *   path: \"logs/app.log\",\n *   content: \"application log entry\"\n * });\n *\n * @example\n * // Update file content and path\n * let file = await File(\"config.json\", {\n *   path: \"config.json\",\n *   content: '{ \"version\": \"1.0.0\" }'\n * });\n *\n * // Later, update the path and content (old file will be removed)\n * file = await File(\"config.json\", {\n *   path: \"config/config.json\",\n *   content: '{ \"version\": \"1.0.1\" }'\n * });\n */\nexport const File = Resource(\n  \"fs::File\",\n  async function (\n    this: Context<File>,\n    id: string,\n    props: {\n      path: string;\n      content: string;\n    }\n  ): Promise<File> {\n    const filePath = props?.path ?? id;\n\n    if (this.phase === \"delete\") {\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(filePath));\n      return this.destroy();\n    } else if (\n      this.phase === \"update\" &&\n      this.output &&\n      this.output.path !== filePath\n    ) {\n      // If path has changed, delete the old file\n      console.log(\n        `File: Path changed from ${this.output.path} to ${filePath}, removing old file`\n      );\n      await ignore(\"ENOENT\", async () => fs.promises.unlink(this.output.path));\n    }\n\n    // Create directory and write file\n    await fs.promises.mkdir(path.dirname(filePath), {\n      recursive: true,\n    });\n    await fs.promises.writeFile(filePath, props.content);\n\n    return this({\n      path: filePath,\n      content: props.content,\n    });\n  }\n);\n\n```\n\n// alchemy/src/fs/folder.ts\n```ts\nimport fs from \"node:fs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\nexport interface FolderProps {\n  /**\n   * The path of the folder\n   */\n  path?: string;\n  /**\n   * Whether to delete the folder during the delete phase\n   * @default true\n   */\n  delete?: boolean;\n\n  /**\n   * Whether to clean the folder during the deletion phase (even if it contains existing files)\n   * @default false\n   */\n  clean?: boolean;\n\n  /**\n   * Whether to create the folder recursively\n   * @default true\n   */\n  recursive?: boolean;\n}\n\n/**\n * Base folder resource type\n */\nexport interface Folder extends Resource<\"fs::Folder\"> {\n  path: string;\n}\n\n/**\n * Folder Resource\n *\n * Creates and manages directories in the filesystem with automatic parent\n * directory creation and cleanup on deletion.\n *\n * @example\n * // Create a directory using id as path\n * const dir = await Folder(\"uploads\");\n *\n * @example\n * // Create a directory with explicit path\n * const dir = await Folder(\"uploads\", {\n *   path: \"uploads\"\n * });\n *\n * @example\n * // Create a nested directory structure\n * const logs = await Folder(\"var/log/app\", {\n *   path: \"var/log/app\"\n * });\n */\nexport const Folder = Resource(\n  \"fs::Folder\",\n  async function (\n    this: Context<Folder>,\n    id: string,\n    props?: FolderProps,\n  ): Promise<Folder> {\n    const dirPath = props?.path ?? id;\n    if (this.phase === \"delete\") {\n      if (props?.delete !== false) {\n        // we just do a best effort attempt\n        await ignore([\"ENOENT\", \"ENOTEMPTY\"], async () =>\n          fs.promises.rmdir(dirPath, { recursive: props?.clean ?? false }),\n        );\n      }\n      return this.destroy();\n    } else {\n      await ignore(\"EEXIST\", async () =>\n        fs.promises.mkdir(dirPath, { recursive: props?.recursive ?? true }),\n      );\n    }\n    return this({\n      path: dirPath,\n    });\n  },\n);\n\n```\n\n// alchemy/src/fs/static-astro-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticAstroFile = File;\n\n/**\n * Creates a static Astro component file\n *\n * @example\n * // Create an Astro component file with content\n * const header = await StaticAstroFile(\"Header.astro\",\n *   `---\n *   import Logo from '../components/Logo.astro';\n *   const navItems = ['Home', 'About', 'Contact'];\n *   ---\n *\n *   <header class=\"header\">\n *     <Logo />\n *     <nav>\n *       <ul>\n *         {navItems.map(item => (\n *           <li><a href={`/${item.toLowerCase()}`}>{item}</a></li>\n *         ))}\n *       </ul>\n *     </nav>\n *   </header>\n *\n *   <style>\n *     .header {\n *       display: flex;\n *       justify-content: space-between;\n *       padding: 1rem;\n *     }\n *   </style>`\n * );\n */\nexport function StaticAstroFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticAstroFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-css-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticCSSFile = File;\n\n/**\n * Creates a static CSS file\n *\n * @example\n * // Create a CSS file with styles\n * const styles = await StaticCSSFile(\"styles.css\",\n *   `.container {\n *     max-width: 1200px;\n *     margin: 0 auto;\n *     padding: 0 1rem;\n *   }\n *\n *   .button {\n *     background-color: #0062ff;\n *     color: white;\n *     border: none;\n *     padding: 0.5rem 1rem;\n *     border-radius: 4px;\n *   }`\n * );\n */\nexport function StaticCSSFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticCSSFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-html-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticHTMLFile = File;\n\n/**\n * Creates a static HTML file\n *\n * @example\n * // Create an HTML file with content\n * const page = await StaticHTMLFile(\"index.html\",\n *   `<!DOCTYPE html>\n *   <html lang=\"en\">\n *   <head>\n *     <meta charset=\"UTF-8\">\n *     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n *     <title>My Website</title>\n *     <link rel=\"stylesheet\" href=\"styles.css\">\n *   </head>\n *   <body>\n *     <header>\n *       <h1>Welcome to My Website</h1>\n *     </header>\n *     <main>\n *       <p>This is the main content of the page.</p>\n *     </main>\n *     <footer>\n *       <p>&copy; 2024 My Company</p>\n *     </footer>\n *   </body>\n *   </html>`\n * );\n */\nexport function StaticHTMLFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticHTMLFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-json-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a JSON file with formatted content\n *\n * @example\n * // Create a JSON configuration file\n * const config = await StaticJsonFile(\"config.json\", {\n *   api: {\n *     endpoint: \"https://api.example.com\",\n *     version: \"v1\"\n *   },\n *   features: [\"auth\", \"logging\"]\n * });\n */\nexport type StaticJsonFile = File;\n\nexport async function StaticJsonFile(\n  id: string,\n  ...args: [content: any] | [path: string, content: any]\n): Promise<StaticJsonFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const prettier = await import(\"prettier\");\n  return File(id, {\n    path,\n    content: await prettier.format(JSON.stringify(content), {\n      parser: \"json\",\n      editor: {\n        tabWidth: 2,\n        indentWidth: 2,\n      },\n    }),\n  });\n}\n\n```\n\n// alchemy/src/fs/static-text-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a plain text file\n *\n * @example\n * // Create a text file with content\n * const readme = await TextFile(\"README.md\",\n *   \"# Project Name\\n\\nProject description goes here.\"\n * );\n */\nexport type StaticTextFile = File;\n\nexport function StaticTextFile(\n  id: string,\n  ...args: \n  | [content: string]\n  | [path: string, content: string]\n): Promise<StaticTextFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-typescript-file.ts\n```ts\nimport { File } from \"./file\";\n\n/**\n * Creates a TypeScript file with formatted content using prettier\n *\n * @example\n * // Create a TypeScript file\n * const component = await StaticTypeScriptFile(\"Component.ts\", `\n *   interface Props {\n *     name: string;\n *     age: number;\n *   }\n *\n *   export function Component({ name, age }: Props) {\n *     return <div>Hello {name}, you are {age} years old</div>;\n *   }\n * `);\n */\nexport type StaticTypeScriptFile = File;\n\nexport async function StaticTypeScriptFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticTypeScriptFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const prettier = await import(\"prettier\");\n  return File(id, {\n    path,\n    content: await prettier.format(content, {\n      parser: \"typescript\",\n      editor: {\n        tabWidth: 2,\n        indentWidth: 2,\n      },\n    }),\n  });\n}\n\n```\n\n// alchemy/src/fs/static-vue-file.ts\n```ts\nimport { File } from \"./file\";\n\nexport type StaticVueFile = File;\n\n/**\n * Creates a static Vue component file\n *\n * @example\n * // Create a Vue component file with content\n * const button = await StaticVueFile(\"Button.vue\",\n *   `<template>\n *     <button class=\"btn\">{{ text }}</button>\n *   </template>\n *\n *   <script>\n *   export default {\n *     props: {\n *       text: String\n *     }\n *   }\n *   </script>\n *\n *   <style>\n *   .btn {\n *     padding: 0.5rem 1rem;\n *   }\n *   </style>`\n * );\n */\nexport function StaticVueFile(\n  id: string,\n  ...args: [content: string] | [path: string, content: string]\n): Promise<StaticVueFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  return File(id, {\n    path,\n    content,\n  });\n}\n\n```\n\n// alchemy/src/fs/static-yaml-file.ts\n```ts\nimport { File } from \"./file\";\n/**\n * Creates a YAML file with formatted content\n *\n * @example\n * // Create a YAML configuration file\n * const config = await StaticYamlFile(\"config.yaml\", {\n *   server: {\n *     host: \"localhost\",\n *     port: 3000\n *   },\n *   database: {\n *     url: \"postgresql://localhost:5432/db\",\n *     pool: {\n *       min: 1,\n *       max: 10\n *     }\n *   }\n * });\n */\nexport type StaticYamlFile = File;\n\nexport async function StaticYamlFile(\n  id: string,\n  ...args: [content: any] | [path: string, content: any]\n): Promise<StaticYamlFile> {\n  const [path, content] = args.length === 1 ? [id, args[0]] : args;\n  const yaml = await import(\"yaml\");\n  return File(id, {\n    path,\n    content: yaml.stringify(content),\n  });\n}\n\n```"
  }
}