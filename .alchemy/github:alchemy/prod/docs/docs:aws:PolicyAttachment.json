{
  "kind": "docs::Document",
  "id": "docs/aws/PolicyAttachment",
  "fqn": "github:alchemy/prod/docs/docs/aws/PolicyAttachment",
  "seq": 45,
  "data": {},
  "status": "updated",
  "output": {
    "title": "PolicyAttachment",
    "path": "alchemy-web/docs/providers/aws/policy-attachment.md",
    "freeze": true,
    "model": {
      "id": "claude-3-5-sonnet-latest",
      "provider": "anthropic"
    },
    "prompt": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         aws Service:\n[function.ts](alchemy/src/aws/function.ts)\n\n[table.ts](alchemy/src/aws/table.ts)\n\n[account-id.ts](alchemy/src/aws/account-id.ts)\n\n[policy-attachment.ts](alchemy/src/aws/policy-attachment.ts)\n\n[role.ts](alchemy/src/aws/role.ts)\n\n[policy.ts](alchemy/src/aws/policy.ts)\n\n[credentials.ts](alchemy/src/aws/credentials.ts)\n\n[ses.ts](alchemy/src/aws/ses.ts)\n\n[bucket.ts](alchemy/src/aws/bucket.ts)\n\n[queue.ts](alchemy/src/aws/queue.ts)\n\nWrite concise documentation for the \"        PolicyAttachment\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         PolicyAttachment\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         PolicyAttachment } from \"alchemy/        aws\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         PolicyAttachment } from \"alchemy/        aws\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        \n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Creating Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroying Resources\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value ðŸ˜µâ€ðŸ’«\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n// env.d.ts\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n### 4. Scope-Based Destruction\n\n```typescript\n// Destroy all resources in a scope\nimport { destroy } from \"alchemy\";\nconst scope = alchemy.scope(\"temporary\");\nconst tempFile = await File(\"temp.txt\", { ... });\n\nawait destroy(scope);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// Clean up test resources reliably with try/finally\nconst scope = alchemy.scope(\"test\");\ntry {\n  // Create test resources\n} finally {\n  await destroy(scope);\n}\n```\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\nâ”œâ”€â”€ dev (Stage Scope)\nâ”‚   â”œâ”€â”€ api (Nested Scope)\nâ”‚   â””â”€â”€ database (Resource)\nâ””â”€â”€ prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/aws/account-id.ts\n```ts\nimport { GetCallerIdentityCommand, STSClient } from \"@aws-sdk/client-sts\";\n\nconst sts = new STSClient({});\n\nexport type AccountId = string & {\n  readonly __brand: \"AccountId\";\n};\n\n/**\n * Helper to get the current AWS account ID\n */\nexport async function AccountId(): Promise<AccountId> {\n  const identity = await sts.send(new GetCallerIdentityCommand({}));\n  return identity.Account! as AccountId;\n}\n\n```\n\n// alchemy/src/aws/bucket.ts\n```ts\nimport {\n  CreateBucketCommand,\n  DeleteBucketCommand,\n  GetBucketAclCommand,\n  GetBucketLocationCommand,\n  GetBucketTaggingCommand,\n  GetBucketVersioningCommand,\n  HeadBucketCommand,\n  NoSuchBucket,\n  PutBucketTaggingCommand,\n  S3Client,\n} from \"@aws-sdk/client-s3\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating an S3 bucket\n */\nexport interface BucketProps {\n  /**\n   * The name of the bucket. Must be globally unique across all AWS accounts.\n   * Should be lowercase alphanumeric characters or hyphens.\n   */\n  bucketName: string;\n\n  /**\n   * Optional tags to apply to the bucket for organization and cost tracking.\n   * Each tag is a key-value pair.\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after S3 bucket creation/update\n */\nexport interface Bucket extends Resource<\"s3::Bucket\">, BucketProps {\n  /**\n   * The ARN (Amazon Resource Name) of the bucket\n   * Format: arn:aws:s3:::bucket-name\n   */\n  arn: string;\n\n  /**\n   * The global domain name for the bucket\n   * Format: bucket-name.s3.amazonaws.com\n   */\n  bucketDomainName: string;\n\n  /**\n   * The regional domain name for the bucket\n   * Format: bucket-name.s3.region.amazonaws.com\n   */\n  bucketRegionalDomainName?: string;\n\n  /**\n   * The S3 hosted zone ID for the region where the bucket resides\n   * Used for DNS configuration with Route 53\n   */\n  hostedZoneId?: string;\n\n  /**\n   * The AWS region where the bucket is located\n   */\n  region?: string;\n\n  /**\n   * The website endpoint URL if static website hosting is enabled\n   * Format: http://bucket-name.s3-website-region.amazonaws.com\n   */\n  websiteEndpoint?: string;\n\n  /**\n   * The website domain if static website hosting is enabled\n   * Format: bucket-name.s3-website-region.amazonaws.com\n   */\n  websiteDomain?: string;\n\n  /**\n   * Whether versioning is enabled for the bucket\n   */\n  versioningEnabled?: boolean;\n\n  /**\n   * The canned ACL applied to the bucket\n   * Common values: private, public-read, public-read-write, authenticated-read\n   */\n  acl?: string;\n}\n\n/**\n * AWS S3 Bucket Resource\n *\n * Creates and manages Amazon S3 buckets with support for versioning, tags, and regional configuration.\n * S3 buckets provide scalable object storage for any type of data, with features like versioning,\n * lifecycle policies, and fine-grained access control.\n *\n * @example\n * // Create a basic S3 bucket with default settings\n * const basicBucket = await Bucket(\"my-app-storage\", {\n *   bucketName: \"my-app-storage\",\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"my-app\"\n *   }\n * });\n *\n * @example\n * // Create a bucket with versioning enabled and specific tags\n * const versionedBucket = await Bucket(\"document-archive\", {\n *   bucketName: \"document-archive\",\n *   tags: {\n *     Environment: \"production\",\n *     Purpose: \"document-storage\",\n *     Versioning: \"enabled\"\n *   }\n * });\n *\n * @example\n * // Create a development bucket with minimal configuration\n * const devBucket = await Bucket(\"dev-testing\", {\n *   bucketName: \"dev-testing\",\n *   tags: {\n *     Environment: \"development\",\n *     Temporary: \"true\"\n *   }\n * });\n */\nexport const Bucket = Resource(\n  \"s3::Bucket\",\n  async function (this: Context<Bucket>, id: string, props: BucketProps) {\n    const client = new S3Client({});\n\n    if (this.phase === \"delete\") {\n      await ignore(NoSuchBucket.name, () =>\n        client.send(\n          new DeleteBucketCommand({\n            Bucket: props.bucketName,\n          }),\n        ),\n      );\n      return this.destroy();\n    } else {\n      try {\n        // Check if bucket exists\n        await client.send(\n          new HeadBucketCommand({\n            Bucket: props.bucketName,\n          }),\n        );\n\n        // Update tags if they changed and bucket exists\n        if (this.phase === \"update\" && props.tags) {\n          await client.send(\n            new PutBucketTaggingCommand({\n              Bucket: props.bucketName,\n              Tagging: {\n                TagSet: Object.entries(props.tags).map(([Key, Value]) => ({\n                  Key,\n                  Value,\n                })),\n              },\n            }),\n          );\n        }\n      } catch (error: any) {\n        if (error.name === \"NotFound\") {\n          // Create bucket if it doesn't exist\n          await client.send(\n            new CreateBucketCommand({\n              Bucket: props.bucketName,\n              // Add tags during creation if specified\n              ...(props.tags && {\n                Tagging: {\n                  TagSet: Object.entries(props.tags).map(([Key, Value]) => ({\n                    Key,\n                    Value,\n                  })),\n                },\n              }),\n            }),\n          );\n        } else {\n          throw error;\n        }\n      }\n\n      // Get bucket details\n      const [locationResponse, versioningResponse, aclResponse] =\n        await Promise.all([\n          client.send(\n            new GetBucketLocationCommand({ Bucket: props.bucketName }),\n          ),\n          client.send(\n            new GetBucketVersioningCommand({ Bucket: props.bucketName }),\n          ),\n          client.send(new GetBucketAclCommand({ Bucket: props.bucketName })),\n        ]);\n\n      const region = locationResponse.LocationConstraint || \"us-east-1\";\n\n      // Get tags if they exist\n      let tags = props.tags;\n      if (!tags) {\n        try {\n          const taggingResponse = await client.send(\n            new GetBucketTaggingCommand({ Bucket: props.bucketName }),\n          );\n          tags = Object.fromEntries(\n            taggingResponse.TagSet?.map(({ Key, Value }) => [Key, Value]) || [],\n          );\n        } catch (error: any) {\n          if (error.name !== \"NoSuchTagSet\") {\n            throw error;\n          }\n        }\n      }\n\n      return this({\n        bucketName: props.bucketName,\n        arn: `arn:aws:s3:::${props.bucketName}`,\n        bucketDomainName: `${props.bucketName}.s3.amazonaws.com`,\n        bucketRegionalDomainName: `${props.bucketName}.s3.${region}.amazonaws.com`,\n        region,\n        hostedZoneId: getHostedZoneId(region),\n        versioningEnabled: versioningResponse.Status === \"Enabled\",\n        acl: aclResponse.Grants?.[0]?.Permission?.toLowerCase(),\n        ...(tags && { tags }),\n      });\n    }\n  },\n);\n\n/**\n * Helper function to get S3 hosted zone IDs by region\n *\n * Returns the S3 hosted zone ID for a given AWS region. These IDs are used when\n * configuring Route 53 DNS records that point to S3 buckets. If the region is not\n * found in the mapping, defaults to the us-east-1 hosted zone ID.\n *\n * @param region - The AWS region code (e.g., us-east-1, eu-west-1)\n * @returns The S3 hosted zone ID for the region\n */\nfunction getHostedZoneId(region: string): string {\n  const hostedZoneIds: Record<string, string> = {\n    \"us-east-1\": \"Z3AQBSTGFYJSTF\",\n    \"us-east-2\": \"Z2O1EMRO9K5GLX\",\n    \"us-west-1\": \"Z2F56UZL2M1ACD\",\n    \"us-west-2\": \"Z3BJ6K6RIION7M\",\n    \"af-south-1\": \"Z11KHD8FBVPUYU\",\n    \"ap-east-1\": \"ZNB98KWMFR0R6\",\n    \"ap-south-1\": \"Z11RGJOFQNVJUP\",\n    \"ap-northeast-1\": \"Z2M4EHUR26P7ZW\",\n    \"ap-northeast-2\": \"Z3W03O7B5YMIYP\",\n    \"ap-northeast-3\": \"Z2YQB5RD63NC85\",\n    \"ap-southeast-1\": \"Z3O0J2DXBE1FTB\",\n    \"ap-southeast-2\": \"Z1WCIGYICN2BYD\",\n    \"ca-central-1\": \"Z1QDHH18159H29\",\n    \"eu-central-1\": \"Z21DNDUVLTQW6Q\",\n    \"eu-west-1\": \"Z1BKCTXD74EZPE\",\n    \"eu-west-2\": \"Z3GKZC51ZF0DB4\",\n    \"eu-west-3\": \"Z3R1K369G5AVDG\",\n    \"eu-north-1\": \"Z3BAZG2TWCNX0D\",\n    \"eu-south-1\": \"Z30OZKI7KPW7MI\",\n    \"me-south-1\": \"Z1MPMWCPA7YB62\",\n    \"sa-east-1\": \"Z7KQH4QJS55SO\",\n  };\n  return hostedZoneIds[region] || \"Z3AQBSTGFYJSTF\"; // Default to us-east-1 if region not found\n}\n\n```\n\n// alchemy/src/aws/credentials.ts\n```ts\nimport type { Secret } from \"../secret\";\n\nexport interface AwsCredentials {\n  accessKeyId: Secret;\n  secretAccessKey: Secret;\n}\n\n```\n\n// alchemy/src/aws/function.ts\n```ts\nimport {\n  Architecture,\n  CreateFunctionCommand,\n  DeleteFunctionCommand,\n  GetFunctionCommand,\n  GetFunctionConfigurationCommand,\n  LambdaClient,\n  ResourceNotFoundException,\n  Runtime,\n  UpdateFunctionCodeCommand,\n  UpdateFunctionConfigurationCommand,\n} from \"@aws-sdk/client-lambda\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating a Lambda function\n */\nexport interface FunctionProps {\n  /**\n   * Name of the Lambda function\n   */\n  functionName: string;\n\n  /**\n   * Path to the zip file containing the function code\n   */\n  zipPath: string;\n\n  /**\n   * ARN of the IAM role that Lambda assumes when executing the function\n   */\n  roleArn: string;\n\n  /**\n   * Function handler in the format 'file.function'\n   * For Node.js this is typically 'index.handler' or similar\n   */\n  handler?: string;\n\n  /**\n   * Lambda runtime environment for the function\n   * @default nodejs20.x if not specified\n   */\n  runtime?: Runtime;\n\n  /**\n   * CPU architecture for the function\n   * @default x86_64 if not specified\n   */\n  architecture?: Architecture;\n\n  /**\n   * Description of the function's purpose\n   */\n  description?: string;\n\n  /**\n   * Maximum execution time in seconds\n   * @default 3 seconds if not specified\n   */\n  timeout?: number;\n\n  /**\n   * Amount of memory available to the function in MB\n   * @default 128 MB if not specified\n   */\n  memorySize?: number;\n\n  /**\n   * Environment variables available to the function code\n   */\n  environment?: Record<string, string>;\n\n  /**\n   * Resource tags for the function\n   */\n  tags?: Record<string, string>;\n\n  /**\n   * Function URL configuration for direct HTTP(S) invocation\n   */\n  url?: {\n    /**\n     * Authentication type for the function URL\n     */\n    authType?: \"AWS_IAM\" | \"NONE\";\n\n    /**\n     * CORS configuration for the function URL\n     */\n    cors?: {\n      /**\n       * Whether to allow credentials in CORS requests\n       */\n      allowCredentials?: boolean;\n\n      /**\n       * Allowed headers in CORS requests\n       */\n      allowHeaders?: string[];\n\n      /**\n       * Allowed HTTP methods in CORS requests\n       */\n      allowMethods?: string[];\n\n      /**\n       * Allowed origins in CORS requests\n       */\n      allowOrigins?: string[];\n\n      /**\n       * Headers exposed to the browser\n       */\n      exposeHeaders?: string[];\n\n      /**\n       * CORS preflight cache time in seconds\n       */\n      maxAge?: number;\n    };\n  };\n}\n\n/**\n * Output returned after Lambda function creation/update\n */\nexport interface Function extends Resource<\"lambda::Function\">, FunctionProps {\n  /**\n   * ARN of the Lambda function\n   */\n  arn: string;\n\n  /**\n   * Timestamp of the last function modification\n   */\n  lastModified: string;\n\n  /**\n   * Function version\n   */\n  version: string;\n\n  /**\n   * ARN with version suffix\n   */\n  qualifiedArn: string;\n\n  /**\n   * ARN for invoking the function through API Gateway\n   */\n  invokeArn: string;\n\n  /**\n   * SHA256 hash of the function code\n   */\n  sourceCodeHash: string;\n\n  /**\n   * Size of the function code in bytes\n   */\n  sourceCodeSize: number;\n\n  /**\n   * Size of ephemeral storage (/tmp) in MB\n   */\n  ephemeralStorageSize?: number;\n\n  /**\n   * List of supported CPU architectures\n   */\n  architectures: string[];\n\n  /**\n   * ARN of the master function (Lambda@Edge only)\n   */\n  masterArn?: string;\n\n  /**\n   * Unique identifier for the current function code/config\n   */\n  revisionId: string;\n\n  /**\n   * Current state of the function\n   */\n  state?: string;\n\n  /**\n   * Reason for the current state\n   */\n  stateReason?: string;\n\n  /**\n   * Code for the current state reason\n   */\n  stateReasonCode?: string;\n\n  /**\n   * Status of the last update operation\n   */\n  lastUpdateStatus?: string;\n\n  /**\n   * Reason for the last update status\n   */\n  lastUpdateStatusReason?: string;\n\n  /**\n   * Code for the last update status reason\n   */\n  lastUpdateStatusReasonCode?: string;\n\n  /**\n   * Function package type (Zip or Image)\n   */\n  packageType: string;\n\n  /**\n   * ARN of the signing profile version\n   */\n  signingProfileVersionArn?: string;\n\n  /**\n   * ARN of the signing job\n   */\n  signingJobArn?: string;\n}\n\n/**\n * AWS Lambda Function Resource\n *\n * Creates and manages AWS Lambda functions with support for Node.js runtimes, custom handlers,\n * environment variables, and function URLs. Handles deployment packaging, IAM role\n * stabilization, and function updates.\n *\n * @example\n * // Create a basic Lambda function with minimal configuration\n * const basicFunction = await Function(\"api-handler\", {\n *   functionName: \"api-handler\",\n *   zipPath: \"./dist/api.zip\",\n *   roleArn: role.arn,\n *   runtime: Runtime.nodejs20x,\n *   handler: \"index.handler\",\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a function with environment variables and custom memory/timeout\n * const configuredFunction = await Function(\"worker\", {\n *   functionName: \"worker\",\n *   zipPath: \"./dist/worker.zip\",\n *   roleArn: role.arn,\n *   runtime: Runtime.nodejs20x,\n *   handler: \"worker.process\",\n *   memorySize: 512,\n *   timeout: 30,\n *   environment: {\n *     QUEUE_URL: queue.url,\n *     LOG_LEVEL: \"info\"\n *   }\n * });\n *\n * @example\n * // Create a function with a public URL endpoint and CORS\n * const apiFunction = await Function(\"public-api\", {\n *   functionName: \"public-api\",\n *   zipPath: \"./dist/api.zip\",\n *   roleArn: role.arn,\n *   handler: \"api.handler\",\n *   url: {\n *     authType: \"NONE\",\n *     cors: {\n *       allowOrigins: [\"*\"],\n *       allowMethods: [\"GET\", \"POST\"],\n *       allowHeaders: [\"content-type\"],\n *       maxAge: 86400\n *     }\n *   }\n * });\n */\nexport const Function = Resource(\n  \"lambda::Function\",\n  async function (this: Context<Function>, id: string, props: FunctionProps) {\n    const client = new LambdaClient({});\n    const region = await resolveRegion(client);\n\n    const code = await zipCode(props.zipPath);\n\n    if (this.phase === \"delete\") {\n      await ignore(ResourceNotFoundException.name, () =>\n        client.send(\n          new DeleteFunctionCommand({\n            FunctionName: props.functionName,\n          }),\n        ),\n      );\n\n      return this.destroy();\n    } else {\n      try {\n        // Check if function exists\n        await client.send(\n          new GetFunctionCommand({\n            FunctionName: props.functionName,\n          }),\n        );\n\n        if (this.phase === \"update\") {\n          // Wait for function to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Update function code\n          await client.send(\n            new UpdateFunctionCodeCommand({\n              FunctionName: props.functionName,\n              ZipFile: code,\n            }),\n          );\n\n          // Wait for code update to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Update function configuration\n          await client.send(\n            new UpdateFunctionConfigurationCommand({\n              FunctionName: props.functionName,\n              Handler: props.handler,\n              Runtime: props.runtime,\n              Role: props.roleArn,\n              Description: props.description,\n              Timeout: props.timeout,\n              MemorySize: props.memorySize,\n              Environment: props.environment\n                ? { Variables: props.environment }\n                : undefined,\n            }),\n          );\n\n          // Wait for configuration update to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n        }\n      } catch (error: any) {\n        if (error.name === \"ResourceNotFoundException\") {\n          // Create function if it doesn't exist\n          const startTime = Date.now();\n          let delay = 100; // Start with 100ms delay\n\n          while (true) {\n            try {\n              await client.send(\n                new CreateFunctionCommand({\n                  FunctionName: props.functionName,\n                  Code: { ZipFile: code },\n                  Handler: props.handler || \"index.handler\",\n                  Runtime: props.runtime || Runtime.nodejs20x,\n                  Role: props.roleArn,\n                  Description: props.description,\n                  Timeout: props.timeout || 3,\n                  MemorySize: props.memorySize || 128,\n                  Environment: props.environment\n                    ? { Variables: props.environment }\n                    : undefined,\n                  Architectures: props.architecture\n                    ? [props.architecture]\n                    : [Architecture.x86_64],\n                  Tags: props.tags,\n                }),\n              );\n              break; // Success - exit retry loop\n            } catch (createError: any) {\n              if (\n                createError.name !== \"InvalidParameterValueException\" ||\n                !createError.message?.includes(\"cannot be assumed by Lambda\")\n              ) {\n                throw createError; // Different error - rethrow\n              }\n\n              if (Date.now() - startTime > 10000) {\n                throw new Error(\n                  \"Timeout waiting for IAM role to be assumable by Lambda after 10s\",\n                );\n              }\n\n              await new Promise((resolve) => setTimeout(resolve, delay));\n              delay = Math.min(delay * 2, 1000); // Exponential backoff capped at 1s\n            }\n          }\n\n          // Wait for function to be active\n          let isCreating = true;\n          while (isCreating) {\n            const config = await client.send(\n              new GetFunctionConfigurationCommand({\n                FunctionName: props.functionName,\n              }),\n            );\n            isCreating = config.State === \"Pending\";\n            if (isCreating) {\n              await new Promise((resolve) => setTimeout(resolve, 1000));\n            }\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      // Get complete function details\n      const [func, config] = await Promise.all([\n        client.send(\n          new GetFunctionCommand({\n            FunctionName: props.functionName,\n          }),\n        ),\n        client.send(\n          new GetFunctionConfigurationCommand({\n            FunctionName: props.functionName,\n          }),\n        ),\n      ]);\n\n      return this({\n        ...props,\n        arn: config.FunctionArn!,\n        lastModified: config.LastModified!,\n        version: config.Version!,\n        qualifiedArn: `${config.FunctionArn}:${config.Version}`,\n        invokeArn: `arn:aws:apigateway:${region}:lambda:path/2015-03-31/functions/${config.FunctionArn}/invocations`,\n        sourceCodeHash: config.CodeSha256!,\n        sourceCodeSize: config.CodeSize!,\n        ephemeralStorageSize: config.EphemeralStorage?.Size,\n        architectures: config.Architectures || [],\n        masterArn: config.MasterArn,\n        revisionId: config.RevisionId!,\n        state: config.State,\n        stateReason: config.StateReason,\n        stateReasonCode: config.StateReasonCode,\n        lastUpdateStatus: config.LastUpdateStatus,\n        lastUpdateStatusReason: config.LastUpdateStatusReason,\n        lastUpdateStatusReasonCode: config.LastUpdateStatusReasonCode,\n        packageType: config.PackageType!,\n        signingProfileVersionArn: config.SigningProfileVersionArn,\n        signingJobArn: config.SigningJobArn,\n      });\n    }\n  },\n);\n\n// Helper to wait for function to stabilize\nasync function waitForFunctionStabilization(\n  client: LambdaClient,\n  functionName: string,\n) {\n  while (true) {\n    const config = await client.send(\n      new GetFunctionConfigurationCommand({\n        FunctionName: functionName,\n      }),\n    );\n\n    // Check if function is in a stable state\n    if (config.State === \"Active\" && config.LastUpdateStatus === \"Successful\") {\n      break;\n    }\n\n    // If there's a failure, throw an error\n    if (config.State === \"Failed\" || config.LastUpdateStatus === \"Failed\") {\n      throw new Error(\n        `Function failed to stabilize: ${config.StateReason || config.LastUpdateStatusReason}`,\n      );\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n  }\n}\n\n// Helper to zip the code\nasync function zipCode(filePath: string): Promise<Buffer> {\n  const fileContent = await fs.promises.readFile(filePath);\n  const fileName = path.basename(filePath);\n\n  // Create a zip buffer in memory\n  const zip = new (await import(\"jszip\")).default();\n  zip.file(fileName, fileContent);\n  return zip.generateAsync({\n    type: \"nodebuffer\",\n    compression: \"DEFLATE\",\n    platform: \"UNIX\",\n  });\n}\n\nasync function resolveRegion(client: LambdaClient): Promise<string> {\n  const region = client.config.region;\n  if (typeof region === \"string\") return region;\n  if (typeof region === \"function\") return region();\n  throw new Error(\"Could not resolve AWS region\");\n}\n\n```\n\n// alchemy/src/aws/policy-attachment.ts\n```ts\nimport {\n  AttachRolePolicyCommand,\n  DetachRolePolicyCommand,\n  IAMClient,\n  NoSuchEntityException,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating a policy attachment\n */\nexport interface PolicyAttachmentProps {\n  /**\n   * ARN of the IAM policy to attach\n   */\n  policyArn: string;\n\n  /**\n   * Name of the IAM role to attach the policy to\n   */\n  roleName: string;\n}\n\n/**\n * Output returned after policy attachment creation/update\n */\nexport interface PolicyAttachment\n  extends Resource<\"iam::PolicyAttachment\">,\n    PolicyAttachmentProps {}\n\n/**\n * AWS IAM Policy Attachment Resource\n *\n * Attaches an IAM policy to a role, enabling the role to use the permissions defined in the policy.\n *\n * @example\n * // Attach an AWS managed policy to a role\n * const adminAccess = await PolicyAttachment(\"admin-policy\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AdministratorAccess\",\n *   roleName: role.name\n * });\n *\n * @example\n * // Attach a custom policy to a role\n * const customPolicy = await PolicyAttachment(\"custom-policy\", {\n *   policyArn: policy.arn,\n *   roleName: role.name\n * });\n *\n * @example\n * // Attach multiple policies to a role\n * const s3Access = await PolicyAttachment(\"s3-access\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AmazonS3FullAccess\",\n *   roleName: role.name\n * });\n *\n * const sqsAccess = await PolicyAttachment(\"sqs-access\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AmazonSQSFullAccess\",\n *   roleName: role.name\n * });\n */\nexport const PolicyAttachment = Resource(\n  \"iam::PolicyAttachment\",\n  async function (\n    this: Context<PolicyAttachment>,\n    id: string,\n    props: PolicyAttachmentProps,\n  ) {\n    const client = new IAMClient({});\n\n    if (this.phase === \"delete\") {\n      await ignore(NoSuchEntityException.name, () =>\n        client.send(\n          new DetachRolePolicyCommand({\n            PolicyArn: props.policyArn,\n            RoleName: props.roleName,\n          }),\n        ),\n      );\n      return this.destroy();\n    } else {\n      await client.send(\n        new AttachRolePolicyCommand({\n          PolicyArn: props.policyArn,\n          RoleName: props.roleName,\n        }),\n      );\n    }\n\n    return this(props);\n  },\n);\n\n```\n\n// alchemy/src/aws/policy.ts\n```ts\nimport {\n  CreatePolicyCommand,\n  CreatePolicyVersionCommand,\n  DeletePolicyCommand,\n  DeletePolicyVersionCommand,\n  GetPolicyCommand,\n  GetPolicyVersionCommand,\n  IAMClient,\n  ListPolicyVersionsCommand,\n  NoSuchEntityException,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Type of effect for a policy statement\n */\nexport type Effect = \"Allow\" | \"Deny\";\n\n/**\n * A single statement within an IAM policy document\n */\nexport interface PolicyStatement {\n  /**\n   * Optional identifier for the statement\n   */\n  Sid?: string;\n\n  /**\n   * Whether to allow or deny the specified actions\n   */\n  Effect: Effect;\n\n  /**\n   * Actions that the policy allows or denies\n   */\n  Action: string | string[];\n\n  /**\n   * Resources that the policy applies to\n   */\n  Resource?: string | string[];\n\n  /**\n   * Additional conditions for when the policy applies\n   */\n  Condition?: Record<string, Record<string, string | string[]>>;\n\n  /**\n   * AWS principals that the policy applies to\n   */\n  Principal?: Record<string, string | string[]>;\n\n  /**\n   * AWS principals that the policy explicitly does not apply to\n   */\n  NotPrincipal?: Record<string, string | string[]>;\n\n  /**\n   * Actions that are explicitly not included in this statement\n   */\n  NotAction?: string | string[];\n\n  /**\n   * Resources that are explicitly not included in this statement\n   */\n  NotResource?: string | string[];\n}\n\n/**\n * An IAM policy document containing one or more statements\n */\nexport interface PolicyDocument {\n  /**\n   * Policy language version (must be \"2012-10-17\")\n   */\n  Version: \"2012-10-17\";\n\n  /**\n   * List of policy statements\n   */\n  Statement: PolicyStatement[];\n}\n\n/**\n * Properties for creating or updating an IAM policy\n */\nexport interface PolicyProps {\n  /**\n   * Name of the policy\n   */\n  policyName: string;\n\n  /**\n   * Policy document defining the permissions\n   */\n  document: PolicyDocument;\n\n  /**\n   * Optional description of the policy's purpose\n   */\n  description?: string;\n\n  /**\n   * Optional path prefix for the policy\n   */\n  path?: string;\n\n  /**\n   * Optional resource tags\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after IAM policy creation/update\n */\nexport interface Policy extends Resource<\"iam::Policy\">, PolicyProps {\n  /**\n   * ARN of the policy\n   */\n  arn: string;\n\n  /**\n   * ID of the default policy version\n   */\n  defaultVersionId: string;\n\n  /**\n   * Number of entities the policy is attached to\n   */\n  attachmentCount: number;\n\n  /**\n   * When the policy was created\n   */\n  createDate: Date;\n\n  /**\n   * When the policy was last updated\n   */\n  updateDate: Date;\n\n  /**\n   * Whether the policy can be attached to IAM users/roles\n   */\n  isAttachable: boolean;\n}\n\n/**\n * AWS IAM Policy Resource\n *\n * Creates and manages IAM policies that define permissions for AWS services and resources.\n * Supports automatic versioning and updates when policy content changes.\n *\n * @example\n * // Create a basic S3 bucket access policy\n * const s3Policy = await Policy(\"bucket-access\", {\n *   policyName: \"s3-bucket-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Action: [\n *         \"s3:GetObject\",\n *         \"s3:PutObject\"\n *       ],\n *       Resource: `${bucket.arn}/*`\n *     }]\n *   }\n * });\n *\n * @example\n * // Create a policy with multiple statements and conditions\n * const apiPolicy = await Policy(\"api-access\", {\n *   policyName: \"api-gateway-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [\n *       {\n *         Sid: \"InvokeAPI\",\n *         Effect: \"Allow\",\n *         Action: \"execute-api:Invoke\",\n *         Resource: `${api.executionArn}/*`,\n *         Condition: {\n *           StringEquals: {\n *             \"aws:SourceVpc\": vpc.id\n *           }\n *         }\n *       },\n *       {\n *         Sid: \"ReadLogs\",\n *         Effect: \"Allow\",\n *         Action: [\n *           \"logs:GetLogEvents\",\n *           \"logs:FilterLogEvents\"\n *         ],\n *         Resource: `${api.logGroupArn}:*`\n *       }\n *     ]\n *   },\n *   description: \"Allows invoking API Gateway endpoints and reading logs\",\n *   tags: {\n *     Service: \"API Gateway\",\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a policy that denies access based on tags\n * const denyPolicy = await Policy(\"deny-production\", {\n *   policyName: \"deny-production-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Deny\",\n *       Action: \"*\",\n *       Resource: \"*\",\n *       Condition: {\n *         StringEquals: {\n *           \"aws:ResourceTag/Environment\": \"production\"\n *         }\n *       }\n *     }]\n *   }\n * });\n */\nexport const Policy = Resource(\n  \"iam::Policy\",\n  async function (\n    this: Context<Policy>,\n    id: string,\n    props: PolicyProps,\n  ): Promise<Policy> {\n    const client = new IAMClient({});\n    const policyArn = `arn:aws:iam::${process.env.AWS_ACCOUNT_ID}:policy${props.path || \"/\"}${props.policyName}`;\n\n    if (this.phase === \"delete\") {\n      try {\n        // List and delete all non-default versions first\n        const versions = await client.send(\n          new ListPolicyVersionsCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        for (const version of versions.Versions || []) {\n          if (!version.IsDefaultVersion) {\n            await client.send(\n              new DeletePolicyVersionCommand({\n                PolicyArn: policyArn,\n                VersionId: version.VersionId,\n              }),\n            );\n          }\n        }\n\n        // Delete the policy\n        await client.send(\n          new DeletePolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n      } catch (error: any) {\n        if (error.name !== NoSuchEntityException.name) {\n          throw error;\n        }\n      }\n      return this.destroy();\n    } else {\n      try {\n        // Check if policy exists\n        const existingPolicy = await client.send(\n          new GetPolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        // Get current policy version\n        const currentVersion = await client.send(\n          new GetPolicyVersionCommand({\n            PolicyArn: policyArn,\n            VersionId: existingPolicy.Policy!.DefaultVersionId!,\n          }),\n        );\n\n        const currentDocument = JSON.parse(\n          decodeURIComponent(currentVersion.PolicyVersion!.Document!),\n        );\n\n        // If policy document changed, create new version\n        if (\n          JSON.stringify(currentDocument) !== JSON.stringify(props.document)\n        ) {\n          // List versions to check if we need to delete old ones\n          const versions = await client.send(\n            new ListPolicyVersionsCommand({\n              PolicyArn: policyArn,\n            }),\n          );\n\n          // Delete oldest version if we have 5 versions (maximum allowed)\n          if (versions.Versions?.length === 5) {\n            const oldestVersion = versions.Versions.sort(\n              (a, b) => a.CreateDate!.getTime() - b.CreateDate!.getTime(),\n            )[0];\n\n            if (!oldestVersion.IsDefaultVersion) {\n              await client.send(\n                new DeletePolicyVersionCommand({\n                  PolicyArn: policyArn,\n                  VersionId: oldestVersion.VersionId!,\n                }),\n              );\n            }\n          }\n\n          // Create new version\n          await client.send(\n            new CreatePolicyVersionCommand({\n              PolicyArn: policyArn,\n              PolicyDocument: JSON.stringify(props.document),\n              SetAsDefault: true,\n            }),\n          );\n        }\n\n        const policy = await client.send(\n          new GetPolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        return this({\n          ...props,\n          arn: policy.Policy!.Arn!,\n          defaultVersionId: policy.Policy!.DefaultVersionId!,\n          attachmentCount: policy.Policy!.AttachmentCount!,\n          createDate: policy.Policy!.CreateDate!,\n          updateDate: policy.Policy!.UpdateDate!,\n          isAttachable: policy.Policy!.IsAttachable!,\n        });\n      } catch (error: any) {\n        if (error.name === \"NoSuchEntity\") {\n          // Create new policy\n          const newPolicy = await client.send(\n            new CreatePolicyCommand({\n              PolicyName: props.policyName,\n              PolicyDocument: JSON.stringify(props.document),\n              Description: props.description,\n              Path: props.path,\n              Tags: props.tags\n                ? Object.entries(props.tags).map(([Key, Value]) => ({\n                    Key,\n                    Value,\n                  }))\n                : undefined,\n            }),\n          );\n\n          return this({\n            ...props,\n            arn: newPolicy.Policy!.Arn!,\n            defaultVersionId: newPolicy.Policy!.DefaultVersionId!,\n            attachmentCount: newPolicy.Policy!.AttachmentCount!,\n            createDate: newPolicy.Policy!.CreateDate!,\n            updateDate: newPolicy.Policy!.UpdateDate!,\n            isAttachable: newPolicy.Policy!.IsAttachable!,\n          });\n        }\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/aws/queue.ts\n```ts\nimport {\n  CreateQueueCommand,\n  DeleteQueueCommand,\n  GetQueueAttributesCommand,\n  GetQueueUrlCommand,\n  SQSClient,\n} from \"@aws-sdk/client-sqs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating an SQS queue\n */\nexport interface QueueProps {\n  /**\n   * Name of the queue\n   * For FIFO queues, the name must end with the .fifo suffix\n   */\n  queueName: string;\n\n  /**\n   * Whether this is a FIFO queue.\n   * If true, the queueName must end with .fifo suffix\n   */\n  fifo?: boolean;\n\n  /**\n   * The length of time (in seconds) that a message received from a queue will be invisible to other receiving components\n   * Default: 30 seconds\n   */\n  visibilityTimeout?: number;\n\n  /**\n   * The length of time (in seconds) for which Amazon SQS retains a message\n   * Default: 345600 seconds (4 days)\n   */\n  messageRetentionPeriod?: number;\n\n  /**\n   * The limit of how many bytes a message can contain before Amazon SQS rejects it\n   * Default: 262144 bytes (256 KB)\n   */\n  maximumMessageSize?: number;\n\n  /**\n   * The time in seconds that the delivery of all messages in the queue will be delayed\n   * Default: 0 seconds\n   */\n  delaySeconds?: number;\n\n  /**\n   * The length of time (in seconds) for which a ReceiveMessage action waits for a message to arrive\n   * Default: 0 seconds\n   */\n  receiveMessageWaitTimeSeconds?: number;\n\n  /**\n   * Enables content-based deduplication for FIFO queues.\n   * Only applicable when fifo is true.\n   */\n  contentBasedDeduplication?: boolean;\n\n  /**\n   * Specifies whether message deduplication occurs at the message group or queue level\n   * Only applicable when fifo is true\n   */\n  deduplicationScope?: \"messageGroup\" | \"queue\";\n\n  /**\n   * Specifies whether the FIFO queue throughput quota applies to the entire queue or per message group\n   * Only applicable when fifo is true\n   */\n  fifoThroughputLimit?: \"perQueue\" | \"perMessageGroupId\";\n\n  /**\n   * Resource tags for the queue\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after SQS queue creation/update\n */\nexport interface Queue extends Resource<\"sqs::Queue\">, QueueProps {\n  /**\n   * ARN of the queue\n   */\n  arn: string;\n\n  /**\n   * URL of the queue\n   */\n  url: string;\n}\n\n/**\n * AWS SQS Queue Resource\n *\n * Creates and manages Amazon SQS queues with support for both standard and FIFO queues.\n * Handles queue creation, attribute configuration, and automatic cleanup of deleted queues.\n *\n * @example\n * // Create a standard queue with custom visibility timeout\n * const standardQueue = await Queue(\"my-queue\", {\n *   queueName: \"my-queue\",\n *   visibilityTimeout: 30,\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a FIFO queue with content-based deduplication\n * const fifoQueue = await Queue(\"orders-queue\", {\n *   queueName: \"orders-queue.fifo\",\n *   fifo: true,\n *   contentBasedDeduplication: true,\n *   visibilityTimeout: 30,\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a queue with custom message retention and size\n * const customQueue = await Queue(\"large-messages\", {\n *   queueName: \"large-messages\",\n *   messageRetentionPeriod: 345600,  // 4 days\n *   maximumMessageSize: 262144,      // 256 KB\n *   visibilityTimeout: 60,\n *   delaySeconds: 5,\n *   receiveMessageWaitTimeSeconds: 20\n * });\n */\nexport const Queue = Resource(\n  \"sqs::Queue\",\n  async function (\n    this: Context<Queue>,\n    id: string,\n    props: QueueProps,\n  ): Promise<Queue> {\n    const client = new SQSClient({});\n    // Don't automatically add .fifo suffix - user must include it in queueName\n    const queueName = props.queueName;\n\n    // Validate that FIFO queues have .fifo suffix\n    if (props.fifo && !queueName.endsWith(\".fifo\")) {\n      throw new Error(\"FIFO queue names must end with .fifo suffix\");\n    }\n\n    if (this.phase === \"delete\") {\n      try {\n        // Get queue URL first\n        const urlResponse = await client.send(\n          new GetQueueUrlCommand({\n            QueueName: queueName,\n          }),\n        );\n\n        // Delete the queue\n        await client.send(\n          new DeleteQueueCommand({\n            QueueUrl: urlResponse.QueueUrl,\n          }),\n        );\n\n        // Wait for queue to be deleted\n        let queueDeleted = false;\n        while (!queueDeleted) {\n          try {\n            await client.send(\n              new GetQueueUrlCommand({\n                QueueName: queueName,\n              }),\n            );\n            // If we get here, queue still exists\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n          } catch (error: any) {\n            if (error.name === \"QueueDoesNotExist\") {\n              queueDeleted = true;\n            } else {\n              throw error;\n            }\n          }\n        }\n      } catch (error: any) {\n        if (error.name !== \"QueueDoesNotExist\") {\n          throw error;\n        }\n      }\n\n      return this.destroy();\n    } else {\n      // Create queue with attributes\n      const attributes: Record<string, string> = {};\n\n      if (props.visibilityTimeout !== undefined) {\n        attributes[\"VisibilityTimeout\"] = props.visibilityTimeout.toString();\n      }\n      if (props.messageRetentionPeriod !== undefined) {\n        attributes[\"MessageRetentionPeriod\"] =\n          props.messageRetentionPeriod.toString();\n      }\n      if (props.maximumMessageSize !== undefined) {\n        attributes[\"MaximumMessageSize\"] = props.maximumMessageSize.toString();\n      }\n      if (props.delaySeconds !== undefined) {\n        attributes[\"DelaySeconds\"] = props.delaySeconds.toString();\n      }\n      if (props.receiveMessageWaitTimeSeconds !== undefined) {\n        attributes[\"ReceiveMessageWaitTimeSeconds\"] =\n          props.receiveMessageWaitTimeSeconds.toString();\n      }\n\n      // FIFO specific attributes\n      if (props.fifo) {\n        attributes[\"FifoQueue\"] = \"true\";\n        if (props.contentBasedDeduplication) {\n          attributes[\"ContentBasedDeduplication\"] = \"true\";\n        }\n        if (props.deduplicationScope) {\n          attributes[\"DeduplicationScope\"] = props.deduplicationScope;\n        }\n        if (props.fifoThroughputLimit) {\n          attributes[\"FifoThroughputLimit\"] = props.fifoThroughputLimit;\n        }\n      }\n\n      // Convert tags to AWS format\n      const tags = props.tags\n        ? Object.entries(props.tags).reduce(\n            (acc, [key, value]) => ({ ...acc, [key]: value }),\n            {},\n          )\n        : undefined;\n\n      try {\n        // Create the queue\n        const createResponse = await client.send(\n          new CreateQueueCommand({\n            QueueName: queueName,\n            Attributes: attributes,\n            tags,\n          }),\n        );\n\n        // Get queue attributes\n        const attributesResponse = await client.send(\n          new GetQueueAttributesCommand({\n            QueueUrl: createResponse.QueueUrl,\n            AttributeNames: [\"QueueArn\"],\n          }),\n        );\n\n        return this({\n          ...props,\n          arn: attributesResponse.Attributes!.QueueArn!,\n          url: createResponse.QueueUrl!,\n        });\n      } catch (error: any) {\n        if (error.name === \"QueueAlreadyExists\") {\n          // Get existing queue URL\n          const urlResponse = await client.send(\n            new GetQueueUrlCommand({\n              QueueName: queueName,\n            }),\n          );\n\n          // Get queue attributes\n          const attributesResponse = await client.send(\n            new GetQueueAttributesCommand({\n              QueueUrl: urlResponse.QueueUrl,\n              AttributeNames: [\"QueueArn\"],\n            }),\n          );\n\n          return this({\n            ...props,\n            arn: attributesResponse.Attributes!.QueueArn!,\n            url: urlResponse.QueueUrl!,\n          });\n        } else if (error.name === \"QueueDeletedRecently\") {\n          // Queue was recently deleted, wait and retry\n          const maxRetries = 3;\n          let retryCount = 0;\n\n          while (retryCount < maxRetries) {\n            try {\n              // Wait for 60 seconds before retrying\n              await new Promise((resolve) => setTimeout(resolve, 61000));\n\n              // Retry creating the queue\n              const createResponse = await client.send(\n                new CreateQueueCommand({\n                  QueueName: queueName,\n                  Attributes: attributes,\n                  tags,\n                }),\n              );\n\n              // Get queue attributes\n              const attributesResponse = await client.send(\n                new GetQueueAttributesCommand({\n                  QueueUrl: createResponse.QueueUrl,\n                  AttributeNames: [\"QueueArn\"],\n                }),\n              );\n\n              return this({\n                ...props,\n                arn: attributesResponse.Attributes!.QueueArn!,\n                url: createResponse.QueueUrl!,\n              });\n            } catch (retryError: any) {\n              if (\n                retryError.name !== \"QueueDeletedRecently\" ||\n                retryCount === maxRetries - 1\n              ) {\n                throw retryError;\n              }\n              retryCount++;\n            }\n          }\n        }\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/aws/role.ts\n```ts\nimport {\n  AttachRolePolicyCommand,\n  CreateRoleCommand,\n  DeleteRoleCommand,\n  DeleteRolePolicyCommand,\n  DetachRolePolicyCommand,\n  EntityAlreadyExistsException,\n  GetRoleCommand,\n  IAMClient,\n  ListAttachedRolePoliciesCommand,\n  NoSuchEntityException,\n  PutRolePolicyCommand,\n  type Tag,\n  TagRoleCommand,\n  UpdateAssumeRolePolicyCommand,\n  UpdateRoleCommand,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\nimport type { PolicyDocument } from \"./policy\";\n\n/**\n * Properties for creating or updating an IAM role\n */\nexport interface RoleProps {\n  /**\n   * Name of the IAM role\n   */\n  roleName: string;\n\n  /**\n   * Policy that defines which entities can assume this role\n   */\n  assumeRolePolicy: PolicyDocument;\n\n  /**\n   * Optional description of the role's purpose\n   */\n  description?: string;\n\n  /**\n   * Optional path prefix for the role\n   */\n  path?: string;\n\n  /**\n   * Maximum session duration in seconds when assumed\n   * Default: 3600 seconds (1 hour)\n   */\n  maxSessionDuration?: number;\n\n  /**\n   * ARN of the policy used to set the permissions boundary\n   */\n  permissionsBoundary?: string;\n\n  /**\n   * Inline policies to embed in the role\n   * Each policy must have a unique name and policy document\n   */\n  policies?: Array<{\n    policyName: string;\n    policyDocument: PolicyDocument;\n  }>;\n\n  /**\n   * List of managed policy ARNs to attach to the role\n   */\n  managedPolicyArns?: string[];\n\n  /**\n   * Resource tags for the role\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after IAM role creation/update\n */\nexport interface Role extends Resource<\"iam::Role\">, RoleProps {\n  /**\n   * ARN of the role\n   */\n  arn: string;\n\n  /**\n   * Unique identifier for the role\n   */\n  uniqueId: string;\n\n  /**\n   * The stable and unique string identifying the role\n   */\n  roleId: string;\n\n  /**\n   * When the role was created\n   */\n  createDate: Date;\n}\n\n/**\n * AWS IAM Role Resource\n *\n * Creates and manages IAM roles with support for inline policies, managed policies,\n * and automatic cleanup of attached policies during deletion.\n *\n * @example\n * // Create a basic Lambda execution role with inline policy\n * const basicRole = await Role(\"lambda-role\", {\n *   roleName: \"lambda-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Basic Lambda execution role\",\n *   tags: {\n *     Environment: \"production\"\n *   },\n *   policies: [{\n *     policyName: \"logs\",\n *     policyDocument: {\n *       Version: \"2012-10-17\",\n *       Statement: [{\n *         Effect: \"Allow\",\n *         Action: [\n *           \"logs:CreateLogGroup\",\n *           \"logs:CreateLogStream\",\n *           \"logs:PutLogEvents\"\n *         ],\n *         Resource: \"*\"\n *       }]\n *     }\n *   }]\n * });\n *\n * @example\n * // Create a role with AWS managed policies\n * const managedRole = await Role(\"readonly-role\", {\n *   roleName: \"readonly-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Role with managed policies\",\n *   managedPolicyArns: [\n *     \"arn:aws:iam::aws:policy/ReadOnlyAccess\"\n *   ],\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a role with multiple inline policies and custom session duration\n * const customRole = await Role(\"custom-role\", {\n *   roleName: \"custom-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Role with multiple policies\",\n *   maxSessionDuration: 7200,\n *   policies: [\n *     {\n *       policyName: \"logs\",\n *       policyDocument: {\n *         Version: \"2012-10-17\",\n *         Statement: [{\n *           Effect: \"Allow\",\n *           Action: [\n *             \"logs:CreateLogGroup\",\n *             \"logs:CreateLogStream\",\n *             \"logs:PutLogEvents\"\n *           ],\n *           Resource: \"*\"\n *         }]\n *       }\n *     },\n *     {\n *       policyName: \"s3\",\n *       policyDocument: {\n *         Version: \"2012-10-17\",\n *         Statement: [{\n *           Effect: \"Allow\",\n *           Action: \"s3:ListBucket\",\n *           Resource: \"*\"\n *         }]\n *       }\n *     }\n *   ],\n *   tags: {\n *     Environment: \"production\",\n *     Updated: \"true\"\n *   }\n * });\n */\nexport const Role = Resource(\n  \"iam::Role\",\n  async function (\n    this: Context<Role>,\n    id: string,\n    props: RoleProps\n  ): Promise<Role> {\n    const client = new IAMClient({});\n\n    if (this.phase === \"delete\") {\n      try {\n        // Delete any inline policies first\n        if (props.policies) {\n          for (const policy of props.policies) {\n            await ignore(NoSuchEntityException.name, () =>\n              client.send(\n                new DeleteRolePolicyCommand({\n                  RoleName: props.roleName,\n                  PolicyName: policy.policyName,\n                })\n              )\n            );\n          }\n        }\n\n        // We need to detach managed policies before deleting the role\n        // First, get all attached policies\n        try {\n          const attachedPoliciesResponse = await client.send(\n            new ListAttachedRolePoliciesCommand({\n              RoleName: props.roleName,\n            })\n          );\n\n          // Detach all managed policies\n          const attachedPolicies =\n            attachedPoliciesResponse.AttachedPolicies || [];\n          for (const policy of attachedPolicies) {\n            await ignore(NoSuchEntityException.name, () =>\n              client.send(\n                new DetachRolePolicyCommand({\n                  RoleName: props.roleName,\n                  PolicyArn: policy.PolicyArn!,\n                })\n              )\n            );\n          }\n        } catch (error: any) {\n          if (error.name !== NoSuchEntityException.name) {\n            throw error;\n          }\n          // Role doesn't exist, no need to continue with detaching policies\n        }\n\n        // Try to delete the role, ignoring if it doesn't exist\n        await ignore(NoSuchEntityException.name, () =>\n          client.send(\n            new DeleteRoleCommand({\n              RoleName: props.roleName,\n            })\n          )\n        );\n      } catch (error: any) {\n        // If we get any other error besides NoSuchEntityException, log it but don't fail\n        // This ensures the resource is still marked as destroyed\n        if (error.name !== NoSuchEntityException.name) {\n          console.error(`Error deleting role ${props.roleName}:`, error);\n        }\n      }\n\n      // Always return destroyed state regardless of any errors\n      return this.destroy();\n    }\n\n    const assumeRolePolicyDocument = JSON.stringify(props.assumeRolePolicy);\n    let role;\n\n    try {\n      if (this.phase === \"create\") {\n        // Try to create the role\n        await client.send(\n          new CreateRoleCommand({\n            RoleName: props.roleName,\n            AssumeRolePolicyDocument: assumeRolePolicyDocument,\n            Description: props.description,\n            Path: props.path,\n            MaxSessionDuration: props.maxSessionDuration,\n            PermissionsBoundary: props.permissionsBoundary,\n            Tags: [\n              ...Object.entries(props.tags || {}).map(([Key, Value]) => ({\n                Key,\n                Value,\n              })),\n              {\n                Key: \"alchemy_stage\",\n                Value: this.stage,\n              },\n              {\n                Key: \"alchemy_resource\",\n                Value: this.id,\n              },\n            ],\n          })\n        );\n      }\n    } catch (error: any) {\n      if (\n        error instanceof EntityAlreadyExistsException &&\n        this.phase === \"create\"\n      ) {\n        // Check if we were the ones who created it\n        const existingRole = await client.send(\n          new GetRoleCommand({\n            RoleName: props.roleName,\n          })\n        );\n        const roleTags =\n          existingRole.Role?.Tags?.reduce(\n            (acc, tag) => {\n              acc[tag.Key!] = tag.Value!;\n              return acc;\n            },\n            {} as Record<string, string>\n          ) || {};\n\n        if (\n          roleTags.alchemy_stage !== this.stage ||\n          roleTags.alchemy_resource !== this.id\n        ) {\n          throw error;\n        }\n      } else if (error.name !== NoSuchEntityException.name) {\n        throw error;\n      }\n    }\n\n    // Get or update the role\n    role = await client.send(\n      new GetRoleCommand({\n        RoleName: props.roleName,\n      })\n    );\n\n    // Update assume role policy if it changed\n    if (role.Role?.AssumeRolePolicyDocument !== assumeRolePolicyDocument) {\n      await client.send(\n        new UpdateAssumeRolePolicyCommand({\n          RoleName: props.roleName,\n          PolicyDocument: assumeRolePolicyDocument,\n        })\n      );\n    }\n\n    // Update role description and max session duration if they changed\n    if (\n      role.Role?.Description !== props.description ||\n      role.Role?.MaxSessionDuration !== props.maxSessionDuration\n    ) {\n      await client.send(\n        new UpdateRoleCommand({\n          RoleName: props.roleName,\n          Description: props.description,\n          MaxSessionDuration: props.maxSessionDuration,\n        })\n      );\n    }\n\n    // Update tags\n    const newTags = {\n      ...props.tags,\n      alchemy_stage: this.stage,\n      alchemy_resource: this.id,\n    };\n    const tags: Tag[] = Object.entries(newTags).map(([Key, Value]) => ({\n      Key,\n      Value,\n    }));\n    await client.send(\n      new TagRoleCommand({\n        RoleName: props.roleName,\n        Tags: tags,\n      })\n    );\n\n    // Handle policy changes\n    const previousPolicies =\n      this.phase === \"update\" ? this.output!.policies || [] : [];\n    const currentPolicies = props.policies || [];\n\n    // Delete policies that were removed\n    for (const oldPolicy of previousPolicies) {\n      if (\n        !currentPolicies.some(\n          (p: { policyName: string }) => p.policyName === oldPolicy.policyName\n        )\n      ) {\n        await ignore(NoSuchEntityException.name, () =>\n          client.send(\n            new DeleteRolePolicyCommand({\n              RoleName: props.roleName,\n              PolicyName: oldPolicy.policyName,\n            })\n          )\n        );\n      }\n    }\n\n    // Update or create policies\n    for (const policy of currentPolicies) {\n      const oldPolicy = previousPolicies.find(\n        (p) => p.policyName === policy.policyName\n      );\n      if (\n        !oldPolicy ||\n        JSON.stringify(oldPolicy.policyDocument) !==\n          JSON.stringify(policy.policyDocument)\n      ) {\n        await client.send(\n          new PutRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyName: policy.policyName,\n            PolicyDocument: JSON.stringify(policy.policyDocument),\n          })\n        );\n      }\n    }\n\n    // Handle managed policy attachments\n    // Get currently attached policies\n    const attachedPoliciesResponse = await client.send(\n      new ListAttachedRolePoliciesCommand({\n        RoleName: props.roleName,\n      })\n    );\n\n    const currentAttachedPolicies =\n      attachedPoliciesResponse.AttachedPolicies || [];\n    const currentPolicyArns = currentAttachedPolicies.map((p) => p.PolicyArn!);\n\n    // If we're updating, use an empty array as default when managedPolicyArns is undefined\n    // to ensure we detach all managed policies\n    const desiredPolicyArns = props.managedPolicyArns || [];\n\n    // Detach policies that are no longer needed\n    for (const policyArn of currentPolicyArns) {\n      if (!desiredPolicyArns.includes(policyArn)) {\n        await client.send(\n          new DetachRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyArn: policyArn,\n          })\n        );\n      }\n    }\n\n    // Attach new policies that weren't attached before\n    for (const policyArn of desiredPolicyArns) {\n      if (!currentPolicyArns.includes(policyArn)) {\n        await client.send(\n          new AttachRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyArn: policyArn,\n          })\n        );\n      }\n    }\n\n    if (!role?.Role) {\n      throw new Error(`Failed to create or update role ${props.roleName}`);\n    }\n\n    return this({\n      ...props,\n      arn: role.Role.Arn!,\n      uniqueId: role.Role.RoleId!,\n      roleId: role.Role.RoleId!,\n      roleName: role.Role.RoleName ?? props.roleName,\n      createDate: role.Role.CreateDate!,\n    });\n  }\n);\n\n```\n\n// alchemy/src/aws/ses.ts\n```ts\nimport {\n  CreateConfigurationSetCommand,\n  CreateEmailIdentityCommand,\n  DeleteConfigurationSetCommand,\n  DeleteEmailIdentityCommand,\n  type DeliveryOptions,\n  GetConfigurationSetCommand,\n  GetEmailIdentityCommand,\n  NotFoundException,\n  PutConfigurationSetDeliveryOptionsCommand,\n  PutConfigurationSetReputationOptionsCommand,\n  PutConfigurationSetSendingOptionsCommand,\n  PutConfigurationSetSuppressionOptionsCommand,\n  PutConfigurationSetTrackingOptionsCommand,\n  PutEmailIdentityDkimAttributesCommand,\n  type ReputationOptions,\n  SESv2Client,\n  type SendingOptions,\n  type SuppressionOptions,\n  type TrackingOptions,\n} from \"@aws-sdk/client-sesv2\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for configuring AWS SES resources\n */\nexport interface SESProps {\n  /**\n   * Name of the configuration set\n   * Used to group email sending and tracking settings\n   */\n  configurationSetName?: string;\n\n  /**\n   * Email identity to verify (email address or domain)\n   * For domains, use the format \"example.com\"\n   * For email addresses, use the format \"user@example.com\"\n   */\n  emailIdentity?: string;\n\n  /**\n   * Whether to enable DKIM signing for the email identity\n   * DKIM helps prevent email spoofing by verifying sender authenticity\n   */\n  enableDkim?: boolean;\n\n  /**\n   * Sending options for the configuration set\n   * Controls whether email sending is enabled and related settings\n   */\n  sendingOptions?: SendingOptions;\n\n  /**\n   * Reputation options for the configuration set\n   * Controls reputation tracking and metrics collection\n   */\n  reputationOptions?: ReputationOptions;\n\n  /**\n   * Tracking options for the configuration set\n   * Controls open and click tracking with optional custom domains\n   */\n  trackingOptions?: TrackingOptions;\n\n  /**\n   * Suppression options for the configuration set\n   * Controls how bounces and complaints are handled\n   */\n  suppressionOptions?: SuppressionOptions;\n\n  /**\n   * Delivery options for the configuration set\n   * Controls TLS settings and sending pool configuration\n   */\n  deliveryOptions?: DeliveryOptions;\n\n  /**\n   * Tags to apply to the SES resources\n   * Key-value pairs for resource organization\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after SES resource creation/update\n */\nexport interface SES extends Resource<\"aws::SES\">, SESProps {\n  /**\n   * ARN of the configuration set if created\n   * Format: arn:aws:ses:region:account-id:configuration-set/name\n   */\n  configurationSetArn?: string;\n\n  /**\n   * Email identity verification status if an identity was created\n   * Can be \"PENDING\" or \"VERIFIED\"\n   */\n  emailIdentityVerificationStatus?: string;\n\n  /**\n   * DKIM verification status if DKIM was enabled\n   * Can be \"PENDING\", \"SUCCESS\", \"FAILED\", \"TEMPORARY_FAILURE\", or \"NOT_STARTED\"\n   */\n  dkimVerificationStatus?: string;\n\n  /**\n   * Email identity ARN if an identity was created\n   * Format: arn:aws:ses:region:account-id:identity/name\n   */\n  emailIdentityArn?: string;\n}\n\n/**\n * AWS SES Resource\n *\n * Creates and manages Amazon Simple Email Service (SES) configuration sets and email identities.\n * Supports email sending configuration, DKIM signing, and identity verification.\n *\n * @example\n * // Create a configuration set with sending options\n * const configSet = await SES(\"email-config\", {\n *   configurationSetName: \"my-email-config\",\n *   sendingOptions: {\n *     SendingEnabled: true\n *   },\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"notifications\"\n *   }\n * });\n *\n * @example\n * // Create and verify a domain identity with DKIM\n * const domainIdentity = await SES(\"domain-identity\", {\n *   emailIdentity: \"example.com\",\n *   enableDkim: true,\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"transactional-emails\"\n *   }\n * });\n *\n * @example\n * // Update configuration set sending options\n * const updatedConfig = await SES(\"email-config\", {\n *   configurationSetName: \"my-email-config\",\n *   sendingOptions: {\n *     SendingEnabled: false\n *   },\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"notifications\",\n *     Updated: \"true\"\n *   }\n * });\n */\nexport const SES = Resource(\n  \"aws::SES\",\n  async function (\n    this: Context<SES>,\n    id: string,\n    props: SESProps,\n  ): Promise<SES> {\n    // Create SES client\n    const client = new SESv2Client({});\n\n    // Resource ID is either based on the configuration set name or email identity\n    // const id =\n    //   props.configurationSetName || props.emailIdentity || this.resourceID;\n\n    // Handle deletion\n    if (this.phase === \"delete\") {\n      const output = this.output;\n\n      // Delete configuration set if it exists\n      if (output?.configurationSetName) {\n        await ignore(NotFoundException.name, () =>\n          client.send(\n            new DeleteConfigurationSetCommand({\n              ConfigurationSetName: output.configurationSetName,\n            }),\n          ),\n        );\n      }\n\n      // Delete email identity if it exists\n      if (output?.emailIdentity) {\n        await ignore(NotFoundException.name, () =>\n          client.send(\n            new DeleteEmailIdentityCommand({\n              EmailIdentity: output.emailIdentity,\n            }),\n          ),\n        );\n      }\n\n      // Return empty output for delete\n      return this.destroy();\n    }\n\n    // Created resources\n    let configurationSetArn: string | undefined;\n    let emailIdentityArn: string | undefined;\n    let emailIdentityVerificationStatus: string | undefined;\n    let dkimVerificationStatus: string | undefined;\n\n    // Create or update configuration set if specified\n    if (props.configurationSetName) {\n      // Check if configuration set exists\n      let configSetExists = false;\n      try {\n        await client.send(\n          new GetConfigurationSetCommand({\n            ConfigurationSetName: props.configurationSetName,\n          }),\n        );\n        configSetExists = true;\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          configSetExists = false;\n        } else {\n          throw error;\n        }\n      }\n\n      if (configSetExists) {\n        // Update existing configuration set using appropriate update commands\n        if (props.sendingOptions) {\n          await client.send(\n            new PutConfigurationSetSendingOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              SendingEnabled: props.sendingOptions.SendingEnabled,\n            }),\n          );\n        }\n\n        if (props.reputationOptions) {\n          await client.send(\n            new PutConfigurationSetReputationOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              ReputationMetricsEnabled:\n                props.reputationOptions.ReputationMetricsEnabled,\n            }),\n          );\n        }\n\n        if (props.trackingOptions) {\n          await client.send(\n            new PutConfigurationSetTrackingOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              CustomRedirectDomain: props.trackingOptions.CustomRedirectDomain,\n            }),\n          );\n        }\n\n        if (props.suppressionOptions) {\n          await client.send(\n            new PutConfigurationSetSuppressionOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              SuppressedReasons: props.suppressionOptions.SuppressedReasons,\n            }),\n          );\n        }\n\n        if (props.deliveryOptions) {\n          await client.send(\n            new PutConfigurationSetDeliveryOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              TlsPolicy: props.deliveryOptions.TlsPolicy,\n              SendingPoolName: props.deliveryOptions.SendingPoolName,\n            }),\n          );\n        }\n\n        // In SESv2, the ARN isn't directly returned in the response\n        configurationSetArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:configuration-set/${props.configurationSetName}`;\n      } else {\n        // Create new configuration set\n        await client.send(\n          new CreateConfigurationSetCommand({\n            ConfigurationSetName: props.configurationSetName,\n            SendingOptions: props.sendingOptions,\n            ReputationOptions: props.reputationOptions,\n            TrackingOptions: props.trackingOptions,\n            SuppressionOptions: props.suppressionOptions,\n            DeliveryOptions: props.deliveryOptions,\n            Tags: Object.entries(props.tags || {}).map(([Key, Value]) => ({\n              Key,\n              Value,\n            })),\n          }),\n        );\n\n        // In SESv2, the ARN isn't directly returned in the response\n        configurationSetArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:configuration-set/${props.configurationSetName}`;\n      }\n    }\n\n    // Create or verify email identity if specified\n    if (props.emailIdentity) {\n      // Check if identity exists\n      let getIdentityResult;\n      try {\n        getIdentityResult = await client.send(\n          new GetEmailIdentityCommand({\n            EmailIdentity: props.emailIdentity,\n          }),\n        );\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          getIdentityResult = null;\n        } else {\n          throw error;\n        }\n      }\n\n      if (!getIdentityResult) {\n        // Create new email identity\n        const createIdentityResult = await client.send(\n          new CreateEmailIdentityCommand({\n            EmailIdentity: props.emailIdentity,\n            Tags: Object.entries(props.tags || {}).map(([Key, Value]) => ({\n              Key,\n              Value,\n            })),\n          }),\n        );\n\n        // If it's an email address, we don't need to explicitly verify in v2\n        // The verification email is automatically sent by SES in v2\n\n        // Store the identity information\n        emailIdentityArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:identity/${props.emailIdentity}`;\n        emailIdentityVerificationStatus =\n          createIdentityResult.VerifiedForSendingStatus\n            ? \"VERIFIED\"\n            : \"PENDING\";\n      } else {\n        // Store the identity information\n        emailIdentityArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:identity/${props.emailIdentity}`;\n        emailIdentityVerificationStatus =\n          getIdentityResult.VerifiedForSendingStatus ? \"VERIFIED\" : \"PENDING\";\n\n        // Update DKIM settings if requested\n        if (props.enableDkim !== undefined) {\n          if (props.enableDkim) {\n            await client.send(\n              new PutEmailIdentityDkimAttributesCommand({\n                EmailIdentity: props.emailIdentity,\n                SigningEnabled: true,\n              }),\n            );\n\n            // We can check the current status of DKIM\n            dkimVerificationStatus = \"PENDING\"; // Default to pending\n\n            // Get the updated identity to check DKIM status\n            const updatedIdentity = await client.send(\n              new GetEmailIdentityCommand({\n                EmailIdentity: props.emailIdentity,\n              }),\n            );\n\n            if (updatedIdentity.DkimAttributes?.Status) {\n              dkimVerificationStatus = updatedIdentity.DkimAttributes.Status;\n            }\n          }\n        }\n      }\n    }\n\n    // Return the resource output\n    return this({\n      ...props,\n      configurationSetArn,\n      emailIdentityArn,\n      emailIdentityVerificationStatus,\n      dkimVerificationStatus,\n    });\n  },\n);\n\n```\n\n// alchemy/src/aws/table.ts\n```ts\nimport {\n  CreateTableCommand,\n  DeleteTableCommand,\n  DescribeTableCommand,\n  DynamoDBClient,\n  InternalServerError,\n  type KeySchemaElement,\n  ResourceInUseException,\n  ResourceNotFoundException,\n} from \"@aws-sdk/client-dynamodb\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\nimport { withExponentialBackoff } from \"../util/retry\";\n\n/**\n * Properties for creating or updating a DynamoDB table\n */\nexport interface TableProps {\n  /**\n   * Name of the DynamoDB table\n   */\n  tableName: string;\n\n  /**\n   * Primary partition key (hash key) configuration\n   * Defines the main identifier for items in the table\n   */\n  partitionKey: {\n    /**\n     * Name of the partition key attribute\n     */\n    name: string;\n    /**\n     * Data type of the partition key\n     * S: String, N: Number, B: Binary\n     */\n    type: \"S\" | \"N\" | \"B\";\n  };\n\n  /**\n   * Optional sort key (range key) configuration\n   * Used to sort items with the same partition key\n   */\n  sortKey?: {\n    /**\n     * Name of the sort key attribute\n     */\n    name: string;\n    /**\n     * Data type of the sort key\n     * S: String, N: Number, B: Binary\n     */\n    type: \"S\" | \"N\" | \"B\";\n  };\n\n  /**\n   * Billing mode for the table\n   * PROVISIONED: Set read/write capacity units\n   * PAY_PER_REQUEST: Pay per request pricing\n   */\n  billingMode?: \"PROVISIONED\" | \"PAY_PER_REQUEST\";\n\n  /**\n   * Read capacity units when using PROVISIONED billing mode\n   * Default: 5\n   */\n  readCapacity?: number;\n\n  /**\n   * Write capacity units when using PROVISIONED billing mode\n   * Default: 5\n   */\n  writeCapacity?: number;\n\n  /**\n   * Tags to apply to the table\n   * Key-value pairs for resource organization\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after DynamoDB table creation/update\n */\nexport interface Table extends Resource<\"dynamo::Table\">, TableProps {\n  /**\n   * ARN of the table\n   * Format: arn:aws:dynamodb:region:account-id:table/table-name\n   */\n  arn: string;\n\n  /**\n   * ARN of the table's stream if enabled\n   * Format: arn:aws:dynamodb:region:account-id:table/table-name/stream/timestamp\n   */\n  streamArn?: string;\n\n  /**\n   * Unique identifier for the table\n   */\n  tableId: string;\n}\n\n/**\n * AWS DynamoDB Table Resource\n *\n * Creates and manages DynamoDB tables with support for partition and sort keys,\n * flexible billing modes, and automatic table status monitoring.\n *\n * @example\n * // Create a table with partition and sort key\n * const table = await Table(\"user-events\", {\n *   tableName: \"user-events\",\n *   partitionKey: {\n *     name: \"id\",\n *     type: \"S\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"N\"\n *   },\n *   tags: {\n *     Environment: \"test\"\n *   }\n * });\n *\n * @example\n * // Create a table with provisioned capacity\n * const table = await Table(\"high-throughput\", {\n *   tableName: \"high-throughput\",\n *   partitionKey: {\n *     name: \"userId\",\n *     type: \"S\"\n *   },\n *   billingMode: \"PROVISIONED\",\n *   readCapacity: 100,\n *   writeCapacity: 50\n * });\n */\nexport const Table = Resource(\n  \"dynamo::Table\",\n  async function (\n    this: Context<Table>,\n    id: string,\n    props: TableProps,\n  ): Promise<Table> {\n    const client = new DynamoDBClient({});\n\n    if (this.phase === \"delete\") {\n      await withExponentialBackoff(\n        async () => {\n          await ignore(ResourceNotFoundException.name, () =>\n            client.send(\n              new DeleteTableCommand({\n                TableName: props.tableName,\n              }),\n            ),\n          );\n        },\n        (error) =>\n          error instanceof ResourceInUseException ||\n          error instanceof InternalServerError,\n        10, // Max attempts\n        200, // Initial delay in ms\n      );\n\n      // Wait for table to be deleted\n      let tableDeleted = false;\n      let retryCount = 0;\n      const maxRetries = 60; // Wait up to 60 seconds\n\n      while (!tableDeleted && retryCount < maxRetries) {\n        try {\n          await client.send(\n            new DescribeTableCommand({\n              TableName: props.tableName,\n            }),\n          );\n          // If we get here, table still exists\n          retryCount++;\n          // Increasing delay for each retry with some jitter\n          const delay = Math.min(1000 * (1 + 0.1 * Math.random()), 5000);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        } catch (error) {\n          if (error instanceof ResourceNotFoundException) {\n            tableDeleted = true;\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      if (!tableDeleted) {\n        throw new Error(\n          `Timed out waiting for table ${props.tableName} to be deleted`,\n        );\n      }\n\n      return this.destroy();\n    } else {\n      // Setup for table creation\n      const attributeDefinitions = [\n        {\n          AttributeName: props.partitionKey.name,\n          AttributeType: props.partitionKey.type,\n        },\n      ];\n\n      const keySchema: KeySchemaElement[] = [\n        {\n          AttributeName: props.partitionKey.name,\n          KeyType: \"HASH\",\n        },\n      ];\n\n      if (props.sortKey) {\n        attributeDefinitions.push({\n          AttributeName: props.sortKey.name,\n          AttributeType: props.sortKey.type,\n        });\n        keySchema.push({\n          AttributeName: props.sortKey.name,\n          KeyType: \"RANGE\",\n        });\n      }\n\n      // Attempt to create the table with exponential backoff for ResourceInUseException\n      await withExponentialBackoff(\n        async () => {\n          try {\n            // First check if table already exists\n            const describeResponse = await client.send(\n              new DescribeTableCommand({\n                TableName: props.tableName,\n              }),\n            );\n\n            // If table exists and is ACTIVE, no need to create it\n            if (describeResponse.Table?.TableStatus === \"ACTIVE\") {\n              return;\n            }\n\n            // If table exists but not ACTIVE, wait for it in the polling loop below\n            if (describeResponse.Table) {\n              return;\n            }\n          } catch (error) {\n            if (error instanceof ResourceNotFoundException) {\n              // Table doesn't exist, try to create it\n              await client.send(\n                new CreateTableCommand({\n                  TableName: props.tableName,\n                  AttributeDefinitions: attributeDefinitions,\n                  KeySchema: keySchema,\n                  BillingMode: props.billingMode || \"PAY_PER_REQUEST\",\n                  ProvisionedThroughput:\n                    props.billingMode === \"PROVISIONED\"\n                      ? {\n                          ReadCapacityUnits: props.readCapacity || 5,\n                          WriteCapacityUnits: props.writeCapacity || 5,\n                        }\n                      : undefined,\n                  Tags: props.tags\n                    ? Object.entries(props.tags).map(([Key, Value]) => ({\n                        Key,\n                        Value,\n                      }))\n                    : undefined,\n                }),\n              );\n            } else {\n              throw error;\n            }\n          }\n        },\n        (error) => error instanceof ResourceInUseException,\n        10, // Max attempts\n        200, // Initial delay in ms\n      );\n\n      // Wait for table to be active with timeout\n      let tableActive = false;\n      let tableDescription;\n      let retryCount = 0;\n      const maxRetries = 60; // Wait up to 60 seconds\n\n      while (!tableActive && retryCount < maxRetries) {\n        try {\n          const response = await client.send(\n            new DescribeTableCommand({\n              TableName: props.tableName,\n            }),\n          );\n\n          tableActive = response.Table?.TableStatus === \"ACTIVE\";\n          if (tableActive) {\n            tableDescription = response.Table;\n          } else {\n            retryCount++;\n            // Increasing delay for each retry with some jitter\n            const delay = Math.min(1000 * (1 + 0.1 * Math.random()), 5000);\n            await new Promise((resolve) => setTimeout(resolve, delay));\n          }\n        } catch (error) {\n          retryCount++;\n          if (!(error instanceof ResourceNotFoundException)) {\n            throw error;\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1000));\n        }\n      }\n\n      if (!tableActive) {\n        throw new Error(\n          `Timed out waiting for table ${props.tableName} to become active`,\n        );\n      }\n\n      return this({\n        ...props,\n        arn: tableDescription!.TableArn!,\n        streamArn: tableDescription!.LatestStreamArn,\n        tableId: tableDescription!.TableId!,\n      });\n    }\n  },\n);\n\n```",
    "content": "# PolicyAttachment\n\nThe PolicyAttachment resource lets you attach [AWS IAM policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html) to IAM roles.\n\n## Minimal Example\n\nAttach an AWS managed policy to a role:\n\n```ts\nimport { PolicyAttachment } from \"alchemy/aws\";\n\nconst adminAccess = await PolicyAttachment(\"admin-policy\", {\n  policyArn: \"arn:aws:iam::aws:policy/AdministratorAccess\", \n  roleName: role.name\n});\n```\n\n## Attach Custom Policy\n\nAttach a custom policy to a role:\n\n```ts\nimport { PolicyAttachment } from \"alchemy/aws\";\n\nconst customPolicy = await PolicyAttachment(\"custom-policy\", {\n  policyArn: policy.arn,\n  roleName: role.name\n});\n```\n\n## Multiple Policy Attachments \n\nAttach multiple policies to a single role:\n\n```ts\nimport { PolicyAttachment } from \"alchemy/aws\";\n\nconst s3Access = await PolicyAttachment(\"s3-access\", {\n  policyArn: \"arn:aws:iam::aws:policy/AmazonS3FullAccess\",\n  roleName: role.name\n});\n\nconst sqsAccess = await PolicyAttachment(\"sqs-access\", {\n  policyArn: \"arn:aws:iam::aws:policy/AmazonSQSFullAccess\", \n  roleName: role.name\n});\n```",
    "messages": [
      {
        "role": "user",
        "content": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         aws Service:\n[function.ts](alchemy/src/aws/function.ts)\n\n[table.ts](alchemy/src/aws/table.ts)\n\n[account-id.ts](alchemy/src/aws/account-id.ts)\n\n[policy-attachment.ts](alchemy/src/aws/policy-attachment.ts)\n\n[role.ts](alchemy/src/aws/role.ts)\n\n[policy.ts](alchemy/src/aws/policy.ts)\n\n[credentials.ts](alchemy/src/aws/credentials.ts)\n\n[ses.ts](alchemy/src/aws/ses.ts)\n\n[bucket.ts](alchemy/src/aws/bucket.ts)\n\n[queue.ts](alchemy/src/aws/queue.ts)\n\nWrite concise documentation for the \"        PolicyAttachment\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         PolicyAttachment\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         PolicyAttachment } from \"alchemy/        aws\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         PolicyAttachment } from \"alchemy/        aws\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        \n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Creating Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroying Resources\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value ðŸ˜µâ€ðŸ’«\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n// env.d.ts\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n### 4. Scope-Based Destruction\n\n```typescript\n// Destroy all resources in a scope\nimport { destroy } from \"alchemy\";\nconst scope = alchemy.scope(\"temporary\");\nconst tempFile = await File(\"temp.txt\", { ... });\n\nawait destroy(scope);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// Clean up test resources reliably with try/finally\nconst scope = alchemy.scope(\"test\");\ntry {\n  // Create test resources\n} finally {\n  await destroy(scope);\n}\n```\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\nâ”œâ”€â”€ dev (Stage Scope)\nâ”‚   â”œâ”€â”€ api (Nested Scope)\nâ”‚   â””â”€â”€ database (Resource)\nâ””â”€â”€ prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/aws/account-id.ts\n```ts\nimport { GetCallerIdentityCommand, STSClient } from \"@aws-sdk/client-sts\";\n\nconst sts = new STSClient({});\n\nexport type AccountId = string & {\n  readonly __brand: \"AccountId\";\n};\n\n/**\n * Helper to get the current AWS account ID\n */\nexport async function AccountId(): Promise<AccountId> {\n  const identity = await sts.send(new GetCallerIdentityCommand({}));\n  return identity.Account! as AccountId;\n}\n\n```\n\n// alchemy/src/aws/bucket.ts\n```ts\nimport {\n  CreateBucketCommand,\n  DeleteBucketCommand,\n  GetBucketAclCommand,\n  GetBucketLocationCommand,\n  GetBucketTaggingCommand,\n  GetBucketVersioningCommand,\n  HeadBucketCommand,\n  NoSuchBucket,\n  PutBucketTaggingCommand,\n  S3Client,\n} from \"@aws-sdk/client-s3\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating an S3 bucket\n */\nexport interface BucketProps {\n  /**\n   * The name of the bucket. Must be globally unique across all AWS accounts.\n   * Should be lowercase alphanumeric characters or hyphens.\n   */\n  bucketName: string;\n\n  /**\n   * Optional tags to apply to the bucket for organization and cost tracking.\n   * Each tag is a key-value pair.\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after S3 bucket creation/update\n */\nexport interface Bucket extends Resource<\"s3::Bucket\">, BucketProps {\n  /**\n   * The ARN (Amazon Resource Name) of the bucket\n   * Format: arn:aws:s3:::bucket-name\n   */\n  arn: string;\n\n  /**\n   * The global domain name for the bucket\n   * Format: bucket-name.s3.amazonaws.com\n   */\n  bucketDomainName: string;\n\n  /**\n   * The regional domain name for the bucket\n   * Format: bucket-name.s3.region.amazonaws.com\n   */\n  bucketRegionalDomainName?: string;\n\n  /**\n   * The S3 hosted zone ID for the region where the bucket resides\n   * Used for DNS configuration with Route 53\n   */\n  hostedZoneId?: string;\n\n  /**\n   * The AWS region where the bucket is located\n   */\n  region?: string;\n\n  /**\n   * The website endpoint URL if static website hosting is enabled\n   * Format: http://bucket-name.s3-website-region.amazonaws.com\n   */\n  websiteEndpoint?: string;\n\n  /**\n   * The website domain if static website hosting is enabled\n   * Format: bucket-name.s3-website-region.amazonaws.com\n   */\n  websiteDomain?: string;\n\n  /**\n   * Whether versioning is enabled for the bucket\n   */\n  versioningEnabled?: boolean;\n\n  /**\n   * The canned ACL applied to the bucket\n   * Common values: private, public-read, public-read-write, authenticated-read\n   */\n  acl?: string;\n}\n\n/**\n * AWS S3 Bucket Resource\n *\n * Creates and manages Amazon S3 buckets with support for versioning, tags, and regional configuration.\n * S3 buckets provide scalable object storage for any type of data, with features like versioning,\n * lifecycle policies, and fine-grained access control.\n *\n * @example\n * // Create a basic S3 bucket with default settings\n * const basicBucket = await Bucket(\"my-app-storage\", {\n *   bucketName: \"my-app-storage\",\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"my-app\"\n *   }\n * });\n *\n * @example\n * // Create a bucket with versioning enabled and specific tags\n * const versionedBucket = await Bucket(\"document-archive\", {\n *   bucketName: \"document-archive\",\n *   tags: {\n *     Environment: \"production\",\n *     Purpose: \"document-storage\",\n *     Versioning: \"enabled\"\n *   }\n * });\n *\n * @example\n * // Create a development bucket with minimal configuration\n * const devBucket = await Bucket(\"dev-testing\", {\n *   bucketName: \"dev-testing\",\n *   tags: {\n *     Environment: \"development\",\n *     Temporary: \"true\"\n *   }\n * });\n */\nexport const Bucket = Resource(\n  \"s3::Bucket\",\n  async function (this: Context<Bucket>, id: string, props: BucketProps) {\n    const client = new S3Client({});\n\n    if (this.phase === \"delete\") {\n      await ignore(NoSuchBucket.name, () =>\n        client.send(\n          new DeleteBucketCommand({\n            Bucket: props.bucketName,\n          }),\n        ),\n      );\n      return this.destroy();\n    } else {\n      try {\n        // Check if bucket exists\n        await client.send(\n          new HeadBucketCommand({\n            Bucket: props.bucketName,\n          }),\n        );\n\n        // Update tags if they changed and bucket exists\n        if (this.phase === \"update\" && props.tags) {\n          await client.send(\n            new PutBucketTaggingCommand({\n              Bucket: props.bucketName,\n              Tagging: {\n                TagSet: Object.entries(props.tags).map(([Key, Value]) => ({\n                  Key,\n                  Value,\n                })),\n              },\n            }),\n          );\n        }\n      } catch (error: any) {\n        if (error.name === \"NotFound\") {\n          // Create bucket if it doesn't exist\n          await client.send(\n            new CreateBucketCommand({\n              Bucket: props.bucketName,\n              // Add tags during creation if specified\n              ...(props.tags && {\n                Tagging: {\n                  TagSet: Object.entries(props.tags).map(([Key, Value]) => ({\n                    Key,\n                    Value,\n                  })),\n                },\n              }),\n            }),\n          );\n        } else {\n          throw error;\n        }\n      }\n\n      // Get bucket details\n      const [locationResponse, versioningResponse, aclResponse] =\n        await Promise.all([\n          client.send(\n            new GetBucketLocationCommand({ Bucket: props.bucketName }),\n          ),\n          client.send(\n            new GetBucketVersioningCommand({ Bucket: props.bucketName }),\n          ),\n          client.send(new GetBucketAclCommand({ Bucket: props.bucketName })),\n        ]);\n\n      const region = locationResponse.LocationConstraint || \"us-east-1\";\n\n      // Get tags if they exist\n      let tags = props.tags;\n      if (!tags) {\n        try {\n          const taggingResponse = await client.send(\n            new GetBucketTaggingCommand({ Bucket: props.bucketName }),\n          );\n          tags = Object.fromEntries(\n            taggingResponse.TagSet?.map(({ Key, Value }) => [Key, Value]) || [],\n          );\n        } catch (error: any) {\n          if (error.name !== \"NoSuchTagSet\") {\n            throw error;\n          }\n        }\n      }\n\n      return this({\n        bucketName: props.bucketName,\n        arn: `arn:aws:s3:::${props.bucketName}`,\n        bucketDomainName: `${props.bucketName}.s3.amazonaws.com`,\n        bucketRegionalDomainName: `${props.bucketName}.s3.${region}.amazonaws.com`,\n        region,\n        hostedZoneId: getHostedZoneId(region),\n        versioningEnabled: versioningResponse.Status === \"Enabled\",\n        acl: aclResponse.Grants?.[0]?.Permission?.toLowerCase(),\n        ...(tags && { tags }),\n      });\n    }\n  },\n);\n\n/**\n * Helper function to get S3 hosted zone IDs by region\n *\n * Returns the S3 hosted zone ID for a given AWS region. These IDs are used when\n * configuring Route 53 DNS records that point to S3 buckets. If the region is not\n * found in the mapping, defaults to the us-east-1 hosted zone ID.\n *\n * @param region - The AWS region code (e.g., us-east-1, eu-west-1)\n * @returns The S3 hosted zone ID for the region\n */\nfunction getHostedZoneId(region: string): string {\n  const hostedZoneIds: Record<string, string> = {\n    \"us-east-1\": \"Z3AQBSTGFYJSTF\",\n    \"us-east-2\": \"Z2O1EMRO9K5GLX\",\n    \"us-west-1\": \"Z2F56UZL2M1ACD\",\n    \"us-west-2\": \"Z3BJ6K6RIION7M\",\n    \"af-south-1\": \"Z11KHD8FBVPUYU\",\n    \"ap-east-1\": \"ZNB98KWMFR0R6\",\n    \"ap-south-1\": \"Z11RGJOFQNVJUP\",\n    \"ap-northeast-1\": \"Z2M4EHUR26P7ZW\",\n    \"ap-northeast-2\": \"Z3W03O7B5YMIYP\",\n    \"ap-northeast-3\": \"Z2YQB5RD63NC85\",\n    \"ap-southeast-1\": \"Z3O0J2DXBE1FTB\",\n    \"ap-southeast-2\": \"Z1WCIGYICN2BYD\",\n    \"ca-central-1\": \"Z1QDHH18159H29\",\n    \"eu-central-1\": \"Z21DNDUVLTQW6Q\",\n    \"eu-west-1\": \"Z1BKCTXD74EZPE\",\n    \"eu-west-2\": \"Z3GKZC51ZF0DB4\",\n    \"eu-west-3\": \"Z3R1K369G5AVDG\",\n    \"eu-north-1\": \"Z3BAZG2TWCNX0D\",\n    \"eu-south-1\": \"Z30OZKI7KPW7MI\",\n    \"me-south-1\": \"Z1MPMWCPA7YB62\",\n    \"sa-east-1\": \"Z7KQH4QJS55SO\",\n  };\n  return hostedZoneIds[region] || \"Z3AQBSTGFYJSTF\"; // Default to us-east-1 if region not found\n}\n\n```\n\n// alchemy/src/aws/credentials.ts\n```ts\nimport type { Secret } from \"../secret\";\n\nexport interface AwsCredentials {\n  accessKeyId: Secret;\n  secretAccessKey: Secret;\n}\n\n```\n\n// alchemy/src/aws/function.ts\n```ts\nimport {\n  Architecture,\n  CreateFunctionCommand,\n  DeleteFunctionCommand,\n  GetFunctionCommand,\n  GetFunctionConfigurationCommand,\n  LambdaClient,\n  ResourceNotFoundException,\n  Runtime,\n  UpdateFunctionCodeCommand,\n  UpdateFunctionConfigurationCommand,\n} from \"@aws-sdk/client-lambda\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating a Lambda function\n */\nexport interface FunctionProps {\n  /**\n   * Name of the Lambda function\n   */\n  functionName: string;\n\n  /**\n   * Path to the zip file containing the function code\n   */\n  zipPath: string;\n\n  /**\n   * ARN of the IAM role that Lambda assumes when executing the function\n   */\n  roleArn: string;\n\n  /**\n   * Function handler in the format 'file.function'\n   * For Node.js this is typically 'index.handler' or similar\n   */\n  handler?: string;\n\n  /**\n   * Lambda runtime environment for the function\n   * @default nodejs20.x if not specified\n   */\n  runtime?: Runtime;\n\n  /**\n   * CPU architecture for the function\n   * @default x86_64 if not specified\n   */\n  architecture?: Architecture;\n\n  /**\n   * Description of the function's purpose\n   */\n  description?: string;\n\n  /**\n   * Maximum execution time in seconds\n   * @default 3 seconds if not specified\n   */\n  timeout?: number;\n\n  /**\n   * Amount of memory available to the function in MB\n   * @default 128 MB if not specified\n   */\n  memorySize?: number;\n\n  /**\n   * Environment variables available to the function code\n   */\n  environment?: Record<string, string>;\n\n  /**\n   * Resource tags for the function\n   */\n  tags?: Record<string, string>;\n\n  /**\n   * Function URL configuration for direct HTTP(S) invocation\n   */\n  url?: {\n    /**\n     * Authentication type for the function URL\n     */\n    authType?: \"AWS_IAM\" | \"NONE\";\n\n    /**\n     * CORS configuration for the function URL\n     */\n    cors?: {\n      /**\n       * Whether to allow credentials in CORS requests\n       */\n      allowCredentials?: boolean;\n\n      /**\n       * Allowed headers in CORS requests\n       */\n      allowHeaders?: string[];\n\n      /**\n       * Allowed HTTP methods in CORS requests\n       */\n      allowMethods?: string[];\n\n      /**\n       * Allowed origins in CORS requests\n       */\n      allowOrigins?: string[];\n\n      /**\n       * Headers exposed to the browser\n       */\n      exposeHeaders?: string[];\n\n      /**\n       * CORS preflight cache time in seconds\n       */\n      maxAge?: number;\n    };\n  };\n}\n\n/**\n * Output returned after Lambda function creation/update\n */\nexport interface Function extends Resource<\"lambda::Function\">, FunctionProps {\n  /**\n   * ARN of the Lambda function\n   */\n  arn: string;\n\n  /**\n   * Timestamp of the last function modification\n   */\n  lastModified: string;\n\n  /**\n   * Function version\n   */\n  version: string;\n\n  /**\n   * ARN with version suffix\n   */\n  qualifiedArn: string;\n\n  /**\n   * ARN for invoking the function through API Gateway\n   */\n  invokeArn: string;\n\n  /**\n   * SHA256 hash of the function code\n   */\n  sourceCodeHash: string;\n\n  /**\n   * Size of the function code in bytes\n   */\n  sourceCodeSize: number;\n\n  /**\n   * Size of ephemeral storage (/tmp) in MB\n   */\n  ephemeralStorageSize?: number;\n\n  /**\n   * List of supported CPU architectures\n   */\n  architectures: string[];\n\n  /**\n   * ARN of the master function (Lambda@Edge only)\n   */\n  masterArn?: string;\n\n  /**\n   * Unique identifier for the current function code/config\n   */\n  revisionId: string;\n\n  /**\n   * Current state of the function\n   */\n  state?: string;\n\n  /**\n   * Reason for the current state\n   */\n  stateReason?: string;\n\n  /**\n   * Code for the current state reason\n   */\n  stateReasonCode?: string;\n\n  /**\n   * Status of the last update operation\n   */\n  lastUpdateStatus?: string;\n\n  /**\n   * Reason for the last update status\n   */\n  lastUpdateStatusReason?: string;\n\n  /**\n   * Code for the last update status reason\n   */\n  lastUpdateStatusReasonCode?: string;\n\n  /**\n   * Function package type (Zip or Image)\n   */\n  packageType: string;\n\n  /**\n   * ARN of the signing profile version\n   */\n  signingProfileVersionArn?: string;\n\n  /**\n   * ARN of the signing job\n   */\n  signingJobArn?: string;\n}\n\n/**\n * AWS Lambda Function Resource\n *\n * Creates and manages AWS Lambda functions with support for Node.js runtimes, custom handlers,\n * environment variables, and function URLs. Handles deployment packaging, IAM role\n * stabilization, and function updates.\n *\n * @example\n * // Create a basic Lambda function with minimal configuration\n * const basicFunction = await Function(\"api-handler\", {\n *   functionName: \"api-handler\",\n *   zipPath: \"./dist/api.zip\",\n *   roleArn: role.arn,\n *   runtime: Runtime.nodejs20x,\n *   handler: \"index.handler\",\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a function with environment variables and custom memory/timeout\n * const configuredFunction = await Function(\"worker\", {\n *   functionName: \"worker\",\n *   zipPath: \"./dist/worker.zip\",\n *   roleArn: role.arn,\n *   runtime: Runtime.nodejs20x,\n *   handler: \"worker.process\",\n *   memorySize: 512,\n *   timeout: 30,\n *   environment: {\n *     QUEUE_URL: queue.url,\n *     LOG_LEVEL: \"info\"\n *   }\n * });\n *\n * @example\n * // Create a function with a public URL endpoint and CORS\n * const apiFunction = await Function(\"public-api\", {\n *   functionName: \"public-api\",\n *   zipPath: \"./dist/api.zip\",\n *   roleArn: role.arn,\n *   handler: \"api.handler\",\n *   url: {\n *     authType: \"NONE\",\n *     cors: {\n *       allowOrigins: [\"*\"],\n *       allowMethods: [\"GET\", \"POST\"],\n *       allowHeaders: [\"content-type\"],\n *       maxAge: 86400\n *     }\n *   }\n * });\n */\nexport const Function = Resource(\n  \"lambda::Function\",\n  async function (this: Context<Function>, id: string, props: FunctionProps) {\n    const client = new LambdaClient({});\n    const region = await resolveRegion(client);\n\n    const code = await zipCode(props.zipPath);\n\n    if (this.phase === \"delete\") {\n      await ignore(ResourceNotFoundException.name, () =>\n        client.send(\n          new DeleteFunctionCommand({\n            FunctionName: props.functionName,\n          }),\n        ),\n      );\n\n      return this.destroy();\n    } else {\n      try {\n        // Check if function exists\n        await client.send(\n          new GetFunctionCommand({\n            FunctionName: props.functionName,\n          }),\n        );\n\n        if (this.phase === \"update\") {\n          // Wait for function to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Update function code\n          await client.send(\n            new UpdateFunctionCodeCommand({\n              FunctionName: props.functionName,\n              ZipFile: code,\n            }),\n          );\n\n          // Wait for code update to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Update function configuration\n          await client.send(\n            new UpdateFunctionConfigurationCommand({\n              FunctionName: props.functionName,\n              Handler: props.handler,\n              Runtime: props.runtime,\n              Role: props.roleArn,\n              Description: props.description,\n              Timeout: props.timeout,\n              MemorySize: props.memorySize,\n              Environment: props.environment\n                ? { Variables: props.environment }\n                : undefined,\n            }),\n          );\n\n          // Wait for configuration update to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n        }\n      } catch (error: any) {\n        if (error.name === \"ResourceNotFoundException\") {\n          // Create function if it doesn't exist\n          const startTime = Date.now();\n          let delay = 100; // Start with 100ms delay\n\n          while (true) {\n            try {\n              await client.send(\n                new CreateFunctionCommand({\n                  FunctionName: props.functionName,\n                  Code: { ZipFile: code },\n                  Handler: props.handler || \"index.handler\",\n                  Runtime: props.runtime || Runtime.nodejs20x,\n                  Role: props.roleArn,\n                  Description: props.description,\n                  Timeout: props.timeout || 3,\n                  MemorySize: props.memorySize || 128,\n                  Environment: props.environment\n                    ? { Variables: props.environment }\n                    : undefined,\n                  Architectures: props.architecture\n                    ? [props.architecture]\n                    : [Architecture.x86_64],\n                  Tags: props.tags,\n                }),\n              );\n              break; // Success - exit retry loop\n            } catch (createError: any) {\n              if (\n                createError.name !== \"InvalidParameterValueException\" ||\n                !createError.message?.includes(\"cannot be assumed by Lambda\")\n              ) {\n                throw createError; // Different error - rethrow\n              }\n\n              if (Date.now() - startTime > 10000) {\n                throw new Error(\n                  \"Timeout waiting for IAM role to be assumable by Lambda after 10s\",\n                );\n              }\n\n              await new Promise((resolve) => setTimeout(resolve, delay));\n              delay = Math.min(delay * 2, 1000); // Exponential backoff capped at 1s\n            }\n          }\n\n          // Wait for function to be active\n          let isCreating = true;\n          while (isCreating) {\n            const config = await client.send(\n              new GetFunctionConfigurationCommand({\n                FunctionName: props.functionName,\n              }),\n            );\n            isCreating = config.State === \"Pending\";\n            if (isCreating) {\n              await new Promise((resolve) => setTimeout(resolve, 1000));\n            }\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      // Get complete function details\n      const [func, config] = await Promise.all([\n        client.send(\n          new GetFunctionCommand({\n            FunctionName: props.functionName,\n          }),\n        ),\n        client.send(\n          new GetFunctionConfigurationCommand({\n            FunctionName: props.functionName,\n          }),\n        ),\n      ]);\n\n      return this({\n        ...props,\n        arn: config.FunctionArn!,\n        lastModified: config.LastModified!,\n        version: config.Version!,\n        qualifiedArn: `${config.FunctionArn}:${config.Version}`,\n        invokeArn: `arn:aws:apigateway:${region}:lambda:path/2015-03-31/functions/${config.FunctionArn}/invocations`,\n        sourceCodeHash: config.CodeSha256!,\n        sourceCodeSize: config.CodeSize!,\n        ephemeralStorageSize: config.EphemeralStorage?.Size,\n        architectures: config.Architectures || [],\n        masterArn: config.MasterArn,\n        revisionId: config.RevisionId!,\n        state: config.State,\n        stateReason: config.StateReason,\n        stateReasonCode: config.StateReasonCode,\n        lastUpdateStatus: config.LastUpdateStatus,\n        lastUpdateStatusReason: config.LastUpdateStatusReason,\n        lastUpdateStatusReasonCode: config.LastUpdateStatusReasonCode,\n        packageType: config.PackageType!,\n        signingProfileVersionArn: config.SigningProfileVersionArn,\n        signingJobArn: config.SigningJobArn,\n      });\n    }\n  },\n);\n\n// Helper to wait for function to stabilize\nasync function waitForFunctionStabilization(\n  client: LambdaClient,\n  functionName: string,\n) {\n  while (true) {\n    const config = await client.send(\n      new GetFunctionConfigurationCommand({\n        FunctionName: functionName,\n      }),\n    );\n\n    // Check if function is in a stable state\n    if (config.State === \"Active\" && config.LastUpdateStatus === \"Successful\") {\n      break;\n    }\n\n    // If there's a failure, throw an error\n    if (config.State === \"Failed\" || config.LastUpdateStatus === \"Failed\") {\n      throw new Error(\n        `Function failed to stabilize: ${config.StateReason || config.LastUpdateStatusReason}`,\n      );\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n  }\n}\n\n// Helper to zip the code\nasync function zipCode(filePath: string): Promise<Buffer> {\n  const fileContent = await fs.promises.readFile(filePath);\n  const fileName = path.basename(filePath);\n\n  // Create a zip buffer in memory\n  const zip = new (await import(\"jszip\")).default();\n  zip.file(fileName, fileContent);\n  return zip.generateAsync({\n    type: \"nodebuffer\",\n    compression: \"DEFLATE\",\n    platform: \"UNIX\",\n  });\n}\n\nasync function resolveRegion(client: LambdaClient): Promise<string> {\n  const region = client.config.region;\n  if (typeof region === \"string\") return region;\n  if (typeof region === \"function\") return region();\n  throw new Error(\"Could not resolve AWS region\");\n}\n\n```\n\n// alchemy/src/aws/policy-attachment.ts\n```ts\nimport {\n  AttachRolePolicyCommand,\n  DetachRolePolicyCommand,\n  IAMClient,\n  NoSuchEntityException,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating a policy attachment\n */\nexport interface PolicyAttachmentProps {\n  /**\n   * ARN of the IAM policy to attach\n   */\n  policyArn: string;\n\n  /**\n   * Name of the IAM role to attach the policy to\n   */\n  roleName: string;\n}\n\n/**\n * Output returned after policy attachment creation/update\n */\nexport interface PolicyAttachment\n  extends Resource<\"iam::PolicyAttachment\">,\n    PolicyAttachmentProps {}\n\n/**\n * AWS IAM Policy Attachment Resource\n *\n * Attaches an IAM policy to a role, enabling the role to use the permissions defined in the policy.\n *\n * @example\n * // Attach an AWS managed policy to a role\n * const adminAccess = await PolicyAttachment(\"admin-policy\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AdministratorAccess\",\n *   roleName: role.name\n * });\n *\n * @example\n * // Attach a custom policy to a role\n * const customPolicy = await PolicyAttachment(\"custom-policy\", {\n *   policyArn: policy.arn,\n *   roleName: role.name\n * });\n *\n * @example\n * // Attach multiple policies to a role\n * const s3Access = await PolicyAttachment(\"s3-access\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AmazonS3FullAccess\",\n *   roleName: role.name\n * });\n *\n * const sqsAccess = await PolicyAttachment(\"sqs-access\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AmazonSQSFullAccess\",\n *   roleName: role.name\n * });\n */\nexport const PolicyAttachment = Resource(\n  \"iam::PolicyAttachment\",\n  async function (\n    this: Context<PolicyAttachment>,\n    id: string,\n    props: PolicyAttachmentProps,\n  ) {\n    const client = new IAMClient({});\n\n    if (this.phase === \"delete\") {\n      await ignore(NoSuchEntityException.name, () =>\n        client.send(\n          new DetachRolePolicyCommand({\n            PolicyArn: props.policyArn,\n            RoleName: props.roleName,\n          }),\n        ),\n      );\n      return this.destroy();\n    } else {\n      await client.send(\n        new AttachRolePolicyCommand({\n          PolicyArn: props.policyArn,\n          RoleName: props.roleName,\n        }),\n      );\n    }\n\n    return this(props);\n  },\n);\n\n```\n\n// alchemy/src/aws/policy.ts\n```ts\nimport {\n  CreatePolicyCommand,\n  CreatePolicyVersionCommand,\n  DeletePolicyCommand,\n  DeletePolicyVersionCommand,\n  GetPolicyCommand,\n  GetPolicyVersionCommand,\n  IAMClient,\n  ListPolicyVersionsCommand,\n  NoSuchEntityException,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Type of effect for a policy statement\n */\nexport type Effect = \"Allow\" | \"Deny\";\n\n/**\n * A single statement within an IAM policy document\n */\nexport interface PolicyStatement {\n  /**\n   * Optional identifier for the statement\n   */\n  Sid?: string;\n\n  /**\n   * Whether to allow or deny the specified actions\n   */\n  Effect: Effect;\n\n  /**\n   * Actions that the policy allows or denies\n   */\n  Action: string | string[];\n\n  /**\n   * Resources that the policy applies to\n   */\n  Resource?: string | string[];\n\n  /**\n   * Additional conditions for when the policy applies\n   */\n  Condition?: Record<string, Record<string, string | string[]>>;\n\n  /**\n   * AWS principals that the policy applies to\n   */\n  Principal?: Record<string, string | string[]>;\n\n  /**\n   * AWS principals that the policy explicitly does not apply to\n   */\n  NotPrincipal?: Record<string, string | string[]>;\n\n  /**\n   * Actions that are explicitly not included in this statement\n   */\n  NotAction?: string | string[];\n\n  /**\n   * Resources that are explicitly not included in this statement\n   */\n  NotResource?: string | string[];\n}\n\n/**\n * An IAM policy document containing one or more statements\n */\nexport interface PolicyDocument {\n  /**\n   * Policy language version (must be \"2012-10-17\")\n   */\n  Version: \"2012-10-17\";\n\n  /**\n   * List of policy statements\n   */\n  Statement: PolicyStatement[];\n}\n\n/**\n * Properties for creating or updating an IAM policy\n */\nexport interface PolicyProps {\n  /**\n   * Name of the policy\n   */\n  policyName: string;\n\n  /**\n   * Policy document defining the permissions\n   */\n  document: PolicyDocument;\n\n  /**\n   * Optional description of the policy's purpose\n   */\n  description?: string;\n\n  /**\n   * Optional path prefix for the policy\n   */\n  path?: string;\n\n  /**\n   * Optional resource tags\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after IAM policy creation/update\n */\nexport interface Policy extends Resource<\"iam::Policy\">, PolicyProps {\n  /**\n   * ARN of the policy\n   */\n  arn: string;\n\n  /**\n   * ID of the default policy version\n   */\n  defaultVersionId: string;\n\n  /**\n   * Number of entities the policy is attached to\n   */\n  attachmentCount: number;\n\n  /**\n   * When the policy was created\n   */\n  createDate: Date;\n\n  /**\n   * When the policy was last updated\n   */\n  updateDate: Date;\n\n  /**\n   * Whether the policy can be attached to IAM users/roles\n   */\n  isAttachable: boolean;\n}\n\n/**\n * AWS IAM Policy Resource\n *\n * Creates and manages IAM policies that define permissions for AWS services and resources.\n * Supports automatic versioning and updates when policy content changes.\n *\n * @example\n * // Create a basic S3 bucket access policy\n * const s3Policy = await Policy(\"bucket-access\", {\n *   policyName: \"s3-bucket-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Action: [\n *         \"s3:GetObject\",\n *         \"s3:PutObject\"\n *       ],\n *       Resource: `${bucket.arn}/*`\n *     }]\n *   }\n * });\n *\n * @example\n * // Create a policy with multiple statements and conditions\n * const apiPolicy = await Policy(\"api-access\", {\n *   policyName: \"api-gateway-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [\n *       {\n *         Sid: \"InvokeAPI\",\n *         Effect: \"Allow\",\n *         Action: \"execute-api:Invoke\",\n *         Resource: `${api.executionArn}/*`,\n *         Condition: {\n *           StringEquals: {\n *             \"aws:SourceVpc\": vpc.id\n *           }\n *         }\n *       },\n *       {\n *         Sid: \"ReadLogs\",\n *         Effect: \"Allow\",\n *         Action: [\n *           \"logs:GetLogEvents\",\n *           \"logs:FilterLogEvents\"\n *         ],\n *         Resource: `${api.logGroupArn}:*`\n *       }\n *     ]\n *   },\n *   description: \"Allows invoking API Gateway endpoints and reading logs\",\n *   tags: {\n *     Service: \"API Gateway\",\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a policy that denies access based on tags\n * const denyPolicy = await Policy(\"deny-production\", {\n *   policyName: \"deny-production-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Deny\",\n *       Action: \"*\",\n *       Resource: \"*\",\n *       Condition: {\n *         StringEquals: {\n *           \"aws:ResourceTag/Environment\": \"production\"\n *         }\n *       }\n *     }]\n *   }\n * });\n */\nexport const Policy = Resource(\n  \"iam::Policy\",\n  async function (\n    this: Context<Policy>,\n    id: string,\n    props: PolicyProps,\n  ): Promise<Policy> {\n    const client = new IAMClient({});\n    const policyArn = `arn:aws:iam::${process.env.AWS_ACCOUNT_ID}:policy${props.path || \"/\"}${props.policyName}`;\n\n    if (this.phase === \"delete\") {\n      try {\n        // List and delete all non-default versions first\n        const versions = await client.send(\n          new ListPolicyVersionsCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        for (const version of versions.Versions || []) {\n          if (!version.IsDefaultVersion) {\n            await client.send(\n              new DeletePolicyVersionCommand({\n                PolicyArn: policyArn,\n                VersionId: version.VersionId,\n              }),\n            );\n          }\n        }\n\n        // Delete the policy\n        await client.send(\n          new DeletePolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n      } catch (error: any) {\n        if (error.name !== NoSuchEntityException.name) {\n          throw error;\n        }\n      }\n      return this.destroy();\n    } else {\n      try {\n        // Check if policy exists\n        const existingPolicy = await client.send(\n          new GetPolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        // Get current policy version\n        const currentVersion = await client.send(\n          new GetPolicyVersionCommand({\n            PolicyArn: policyArn,\n            VersionId: existingPolicy.Policy!.DefaultVersionId!,\n          }),\n        );\n\n        const currentDocument = JSON.parse(\n          decodeURIComponent(currentVersion.PolicyVersion!.Document!),\n        );\n\n        // If policy document changed, create new version\n        if (\n          JSON.stringify(currentDocument) !== JSON.stringify(props.document)\n        ) {\n          // List versions to check if we need to delete old ones\n          const versions = await client.send(\n            new ListPolicyVersionsCommand({\n              PolicyArn: policyArn,\n            }),\n          );\n\n          // Delete oldest version if we have 5 versions (maximum allowed)\n          if (versions.Versions?.length === 5) {\n            const oldestVersion = versions.Versions.sort(\n              (a, b) => a.CreateDate!.getTime() - b.CreateDate!.getTime(),\n            )[0];\n\n            if (!oldestVersion.IsDefaultVersion) {\n              await client.send(\n                new DeletePolicyVersionCommand({\n                  PolicyArn: policyArn,\n                  VersionId: oldestVersion.VersionId!,\n                }),\n              );\n            }\n          }\n\n          // Create new version\n          await client.send(\n            new CreatePolicyVersionCommand({\n              PolicyArn: policyArn,\n              PolicyDocument: JSON.stringify(props.document),\n              SetAsDefault: true,\n            }),\n          );\n        }\n\n        const policy = await client.send(\n          new GetPolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        return this({\n          ...props,\n          arn: policy.Policy!.Arn!,\n          defaultVersionId: policy.Policy!.DefaultVersionId!,\n          attachmentCount: policy.Policy!.AttachmentCount!,\n          createDate: policy.Policy!.CreateDate!,\n          updateDate: policy.Policy!.UpdateDate!,\n          isAttachable: policy.Policy!.IsAttachable!,\n        });\n      } catch (error: any) {\n        if (error.name === \"NoSuchEntity\") {\n          // Create new policy\n          const newPolicy = await client.send(\n            new CreatePolicyCommand({\n              PolicyName: props.policyName,\n              PolicyDocument: JSON.stringify(props.document),\n              Description: props.description,\n              Path: props.path,\n              Tags: props.tags\n                ? Object.entries(props.tags).map(([Key, Value]) => ({\n                    Key,\n                    Value,\n                  }))\n                : undefined,\n            }),\n          );\n\n          return this({\n            ...props,\n            arn: newPolicy.Policy!.Arn!,\n            defaultVersionId: newPolicy.Policy!.DefaultVersionId!,\n            attachmentCount: newPolicy.Policy!.AttachmentCount!,\n            createDate: newPolicy.Policy!.CreateDate!,\n            updateDate: newPolicy.Policy!.UpdateDate!,\n            isAttachable: newPolicy.Policy!.IsAttachable!,\n          });\n        }\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/aws/queue.ts\n```ts\nimport {\n  CreateQueueCommand,\n  DeleteQueueCommand,\n  GetQueueAttributesCommand,\n  GetQueueUrlCommand,\n  SQSClient,\n} from \"@aws-sdk/client-sqs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating an SQS queue\n */\nexport interface QueueProps {\n  /**\n   * Name of the queue\n   * For FIFO queues, the name must end with the .fifo suffix\n   */\n  queueName: string;\n\n  /**\n   * Whether this is a FIFO queue.\n   * If true, the queueName must end with .fifo suffix\n   */\n  fifo?: boolean;\n\n  /**\n   * The length of time (in seconds) that a message received from a queue will be invisible to other receiving components\n   * Default: 30 seconds\n   */\n  visibilityTimeout?: number;\n\n  /**\n   * The length of time (in seconds) for which Amazon SQS retains a message\n   * Default: 345600 seconds (4 days)\n   */\n  messageRetentionPeriod?: number;\n\n  /**\n   * The limit of how many bytes a message can contain before Amazon SQS rejects it\n   * Default: 262144 bytes (256 KB)\n   */\n  maximumMessageSize?: number;\n\n  /**\n   * The time in seconds that the delivery of all messages in the queue will be delayed\n   * Default: 0 seconds\n   */\n  delaySeconds?: number;\n\n  /**\n   * The length of time (in seconds) for which a ReceiveMessage action waits for a message to arrive\n   * Default: 0 seconds\n   */\n  receiveMessageWaitTimeSeconds?: number;\n\n  /**\n   * Enables content-based deduplication for FIFO queues.\n   * Only applicable when fifo is true.\n   */\n  contentBasedDeduplication?: boolean;\n\n  /**\n   * Specifies whether message deduplication occurs at the message group or queue level\n   * Only applicable when fifo is true\n   */\n  deduplicationScope?: \"messageGroup\" | \"queue\";\n\n  /**\n   * Specifies whether the FIFO queue throughput quota applies to the entire queue or per message group\n   * Only applicable when fifo is true\n   */\n  fifoThroughputLimit?: \"perQueue\" | \"perMessageGroupId\";\n\n  /**\n   * Resource tags for the queue\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after SQS queue creation/update\n */\nexport interface Queue extends Resource<\"sqs::Queue\">, QueueProps {\n  /**\n   * ARN of the queue\n   */\n  arn: string;\n\n  /**\n   * URL of the queue\n   */\n  url: string;\n}\n\n/**\n * AWS SQS Queue Resource\n *\n * Creates and manages Amazon SQS queues with support for both standard and FIFO queues.\n * Handles queue creation, attribute configuration, and automatic cleanup of deleted queues.\n *\n * @example\n * // Create a standard queue with custom visibility timeout\n * const standardQueue = await Queue(\"my-queue\", {\n *   queueName: \"my-queue\",\n *   visibilityTimeout: 30,\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a FIFO queue with content-based deduplication\n * const fifoQueue = await Queue(\"orders-queue\", {\n *   queueName: \"orders-queue.fifo\",\n *   fifo: true,\n *   contentBasedDeduplication: true,\n *   visibilityTimeout: 30,\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a queue with custom message retention and size\n * const customQueue = await Queue(\"large-messages\", {\n *   queueName: \"large-messages\",\n *   messageRetentionPeriod: 345600,  // 4 days\n *   maximumMessageSize: 262144,      // 256 KB\n *   visibilityTimeout: 60,\n *   delaySeconds: 5,\n *   receiveMessageWaitTimeSeconds: 20\n * });\n */\nexport const Queue = Resource(\n  \"sqs::Queue\",\n  async function (\n    this: Context<Queue>,\n    id: string,\n    props: QueueProps,\n  ): Promise<Queue> {\n    const client = new SQSClient({});\n    // Don't automatically add .fifo suffix - user must include it in queueName\n    const queueName = props.queueName;\n\n    // Validate that FIFO queues have .fifo suffix\n    if (props.fifo && !queueName.endsWith(\".fifo\")) {\n      throw new Error(\"FIFO queue names must end with .fifo suffix\");\n    }\n\n    if (this.phase === \"delete\") {\n      try {\n        // Get queue URL first\n        const urlResponse = await client.send(\n          new GetQueueUrlCommand({\n            QueueName: queueName,\n          }),\n        );\n\n        // Delete the queue\n        await client.send(\n          new DeleteQueueCommand({\n            QueueUrl: urlResponse.QueueUrl,\n          }),\n        );\n\n        // Wait for queue to be deleted\n        let queueDeleted = false;\n        while (!queueDeleted) {\n          try {\n            await client.send(\n              new GetQueueUrlCommand({\n                QueueName: queueName,\n              }),\n            );\n            // If we get here, queue still exists\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n          } catch (error: any) {\n            if (error.name === \"QueueDoesNotExist\") {\n              queueDeleted = true;\n            } else {\n              throw error;\n            }\n          }\n        }\n      } catch (error: any) {\n        if (error.name !== \"QueueDoesNotExist\") {\n          throw error;\n        }\n      }\n\n      return this.destroy();\n    } else {\n      // Create queue with attributes\n      const attributes: Record<string, string> = {};\n\n      if (props.visibilityTimeout !== undefined) {\n        attributes[\"VisibilityTimeout\"] = props.visibilityTimeout.toString();\n      }\n      if (props.messageRetentionPeriod !== undefined) {\n        attributes[\"MessageRetentionPeriod\"] =\n          props.messageRetentionPeriod.toString();\n      }\n      if (props.maximumMessageSize !== undefined) {\n        attributes[\"MaximumMessageSize\"] = props.maximumMessageSize.toString();\n      }\n      if (props.delaySeconds !== undefined) {\n        attributes[\"DelaySeconds\"] = props.delaySeconds.toString();\n      }\n      if (props.receiveMessageWaitTimeSeconds !== undefined) {\n        attributes[\"ReceiveMessageWaitTimeSeconds\"] =\n          props.receiveMessageWaitTimeSeconds.toString();\n      }\n\n      // FIFO specific attributes\n      if (props.fifo) {\n        attributes[\"FifoQueue\"] = \"true\";\n        if (props.contentBasedDeduplication) {\n          attributes[\"ContentBasedDeduplication\"] = \"true\";\n        }\n        if (props.deduplicationScope) {\n          attributes[\"DeduplicationScope\"] = props.deduplicationScope;\n        }\n        if (props.fifoThroughputLimit) {\n          attributes[\"FifoThroughputLimit\"] = props.fifoThroughputLimit;\n        }\n      }\n\n      // Convert tags to AWS format\n      const tags = props.tags\n        ? Object.entries(props.tags).reduce(\n            (acc, [key, value]) => ({ ...acc, [key]: value }),\n            {},\n          )\n        : undefined;\n\n      try {\n        // Create the queue\n        const createResponse = await client.send(\n          new CreateQueueCommand({\n            QueueName: queueName,\n            Attributes: attributes,\n            tags,\n          }),\n        );\n\n        // Get queue attributes\n        const attributesResponse = await client.send(\n          new GetQueueAttributesCommand({\n            QueueUrl: createResponse.QueueUrl,\n            AttributeNames: [\"QueueArn\"],\n          }),\n        );\n\n        return this({\n          ...props,\n          arn: attributesResponse.Attributes!.QueueArn!,\n          url: createResponse.QueueUrl!,\n        });\n      } catch (error: any) {\n        if (error.name === \"QueueAlreadyExists\") {\n          // Get existing queue URL\n          const urlResponse = await client.send(\n            new GetQueueUrlCommand({\n              QueueName: queueName,\n            }),\n          );\n\n          // Get queue attributes\n          const attributesResponse = await client.send(\n            new GetQueueAttributesCommand({\n              QueueUrl: urlResponse.QueueUrl,\n              AttributeNames: [\"QueueArn\"],\n            }),\n          );\n\n          return this({\n            ...props,\n            arn: attributesResponse.Attributes!.QueueArn!,\n            url: urlResponse.QueueUrl!,\n          });\n        } else if (error.name === \"QueueDeletedRecently\") {\n          // Queue was recently deleted, wait and retry\n          const maxRetries = 3;\n          let retryCount = 0;\n\n          while (retryCount < maxRetries) {\n            try {\n              // Wait for 60 seconds before retrying\n              await new Promise((resolve) => setTimeout(resolve, 61000));\n\n              // Retry creating the queue\n              const createResponse = await client.send(\n                new CreateQueueCommand({\n                  QueueName: queueName,\n                  Attributes: attributes,\n                  tags,\n                }),\n              );\n\n              // Get queue attributes\n              const attributesResponse = await client.send(\n                new GetQueueAttributesCommand({\n                  QueueUrl: createResponse.QueueUrl,\n                  AttributeNames: [\"QueueArn\"],\n                }),\n              );\n\n              return this({\n                ...props,\n                arn: attributesResponse.Attributes!.QueueArn!,\n                url: createResponse.QueueUrl!,\n              });\n            } catch (retryError: any) {\n              if (\n                retryError.name !== \"QueueDeletedRecently\" ||\n                retryCount === maxRetries - 1\n              ) {\n                throw retryError;\n              }\n              retryCount++;\n            }\n          }\n        }\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/aws/role.ts\n```ts\nimport {\n  AttachRolePolicyCommand,\n  CreateRoleCommand,\n  DeleteRoleCommand,\n  DeleteRolePolicyCommand,\n  DetachRolePolicyCommand,\n  EntityAlreadyExistsException,\n  GetRoleCommand,\n  IAMClient,\n  ListAttachedRolePoliciesCommand,\n  NoSuchEntityException,\n  PutRolePolicyCommand,\n  type Tag,\n  TagRoleCommand,\n  UpdateAssumeRolePolicyCommand,\n  UpdateRoleCommand,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\nimport type { PolicyDocument } from \"./policy\";\n\n/**\n * Properties for creating or updating an IAM role\n */\nexport interface RoleProps {\n  /**\n   * Name of the IAM role\n   */\n  roleName: string;\n\n  /**\n   * Policy that defines which entities can assume this role\n   */\n  assumeRolePolicy: PolicyDocument;\n\n  /**\n   * Optional description of the role's purpose\n   */\n  description?: string;\n\n  /**\n   * Optional path prefix for the role\n   */\n  path?: string;\n\n  /**\n   * Maximum session duration in seconds when assumed\n   * Default: 3600 seconds (1 hour)\n   */\n  maxSessionDuration?: number;\n\n  /**\n   * ARN of the policy used to set the permissions boundary\n   */\n  permissionsBoundary?: string;\n\n  /**\n   * Inline policies to embed in the role\n   * Each policy must have a unique name and policy document\n   */\n  policies?: Array<{\n    policyName: string;\n    policyDocument: PolicyDocument;\n  }>;\n\n  /**\n   * List of managed policy ARNs to attach to the role\n   */\n  managedPolicyArns?: string[];\n\n  /**\n   * Resource tags for the role\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after IAM role creation/update\n */\nexport interface Role extends Resource<\"iam::Role\">, RoleProps {\n  /**\n   * ARN of the role\n   */\n  arn: string;\n\n  /**\n   * Unique identifier for the role\n   */\n  uniqueId: string;\n\n  /**\n   * The stable and unique string identifying the role\n   */\n  roleId: string;\n\n  /**\n   * When the role was created\n   */\n  createDate: Date;\n}\n\n/**\n * AWS IAM Role Resource\n *\n * Creates and manages IAM roles with support for inline policies, managed policies,\n * and automatic cleanup of attached policies during deletion.\n *\n * @example\n * // Create a basic Lambda execution role with inline policy\n * const basicRole = await Role(\"lambda-role\", {\n *   roleName: \"lambda-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Basic Lambda execution role\",\n *   tags: {\n *     Environment: \"production\"\n *   },\n *   policies: [{\n *     policyName: \"logs\",\n *     policyDocument: {\n *       Version: \"2012-10-17\",\n *       Statement: [{\n *         Effect: \"Allow\",\n *         Action: [\n *           \"logs:CreateLogGroup\",\n *           \"logs:CreateLogStream\",\n *           \"logs:PutLogEvents\"\n *         ],\n *         Resource: \"*\"\n *       }]\n *     }\n *   }]\n * });\n *\n * @example\n * // Create a role with AWS managed policies\n * const managedRole = await Role(\"readonly-role\", {\n *   roleName: \"readonly-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Role with managed policies\",\n *   managedPolicyArns: [\n *     \"arn:aws:iam::aws:policy/ReadOnlyAccess\"\n *   ],\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a role with multiple inline policies and custom session duration\n * const customRole = await Role(\"custom-role\", {\n *   roleName: \"custom-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Role with multiple policies\",\n *   maxSessionDuration: 7200,\n *   policies: [\n *     {\n *       policyName: \"logs\",\n *       policyDocument: {\n *         Version: \"2012-10-17\",\n *         Statement: [{\n *           Effect: \"Allow\",\n *           Action: [\n *             \"logs:CreateLogGroup\",\n *             \"logs:CreateLogStream\",\n *             \"logs:PutLogEvents\"\n *           ],\n *           Resource: \"*\"\n *         }]\n *       }\n *     },\n *     {\n *       policyName: \"s3\",\n *       policyDocument: {\n *         Version: \"2012-10-17\",\n *         Statement: [{\n *           Effect: \"Allow\",\n *           Action: \"s3:ListBucket\",\n *           Resource: \"*\"\n *         }]\n *       }\n *     }\n *   ],\n *   tags: {\n *     Environment: \"production\",\n *     Updated: \"true\"\n *   }\n * });\n */\nexport const Role = Resource(\n  \"iam::Role\",\n  async function (\n    this: Context<Role>,\n    id: string,\n    props: RoleProps\n  ): Promise<Role> {\n    const client = new IAMClient({});\n\n    if (this.phase === \"delete\") {\n      try {\n        // Delete any inline policies first\n        if (props.policies) {\n          for (const policy of props.policies) {\n            await ignore(NoSuchEntityException.name, () =>\n              client.send(\n                new DeleteRolePolicyCommand({\n                  RoleName: props.roleName,\n                  PolicyName: policy.policyName,\n                })\n              )\n            );\n          }\n        }\n\n        // We need to detach managed policies before deleting the role\n        // First, get all attached policies\n        try {\n          const attachedPoliciesResponse = await client.send(\n            new ListAttachedRolePoliciesCommand({\n              RoleName: props.roleName,\n            })\n          );\n\n          // Detach all managed policies\n          const attachedPolicies =\n            attachedPoliciesResponse.AttachedPolicies || [];\n          for (const policy of attachedPolicies) {\n            await ignore(NoSuchEntityException.name, () =>\n              client.send(\n                new DetachRolePolicyCommand({\n                  RoleName: props.roleName,\n                  PolicyArn: policy.PolicyArn!,\n                })\n              )\n            );\n          }\n        } catch (error: any) {\n          if (error.name !== NoSuchEntityException.name) {\n            throw error;\n          }\n          // Role doesn't exist, no need to continue with detaching policies\n        }\n\n        // Try to delete the role, ignoring if it doesn't exist\n        await ignore(NoSuchEntityException.name, () =>\n          client.send(\n            new DeleteRoleCommand({\n              RoleName: props.roleName,\n            })\n          )\n        );\n      } catch (error: any) {\n        // If we get any other error besides NoSuchEntityException, log it but don't fail\n        // This ensures the resource is still marked as destroyed\n        if (error.name !== NoSuchEntityException.name) {\n          console.error(`Error deleting role ${props.roleName}:`, error);\n        }\n      }\n\n      // Always return destroyed state regardless of any errors\n      return this.destroy();\n    }\n\n    const assumeRolePolicyDocument = JSON.stringify(props.assumeRolePolicy);\n    let role;\n\n    try {\n      if (this.phase === \"create\") {\n        // Try to create the role\n        await client.send(\n          new CreateRoleCommand({\n            RoleName: props.roleName,\n            AssumeRolePolicyDocument: assumeRolePolicyDocument,\n            Description: props.description,\n            Path: props.path,\n            MaxSessionDuration: props.maxSessionDuration,\n            PermissionsBoundary: props.permissionsBoundary,\n            Tags: [\n              ...Object.entries(props.tags || {}).map(([Key, Value]) => ({\n                Key,\n                Value,\n              })),\n              {\n                Key: \"alchemy_stage\",\n                Value: this.stage,\n              },\n              {\n                Key: \"alchemy_resource\",\n                Value: this.id,\n              },\n            ],\n          })\n        );\n      }\n    } catch (error: any) {\n      if (\n        error instanceof EntityAlreadyExistsException &&\n        this.phase === \"create\"\n      ) {\n        // Check if we were the ones who created it\n        const existingRole = await client.send(\n          new GetRoleCommand({\n            RoleName: props.roleName,\n          })\n        );\n        const roleTags =\n          existingRole.Role?.Tags?.reduce(\n            (acc, tag) => {\n              acc[tag.Key!] = tag.Value!;\n              return acc;\n            },\n            {} as Record<string, string>\n          ) || {};\n\n        if (\n          roleTags.alchemy_stage !== this.stage ||\n          roleTags.alchemy_resource !== this.id\n        ) {\n          throw error;\n        }\n      } else if (error.name !== NoSuchEntityException.name) {\n        throw error;\n      }\n    }\n\n    // Get or update the role\n    role = await client.send(\n      new GetRoleCommand({\n        RoleName: props.roleName,\n      })\n    );\n\n    // Update assume role policy if it changed\n    if (role.Role?.AssumeRolePolicyDocument !== assumeRolePolicyDocument) {\n      await client.send(\n        new UpdateAssumeRolePolicyCommand({\n          RoleName: props.roleName,\n          PolicyDocument: assumeRolePolicyDocument,\n        })\n      );\n    }\n\n    // Update role description and max session duration if they changed\n    if (\n      role.Role?.Description !== props.description ||\n      role.Role?.MaxSessionDuration !== props.maxSessionDuration\n    ) {\n      await client.send(\n        new UpdateRoleCommand({\n          RoleName: props.roleName,\n          Description: props.description,\n          MaxSessionDuration: props.maxSessionDuration,\n        })\n      );\n    }\n\n    // Update tags\n    const newTags = {\n      ...props.tags,\n      alchemy_stage: this.stage,\n      alchemy_resource: this.id,\n    };\n    const tags: Tag[] = Object.entries(newTags).map(([Key, Value]) => ({\n      Key,\n      Value,\n    }));\n    await client.send(\n      new TagRoleCommand({\n        RoleName: props.roleName,\n        Tags: tags,\n      })\n    );\n\n    // Handle policy changes\n    const previousPolicies =\n      this.phase === \"update\" ? this.output!.policies || [] : [];\n    const currentPolicies = props.policies || [];\n\n    // Delete policies that were removed\n    for (const oldPolicy of previousPolicies) {\n      if (\n        !currentPolicies.some(\n          (p: { policyName: string }) => p.policyName === oldPolicy.policyName\n        )\n      ) {\n        await ignore(NoSuchEntityException.name, () =>\n          client.send(\n            new DeleteRolePolicyCommand({\n              RoleName: props.roleName,\n              PolicyName: oldPolicy.policyName,\n            })\n          )\n        );\n      }\n    }\n\n    // Update or create policies\n    for (const policy of currentPolicies) {\n      const oldPolicy = previousPolicies.find(\n        (p) => p.policyName === policy.policyName\n      );\n      if (\n        !oldPolicy ||\n        JSON.stringify(oldPolicy.policyDocument) !==\n          JSON.stringify(policy.policyDocument)\n      ) {\n        await client.send(\n          new PutRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyName: policy.policyName,\n            PolicyDocument: JSON.stringify(policy.policyDocument),\n          })\n        );\n      }\n    }\n\n    // Handle managed policy attachments\n    // Get currently attached policies\n    const attachedPoliciesResponse = await client.send(\n      new ListAttachedRolePoliciesCommand({\n        RoleName: props.roleName,\n      })\n    );\n\n    const currentAttachedPolicies =\n      attachedPoliciesResponse.AttachedPolicies || [];\n    const currentPolicyArns = currentAttachedPolicies.map((p) => p.PolicyArn!);\n\n    // If we're updating, use an empty array as default when managedPolicyArns is undefined\n    // to ensure we detach all managed policies\n    const desiredPolicyArns = props.managedPolicyArns || [];\n\n    // Detach policies that are no longer needed\n    for (const policyArn of currentPolicyArns) {\n      if (!desiredPolicyArns.includes(policyArn)) {\n        await client.send(\n          new DetachRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyArn: policyArn,\n          })\n        );\n      }\n    }\n\n    // Attach new policies that weren't attached before\n    for (const policyArn of desiredPolicyArns) {\n      if (!currentPolicyArns.includes(policyArn)) {\n        await client.send(\n          new AttachRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyArn: policyArn,\n          })\n        );\n      }\n    }\n\n    if (!role?.Role) {\n      throw new Error(`Failed to create or update role ${props.roleName}`);\n    }\n\n    return this({\n      ...props,\n      arn: role.Role.Arn!,\n      uniqueId: role.Role.RoleId!,\n      roleId: role.Role.RoleId!,\n      roleName: role.Role.RoleName ?? props.roleName,\n      createDate: role.Role.CreateDate!,\n    });\n  }\n);\n\n```\n\n// alchemy/src/aws/ses.ts\n```ts\nimport {\n  CreateConfigurationSetCommand,\n  CreateEmailIdentityCommand,\n  DeleteConfigurationSetCommand,\n  DeleteEmailIdentityCommand,\n  type DeliveryOptions,\n  GetConfigurationSetCommand,\n  GetEmailIdentityCommand,\n  NotFoundException,\n  PutConfigurationSetDeliveryOptionsCommand,\n  PutConfigurationSetReputationOptionsCommand,\n  PutConfigurationSetSendingOptionsCommand,\n  PutConfigurationSetSuppressionOptionsCommand,\n  PutConfigurationSetTrackingOptionsCommand,\n  PutEmailIdentityDkimAttributesCommand,\n  type ReputationOptions,\n  SESv2Client,\n  type SendingOptions,\n  type SuppressionOptions,\n  type TrackingOptions,\n} from \"@aws-sdk/client-sesv2\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for configuring AWS SES resources\n */\nexport interface SESProps {\n  /**\n   * Name of the configuration set\n   * Used to group email sending and tracking settings\n   */\n  configurationSetName?: string;\n\n  /**\n   * Email identity to verify (email address or domain)\n   * For domains, use the format \"example.com\"\n   * For email addresses, use the format \"user@example.com\"\n   */\n  emailIdentity?: string;\n\n  /**\n   * Whether to enable DKIM signing for the email identity\n   * DKIM helps prevent email spoofing by verifying sender authenticity\n   */\n  enableDkim?: boolean;\n\n  /**\n   * Sending options for the configuration set\n   * Controls whether email sending is enabled and related settings\n   */\n  sendingOptions?: SendingOptions;\n\n  /**\n   * Reputation options for the configuration set\n   * Controls reputation tracking and metrics collection\n   */\n  reputationOptions?: ReputationOptions;\n\n  /**\n   * Tracking options for the configuration set\n   * Controls open and click tracking with optional custom domains\n   */\n  trackingOptions?: TrackingOptions;\n\n  /**\n   * Suppression options for the configuration set\n   * Controls how bounces and complaints are handled\n   */\n  suppressionOptions?: SuppressionOptions;\n\n  /**\n   * Delivery options for the configuration set\n   * Controls TLS settings and sending pool configuration\n   */\n  deliveryOptions?: DeliveryOptions;\n\n  /**\n   * Tags to apply to the SES resources\n   * Key-value pairs for resource organization\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after SES resource creation/update\n */\nexport interface SES extends Resource<\"aws::SES\">, SESProps {\n  /**\n   * ARN of the configuration set if created\n   * Format: arn:aws:ses:region:account-id:configuration-set/name\n   */\n  configurationSetArn?: string;\n\n  /**\n   * Email identity verification status if an identity was created\n   * Can be \"PENDING\" or \"VERIFIED\"\n   */\n  emailIdentityVerificationStatus?: string;\n\n  /**\n   * DKIM verification status if DKIM was enabled\n   * Can be \"PENDING\", \"SUCCESS\", \"FAILED\", \"TEMPORARY_FAILURE\", or \"NOT_STARTED\"\n   */\n  dkimVerificationStatus?: string;\n\n  /**\n   * Email identity ARN if an identity was created\n   * Format: arn:aws:ses:region:account-id:identity/name\n   */\n  emailIdentityArn?: string;\n}\n\n/**\n * AWS SES Resource\n *\n * Creates and manages Amazon Simple Email Service (SES) configuration sets and email identities.\n * Supports email sending configuration, DKIM signing, and identity verification.\n *\n * @example\n * // Create a configuration set with sending options\n * const configSet = await SES(\"email-config\", {\n *   configurationSetName: \"my-email-config\",\n *   sendingOptions: {\n *     SendingEnabled: true\n *   },\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"notifications\"\n *   }\n * });\n *\n * @example\n * // Create and verify a domain identity with DKIM\n * const domainIdentity = await SES(\"domain-identity\", {\n *   emailIdentity: \"example.com\",\n *   enableDkim: true,\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"transactional-emails\"\n *   }\n * });\n *\n * @example\n * // Update configuration set sending options\n * const updatedConfig = await SES(\"email-config\", {\n *   configurationSetName: \"my-email-config\",\n *   sendingOptions: {\n *     SendingEnabled: false\n *   },\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"notifications\",\n *     Updated: \"true\"\n *   }\n * });\n */\nexport const SES = Resource(\n  \"aws::SES\",\n  async function (\n    this: Context<SES>,\n    id: string,\n    props: SESProps,\n  ): Promise<SES> {\n    // Create SES client\n    const client = new SESv2Client({});\n\n    // Resource ID is either based on the configuration set name or email identity\n    // const id =\n    //   props.configurationSetName || props.emailIdentity || this.resourceID;\n\n    // Handle deletion\n    if (this.phase === \"delete\") {\n      const output = this.output;\n\n      // Delete configuration set if it exists\n      if (output?.configurationSetName) {\n        await ignore(NotFoundException.name, () =>\n          client.send(\n            new DeleteConfigurationSetCommand({\n              ConfigurationSetName: output.configurationSetName,\n            }),\n          ),\n        );\n      }\n\n      // Delete email identity if it exists\n      if (output?.emailIdentity) {\n        await ignore(NotFoundException.name, () =>\n          client.send(\n            new DeleteEmailIdentityCommand({\n              EmailIdentity: output.emailIdentity,\n            }),\n          ),\n        );\n      }\n\n      // Return empty output for delete\n      return this.destroy();\n    }\n\n    // Created resources\n    let configurationSetArn: string | undefined;\n    let emailIdentityArn: string | undefined;\n    let emailIdentityVerificationStatus: string | undefined;\n    let dkimVerificationStatus: string | undefined;\n\n    // Create or update configuration set if specified\n    if (props.configurationSetName) {\n      // Check if configuration set exists\n      let configSetExists = false;\n      try {\n        await client.send(\n          new GetConfigurationSetCommand({\n            ConfigurationSetName: props.configurationSetName,\n          }),\n        );\n        configSetExists = true;\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          configSetExists = false;\n        } else {\n          throw error;\n        }\n      }\n\n      if (configSetExists) {\n        // Update existing configuration set using appropriate update commands\n        if (props.sendingOptions) {\n          await client.send(\n            new PutConfigurationSetSendingOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              SendingEnabled: props.sendingOptions.SendingEnabled,\n            }),\n          );\n        }\n\n        if (props.reputationOptions) {\n          await client.send(\n            new PutConfigurationSetReputationOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              ReputationMetricsEnabled:\n                props.reputationOptions.ReputationMetricsEnabled,\n            }),\n          );\n        }\n\n        if (props.trackingOptions) {\n          await client.send(\n            new PutConfigurationSetTrackingOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              CustomRedirectDomain: props.trackingOptions.CustomRedirectDomain,\n            }),\n          );\n        }\n\n        if (props.suppressionOptions) {\n          await client.send(\n            new PutConfigurationSetSuppressionOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              SuppressedReasons: props.suppressionOptions.SuppressedReasons,\n            }),\n          );\n        }\n\n        if (props.deliveryOptions) {\n          await client.send(\n            new PutConfigurationSetDeliveryOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              TlsPolicy: props.deliveryOptions.TlsPolicy,\n              SendingPoolName: props.deliveryOptions.SendingPoolName,\n            }),\n          );\n        }\n\n        // In SESv2, the ARN isn't directly returned in the response\n        configurationSetArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:configuration-set/${props.configurationSetName}`;\n      } else {\n        // Create new configuration set\n        await client.send(\n          new CreateConfigurationSetCommand({\n            ConfigurationSetName: props.configurationSetName,\n            SendingOptions: props.sendingOptions,\n            ReputationOptions: props.reputationOptions,\n            TrackingOptions: props.trackingOptions,\n            SuppressionOptions: props.suppressionOptions,\n            DeliveryOptions: props.deliveryOptions,\n            Tags: Object.entries(props.tags || {}).map(([Key, Value]) => ({\n              Key,\n              Value,\n            })),\n          }),\n        );\n\n        // In SESv2, the ARN isn't directly returned in the response\n        configurationSetArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:configuration-set/${props.configurationSetName}`;\n      }\n    }\n\n    // Create or verify email identity if specified\n    if (props.emailIdentity) {\n      // Check if identity exists\n      let getIdentityResult;\n      try {\n        getIdentityResult = await client.send(\n          new GetEmailIdentityCommand({\n            EmailIdentity: props.emailIdentity,\n          }),\n        );\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          getIdentityResult = null;\n        } else {\n          throw error;\n        }\n      }\n\n      if (!getIdentityResult) {\n        // Create new email identity\n        const createIdentityResult = await client.send(\n          new CreateEmailIdentityCommand({\n            EmailIdentity: props.emailIdentity,\n            Tags: Object.entries(props.tags || {}).map(([Key, Value]) => ({\n              Key,\n              Value,\n            })),\n          }),\n        );\n\n        // If it's an email address, we don't need to explicitly verify in v2\n        // The verification email is automatically sent by SES in v2\n\n        // Store the identity information\n        emailIdentityArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:identity/${props.emailIdentity}`;\n        emailIdentityVerificationStatus =\n          createIdentityResult.VerifiedForSendingStatus\n            ? \"VERIFIED\"\n            : \"PENDING\";\n      } else {\n        // Store the identity information\n        emailIdentityArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:identity/${props.emailIdentity}`;\n        emailIdentityVerificationStatus =\n          getIdentityResult.VerifiedForSendingStatus ? \"VERIFIED\" : \"PENDING\";\n\n        // Update DKIM settings if requested\n        if (props.enableDkim !== undefined) {\n          if (props.enableDkim) {\n            await client.send(\n              new PutEmailIdentityDkimAttributesCommand({\n                EmailIdentity: props.emailIdentity,\n                SigningEnabled: true,\n              }),\n            );\n\n            // We can check the current status of DKIM\n            dkimVerificationStatus = \"PENDING\"; // Default to pending\n\n            // Get the updated identity to check DKIM status\n            const updatedIdentity = await client.send(\n              new GetEmailIdentityCommand({\n                EmailIdentity: props.emailIdentity,\n              }),\n            );\n\n            if (updatedIdentity.DkimAttributes?.Status) {\n              dkimVerificationStatus = updatedIdentity.DkimAttributes.Status;\n            }\n          }\n        }\n      }\n    }\n\n    // Return the resource output\n    return this({\n      ...props,\n      configurationSetArn,\n      emailIdentityArn,\n      emailIdentityVerificationStatus,\n      dkimVerificationStatus,\n    });\n  },\n);\n\n```\n\n// alchemy/src/aws/table.ts\n```ts\nimport {\n  CreateTableCommand,\n  DeleteTableCommand,\n  DescribeTableCommand,\n  DynamoDBClient,\n  InternalServerError,\n  type KeySchemaElement,\n  ResourceInUseException,\n  ResourceNotFoundException,\n} from \"@aws-sdk/client-dynamodb\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\nimport { withExponentialBackoff } from \"../util/retry\";\n\n/**\n * Properties for creating or updating a DynamoDB table\n */\nexport interface TableProps {\n  /**\n   * Name of the DynamoDB table\n   */\n  tableName: string;\n\n  /**\n   * Primary partition key (hash key) configuration\n   * Defines the main identifier for items in the table\n   */\n  partitionKey: {\n    /**\n     * Name of the partition key attribute\n     */\n    name: string;\n    /**\n     * Data type of the partition key\n     * S: String, N: Number, B: Binary\n     */\n    type: \"S\" | \"N\" | \"B\";\n  };\n\n  /**\n   * Optional sort key (range key) configuration\n   * Used to sort items with the same partition key\n   */\n  sortKey?: {\n    /**\n     * Name of the sort key attribute\n     */\n    name: string;\n    /**\n     * Data type of the sort key\n     * S: String, N: Number, B: Binary\n     */\n    type: \"S\" | \"N\" | \"B\";\n  };\n\n  /**\n   * Billing mode for the table\n   * PROVISIONED: Set read/write capacity units\n   * PAY_PER_REQUEST: Pay per request pricing\n   */\n  billingMode?: \"PROVISIONED\" | \"PAY_PER_REQUEST\";\n\n  /**\n   * Read capacity units when using PROVISIONED billing mode\n   * Default: 5\n   */\n  readCapacity?: number;\n\n  /**\n   * Write capacity units when using PROVISIONED billing mode\n   * Default: 5\n   */\n  writeCapacity?: number;\n\n  /**\n   * Tags to apply to the table\n   * Key-value pairs for resource organization\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after DynamoDB table creation/update\n */\nexport interface Table extends Resource<\"dynamo::Table\">, TableProps {\n  /**\n   * ARN of the table\n   * Format: arn:aws:dynamodb:region:account-id:table/table-name\n   */\n  arn: string;\n\n  /**\n   * ARN of the table's stream if enabled\n   * Format: arn:aws:dynamodb:region:account-id:table/table-name/stream/timestamp\n   */\n  streamArn?: string;\n\n  /**\n   * Unique identifier for the table\n   */\n  tableId: string;\n}\n\n/**\n * AWS DynamoDB Table Resource\n *\n * Creates and manages DynamoDB tables with support for partition and sort keys,\n * flexible billing modes, and automatic table status monitoring.\n *\n * @example\n * // Create a table with partition and sort key\n * const table = await Table(\"user-events\", {\n *   tableName: \"user-events\",\n *   partitionKey: {\n *     name: \"id\",\n *     type: \"S\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"N\"\n *   },\n *   tags: {\n *     Environment: \"test\"\n *   }\n * });\n *\n * @example\n * // Create a table with provisioned capacity\n * const table = await Table(\"high-throughput\", {\n *   tableName: \"high-throughput\",\n *   partitionKey: {\n *     name: \"userId\",\n *     type: \"S\"\n *   },\n *   billingMode: \"PROVISIONED\",\n *   readCapacity: 100,\n *   writeCapacity: 50\n * });\n */\nexport const Table = Resource(\n  \"dynamo::Table\",\n  async function (\n    this: Context<Table>,\n    id: string,\n    props: TableProps,\n  ): Promise<Table> {\n    const client = new DynamoDBClient({});\n\n    if (this.phase === \"delete\") {\n      await withExponentialBackoff(\n        async () => {\n          await ignore(ResourceNotFoundException.name, () =>\n            client.send(\n              new DeleteTableCommand({\n                TableName: props.tableName,\n              }),\n            ),\n          );\n        },\n        (error) =>\n          error instanceof ResourceInUseException ||\n          error instanceof InternalServerError,\n        10, // Max attempts\n        200, // Initial delay in ms\n      );\n\n      // Wait for table to be deleted\n      let tableDeleted = false;\n      let retryCount = 0;\n      const maxRetries = 60; // Wait up to 60 seconds\n\n      while (!tableDeleted && retryCount < maxRetries) {\n        try {\n          await client.send(\n            new DescribeTableCommand({\n              TableName: props.tableName,\n            }),\n          );\n          // If we get here, table still exists\n          retryCount++;\n          // Increasing delay for each retry with some jitter\n          const delay = Math.min(1000 * (1 + 0.1 * Math.random()), 5000);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        } catch (error) {\n          if (error instanceof ResourceNotFoundException) {\n            tableDeleted = true;\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      if (!tableDeleted) {\n        throw new Error(\n          `Timed out waiting for table ${props.tableName} to be deleted`,\n        );\n      }\n\n      return this.destroy();\n    } else {\n      // Setup for table creation\n      const attributeDefinitions = [\n        {\n          AttributeName: props.partitionKey.name,\n          AttributeType: props.partitionKey.type,\n        },\n      ];\n\n      const keySchema: KeySchemaElement[] = [\n        {\n          AttributeName: props.partitionKey.name,\n          KeyType: \"HASH\",\n        },\n      ];\n\n      if (props.sortKey) {\n        attributeDefinitions.push({\n          AttributeName: props.sortKey.name,\n          AttributeType: props.sortKey.type,\n        });\n        keySchema.push({\n          AttributeName: props.sortKey.name,\n          KeyType: \"RANGE\",\n        });\n      }\n\n      // Attempt to create the table with exponential backoff for ResourceInUseException\n      await withExponentialBackoff(\n        async () => {\n          try {\n            // First check if table already exists\n            const describeResponse = await client.send(\n              new DescribeTableCommand({\n                TableName: props.tableName,\n              }),\n            );\n\n            // If table exists and is ACTIVE, no need to create it\n            if (describeResponse.Table?.TableStatus === \"ACTIVE\") {\n              return;\n            }\n\n            // If table exists but not ACTIVE, wait for it in the polling loop below\n            if (describeResponse.Table) {\n              return;\n            }\n          } catch (error) {\n            if (error instanceof ResourceNotFoundException) {\n              // Table doesn't exist, try to create it\n              await client.send(\n                new CreateTableCommand({\n                  TableName: props.tableName,\n                  AttributeDefinitions: attributeDefinitions,\n                  KeySchema: keySchema,\n                  BillingMode: props.billingMode || \"PAY_PER_REQUEST\",\n                  ProvisionedThroughput:\n                    props.billingMode === \"PROVISIONED\"\n                      ? {\n                          ReadCapacityUnits: props.readCapacity || 5,\n                          WriteCapacityUnits: props.writeCapacity || 5,\n                        }\n                      : undefined,\n                  Tags: props.tags\n                    ? Object.entries(props.tags).map(([Key, Value]) => ({\n                        Key,\n                        Value,\n                      }))\n                    : undefined,\n                }),\n              );\n            } else {\n              throw error;\n            }\n          }\n        },\n        (error) => error instanceof ResourceInUseException,\n        10, // Max attempts\n        200, // Initial delay in ms\n      );\n\n      // Wait for table to be active with timeout\n      let tableActive = false;\n      let tableDescription;\n      let retryCount = 0;\n      const maxRetries = 60; // Wait up to 60 seconds\n\n      while (!tableActive && retryCount < maxRetries) {\n        try {\n          const response = await client.send(\n            new DescribeTableCommand({\n              TableName: props.tableName,\n            }),\n          );\n\n          tableActive = response.Table?.TableStatus === \"ACTIVE\";\n          if (tableActive) {\n            tableDescription = response.Table;\n          } else {\n            retryCount++;\n            // Increasing delay for each retry with some jitter\n            const delay = Math.min(1000 * (1 + 0.1 * Math.random()), 5000);\n            await new Promise((resolve) => setTimeout(resolve, delay));\n          }\n        } catch (error) {\n          retryCount++;\n          if (!(error instanceof ResourceNotFoundException)) {\n            throw error;\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1000));\n        }\n      }\n\n      if (!tableActive) {\n        throw new Error(\n          `Timed out waiting for table ${props.tableName} to become active`,\n        );\n      }\n\n      return this({\n        ...props,\n        arn: tableDescription!.TableArn!,\n        streamArn: tableDescription!.LatestStreamArn,\n        tableId: tableDescription!.TableId!,\n      });\n    }\n  },\n);\n\n```"
      },
      {
        "role": "assistant",
        "content": "# PolicyAttachment\n\nThe PolicyAttachment resource lets you attach [AWS IAM policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html) to IAM roles.\n\n## Minimal Example\n\nAttach an AWS managed policy to a role:\n\n```ts\nimport { PolicyAttachment } from \"alchemy/aws\";\n\nconst adminAccess = await PolicyAttachment(\"admin-policy\", {\n  policyArn: \"arn:aws:iam::aws:policy/AdministratorAccess\", \n  roleName: role.name\n});\n```\n\n## Attach Custom Policy\n\nAttach a custom policy to a role:\n\n```ts\nimport { PolicyAttachment } from \"alchemy/aws\";\n\nconst customPolicy = await PolicyAttachment(\"custom-policy\", {\n  policyArn: policy.arn,\n  roleName: role.name\n});\n```\n\n## Multiple Policy Attachments \n\nAttach multiple policies to a single role:\n\n```ts\nimport { PolicyAttachment } from \"alchemy/aws\";\n\nconst s3Access = await PolicyAttachment(\"s3-access\", {\n  policyArn: \"arn:aws:iam::aws:policy/AmazonS3FullAccess\",\n  roleName: role.name\n});\n\nconst sqsAccess = await PolicyAttachment(\"sqs-access\", {\n  policyArn: \"arn:aws:iam::aws:policy/AmazonSQSFullAccess\", \n  roleName: role.name\n});\n```"
      }
    ],
    "createdAt": 1744513310365,
    "updatedAt": 1744513310365,
    "file": {
      "path": "alchemy-web/docs/providers/aws/policy-attachment.md",
      "content": "# PolicyAttachment\n\nThe PolicyAttachment resource lets you attach [AWS IAM policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html) to IAM roles.\n\n## Minimal Example\n\nAttach an AWS managed policy to a role:\n\n```ts\nimport { PolicyAttachment } from \"alchemy/aws\";\n\nconst adminAccess = await PolicyAttachment(\"admin-policy\", {\n  policyArn: \"arn:aws:iam::aws:policy/AdministratorAccess\", \n  roleName: role.name\n});\n```\n\n## Attach Custom Policy\n\nAttach a custom policy to a role:\n\n```ts\nimport { PolicyAttachment } from \"alchemy/aws\";\n\nconst customPolicy = await PolicyAttachment(\"custom-policy\", {\n  policyArn: policy.arn,\n  roleName: role.name\n});\n```\n\n## Multiple Policy Attachments \n\nAttach multiple policies to a single role:\n\n```ts\nimport { PolicyAttachment } from \"alchemy/aws\";\n\nconst s3Access = await PolicyAttachment(\"s3-access\", {\n  policyArn: \"arn:aws:iam::aws:policy/AmazonS3FullAccess\",\n  roleName: role.name\n});\n\nconst sqsAccess = await PolicyAttachment(\"sqs-access\", {\n  policyArn: \"arn:aws:iam::aws:policy/AmazonSQSFullAccess\", \n  roleName: role.name\n});\n```",
      "Kind": "fs::File",
      "ID": "docs/aws/PolicyAttachment-file",
      "FQN": "github:alchemy/prod/docs/docs/aws/PolicyAttachment/docs/aws/PolicyAttachment-file",
      "Seq": 0
    },
    "Kind": "docs::Document",
    "ID": "docs/aws/PolicyAttachment",
    "FQN": "github:alchemy/prod/docs/docs/aws/PolicyAttachment",
    "Seq": 45
  },
  "props": {
    "title": "PolicyAttachment",
    "path": "alchemy-web/docs/providers/aws/policy-attachment.md",
    "freeze": true,
    "model": {
      "id": "claude-3-5-sonnet-latest",
      "provider": "anthropic"
    },
    "prompt": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         aws Service:\n[function.ts](alchemy/src/aws/function.ts)\n\n[table.ts](alchemy/src/aws/table.ts)\n\n[account-id.ts](alchemy/src/aws/account-id.ts)\n\n[policy-attachment.ts](alchemy/src/aws/policy-attachment.ts)\n\n[role.ts](alchemy/src/aws/role.ts)\n\n[policy.ts](alchemy/src/aws/policy.ts)\n\n[credentials.ts](alchemy/src/aws/credentials.ts)\n\n[ses.ts](alchemy/src/aws/ses.ts)\n\n[bucket.ts](alchemy/src/aws/bucket.ts)\n\n[queue.ts](alchemy/src/aws/queue.ts)\n\nWrite concise documentation for the \"        PolicyAttachment\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         PolicyAttachment\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         PolicyAttachment } from \"alchemy/        aws\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         PolicyAttachment } from \"alchemy/        aws\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        \n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Create Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroy the Resource\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\n> [!CAUTION]\n> Now, before we run our script again, you need to first add a \"naked\" impot of `alchemy/fs` at the top of our `alchemy.run.ts` script.\n> ```typescript\n> import \"alchemy/fs\"\n> ```\n> If you forget this, you would get an error\n> `Cannot destroy resource \"my-first-app/dev/hello\" type fs::File - no provider found. You may need to import the provider in your alchemy.config.ts.`\n> \n> This is because IDEs usually remove unused imports. If you don't import the resource, the delete handler won't be registered which Alchemy needs to delete the resource.\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value ðŸ˜µâ€ðŸ’«\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n/// <reference types=\"./env.d.ts\" />\n\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\nâ”œâ”€â”€ dev (Stage Scope)\nâ”‚   â”œâ”€â”€ api (Nested Scope)\nâ”‚   â””â”€â”€ database (Resource)\nâ””â”€â”€ prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/aws/account-id.ts\n```ts\nimport { GetCallerIdentityCommand, STSClient } from \"@aws-sdk/client-sts\";\n\nconst sts = new STSClient({});\n\nexport type AccountId = string & {\n  readonly __brand: \"AccountId\";\n};\n\n/**\n * Helper to get the current AWS account ID\n */\nexport async function AccountId(): Promise<AccountId> {\n  const identity = await sts.send(new GetCallerIdentityCommand({}));\n  return identity.Account! as AccountId;\n}\n\n```\n\n// alchemy/src/aws/bucket.ts\n```ts\nimport {\n  CreateBucketCommand,\n  DeleteBucketCommand,\n  GetBucketAclCommand,\n  GetBucketLocationCommand,\n  GetBucketTaggingCommand,\n  GetBucketVersioningCommand,\n  HeadBucketCommand,\n  NoSuchBucket,\n  PutBucketTaggingCommand,\n  S3Client,\n} from \"@aws-sdk/client-s3\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating an S3 bucket\n */\nexport interface BucketProps {\n  /**\n   * The name of the bucket. Must be globally unique across all AWS accounts.\n   * Should be lowercase alphanumeric characters or hyphens.\n   */\n  bucketName: string;\n\n  /**\n   * Optional tags to apply to the bucket for organization and cost tracking.\n   * Each tag is a key-value pair.\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after S3 bucket creation/update\n */\nexport interface Bucket extends Resource<\"s3::Bucket\">, BucketProps {\n  /**\n   * The ARN (Amazon Resource Name) of the bucket\n   * Format: arn:aws:s3:::bucket-name\n   */\n  arn: string;\n\n  /**\n   * The global domain name for the bucket\n   * Format: bucket-name.s3.amazonaws.com\n   */\n  bucketDomainName: string;\n\n  /**\n   * The regional domain name for the bucket\n   * Format: bucket-name.s3.region.amazonaws.com\n   */\n  bucketRegionalDomainName?: string;\n\n  /**\n   * The S3 hosted zone ID for the region where the bucket resides\n   * Used for DNS configuration with Route 53\n   */\n  hostedZoneId?: string;\n\n  /**\n   * The AWS region where the bucket is located\n   */\n  region?: string;\n\n  /**\n   * The website endpoint URL if static website hosting is enabled\n   * Format: http://bucket-name.s3-website-region.amazonaws.com\n   */\n  websiteEndpoint?: string;\n\n  /**\n   * The website domain if static website hosting is enabled\n   * Format: bucket-name.s3-website-region.amazonaws.com\n   */\n  websiteDomain?: string;\n\n  /**\n   * Whether versioning is enabled for the bucket\n   */\n  versioningEnabled?: boolean;\n\n  /**\n   * The canned ACL applied to the bucket\n   * Common values: private, public-read, public-read-write, authenticated-read\n   */\n  acl?: string;\n}\n\n/**\n * AWS S3 Bucket Resource\n *\n * Creates and manages Amazon S3 buckets with support for versioning, tags, and regional configuration.\n * S3 buckets provide scalable object storage for any type of data, with features like versioning,\n * lifecycle policies, and fine-grained access control.\n *\n * @example\n * // Create a basic S3 bucket with default settings\n * const basicBucket = await Bucket(\"my-app-storage\", {\n *   bucketName: \"my-app-storage\",\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"my-app\"\n *   }\n * });\n *\n * @example\n * // Create a bucket with versioning enabled and specific tags\n * const versionedBucket = await Bucket(\"document-archive\", {\n *   bucketName: \"document-archive\",\n *   tags: {\n *     Environment: \"production\",\n *     Purpose: \"document-storage\",\n *     Versioning: \"enabled\"\n *   }\n * });\n *\n * @example\n * // Create a development bucket with minimal configuration\n * const devBucket = await Bucket(\"dev-testing\", {\n *   bucketName: \"dev-testing\",\n *   tags: {\n *     Environment: \"development\",\n *     Temporary: \"true\"\n *   }\n * });\n */\nexport const Bucket = Resource(\n  \"s3::Bucket\",\n  async function (this: Context<Bucket>, id: string, props: BucketProps) {\n    const client = new S3Client({});\n\n    if (this.phase === \"delete\") {\n      await ignore(NoSuchBucket.name, () =>\n        client.send(\n          new DeleteBucketCommand({\n            Bucket: props.bucketName,\n          }),\n        ),\n      );\n      return this.destroy();\n    } else {\n      try {\n        // Check if bucket exists\n        await client.send(\n          new HeadBucketCommand({\n            Bucket: props.bucketName,\n          }),\n        );\n\n        // Update tags if they changed and bucket exists\n        if (this.phase === \"update\" && props.tags) {\n          await client.send(\n            new PutBucketTaggingCommand({\n              Bucket: props.bucketName,\n              Tagging: {\n                TagSet: Object.entries(props.tags).map(([Key, Value]) => ({\n                  Key,\n                  Value,\n                })),\n              },\n            }),\n          );\n        }\n      } catch (error: any) {\n        if (error.name === \"NotFound\") {\n          // Create bucket if it doesn't exist\n          await client.send(\n            new CreateBucketCommand({\n              Bucket: props.bucketName,\n              // Add tags during creation if specified\n              ...(props.tags && {\n                Tagging: {\n                  TagSet: Object.entries(props.tags).map(([Key, Value]) => ({\n                    Key,\n                    Value,\n                  })),\n                },\n              }),\n            }),\n          );\n        } else {\n          throw error;\n        }\n      }\n\n      // Get bucket details\n      const [locationResponse, versioningResponse, aclResponse] =\n        await Promise.all([\n          client.send(\n            new GetBucketLocationCommand({ Bucket: props.bucketName }),\n          ),\n          client.send(\n            new GetBucketVersioningCommand({ Bucket: props.bucketName }),\n          ),\n          client.send(new GetBucketAclCommand({ Bucket: props.bucketName })),\n        ]);\n\n      const region = locationResponse.LocationConstraint || \"us-east-1\";\n\n      // Get tags if they exist\n      let tags = props.tags;\n      if (!tags) {\n        try {\n          const taggingResponse = await client.send(\n            new GetBucketTaggingCommand({ Bucket: props.bucketName }),\n          );\n          tags = Object.fromEntries(\n            taggingResponse.TagSet?.map(({ Key, Value }) => [Key, Value]) || [],\n          );\n        } catch (error: any) {\n          if (error.name !== \"NoSuchTagSet\") {\n            throw error;\n          }\n        }\n      }\n\n      return this({\n        bucketName: props.bucketName,\n        arn: `arn:aws:s3:::${props.bucketName}`,\n        bucketDomainName: `${props.bucketName}.s3.amazonaws.com`,\n        bucketRegionalDomainName: `${props.bucketName}.s3.${region}.amazonaws.com`,\n        region,\n        hostedZoneId: getHostedZoneId(region),\n        versioningEnabled: versioningResponse.Status === \"Enabled\",\n        acl: aclResponse.Grants?.[0]?.Permission?.toLowerCase(),\n        ...(tags && { tags }),\n      });\n    }\n  },\n);\n\n/**\n * Helper function to get S3 hosted zone IDs by region\n *\n * Returns the S3 hosted zone ID for a given AWS region. These IDs are used when\n * configuring Route 53 DNS records that point to S3 buckets. If the region is not\n * found in the mapping, defaults to the us-east-1 hosted zone ID.\n *\n * @param region - The AWS region code (e.g., us-east-1, eu-west-1)\n * @returns The S3 hosted zone ID for the region\n */\nfunction getHostedZoneId(region: string): string {\n  const hostedZoneIds: Record<string, string> = {\n    \"us-east-1\": \"Z3AQBSTGFYJSTF\",\n    \"us-east-2\": \"Z2O1EMRO9K5GLX\",\n    \"us-west-1\": \"Z2F56UZL2M1ACD\",\n    \"us-west-2\": \"Z3BJ6K6RIION7M\",\n    \"af-south-1\": \"Z11KHD8FBVPUYU\",\n    \"ap-east-1\": \"ZNB98KWMFR0R6\",\n    \"ap-south-1\": \"Z11RGJOFQNVJUP\",\n    \"ap-northeast-1\": \"Z2M4EHUR26P7ZW\",\n    \"ap-northeast-2\": \"Z3W03O7B5YMIYP\",\n    \"ap-northeast-3\": \"Z2YQB5RD63NC85\",\n    \"ap-southeast-1\": \"Z3O0J2DXBE1FTB\",\n    \"ap-southeast-2\": \"Z1WCIGYICN2BYD\",\n    \"ca-central-1\": \"Z1QDHH18159H29\",\n    \"eu-central-1\": \"Z21DNDUVLTQW6Q\",\n    \"eu-west-1\": \"Z1BKCTXD74EZPE\",\n    \"eu-west-2\": \"Z3GKZC51ZF0DB4\",\n    \"eu-west-3\": \"Z3R1K369G5AVDG\",\n    \"eu-north-1\": \"Z3BAZG2TWCNX0D\",\n    \"eu-south-1\": \"Z30OZKI7KPW7MI\",\n    \"me-south-1\": \"Z1MPMWCPA7YB62\",\n    \"sa-east-1\": \"Z7KQH4QJS55SO\",\n  };\n  return hostedZoneIds[region] || \"Z3AQBSTGFYJSTF\"; // Default to us-east-1 if region not found\n}\n\n```\n\n// alchemy/src/aws/credentials.ts\n```ts\nimport type { Secret } from \"../secret\";\n\nexport interface AwsCredentials {\n  accessKeyId: Secret;\n  secretAccessKey: Secret;\n}\n\n```\n\n// alchemy/src/aws/function.ts\n```ts\nimport {\n  AddPermissionCommand,\n  Architecture,\n  CreateFunctionCommand,\n  CreateFunctionUrlConfigCommand,\n  DeleteFunctionCommand,\n  DeleteFunctionUrlConfigCommand,\n  GetFunctionCommand,\n  GetFunctionConfigurationCommand,\n  GetFunctionUrlConfigCommand,\n  LambdaClient,\n  ResourceNotFoundException,\n  Runtime,\n  UpdateFunctionCodeCommand,\n  UpdateFunctionConfigurationCommand,\n  UpdateFunctionUrlConfigCommand,\n} from \"@aws-sdk/client-lambda\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating a Lambda function\n */\nexport interface FunctionProps {\n  /**\n   * Name of the Lambda function\n   */\n  functionName: string;\n\n  /**\n   * Path to the zip file containing the function code\n   */\n  zipPath: string;\n\n  /**\n   * ARN of the IAM role that Lambda assumes when executing the function\n   */\n  roleArn: string;\n\n  /**\n   * Function handler in the format 'file.function'\n   * For Node.js this is typically 'index.handler' or similar\n   */\n  handler?: string;\n\n  /**\n   * Lambda runtime environment for the function\n   * @default nodejs20.x if not specified\n   */\n  runtime?: Runtime;\n\n  /**\n   * CPU architecture for the function\n   * @default x86_64 if not specified\n   */\n  architecture?: Architecture;\n\n  /**\n   * Description of the function's purpose\n   */\n  description?: string;\n\n  /**\n   * Maximum execution time in seconds\n   * @default 3 seconds if not specified\n   */\n  timeout?: number;\n\n  /**\n   * Amount of memory available to the function in MB\n   * @default 128 MB if not specified\n   */\n  memorySize?: number;\n\n  /**\n   * Environment variables available to the function code\n   */\n  environment?: Record<string, string>;\n\n  /**\n   * Resource tags for the function\n   */\n  tags?: Record<string, string>;\n\n  /**\n   * Function URL configuration for direct HTTP(S) invocation\n   */\n  url?: {\n    /**\n     * Authentication type for the function URL\n     */\n    authType?: \"AWS_IAM\" | \"NONE\";\n\n    /**\n     * CORS configuration for the function URL\n     */\n    cors?: {\n      /**\n       * Whether to allow credentials in CORS requests\n       */\n      allowCredentials?: boolean;\n\n      /**\n       * Allowed headers in CORS requests\n       */\n      allowHeaders?: string[];\n\n      /**\n       * Allowed HTTP methods in CORS requests\n       */\n      allowMethods?: string[];\n\n      /**\n       * Allowed origins in CORS requests\n       */\n      allowOrigins?: string[];\n\n      /**\n       * Headers exposed to the browser\n       */\n      exposeHeaders?: string[];\n\n      /**\n       * CORS preflight cache time in seconds\n       */\n      maxAge?: number;\n    };\n  };\n}\n\n/**\n * Output returned after Lambda function creation/update\n */\nexport interface Function extends Resource<\"lambda::Function\">, FunctionProps {\n  /**\n   * ARN of the Lambda function\n   */\n  arn: string;\n\n  /**\n   * Timestamp of the last function modification\n   */\n  lastModified: string;\n\n  /**\n   * Function version\n   */\n  version: string;\n\n  /**\n   * ARN with version suffix\n   */\n  qualifiedArn: string;\n\n  /**\n   * ARN for invoking the function through API Gateway\n   */\n  invokeArn: string;\n\n  /**\n   * SHA256 hash of the function code\n   */\n  sourceCodeHash: string;\n\n  /**\n   * Size of the function code in bytes\n   */\n  sourceCodeSize: number;\n\n  /**\n   * Size of ephemeral storage (/tmp) in MB\n   */\n  ephemeralStorageSize?: number;\n\n  /**\n   * List of supported CPU architectures\n   */\n  architectures: string[];\n\n  /**\n   * ARN of the master function (Lambda@Edge only)\n   */\n  masterArn?: string;\n\n  /**\n   * Unique identifier for the current function code/config\n   */\n  revisionId: string;\n\n  /**\n   * Current state of the function\n   */\n  state?: string;\n\n  /**\n   * Reason for the current state\n   */\n  stateReason?: string;\n\n  /**\n   * Code for the current state reason\n   */\n  stateReasonCode?: string;\n\n  /**\n   * Status of the last update operation\n   */\n  lastUpdateStatus?: string;\n\n  /**\n   * Reason for the last update status\n   */\n  lastUpdateStatusReason?: string;\n\n  /**\n   * Code for the last update status reason\n   */\n  lastUpdateStatusReasonCode?: string;\n\n  /**\n   * Function package type (Zip or Image)\n   */\n  packageType: string;\n\n  /**\n   * ARN of the signing profile version\n   */\n  signingProfileVersionArn?: string;\n\n  /**\n   * ARN of the signing job\n   */\n  signingJobArn?: string;\n\n  /**\n   * Function URL if configured\n   */\n  functionUrl?: string;\n}\n\n/**\n * AWS Lambda Function Resource\n *\n * Creates and manages AWS Lambda functions with support for Node.js runtimes, custom handlers,\n * environment variables, and function URLs. Handles deployment packaging, IAM role\n * stabilization, and function updates.\n *\n * @example\n * // Create a basic Lambda function with minimal configuration\n * const basicFunction = await Function(\"api-handler\", {\n *   functionName: \"api-handler\",\n *   zipPath: \"./dist/api.zip\",\n *   roleArn: role.arn,\n *   runtime: Runtime.nodejs20x,\n *   handler: \"index.handler\",\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a function with environment variables and custom memory/timeout\n * const configuredFunction = await Function(\"worker\", {\n *   functionName: \"worker\",\n *   zipPath: \"./dist/worker.zip\",\n *   roleArn: role.arn,\n *   runtime: Runtime.nodejs20x,\n *   handler: \"worker.process\",\n *   memorySize: 512,\n *   timeout: 30,\n *   environment: {\n *     QUEUE_URL: queue.url,\n *     LOG_LEVEL: \"info\"\n *   }\n * });\n *\n * @example\n * // Create a function with a public URL endpoint and CORS\n * const apiFunction = await Function(\"public-api\", {\n *   functionName: \"public-api\",\n *   zipPath: \"./dist/api.zip\",\n *   roleArn: role.arn,\n *   handler: \"api.handler\",\n *   url: {\n *     authType: \"NONE\",\n *     cors: {\n *       allowOrigins: [\"*\"],\n *       allowMethods: [\"GET\", \"POST\"],\n *       allowHeaders: [\"content-type\"],\n *       maxAge: 86400\n *     }\n *   }\n * });\n */\nexport const Function = Resource(\n  \"lambda::Function\",\n  async function (this: Context<Function>, id: string, props: FunctionProps) {\n    const client = new LambdaClient({});\n    const region = await resolveRegion(client);\n\n    const code = await zipCode(props.zipPath);\n\n    if (this.phase === \"delete\") {\n      // Delete function URL if it exists\n      if (this.output?.url) {\n        try {\n          await client.send(\n            new DeleteFunctionUrlConfigCommand({\n              FunctionName: props.functionName,\n            })\n          );\n        } catch (error: any) {\n          if (error.name !== \"ResourceNotFoundException\") {\n            console.warn(\"Failed to delete function URL:\", error);\n          }\n        }\n      }\n\n      await ignore(ResourceNotFoundException.name, () =>\n        client.send(\n          new DeleteFunctionCommand({\n            FunctionName: props.functionName,\n          })\n        )\n      );\n\n      return this.destroy();\n    } else {\n      let functionUrl: string | undefined;\n      try {\n        // Check if function exists\n        await client.send(\n          new GetFunctionCommand({\n            FunctionName: props.functionName,\n          })\n        );\n\n        if (this.phase === \"update\") {\n          // Wait for function to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Update function code\n          await client.send(\n            new UpdateFunctionCodeCommand({\n              FunctionName: props.functionName,\n              ZipFile: code,\n            })\n          );\n\n          // Wait for code update to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Update function configuration\n          await client.send(\n            new UpdateFunctionConfigurationCommand({\n              FunctionName: props.functionName,\n              Handler: props.handler,\n              Runtime: props.runtime,\n              Role: props.roleArn,\n              Description: props.description,\n              Timeout: props.timeout,\n              MemorySize: props.memorySize,\n              Environment: props.environment\n                ? { Variables: props.environment }\n                : undefined,\n            })\n          );\n\n          // Wait for configuration update to stabilize\n          await waitForFunctionStabilization(client, props.functionName);\n\n          // Handle URL configuration\n          if (props.url) {\n            try {\n              // Check if URL config exists already\n              const urlConfig = await client.send(\n                new GetFunctionUrlConfigCommand({\n                  FunctionName: props.functionName,\n                })\n              );\n\n              // Update URL configuration if it exists\n              if (urlConfig) {\n                const updateResult = await client.send(\n                  new UpdateFunctionUrlConfigCommand({\n                    FunctionName: props.functionName,\n                    AuthType: props.url.authType || \"NONE\",\n                    Cors: props.url.cors\n                      ? {\n                          AllowCredentials: props.url.cors.allowCredentials,\n                          AllowHeaders: props.url.cors.allowHeaders,\n                          AllowMethods: props.url.cors.allowMethods,\n                          AllowOrigins: props.url.cors.allowOrigins,\n                          ExposeHeaders: props.url.cors.exposeHeaders,\n                          MaxAge: props.url.cors.maxAge,\n                        }\n                      : undefined,\n                  })\n                );\n                functionUrl = updateResult.FunctionUrl;\n\n                // Add public access permission for function URL\n                if (props.url.authType === \"NONE\") {\n                  try {\n                    await client.send(\n                      new AddPermissionCommand({\n                        FunctionName: props.functionName,\n                        StatementId: \"FunctionURLAllowPublicAccess\",\n                        Action: \"lambda:InvokeFunctionUrl\",\n                        Principal: \"*\",\n                        FunctionUrlAuthType: \"NONE\",\n                      })\n                    );\n                  } catch (permError: any) {\n                    if (!permError.message?.includes(\"already exists\")) {\n                      console.warn(\"Error adding URL permission:\", permError);\n                    }\n                  }\n                }\n              } else {\n                // Create URL configuration if it doesn't exist\n                const createResult = await client.send(\n                  new CreateFunctionUrlConfigCommand({\n                    FunctionName: props.functionName,\n                    AuthType: props.url.authType || \"NONE\",\n                    Cors: props.url.cors\n                      ? {\n                          AllowCredentials: props.url.cors.allowCredentials,\n                          AllowHeaders: props.url.cors.allowHeaders,\n                          AllowMethods: props.url.cors.allowMethods,\n                          AllowOrigins: props.url.cors.allowOrigins,\n                          ExposeHeaders: props.url.cors.exposeHeaders,\n                          MaxAge: props.url.cors.maxAge,\n                        }\n                      : undefined,\n                  })\n                );\n                functionUrl = createResult.FunctionUrl;\n\n                // Add public access permission for function URL\n                if (props.url.authType === \"NONE\") {\n                  try {\n                    await client.send(\n                      new AddPermissionCommand({\n                        FunctionName: props.functionName,\n                        StatementId: \"FunctionURLAllowPublicAccess\",\n                        Action: \"lambda:InvokeFunctionUrl\",\n                        Principal: \"*\",\n                        FunctionUrlAuthType: \"NONE\",\n                      })\n                    );\n                  } catch (permError: any) {\n                    if (!permError.message?.includes(\"already exists\")) {\n                      console.warn(\"Error adding URL permission:\", permError);\n                    }\n                  }\n                }\n              }\n            } catch (error: any) {\n              if (error.name === \"ResourceNotFoundException\") {\n                // Create URL configuration if it doesn't exist\n                const createResult = await client.send(\n                  new CreateFunctionUrlConfigCommand({\n                    FunctionName: props.functionName,\n                    AuthType: props.url.authType || \"NONE\",\n                    Cors: props.url.cors\n                      ? {\n                          AllowCredentials: props.url.cors.allowCredentials,\n                          AllowHeaders: props.url.cors.allowHeaders,\n                          AllowMethods: props.url.cors.allowMethods,\n                          AllowOrigins: props.url.cors.allowOrigins,\n                          ExposeHeaders: props.url.cors.exposeHeaders,\n                          MaxAge: props.url.cors.maxAge,\n                        }\n                      : undefined,\n                  })\n                );\n                functionUrl = createResult.FunctionUrl;\n\n                // Add public access permission for function URL\n                if (props.url.authType === \"NONE\") {\n                  try {\n                    await client.send(\n                      new AddPermissionCommand({\n                        FunctionName: props.functionName,\n                        StatementId: \"FunctionURLAllowPublicAccess\",\n                        Action: \"lambda:InvokeFunctionUrl\",\n                        Principal: \"*\",\n                        FunctionUrlAuthType: \"NONE\",\n                      })\n                    );\n                  } catch (permError: any) {\n                    if (!permError.message?.includes(\"already exists\")) {\n                      console.warn(\"Error adding URL permission:\", permError);\n                    }\n                  }\n                }\n              } else {\n                throw error;\n              }\n            }\n          } else if (this.output?.url) {\n            // Remove URL config if it was previously set but not in current props\n            try {\n              await client.send(\n                new DeleteFunctionUrlConfigCommand({\n                  FunctionName: props.functionName,\n                })\n              );\n              functionUrl = undefined;\n            } catch (error: any) {\n              if (error.name !== \"ResourceNotFoundException\") {\n                console.warn(\"Failed to delete function URL:\", error);\n              }\n            }\n          }\n        }\n      } catch (error: any) {\n        if (error.name === \"ResourceNotFoundException\") {\n          // Create function if it doesn't exist\n          const startTime = Date.now();\n          let delay = 100; // Start with 100ms delay\n\n          while (true) {\n            try {\n              await client.send(\n                new CreateFunctionCommand({\n                  FunctionName: props.functionName,\n                  Code: { ZipFile: code },\n                  Handler: props.handler || \"index.handler\",\n                  Runtime: props.runtime || Runtime.nodejs20x,\n                  Role: props.roleArn,\n                  Description: props.description,\n                  Timeout: props.timeout || 3,\n                  MemorySize: props.memorySize || 128,\n                  Environment: props.environment\n                    ? { Variables: props.environment }\n                    : undefined,\n                  Architectures: props.architecture\n                    ? [props.architecture]\n                    : [Architecture.x86_64],\n                  Tags: props.tags,\n                })\n              );\n              break; // Success - exit retry loop\n            } catch (createError: any) {\n              if (\n                createError.name !== \"InvalidParameterValueException\" ||\n                !createError.message?.includes(\"cannot be assumed by Lambda\")\n              ) {\n                throw createError; // Different error - rethrow\n              }\n\n              if (Date.now() - startTime > 10000) {\n                throw new Error(\n                  \"Timeout waiting for IAM role to be assumable by Lambda after 10s\"\n                );\n              }\n\n              await new Promise((resolve) => setTimeout(resolve, delay));\n              delay = Math.min(delay * 2, 1000); // Exponential backoff capped at 1s\n            }\n          }\n\n          // Wait for function to be active\n          let isCreating = true;\n          while (isCreating) {\n            const config = await client.send(\n              new GetFunctionConfigurationCommand({\n                FunctionName: props.functionName,\n              })\n            );\n            isCreating = config.State === \"Pending\";\n            if (isCreating) {\n              await new Promise((resolve) => setTimeout(resolve, 1000));\n            }\n          }\n\n          // Create URL configuration if needed\n          if (props.url) {\n            try {\n              const createResult = await client.send(\n                new CreateFunctionUrlConfigCommand({\n                  FunctionName: props.functionName,\n                  AuthType: props.url.authType || \"NONE\",\n                  Cors: props.url.cors\n                    ? {\n                        AllowCredentials: props.url.cors.allowCredentials,\n                        AllowHeaders: props.url.cors.allowHeaders,\n                        AllowMethods: props.url.cors.allowMethods,\n                        AllowOrigins: props.url.cors.allowOrigins,\n                        ExposeHeaders: props.url.cors.exposeHeaders,\n                        MaxAge: props.url.cors.maxAge,\n                      }\n                    : undefined,\n                })\n              );\n              functionUrl = createResult.FunctionUrl;\n\n              // Add public access permission for function URL\n              if (props.url.authType === \"NONE\") {\n                try {\n                  await client.send(\n                    new AddPermissionCommand({\n                      FunctionName: props.functionName,\n                      StatementId: \"FunctionURLAllowPublicAccess\",\n                      Action: \"lambda:InvokeFunctionUrl\",\n                      Principal: \"*\",\n                      FunctionUrlAuthType: \"NONE\",\n                    })\n                  );\n                } catch (permError: any) {\n                  if (!permError.message?.includes(\"already exists\")) {\n                    console.warn(\"Error adding URL permission:\", permError);\n                  }\n                }\n              }\n            } catch (error) {\n              console.warn(\"Failed to create function URL:\", error);\n            }\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      // Get complete function details\n      const [func, config] = await Promise.all([\n        client.send(\n          new GetFunctionCommand({\n            FunctionName: props.functionName,\n          })\n        ),\n        client.send(\n          new GetFunctionConfigurationCommand({\n            FunctionName: props.functionName,\n          })\n        ),\n      ]);\n\n      // Try to get function URL if it wasn't already retrieved and URL is configured\n      if (!functionUrl && (props.url || this.output?.url)) {\n        try {\n          const urlConfig = await client.send(\n            new GetFunctionUrlConfigCommand({\n              FunctionName: props.functionName,\n            })\n          );\n          functionUrl = urlConfig.FunctionUrl;\n        } catch (error: any) {\n          if (error.name !== \"ResourceNotFoundException\") {\n            console.warn(\"Failed to get function URL:\", error);\n          }\n        }\n      }\n\n      return this({\n        ...props,\n        arn: config.FunctionArn!,\n        lastModified: config.LastModified!,\n        version: config.Version!,\n        qualifiedArn: `${config.FunctionArn}:${config.Version}`,\n        invokeArn: `arn:aws:apigateway:${region}:lambda:path/2015-03-31/functions/${config.FunctionArn}/invocations`,\n        sourceCodeHash: config.CodeSha256!,\n        sourceCodeSize: config.CodeSize!,\n        ephemeralStorageSize: config.EphemeralStorage?.Size,\n        architectures: config.Architectures || [],\n        masterArn: config.MasterArn,\n        revisionId: config.RevisionId!,\n        state: config.State,\n        stateReason: config.StateReason,\n        stateReasonCode: config.StateReasonCode,\n        lastUpdateStatus: config.LastUpdateStatus,\n        lastUpdateStatusReason: config.LastUpdateStatusReason,\n        lastUpdateStatusReasonCode: config.LastUpdateStatusReasonCode,\n        packageType: config.PackageType!,\n        signingProfileVersionArn: config.SigningProfileVersionArn,\n        signingJobArn: config.SigningJobArn,\n        functionUrl: functionUrl,\n      });\n    }\n  }\n);\n\n// Helper to wait for function to stabilize\nasync function waitForFunctionStabilization(\n  client: LambdaClient,\n  functionName: string\n) {\n  while (true) {\n    const config = await client.send(\n      new GetFunctionConfigurationCommand({\n        FunctionName: functionName,\n      })\n    );\n\n    // Check if function is in a stable state\n    if (config.State === \"Active\" && config.LastUpdateStatus === \"Successful\") {\n      break;\n    }\n\n    // If there's a failure, throw an error\n    if (config.State === \"Failed\" || config.LastUpdateStatus === \"Failed\") {\n      throw new Error(\n        `Function failed to stabilize: ${config.StateReason || config.LastUpdateStatusReason}`\n      );\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n  }\n}\n\n// Helper to zip the code\nasync function zipCode(filePath: string): Promise<Buffer> {\n  const fileContent = await fs.promises.readFile(filePath);\n  const fileName = path.basename(filePath);\n\n  // Create a zip buffer in memory\n  const zip = new (await import(\"jszip\")).default();\n  zip.file(fileName, fileContent);\n  return zip.generateAsync({\n    type: \"nodebuffer\",\n    compression: \"DEFLATE\",\n    platform: \"UNIX\",\n  });\n}\n\nasync function resolveRegion(client: LambdaClient): Promise<string> {\n  const region = client.config.region;\n  if (typeof region === \"string\") return region;\n  if (typeof region === \"function\") return region();\n  throw new Error(\"Could not resolve AWS region\");\n}\n\n```\n\n// alchemy/src/aws/policy-attachment.ts\n```ts\nimport {\n  AttachRolePolicyCommand,\n  DetachRolePolicyCommand,\n  IAMClient,\n  NoSuchEntityException,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for creating or updating a policy attachment\n */\nexport interface PolicyAttachmentProps {\n  /**\n   * ARN of the IAM policy to attach\n   */\n  policyArn: string;\n\n  /**\n   * Name of the IAM role to attach the policy to\n   */\n  roleName: string;\n}\n\n/**\n * Output returned after policy attachment creation/update\n */\nexport interface PolicyAttachment\n  extends Resource<\"iam::PolicyAttachment\">,\n    PolicyAttachmentProps {}\n\n/**\n * AWS IAM Policy Attachment Resource\n *\n * Attaches an IAM policy to a role, enabling the role to use the permissions defined in the policy.\n *\n * @example\n * // Attach an AWS managed policy to a role\n * const adminAccess = await PolicyAttachment(\"admin-policy\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AdministratorAccess\",\n *   roleName: role.name\n * });\n *\n * @example\n * // Attach a custom policy to a role\n * const customPolicy = await PolicyAttachment(\"custom-policy\", {\n *   policyArn: policy.arn,\n *   roleName: role.name\n * });\n *\n * @example\n * // Attach multiple policies to a role\n * const s3Access = await PolicyAttachment(\"s3-access\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AmazonS3FullAccess\",\n *   roleName: role.name\n * });\n *\n * const sqsAccess = await PolicyAttachment(\"sqs-access\", {\n *   policyArn: \"arn:aws:iam::aws:policy/AmazonSQSFullAccess\",\n *   roleName: role.name\n * });\n */\nexport const PolicyAttachment = Resource(\n  \"iam::PolicyAttachment\",\n  async function (\n    this: Context<PolicyAttachment>,\n    id: string,\n    props: PolicyAttachmentProps,\n  ) {\n    const client = new IAMClient({});\n\n    if (this.phase === \"delete\") {\n      await ignore(NoSuchEntityException.name, () =>\n        client.send(\n          new DetachRolePolicyCommand({\n            PolicyArn: props.policyArn,\n            RoleName: props.roleName,\n          }),\n        ),\n      );\n      return this.destroy();\n    } else {\n      await client.send(\n        new AttachRolePolicyCommand({\n          PolicyArn: props.policyArn,\n          RoleName: props.roleName,\n        }),\n      );\n    }\n\n    return this(props);\n  },\n);\n\n```\n\n// alchemy/src/aws/policy.ts\n```ts\nimport {\n  CreatePolicyCommand,\n  CreatePolicyVersionCommand,\n  DeletePolicyCommand,\n  DeletePolicyVersionCommand,\n  GetPolicyCommand,\n  GetPolicyVersionCommand,\n  IAMClient,\n  ListPolicyVersionsCommand,\n  NoSuchEntityException,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Type of effect for a policy statement\n */\nexport type Effect = \"Allow\" | \"Deny\";\n\n/**\n * A single statement within an IAM policy document\n */\nexport interface PolicyStatement {\n  /**\n   * Optional identifier for the statement\n   */\n  Sid?: string;\n\n  /**\n   * Whether to allow or deny the specified actions\n   */\n  Effect: Effect;\n\n  /**\n   * Actions that the policy allows or denies\n   */\n  Action: string | string[];\n\n  /**\n   * Resources that the policy applies to\n   */\n  Resource?: string | string[];\n\n  /**\n   * Additional conditions for when the policy applies\n   */\n  Condition?: Record<string, Record<string, string | string[]>>;\n\n  /**\n   * AWS principals that the policy applies to\n   */\n  Principal?: Record<string, string | string[]>;\n\n  /**\n   * AWS principals that the policy explicitly does not apply to\n   */\n  NotPrincipal?: Record<string, string | string[]>;\n\n  /**\n   * Actions that are explicitly not included in this statement\n   */\n  NotAction?: string | string[];\n\n  /**\n   * Resources that are explicitly not included in this statement\n   */\n  NotResource?: string | string[];\n}\n\n/**\n * An IAM policy document containing one or more statements\n */\nexport interface PolicyDocument {\n  /**\n   * Policy language version (must be \"2012-10-17\")\n   */\n  Version: \"2012-10-17\";\n\n  /**\n   * List of policy statements\n   */\n  Statement: PolicyStatement[];\n}\n\n/**\n * Properties for creating or updating an IAM policy\n */\nexport interface PolicyProps {\n  /**\n   * Name of the policy\n   */\n  policyName: string;\n\n  /**\n   * Policy document defining the permissions\n   */\n  document: PolicyDocument;\n\n  /**\n   * Optional description of the policy's purpose\n   */\n  description?: string;\n\n  /**\n   * Optional path prefix for the policy\n   */\n  path?: string;\n\n  /**\n   * Optional resource tags\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after IAM policy creation/update\n */\nexport interface Policy extends Resource<\"iam::Policy\">, PolicyProps {\n  /**\n   * ARN of the policy\n   */\n  arn: string;\n\n  /**\n   * ID of the default policy version\n   */\n  defaultVersionId: string;\n\n  /**\n   * Number of entities the policy is attached to\n   */\n  attachmentCount: number;\n\n  /**\n   * When the policy was created\n   */\n  createDate: Date;\n\n  /**\n   * When the policy was last updated\n   */\n  updateDate: Date;\n\n  /**\n   * Whether the policy can be attached to IAM users/roles\n   */\n  isAttachable: boolean;\n}\n\n/**\n * AWS IAM Policy Resource\n *\n * Creates and manages IAM policies that define permissions for AWS services and resources.\n * Supports automatic versioning and updates when policy content changes.\n *\n * @example\n * // Create a basic S3 bucket access policy\n * const s3Policy = await Policy(\"bucket-access\", {\n *   policyName: \"s3-bucket-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Action: [\n *         \"s3:GetObject\",\n *         \"s3:PutObject\"\n *       ],\n *       Resource: `${bucket.arn}/*`\n *     }]\n *   }\n * });\n *\n * @example\n * // Create a policy with multiple statements and conditions\n * const apiPolicy = await Policy(\"api-access\", {\n *   policyName: \"api-gateway-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [\n *       {\n *         Sid: \"InvokeAPI\",\n *         Effect: \"Allow\",\n *         Action: \"execute-api:Invoke\",\n *         Resource: `${api.executionArn}/*`,\n *         Condition: {\n *           StringEquals: {\n *             \"aws:SourceVpc\": vpc.id\n *           }\n *         }\n *       },\n *       {\n *         Sid: \"ReadLogs\",\n *         Effect: \"Allow\",\n *         Action: [\n *           \"logs:GetLogEvents\",\n *           \"logs:FilterLogEvents\"\n *         ],\n *         Resource: `${api.logGroupArn}:*`\n *       }\n *     ]\n *   },\n *   description: \"Allows invoking API Gateway endpoints and reading logs\",\n *   tags: {\n *     Service: \"API Gateway\",\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a policy that denies access based on tags\n * const denyPolicy = await Policy(\"deny-production\", {\n *   policyName: \"deny-production-access\",\n *   document: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Deny\",\n *       Action: \"*\",\n *       Resource: \"*\",\n *       Condition: {\n *         StringEquals: {\n *           \"aws:ResourceTag/Environment\": \"production\"\n *         }\n *       }\n *     }]\n *   }\n * });\n */\nexport const Policy = Resource(\n  \"iam::Policy\",\n  async function (\n    this: Context<Policy>,\n    id: string,\n    props: PolicyProps,\n  ): Promise<Policy> {\n    const client = new IAMClient({});\n    const policyArn = `arn:aws:iam::${process.env.AWS_ACCOUNT_ID}:policy${props.path || \"/\"}${props.policyName}`;\n\n    if (this.phase === \"delete\") {\n      try {\n        // List and delete all non-default versions first\n        const versions = await client.send(\n          new ListPolicyVersionsCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        for (const version of versions.Versions || []) {\n          if (!version.IsDefaultVersion) {\n            await client.send(\n              new DeletePolicyVersionCommand({\n                PolicyArn: policyArn,\n                VersionId: version.VersionId,\n              }),\n            );\n          }\n        }\n\n        // Delete the policy\n        await client.send(\n          new DeletePolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n      } catch (error: any) {\n        if (error.name !== NoSuchEntityException.name) {\n          throw error;\n        }\n      }\n      return this.destroy();\n    } else {\n      try {\n        // Check if policy exists\n        const existingPolicy = await client.send(\n          new GetPolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        // Get current policy version\n        const currentVersion = await client.send(\n          new GetPolicyVersionCommand({\n            PolicyArn: policyArn,\n            VersionId: existingPolicy.Policy!.DefaultVersionId!,\n          }),\n        );\n\n        const currentDocument = JSON.parse(\n          decodeURIComponent(currentVersion.PolicyVersion!.Document!),\n        );\n\n        // If policy document changed, create new version\n        if (\n          JSON.stringify(currentDocument) !== JSON.stringify(props.document)\n        ) {\n          // List versions to check if we need to delete old ones\n          const versions = await client.send(\n            new ListPolicyVersionsCommand({\n              PolicyArn: policyArn,\n            }),\n          );\n\n          // Delete oldest version if we have 5 versions (maximum allowed)\n          if (versions.Versions?.length === 5) {\n            const oldestVersion = versions.Versions.sort(\n              (a, b) => a.CreateDate!.getTime() - b.CreateDate!.getTime(),\n            )[0];\n\n            if (!oldestVersion.IsDefaultVersion) {\n              await client.send(\n                new DeletePolicyVersionCommand({\n                  PolicyArn: policyArn,\n                  VersionId: oldestVersion.VersionId!,\n                }),\n              );\n            }\n          }\n\n          // Create new version\n          await client.send(\n            new CreatePolicyVersionCommand({\n              PolicyArn: policyArn,\n              PolicyDocument: JSON.stringify(props.document),\n              SetAsDefault: true,\n            }),\n          );\n        }\n\n        const policy = await client.send(\n          new GetPolicyCommand({\n            PolicyArn: policyArn,\n          }),\n        );\n\n        return this({\n          ...props,\n          arn: policy.Policy!.Arn!,\n          defaultVersionId: policy.Policy!.DefaultVersionId!,\n          attachmentCount: policy.Policy!.AttachmentCount!,\n          createDate: policy.Policy!.CreateDate!,\n          updateDate: policy.Policy!.UpdateDate!,\n          isAttachable: policy.Policy!.IsAttachable!,\n        });\n      } catch (error: any) {\n        if (error.name === \"NoSuchEntity\") {\n          // Create new policy\n          const newPolicy = await client.send(\n            new CreatePolicyCommand({\n              PolicyName: props.policyName,\n              PolicyDocument: JSON.stringify(props.document),\n              Description: props.description,\n              Path: props.path,\n              Tags: props.tags\n                ? Object.entries(props.tags).map(([Key, Value]) => ({\n                    Key,\n                    Value,\n                  }))\n                : undefined,\n            }),\n          );\n\n          return this({\n            ...props,\n            arn: newPolicy.Policy!.Arn!,\n            defaultVersionId: newPolicy.Policy!.DefaultVersionId!,\n            attachmentCount: newPolicy.Policy!.AttachmentCount!,\n            createDate: newPolicy.Policy!.CreateDate!,\n            updateDate: newPolicy.Policy!.UpdateDate!,\n            isAttachable: newPolicy.Policy!.IsAttachable!,\n          });\n        }\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/aws/queue.ts\n```ts\nimport {\n  CreateQueueCommand,\n  DeleteQueueCommand,\n  GetQueueAttributesCommand,\n  GetQueueUrlCommand,\n  SQSClient,\n} from \"@aws-sdk/client-sqs\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating an SQS queue\n */\nexport interface QueueProps {\n  /**\n   * Name of the queue\n   * For FIFO queues, the name must end with the .fifo suffix\n   */\n  queueName: string;\n\n  /**\n   * Whether this is a FIFO queue.\n   * If true, the queueName must end with .fifo suffix\n   */\n  fifo?: boolean;\n\n  /**\n   * The length of time (in seconds) that a message received from a queue will be invisible to other receiving components\n   * Default: 30 seconds\n   */\n  visibilityTimeout?: number;\n\n  /**\n   * The length of time (in seconds) for which Amazon SQS retains a message\n   * Default: 345600 seconds (4 days)\n   */\n  messageRetentionPeriod?: number;\n\n  /**\n   * The limit of how many bytes a message can contain before Amazon SQS rejects it\n   * Default: 262144 bytes (256 KB)\n   */\n  maximumMessageSize?: number;\n\n  /**\n   * The time in seconds that the delivery of all messages in the queue will be delayed\n   * Default: 0 seconds\n   */\n  delaySeconds?: number;\n\n  /**\n   * The length of time (in seconds) for which a ReceiveMessage action waits for a message to arrive\n   * Default: 0 seconds\n   */\n  receiveMessageWaitTimeSeconds?: number;\n\n  /**\n   * Enables content-based deduplication for FIFO queues.\n   * Only applicable when fifo is true.\n   */\n  contentBasedDeduplication?: boolean;\n\n  /**\n   * Specifies whether message deduplication occurs at the message group or queue level\n   * Only applicable when fifo is true\n   */\n  deduplicationScope?: \"messageGroup\" | \"queue\";\n\n  /**\n   * Specifies whether the FIFO queue throughput quota applies to the entire queue or per message group\n   * Only applicable when fifo is true\n   */\n  fifoThroughputLimit?: \"perQueue\" | \"perMessageGroupId\";\n\n  /**\n   * Resource tags for the queue\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after SQS queue creation/update\n */\nexport interface Queue extends Resource<\"sqs::Queue\">, QueueProps {\n  /**\n   * ARN of the queue\n   */\n  arn: string;\n\n  /**\n   * URL of the queue\n   */\n  url: string;\n}\n\n/**\n * AWS SQS Queue Resource\n *\n * Creates and manages Amazon SQS queues with support for both standard and FIFO queues.\n * Handles queue creation, attribute configuration, and automatic cleanup of deleted queues.\n *\n * @example\n * // Create a standard queue with custom visibility timeout\n * const standardQueue = await Queue(\"my-queue\", {\n *   queueName: \"my-queue\",\n *   visibilityTimeout: 30,\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a FIFO queue with content-based deduplication\n * const fifoQueue = await Queue(\"orders-queue\", {\n *   queueName: \"orders-queue.fifo\",\n *   fifo: true,\n *   contentBasedDeduplication: true,\n *   visibilityTimeout: 30,\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a queue with custom message retention and size\n * const customQueue = await Queue(\"large-messages\", {\n *   queueName: \"large-messages\",\n *   messageRetentionPeriod: 345600,  // 4 days\n *   maximumMessageSize: 262144,      // 256 KB\n *   visibilityTimeout: 60,\n *   delaySeconds: 5,\n *   receiveMessageWaitTimeSeconds: 20\n * });\n */\nexport const Queue = Resource(\n  \"sqs::Queue\",\n  async function (\n    this: Context<Queue>,\n    id: string,\n    props: QueueProps,\n  ): Promise<Queue> {\n    const client = new SQSClient({});\n    // Don't automatically add .fifo suffix - user must include it in queueName\n    const queueName = props.queueName;\n\n    // Validate that FIFO queues have .fifo suffix\n    if (props.fifo && !queueName.endsWith(\".fifo\")) {\n      throw new Error(\"FIFO queue names must end with .fifo suffix\");\n    }\n\n    if (this.phase === \"delete\") {\n      try {\n        // Get queue URL first\n        const urlResponse = await client.send(\n          new GetQueueUrlCommand({\n            QueueName: queueName,\n          }),\n        );\n\n        // Delete the queue\n        await client.send(\n          new DeleteQueueCommand({\n            QueueUrl: urlResponse.QueueUrl,\n          }),\n        );\n\n        // Wait for queue to be deleted\n        let queueDeleted = false;\n        while (!queueDeleted) {\n          try {\n            await client.send(\n              new GetQueueUrlCommand({\n                QueueName: queueName,\n              }),\n            );\n            // If we get here, queue still exists\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n          } catch (error: any) {\n            if (error.name === \"QueueDoesNotExist\") {\n              queueDeleted = true;\n            } else {\n              throw error;\n            }\n          }\n        }\n      } catch (error: any) {\n        if (error.name !== \"QueueDoesNotExist\") {\n          throw error;\n        }\n      }\n\n      return this.destroy();\n    } else {\n      // Create queue with attributes\n      const attributes: Record<string, string> = {};\n\n      if (props.visibilityTimeout !== undefined) {\n        attributes[\"VisibilityTimeout\"] = props.visibilityTimeout.toString();\n      }\n      if (props.messageRetentionPeriod !== undefined) {\n        attributes[\"MessageRetentionPeriod\"] =\n          props.messageRetentionPeriod.toString();\n      }\n      if (props.maximumMessageSize !== undefined) {\n        attributes[\"MaximumMessageSize\"] = props.maximumMessageSize.toString();\n      }\n      if (props.delaySeconds !== undefined) {\n        attributes[\"DelaySeconds\"] = props.delaySeconds.toString();\n      }\n      if (props.receiveMessageWaitTimeSeconds !== undefined) {\n        attributes[\"ReceiveMessageWaitTimeSeconds\"] =\n          props.receiveMessageWaitTimeSeconds.toString();\n      }\n\n      // FIFO specific attributes\n      if (props.fifo) {\n        attributes[\"FifoQueue\"] = \"true\";\n        if (props.contentBasedDeduplication) {\n          attributes[\"ContentBasedDeduplication\"] = \"true\";\n        }\n        if (props.deduplicationScope) {\n          attributes[\"DeduplicationScope\"] = props.deduplicationScope;\n        }\n        if (props.fifoThroughputLimit) {\n          attributes[\"FifoThroughputLimit\"] = props.fifoThroughputLimit;\n        }\n      }\n\n      // Convert tags to AWS format\n      const tags = props.tags\n        ? Object.entries(props.tags).reduce(\n            (acc, [key, value]) => ({ ...acc, [key]: value }),\n            {},\n          )\n        : undefined;\n\n      try {\n        // Create the queue\n        const createResponse = await client.send(\n          new CreateQueueCommand({\n            QueueName: queueName,\n            Attributes: attributes,\n            tags,\n          }),\n        );\n\n        // Get queue attributes\n        const attributesResponse = await client.send(\n          new GetQueueAttributesCommand({\n            QueueUrl: createResponse.QueueUrl,\n            AttributeNames: [\"QueueArn\"],\n          }),\n        );\n\n        return this({\n          ...props,\n          arn: attributesResponse.Attributes!.QueueArn!,\n          url: createResponse.QueueUrl!,\n        });\n      } catch (error: any) {\n        if (error.name === \"QueueAlreadyExists\") {\n          // Get existing queue URL\n          const urlResponse = await client.send(\n            new GetQueueUrlCommand({\n              QueueName: queueName,\n            }),\n          );\n\n          // Get queue attributes\n          const attributesResponse = await client.send(\n            new GetQueueAttributesCommand({\n              QueueUrl: urlResponse.QueueUrl,\n              AttributeNames: [\"QueueArn\"],\n            }),\n          );\n\n          return this({\n            ...props,\n            arn: attributesResponse.Attributes!.QueueArn!,\n            url: urlResponse.QueueUrl!,\n          });\n        } else if (error.name === \"QueueDeletedRecently\") {\n          // Queue was recently deleted, wait and retry\n          const maxRetries = 3;\n          let retryCount = 0;\n\n          while (retryCount < maxRetries) {\n            try {\n              // Wait for 60 seconds before retrying\n              await new Promise((resolve) => setTimeout(resolve, 61000));\n\n              // Retry creating the queue\n              const createResponse = await client.send(\n                new CreateQueueCommand({\n                  QueueName: queueName,\n                  Attributes: attributes,\n                  tags,\n                }),\n              );\n\n              // Get queue attributes\n              const attributesResponse = await client.send(\n                new GetQueueAttributesCommand({\n                  QueueUrl: createResponse.QueueUrl,\n                  AttributeNames: [\"QueueArn\"],\n                }),\n              );\n\n              return this({\n                ...props,\n                arn: attributesResponse.Attributes!.QueueArn!,\n                url: createResponse.QueueUrl!,\n              });\n            } catch (retryError: any) {\n              if (\n                retryError.name !== \"QueueDeletedRecently\" ||\n                retryCount === maxRetries - 1\n              ) {\n                throw retryError;\n              }\n              retryCount++;\n            }\n          }\n        }\n        throw error;\n      }\n    }\n  },\n);\n\n```\n\n// alchemy/src/aws/role.ts\n```ts\nimport {\n  AttachRolePolicyCommand,\n  CreateRoleCommand,\n  DeleteRoleCommand,\n  DeleteRolePolicyCommand,\n  DetachRolePolicyCommand,\n  EntityAlreadyExistsException,\n  GetRoleCommand,\n  IAMClient,\n  ListAttachedRolePoliciesCommand,\n  NoSuchEntityException,\n  PutRolePolicyCommand,\n  type Tag,\n  TagRoleCommand,\n  UpdateAssumeRolePolicyCommand,\n  UpdateRoleCommand,\n} from \"@aws-sdk/client-iam\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\nimport type { PolicyDocument } from \"./policy\";\n\n/**\n * Properties for creating or updating an IAM role\n */\nexport interface RoleProps {\n  /**\n   * Name of the IAM role\n   */\n  roleName: string;\n\n  /**\n   * Policy that defines which entities can assume this role\n   */\n  assumeRolePolicy: PolicyDocument;\n\n  /**\n   * Optional description of the role's purpose\n   */\n  description?: string;\n\n  /**\n   * Optional path prefix for the role\n   */\n  path?: string;\n\n  /**\n   * Maximum session duration in seconds when assumed\n   * Default: 3600 seconds (1 hour)\n   */\n  maxSessionDuration?: number;\n\n  /**\n   * ARN of the policy used to set the permissions boundary\n   */\n  permissionsBoundary?: string;\n\n  /**\n   * Inline policies to embed in the role\n   * Each policy must have a unique name and policy document\n   */\n  policies?: Array<{\n    policyName: string;\n    policyDocument: PolicyDocument;\n  }>;\n\n  /**\n   * List of managed policy ARNs to attach to the role\n   */\n  managedPolicyArns?: string[];\n\n  /**\n   * Resource tags for the role\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after IAM role creation/update\n */\nexport interface Role extends Resource<\"iam::Role\">, RoleProps {\n  /**\n   * ARN of the role\n   */\n  arn: string;\n\n  /**\n   * Unique identifier for the role\n   */\n  uniqueId: string;\n\n  /**\n   * The stable and unique string identifying the role\n   */\n  roleId: string;\n\n  /**\n   * When the role was created\n   */\n  createDate: Date;\n}\n\n/**\n * AWS IAM Role Resource\n *\n * Creates and manages IAM roles with support for inline policies, managed policies,\n * and automatic cleanup of attached policies during deletion.\n *\n * @example\n * // Create a basic Lambda execution role with inline policy\n * const basicRole = await Role(\"lambda-role\", {\n *   roleName: \"lambda-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Basic Lambda execution role\",\n *   tags: {\n *     Environment: \"production\"\n *   },\n *   policies: [{\n *     policyName: \"logs\",\n *     policyDocument: {\n *       Version: \"2012-10-17\",\n *       Statement: [{\n *         Effect: \"Allow\",\n *         Action: [\n *           \"logs:CreateLogGroup\",\n *           \"logs:CreateLogStream\",\n *           \"logs:PutLogEvents\"\n *         ],\n *         Resource: \"*\"\n *       }]\n *     }\n *   }]\n * });\n *\n * @example\n * // Create a role with AWS managed policies\n * const managedRole = await Role(\"readonly-role\", {\n *   roleName: \"readonly-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Role with managed policies\",\n *   managedPolicyArns: [\n *     \"arn:aws:iam::aws:policy/ReadOnlyAccess\"\n *   ],\n *   tags: {\n *     Environment: \"production\"\n *   }\n * });\n *\n * @example\n * // Create a role with multiple inline policies and custom session duration\n * const customRole = await Role(\"custom-role\", {\n *   roleName: \"custom-role\",\n *   assumeRolePolicy: {\n *     Version: \"2012-10-17\",\n *     Statement: [{\n *       Effect: \"Allow\",\n *       Principal: {\n *         Service: \"lambda.amazonaws.com\"\n *       },\n *       Action: \"sts:AssumeRole\"\n *     }]\n *   },\n *   description: \"Role with multiple policies\",\n *   maxSessionDuration: 7200,\n *   policies: [\n *     {\n *       policyName: \"logs\",\n *       policyDocument: {\n *         Version: \"2012-10-17\",\n *         Statement: [{\n *           Effect: \"Allow\",\n *           Action: [\n *             \"logs:CreateLogGroup\",\n *             \"logs:CreateLogStream\",\n *             \"logs:PutLogEvents\"\n *           ],\n *           Resource: \"*\"\n *         }]\n *       }\n *     },\n *     {\n *       policyName: \"s3\",\n *       policyDocument: {\n *         Version: \"2012-10-17\",\n *         Statement: [{\n *           Effect: \"Allow\",\n *           Action: \"s3:ListBucket\",\n *           Resource: \"*\"\n *         }]\n *       }\n *     }\n *   ],\n *   tags: {\n *     Environment: \"production\",\n *     Updated: \"true\"\n *   }\n * });\n */\nexport const Role = Resource(\n  \"iam::Role\",\n  async function (\n    this: Context<Role>,\n    id: string,\n    props: RoleProps\n  ): Promise<Role> {\n    const client = new IAMClient({});\n\n    if (this.phase === \"delete\") {\n      try {\n        // Delete any inline policies first\n        if (props.policies) {\n          for (const policy of props.policies) {\n            await ignore(NoSuchEntityException.name, () =>\n              client.send(\n                new DeleteRolePolicyCommand({\n                  RoleName: props.roleName,\n                  PolicyName: policy.policyName,\n                })\n              )\n            );\n          }\n        }\n\n        // We need to detach managed policies before deleting the role\n        // First, get all attached policies\n        try {\n          const attachedPoliciesResponse = await client.send(\n            new ListAttachedRolePoliciesCommand({\n              RoleName: props.roleName,\n            })\n          );\n\n          // Detach all managed policies\n          const attachedPolicies =\n            attachedPoliciesResponse.AttachedPolicies || [];\n          for (const policy of attachedPolicies) {\n            await ignore(NoSuchEntityException.name, () =>\n              client.send(\n                new DetachRolePolicyCommand({\n                  RoleName: props.roleName,\n                  PolicyArn: policy.PolicyArn!,\n                })\n              )\n            );\n          }\n        } catch (error: any) {\n          if (error.name !== NoSuchEntityException.name) {\n            throw error;\n          }\n          // Role doesn't exist, no need to continue with detaching policies\n        }\n\n        // Try to delete the role, ignoring if it doesn't exist\n        await ignore(NoSuchEntityException.name, () =>\n          client.send(\n            new DeleteRoleCommand({\n              RoleName: props.roleName,\n            })\n          )\n        );\n      } catch (error: any) {\n        // If we get any other error besides NoSuchEntityException, log it but don't fail\n        // This ensures the resource is still marked as destroyed\n        if (error.name !== NoSuchEntityException.name) {\n          console.error(`Error deleting role ${props.roleName}:`, error);\n        }\n      }\n\n      // Always return destroyed state regardless of any errors\n      return this.destroy();\n    }\n\n    const assumeRolePolicyDocument = JSON.stringify(props.assumeRolePolicy);\n    let role;\n\n    try {\n      if (this.phase === \"create\") {\n        // Try to create the role\n        await client.send(\n          new CreateRoleCommand({\n            RoleName: props.roleName,\n            AssumeRolePolicyDocument: assumeRolePolicyDocument,\n            Description: props.description,\n            Path: props.path,\n            MaxSessionDuration: props.maxSessionDuration,\n            PermissionsBoundary: props.permissionsBoundary,\n            Tags: [\n              ...Object.entries(props.tags || {}).map(([Key, Value]) => ({\n                Key,\n                Value,\n              })),\n              {\n                Key: \"alchemy_stage\",\n                Value: this.stage,\n              },\n              {\n                Key: \"alchemy_resource\",\n                Value: this.id,\n              },\n            ],\n          })\n        );\n      }\n    } catch (error: any) {\n      if (\n        error instanceof EntityAlreadyExistsException &&\n        this.phase === \"create\"\n      ) {\n        // Check if we were the ones who created it\n        const existingRole = await client.send(\n          new GetRoleCommand({\n            RoleName: props.roleName,\n          })\n        );\n        const roleTags =\n          existingRole.Role?.Tags?.reduce(\n            (acc, tag) => {\n              acc[tag.Key!] = tag.Value!;\n              return acc;\n            },\n            {} as Record<string, string>\n          ) || {};\n\n        if (\n          roleTags.alchemy_stage !== this.stage ||\n          roleTags.alchemy_resource !== this.id\n        ) {\n          throw error;\n        }\n      } else if (error.name !== NoSuchEntityException.name) {\n        throw error;\n      }\n    }\n\n    // Get or update the role\n    role = await client.send(\n      new GetRoleCommand({\n        RoleName: props.roleName,\n      })\n    );\n\n    // Update assume role policy if it changed\n    if (role.Role?.AssumeRolePolicyDocument !== assumeRolePolicyDocument) {\n      await client.send(\n        new UpdateAssumeRolePolicyCommand({\n          RoleName: props.roleName,\n          PolicyDocument: assumeRolePolicyDocument,\n        })\n      );\n    }\n\n    // Update role description and max session duration if they changed\n    if (\n      role.Role?.Description !== props.description ||\n      role.Role?.MaxSessionDuration !== props.maxSessionDuration\n    ) {\n      await client.send(\n        new UpdateRoleCommand({\n          RoleName: props.roleName,\n          Description: props.description,\n          MaxSessionDuration: props.maxSessionDuration,\n        })\n      );\n    }\n\n    // Update tags\n    const newTags = {\n      ...props.tags,\n      alchemy_stage: this.stage,\n      alchemy_resource: this.id,\n    };\n    const tags: Tag[] = Object.entries(newTags).map(([Key, Value]) => ({\n      Key,\n      Value,\n    }));\n    await client.send(\n      new TagRoleCommand({\n        RoleName: props.roleName,\n        Tags: tags,\n      })\n    );\n\n    // Handle policy changes\n    const previousPolicies =\n      this.phase === \"update\" ? this.output!.policies || [] : [];\n    const currentPolicies = props.policies || [];\n\n    // Delete policies that were removed\n    for (const oldPolicy of previousPolicies) {\n      if (\n        !currentPolicies.some(\n          (p: { policyName: string }) => p.policyName === oldPolicy.policyName\n        )\n      ) {\n        await ignore(NoSuchEntityException.name, () =>\n          client.send(\n            new DeleteRolePolicyCommand({\n              RoleName: props.roleName,\n              PolicyName: oldPolicy.policyName,\n            })\n          )\n        );\n      }\n    }\n\n    // Update or create policies\n    for (const policy of currentPolicies) {\n      const oldPolicy = previousPolicies.find(\n        (p) => p.policyName === policy.policyName\n      );\n      if (\n        !oldPolicy ||\n        JSON.stringify(oldPolicy.policyDocument) !==\n          JSON.stringify(policy.policyDocument)\n      ) {\n        await client.send(\n          new PutRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyName: policy.policyName,\n            PolicyDocument: JSON.stringify(policy.policyDocument),\n          })\n        );\n      }\n    }\n\n    // Handle managed policy attachments\n    // Get currently attached policies\n    const attachedPoliciesResponse = await client.send(\n      new ListAttachedRolePoliciesCommand({\n        RoleName: props.roleName,\n      })\n    );\n\n    const currentAttachedPolicies =\n      attachedPoliciesResponse.AttachedPolicies || [];\n    const currentPolicyArns = currentAttachedPolicies.map((p) => p.PolicyArn!);\n\n    // If we're updating, use an empty array as default when managedPolicyArns is undefined\n    // to ensure we detach all managed policies\n    const desiredPolicyArns = props.managedPolicyArns || [];\n\n    // Detach policies that are no longer needed\n    for (const policyArn of currentPolicyArns) {\n      if (!desiredPolicyArns.includes(policyArn)) {\n        await client.send(\n          new DetachRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyArn: policyArn,\n          })\n        );\n      }\n    }\n\n    // Attach new policies that weren't attached before\n    for (const policyArn of desiredPolicyArns) {\n      if (!currentPolicyArns.includes(policyArn)) {\n        await client.send(\n          new AttachRolePolicyCommand({\n            RoleName: props.roleName,\n            PolicyArn: policyArn,\n          })\n        );\n      }\n    }\n\n    if (!role?.Role) {\n      throw new Error(`Failed to create or update role ${props.roleName}`);\n    }\n\n    return this({\n      ...props,\n      arn: role.Role.Arn!,\n      uniqueId: role.Role.RoleId!,\n      roleId: role.Role.RoleId!,\n      roleName: role.Role.RoleName ?? props.roleName,\n      createDate: role.Role.CreateDate!,\n    });\n  }\n);\n\n```\n\n// alchemy/src/aws/ses.ts\n```ts\nimport {\n  CreateConfigurationSetCommand,\n  CreateEmailIdentityCommand,\n  DeleteConfigurationSetCommand,\n  DeleteEmailIdentityCommand,\n  type DeliveryOptions,\n  GetConfigurationSetCommand,\n  GetEmailIdentityCommand,\n  NotFoundException,\n  PutConfigurationSetDeliveryOptionsCommand,\n  PutConfigurationSetReputationOptionsCommand,\n  PutConfigurationSetSendingOptionsCommand,\n  PutConfigurationSetSuppressionOptionsCommand,\n  PutConfigurationSetTrackingOptionsCommand,\n  PutEmailIdentityDkimAttributesCommand,\n  type ReputationOptions,\n  SESv2Client,\n  type SendingOptions,\n  type SuppressionOptions,\n  type TrackingOptions,\n} from \"@aws-sdk/client-sesv2\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\n\n/**\n * Properties for configuring AWS SES resources\n */\nexport interface SESProps {\n  /**\n   * Name of the configuration set\n   * Used to group email sending and tracking settings\n   */\n  configurationSetName?: string;\n\n  /**\n   * Email identity to verify (email address or domain)\n   * For domains, use the format \"example.com\"\n   * For email addresses, use the format \"user@example.com\"\n   */\n  emailIdentity?: string;\n\n  /**\n   * Whether to enable DKIM signing for the email identity\n   * DKIM helps prevent email spoofing by verifying sender authenticity\n   */\n  enableDkim?: boolean;\n\n  /**\n   * Sending options for the configuration set\n   * Controls whether email sending is enabled and related settings\n   */\n  sendingOptions?: SendingOptions;\n\n  /**\n   * Reputation options for the configuration set\n   * Controls reputation tracking and metrics collection\n   */\n  reputationOptions?: ReputationOptions;\n\n  /**\n   * Tracking options for the configuration set\n   * Controls open and click tracking with optional custom domains\n   */\n  trackingOptions?: TrackingOptions;\n\n  /**\n   * Suppression options for the configuration set\n   * Controls how bounces and complaints are handled\n   */\n  suppressionOptions?: SuppressionOptions;\n\n  /**\n   * Delivery options for the configuration set\n   * Controls TLS settings and sending pool configuration\n   */\n  deliveryOptions?: DeliveryOptions;\n\n  /**\n   * Tags to apply to the SES resources\n   * Key-value pairs for resource organization\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after SES resource creation/update\n */\nexport interface SES extends Resource<\"aws::SES\">, SESProps {\n  /**\n   * ARN of the configuration set if created\n   * Format: arn:aws:ses:region:account-id:configuration-set/name\n   */\n  configurationSetArn?: string;\n\n  /**\n   * Email identity verification status if an identity was created\n   * Can be \"PENDING\" or \"VERIFIED\"\n   */\n  emailIdentityVerificationStatus?: string;\n\n  /**\n   * DKIM verification status if DKIM was enabled\n   * Can be \"PENDING\", \"SUCCESS\", \"FAILED\", \"TEMPORARY_FAILURE\", or \"NOT_STARTED\"\n   */\n  dkimVerificationStatus?: string;\n\n  /**\n   * Email identity ARN if an identity was created\n   * Format: arn:aws:ses:region:account-id:identity/name\n   */\n  emailIdentityArn?: string;\n}\n\n/**\n * AWS SES Resource\n *\n * Creates and manages Amazon Simple Email Service (SES) configuration sets and email identities.\n * Supports email sending configuration, DKIM signing, and identity verification.\n *\n * @example\n * // Create a configuration set with sending options\n * const configSet = await SES(\"email-config\", {\n *   configurationSetName: \"my-email-config\",\n *   sendingOptions: {\n *     SendingEnabled: true\n *   },\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"notifications\"\n *   }\n * });\n *\n * @example\n * // Create and verify a domain identity with DKIM\n * const domainIdentity = await SES(\"domain-identity\", {\n *   emailIdentity: \"example.com\",\n *   enableDkim: true,\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"transactional-emails\"\n *   }\n * });\n *\n * @example\n * // Update configuration set sending options\n * const updatedConfig = await SES(\"email-config\", {\n *   configurationSetName: \"my-email-config\",\n *   sendingOptions: {\n *     SendingEnabled: false\n *   },\n *   tags: {\n *     Environment: \"production\",\n *     Project: \"notifications\",\n *     Updated: \"true\"\n *   }\n * });\n */\nexport const SES = Resource(\n  \"aws::SES\",\n  async function (\n    this: Context<SES>,\n    id: string,\n    props: SESProps,\n  ): Promise<SES> {\n    // Create SES client\n    const client = new SESv2Client({});\n\n    // Resource ID is either based on the configuration set name or email identity\n    // const id =\n    //   props.configurationSetName || props.emailIdentity || this.resourceID;\n\n    // Handle deletion\n    if (this.phase === \"delete\") {\n      const output = this.output;\n\n      // Delete configuration set if it exists\n      if (output?.configurationSetName) {\n        await ignore(NotFoundException.name, () =>\n          client.send(\n            new DeleteConfigurationSetCommand({\n              ConfigurationSetName: output.configurationSetName,\n            }),\n          ),\n        );\n      }\n\n      // Delete email identity if it exists\n      if (output?.emailIdentity) {\n        await ignore(NotFoundException.name, () =>\n          client.send(\n            new DeleteEmailIdentityCommand({\n              EmailIdentity: output.emailIdentity,\n            }),\n          ),\n        );\n      }\n\n      // Return empty output for delete\n      return this.destroy();\n    }\n\n    // Created resources\n    let configurationSetArn: string | undefined;\n    let emailIdentityArn: string | undefined;\n    let emailIdentityVerificationStatus: string | undefined;\n    let dkimVerificationStatus: string | undefined;\n\n    // Create or update configuration set if specified\n    if (props.configurationSetName) {\n      // Check if configuration set exists\n      let configSetExists = false;\n      try {\n        await client.send(\n          new GetConfigurationSetCommand({\n            ConfigurationSetName: props.configurationSetName,\n          }),\n        );\n        configSetExists = true;\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          configSetExists = false;\n        } else {\n          throw error;\n        }\n      }\n\n      if (configSetExists) {\n        // Update existing configuration set using appropriate update commands\n        if (props.sendingOptions) {\n          await client.send(\n            new PutConfigurationSetSendingOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              SendingEnabled: props.sendingOptions.SendingEnabled,\n            }),\n          );\n        }\n\n        if (props.reputationOptions) {\n          await client.send(\n            new PutConfigurationSetReputationOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              ReputationMetricsEnabled:\n                props.reputationOptions.ReputationMetricsEnabled,\n            }),\n          );\n        }\n\n        if (props.trackingOptions) {\n          await client.send(\n            new PutConfigurationSetTrackingOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              CustomRedirectDomain: props.trackingOptions.CustomRedirectDomain,\n            }),\n          );\n        }\n\n        if (props.suppressionOptions) {\n          await client.send(\n            new PutConfigurationSetSuppressionOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              SuppressedReasons: props.suppressionOptions.SuppressedReasons,\n            }),\n          );\n        }\n\n        if (props.deliveryOptions) {\n          await client.send(\n            new PutConfigurationSetDeliveryOptionsCommand({\n              ConfigurationSetName: props.configurationSetName,\n              TlsPolicy: props.deliveryOptions.TlsPolicy,\n              SendingPoolName: props.deliveryOptions.SendingPoolName,\n            }),\n          );\n        }\n\n        // In SESv2, the ARN isn't directly returned in the response\n        configurationSetArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:configuration-set/${props.configurationSetName}`;\n      } else {\n        // Create new configuration set\n        await client.send(\n          new CreateConfigurationSetCommand({\n            ConfigurationSetName: props.configurationSetName,\n            SendingOptions: props.sendingOptions,\n            ReputationOptions: props.reputationOptions,\n            TrackingOptions: props.trackingOptions,\n            SuppressionOptions: props.suppressionOptions,\n            DeliveryOptions: props.deliveryOptions,\n            Tags: Object.entries(props.tags || {}).map(([Key, Value]) => ({\n              Key,\n              Value,\n            })),\n          }),\n        );\n\n        // In SESv2, the ARN isn't directly returned in the response\n        configurationSetArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:configuration-set/${props.configurationSetName}`;\n      }\n    }\n\n    // Create or verify email identity if specified\n    if (props.emailIdentity) {\n      // Check if identity exists\n      let getIdentityResult;\n      try {\n        getIdentityResult = await client.send(\n          new GetEmailIdentityCommand({\n            EmailIdentity: props.emailIdentity,\n          }),\n        );\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          getIdentityResult = null;\n        } else {\n          throw error;\n        }\n      }\n\n      if (!getIdentityResult) {\n        // Create new email identity\n        const createIdentityResult = await client.send(\n          new CreateEmailIdentityCommand({\n            EmailIdentity: props.emailIdentity,\n            Tags: Object.entries(props.tags || {}).map(([Key, Value]) => ({\n              Key,\n              Value,\n            })),\n          }),\n        );\n\n        // If it's an email address, we don't need to explicitly verify in v2\n        // The verification email is automatically sent by SES in v2\n\n        // Store the identity information\n        emailIdentityArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:identity/${props.emailIdentity}`;\n        emailIdentityVerificationStatus =\n          createIdentityResult.VerifiedForSendingStatus\n            ? \"VERIFIED\"\n            : \"PENDING\";\n      } else {\n        // Store the identity information\n        emailIdentityArn = `arn:aws:ses:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:identity/${props.emailIdentity}`;\n        emailIdentityVerificationStatus =\n          getIdentityResult.VerifiedForSendingStatus ? \"VERIFIED\" : \"PENDING\";\n\n        // Update DKIM settings if requested\n        if (props.enableDkim !== undefined) {\n          if (props.enableDkim) {\n            await client.send(\n              new PutEmailIdentityDkimAttributesCommand({\n                EmailIdentity: props.emailIdentity,\n                SigningEnabled: true,\n              }),\n            );\n\n            // We can check the current status of DKIM\n            dkimVerificationStatus = \"PENDING\"; // Default to pending\n\n            // Get the updated identity to check DKIM status\n            const updatedIdentity = await client.send(\n              new GetEmailIdentityCommand({\n                EmailIdentity: props.emailIdentity,\n              }),\n            );\n\n            if (updatedIdentity.DkimAttributes?.Status) {\n              dkimVerificationStatus = updatedIdentity.DkimAttributes.Status;\n            }\n          }\n        }\n      }\n    }\n\n    // Return the resource output\n    return this({\n      ...props,\n      configurationSetArn,\n      emailIdentityArn,\n      emailIdentityVerificationStatus,\n      dkimVerificationStatus,\n    });\n  },\n);\n\n```\n\n// alchemy/src/aws/table.ts\n```ts\nimport {\n  CreateTableCommand,\n  DeleteTableCommand,\n  DescribeTableCommand,\n  DynamoDBClient,\n  InternalServerError,\n  type KeySchemaElement,\n  ResourceInUseException,\n  ResourceNotFoundException,\n} from \"@aws-sdk/client-dynamodb\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { ignore } from \"../util/ignore\";\nimport { withExponentialBackoff } from \"../util/retry\";\n\n/**\n * Properties for creating or updating a DynamoDB table\n */\nexport interface TableProps {\n  /**\n   * Name of the DynamoDB table\n   */\n  tableName: string;\n\n  /**\n   * Primary partition key (hash key) configuration\n   * Defines the main identifier for items in the table\n   */\n  partitionKey: {\n    /**\n     * Name of the partition key attribute\n     */\n    name: string;\n    /**\n     * Data type of the partition key\n     * S: String, N: Number, B: Binary\n     */\n    type: \"S\" | \"N\" | \"B\";\n  };\n\n  /**\n   * Optional sort key (range key) configuration\n   * Used to sort items with the same partition key\n   */\n  sortKey?: {\n    /**\n     * Name of the sort key attribute\n     */\n    name: string;\n    /**\n     * Data type of the sort key\n     * S: String, N: Number, B: Binary\n     */\n    type: \"S\" | \"N\" | \"B\";\n  };\n\n  /**\n   * Billing mode for the table\n   * PROVISIONED: Set read/write capacity units\n   * PAY_PER_REQUEST: Pay per request pricing\n   */\n  billingMode?: \"PROVISIONED\" | \"PAY_PER_REQUEST\";\n\n  /**\n   * Read capacity units when using PROVISIONED billing mode\n   * Default: 5\n   */\n  readCapacity?: number;\n\n  /**\n   * Write capacity units when using PROVISIONED billing mode\n   * Default: 5\n   */\n  writeCapacity?: number;\n\n  /**\n   * Tags to apply to the table\n   * Key-value pairs for resource organization\n   */\n  tags?: Record<string, string>;\n}\n\n/**\n * Output returned after DynamoDB table creation/update\n */\nexport interface Table extends Resource<\"dynamo::Table\">, TableProps {\n  /**\n   * ARN of the table\n   * Format: arn:aws:dynamodb:region:account-id:table/table-name\n   */\n  arn: string;\n\n  /**\n   * ARN of the table's stream if enabled\n   * Format: arn:aws:dynamodb:region:account-id:table/table-name/stream/timestamp\n   */\n  streamArn?: string;\n\n  /**\n   * Unique identifier for the table\n   */\n  tableId: string;\n}\n\n/**\n * AWS DynamoDB Table Resource\n *\n * Creates and manages DynamoDB tables with support for partition and sort keys,\n * flexible billing modes, and automatic table status monitoring.\n *\n * @example\n * // Create a table with partition and sort key\n * const table = await Table(\"user-events\", {\n *   tableName: \"user-events\",\n *   partitionKey: {\n *     name: \"id\",\n *     type: \"S\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"N\"\n *   },\n *   tags: {\n *     Environment: \"test\"\n *   }\n * });\n *\n * @example\n * // Create a table with provisioned capacity\n * const table = await Table(\"high-throughput\", {\n *   tableName: \"high-throughput\",\n *   partitionKey: {\n *     name: \"userId\",\n *     type: \"S\"\n *   },\n *   billingMode: \"PROVISIONED\",\n *   readCapacity: 100,\n *   writeCapacity: 50\n * });\n */\nexport const Table = Resource(\n  \"dynamo::Table\",\n  async function (\n    this: Context<Table>,\n    id: string,\n    props: TableProps\n  ): Promise<Table> {\n    const client = new DynamoDBClient({});\n\n    (\"foo\");\n\n    if (this.phase === \"delete\") {\n      await withExponentialBackoff(\n        async () => {\n          await ignore(ResourceNotFoundException.name, () =>\n            client.send(\n              new DeleteTableCommand({\n                TableName: props.tableName,\n              })\n            )\n          );\n        },\n        isRetryableError,\n        10, // Max attempts\n        200 // Initial delay in ms\n      );\n\n      // Wait for table to be deleted\n      let tableDeleted = false;\n      let retryCount = 0;\n      const maxRetries = 60; // Wait up to 60 seconds\n\n      while (!tableDeleted && retryCount < maxRetries) {\n        try {\n          await client.send(\n            new DescribeTableCommand({\n              TableName: props.tableName,\n            })\n          );\n          // If we get here, table still exists\n          retryCount++;\n          // Increasing delay for each retry with some jitter\n          const delay = Math.min(1000 * (1 + 0.1 * Math.random()), 5000);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        } catch (error) {\n          if (error instanceof ResourceNotFoundException) {\n            tableDeleted = true;\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      if (!tableDeleted) {\n        throw new Error(\n          `Timed out waiting for table ${props.tableName} to be deleted`\n        );\n      }\n\n      return this.destroy();\n    } else {\n      // Setup for table creation\n      const attributeDefinitions = [\n        {\n          AttributeName: props.partitionKey.name,\n          AttributeType: props.partitionKey.type,\n        },\n      ];\n\n      const keySchema: KeySchemaElement[] = [\n        {\n          AttributeName: props.partitionKey.name,\n          KeyType: \"HASH\",\n        },\n      ];\n\n      if (props.sortKey) {\n        attributeDefinitions.push({\n          AttributeName: props.sortKey.name,\n          AttributeType: props.sortKey.type,\n        });\n        keySchema.push({\n          AttributeName: props.sortKey.name,\n          KeyType: \"RANGE\",\n        });\n      }\n\n      // Attempt to create the table with exponential backoff for ResourceInUseException\n      await withExponentialBackoff(\n        async () => {\n          try {\n            // First check if table already exists\n            const describeResponse = await client.send(\n              new DescribeTableCommand({\n                TableName: props.tableName,\n              })\n            );\n\n            // If table exists and is ACTIVE, no need to create it\n            if (describeResponse.Table?.TableStatus === \"ACTIVE\") {\n              return;\n            }\n\n            // If table exists but not ACTIVE, wait for it in the polling loop below\n            if (describeResponse.Table) {\n              return;\n            }\n          } catch (error) {\n            if (error instanceof ResourceNotFoundException) {\n              // Table doesn't exist, try to create it\n              await client.send(\n                new CreateTableCommand({\n                  TableName: props.tableName,\n                  AttributeDefinitions: attributeDefinitions,\n                  KeySchema: keySchema,\n                  BillingMode: props.billingMode || \"PAY_PER_REQUEST\",\n                  ProvisionedThroughput:\n                    props.billingMode === \"PROVISIONED\"\n                      ? {\n                          ReadCapacityUnits: props.readCapacity || 5,\n                          WriteCapacityUnits: props.writeCapacity || 5,\n                        }\n                      : undefined,\n                  Tags: props.tags\n                    ? Object.entries(props.tags).map(([Key, Value]) => ({\n                        Key,\n                        Value,\n                      }))\n                    : undefined,\n                })\n              );\n            } else {\n              throw error;\n            }\n          }\n        },\n        isRetryableError,\n        10, // Max attempts\n        200 // Initial delay in ms\n      );\n\n      // Wait for table to be active with timeout\n      let tableActive = false;\n      let tableDescription;\n      let retryCount = 0;\n      const maxRetries = 60; // Wait up to 60 seconds\n\n      while (!tableActive && retryCount < maxRetries) {\n        try {\n          const response = await client.send(\n            new DescribeTableCommand({\n              TableName: props.tableName,\n            })\n          );\n\n          tableActive = response.Table?.TableStatus === \"ACTIVE\";\n          if (tableActive) {\n            tableDescription = response.Table;\n          } else {\n            retryCount++;\n            // Increasing delay for each retry with some jitter\n            const delay = Math.min(1000 * (1 + 0.1 * Math.random()), 5000);\n            await new Promise((resolve) => setTimeout(resolve, delay));\n          }\n        } catch (error) {\n          retryCount++;\n          if (!(error instanceof ResourceNotFoundException)) {\n            throw error;\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1000));\n        }\n      }\n\n      if (!tableActive) {\n        throw new Error(\n          `Timed out waiting for table ${props.tableName} to become active`\n        );\n      }\n\n      return this({\n        ...props,\n        arn: tableDescription!.TableArn!,\n        streamArn: tableDescription!.LatestStreamArn,\n        tableId: tableDescription!.TableId!,\n      });\n    }\n  }\n);\n\nconst retryableErrors = [\n  \"ResourceInUseException\",\n  \"ResourceNotFoundException\",\n  \"InternalServerError\",\n  \"ThrottlingException\",\n  \"ProvisionedThroughputExceededException\",\n  \"LimitExceededException\",\n  \"RequestLimitExceeded\",\n];\n\nfunction isRetryableError(error: any) {\n  return (\n    error instanceof ResourceInUseException ||\n    error instanceof InternalServerError ||\n    retryableErrors.includes(error?.name) ||\n    retryableErrors.includes(error?.code) ||\n    error?.$metadata?.httpStatusCode === 500\n  );\n}\n\n```"
  }
}