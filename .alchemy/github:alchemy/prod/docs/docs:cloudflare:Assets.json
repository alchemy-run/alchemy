{
  "kind": "docs::Document",
  "id": "docs/cloudflare/Assets",
  "fqn": "github:alchemy/prod/docs/docs/cloudflare/Assets",
  "seq": 14,
  "data": {},
  "status": "updated",
  "output": {
    "title": "Assets",
    "path": "alchemy-web/docs/providers/cloudflare/assets.md",
    "freeze": true,
    "model": {
      "id": "claude-3-5-sonnet-latest",
      "provider": "anthropic"
    },
    "prompt": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         cloudflare Service:\n[bound.ts](alchemy/src/cloudflare/bound.ts)\n\n[custom-domain.ts](alchemy/src/cloudflare/custom-domain.ts)\n\n[durable-object-namespace.ts](alchemy/src/cloudflare/durable-object-namespace.ts)\n\n[api-error.ts](alchemy/src/cloudflare/api-error.ts)\n\n[bindings.ts](alchemy/src/cloudflare/bindings.ts)\n\n[zone.ts](alchemy/src/cloudflare/zone.ts)\n\n[assets.ts](alchemy/src/cloudflare/assets.ts)\n\n[account-id.ts](alchemy/src/cloudflare/account-id.ts)\n\n[dns-records.ts](alchemy/src/cloudflare/dns-records.ts)\n\n[api.ts](alchemy/src/cloudflare/api.ts)\n\n[worker-metadata.ts](alchemy/src/cloudflare/worker-metadata.ts)\n\n[types.ts](alchemy/src/cloudflare/types.ts)\n\n[response.ts](alchemy/src/cloudflare/response.ts)\n\n[zone-settings.ts](alchemy/src/cloudflare/zone-settings.ts)\n\n[r2-rest-state-store.ts](alchemy/src/cloudflare/r2-rest-state-store.ts)\n\n[permission-groups.ts](alchemy/src/cloudflare/permission-groups.ts)\n\n[wrangler.json.ts](alchemy/src/cloudflare/wrangler.json.ts)\n\n[bucket.ts](alchemy/src/cloudflare/bucket.ts)\n\n[kv-namespace.ts](alchemy/src/cloudflare/kv-namespace.ts)\n\n[account-api-token.ts](alchemy/src/cloudflare/account-api-token.ts)\n\n[worker-migration.ts](alchemy/src/cloudflare/worker-migration.ts)\n\n[auth.ts](alchemy/src/cloudflare/auth.ts)\n\n[worker.ts](alchemy/src/cloudflare/worker.ts)\n\n[asset-manifest.ts](alchemy/src/cloudflare/asset-manifest.ts)\n\nWrite concise documentation for the \"        Assets\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         Assets\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         Assets } from \"alchemy/        cloudflare\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         Assets } from \"alchemy/        cloudflare\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        # Bind to a Worker\n(if it is a Cloudflare Resource)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport { Worker,         Assets } from \"alchemy/        cloudflare\";\n\nconst myResource = await         Assets(\"my-resource\", {\n  // ...\n});\n\nawait Worker(\"my-worker\", {\n  name: \"my-worker\",\n  script: \"console.log('Hello, world!')\",\n  bindings: {\n    myResource,\n  },\n});\n```\n\n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Creating Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroying Resources\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value 😵‍💫\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n// env.d.ts\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n### 4. Scope-Based Destruction\n\n```typescript\n// Destroy all resources in a scope\nimport { destroy } from \"alchemy\";\nconst scope = alchemy.scope(\"temporary\");\nconst tempFile = await File(\"temp.txt\", { ... });\n\nawait destroy(scope);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// Clean up test resources reliably with try/finally\nconst scope = alchemy.scope(\"test\");\ntry {\n  // Create test resources\n} finally {\n  await destroy(scope);\n}\n```\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\n├── dev (Stage Scope)\n│   ├── api (Nested Scope)\n│   └── database (Resource)\n└── prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/cloudflare/account-api-token.ts\n```ts\nimport { alchemy } from \"../alchemy\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { Secret } from \"../secret\";\nimport { sha256 } from \"../util/sha256\";\nimport { createCloudflareApi, type CloudflareApiOptions } from \"./api\";\n\n/**\n * Permission group for a token policy\n */\nexport interface TokenPolicyPermissionGroup {\n  /**\n   * ID of the permission group\n   */\n  id: string;\n\n  /**\n   * Optional metadata for the permission group\n   */\n  meta?: Record<string, any>;\n}\n\n/**\n * Policy that defines what the token can access\n */\nexport interface TokenPolicy {\n  /**\n   * Effect of the policy\n   */\n  effect: \"allow\" | \"deny\";\n\n  /**\n   * Permission groups to include in the policy\n   */\n  permissionGroups: TokenPolicyPermissionGroup[];\n\n  /**\n   * Resources the policy applies to\n   */\n  resources: Record<string, string>;\n}\n\n/**\n * Condition for token usage (e.g., IP restrictions)\n */\nexport interface TokenCondition {\n  /**\n   * IP address conditions\n   */\n  requestIp?: {\n    /**\n     * IP ranges to allow\n     */\n    in?: string[];\n\n    /**\n     * IP ranges to deny\n     */\n    notIn?: string[];\n  };\n}\n\n/**\n * Properties for creating or updating an Account API Token\n */\nexport interface AccountApiTokenProps extends CloudflareApiOptions {\n  /**\n   * Name of the token\n   */\n  name: string;\n\n  /**\n   * Policies that define what the token can access\n   */\n  policies: TokenPolicy[];\n\n  /**\n   * Optional expiration date for the token (ISO format)\n   */\n  expiresOn?: string;\n\n  /**\n   * Optional \"not before\" date (token is not valid before this date) (ISO format)\n   */\n  notBefore?: string;\n\n  /**\n   * Optional conditions for token use (like IP restrictions)\n   */\n  condition?: TokenCondition;\n}\n\n/**\n * Cloudflare API token format as returned by the API\n */\ninterface CloudflareApiToken {\n  id: string;\n  name: string;\n  status: string;\n  policies: {\n    effect: \"allow\" | \"deny\";\n    permission_groups: {\n      id: string;\n      meta: Record<string, any>;\n    }[];\n    resources: Record<string, string>;\n  }[];\n  expires_on?: string;\n  not_before?: string;\n  condition?: {\n    request_ip?: {\n      in?: string[];\n      not_in?: string[];\n    };\n  };\n  value?: string;\n}\n\n/**\n * Output returned after Account API Token creation/update\n */\nexport interface AccountApiToken\n  extends Resource<\"cloudflare::AccountApiToken\">,\n    AccountApiTokenProps {\n  /**\n   * The ID of the token\n   *\n   * Equiv. to ACCESS_KEY_ID\n   */\n  id: string;\n\n  /**\n   * Status of the token\n   */\n  status: string;\n\n  /**\n   * Actual token value (only available on creation)\n   * Stored as a Secret for security\n   *\n   * Equiv. to SECRET_ACCESS_KEY\n   */\n  value?: Secret;\n\n  /**\n   * Access key ID for the token\n   *\n   * An alias of {@link id}\n   */\n  accessKeyId: string;\n\n  /**\n   * Secret access key for the token\n   *\n   * The SHA-256 hash of the token {@link value}\n   *\n   * @see https://developers.cloudflare.com/r2/api/tokens/#get-s3-api-credentials-from-an-api-token\n   */\n  secretAccessKey: string;\n}\n\n/**\n * Creates a Cloudflare Account API Token with specified permissions.\n *\n * Note: Requires a Cloudflare API Key or Token with admin-level account access.\n * The OAuth token from `wrangler login` is NOT sufficient for this operation.\n * You must use an API token with permission to manage account API tokens.\n *\n * @see https://developers.cloudflare.com/api/resources/accounts/subresources/tokens/methods/create/\n *\n * @example\n * // First, fetch all permission groups\n * const permissions = await PermissionGroups(\"cloudflare-permissions\", {\n *   accountId: cfAccountId,\n * });\n *\n * // Create a token with read-only permissions for specific zones\n * const readOnlyToken = await AccountApiToken(\"readonly-token\", {\n *   name: \"Readonly Zone Token\",\n *   policies: [\n *     {\n *       effect: \"allow\",\n *       permissionGroups: [\n *         { id: permissions[\"Zone Read\"].id },\n *         { id: permissions[\"Analytics Read\"].id }\n *       ],\n *       resources: {\n *         \"com.cloudflare.api.account.zone.22b1de5f1c0e4b3ea97bb1e963b06a43\": \"*\",\n *         \"com.cloudflare.api.account.zone.eb78d65290b24279ba6f44721b3ea3c4\": \"*\"\n *       }\n *     }\n *   ],\n *   expiresOn: \"2024-12-31T23:59:59Z\"\n * });\n *\n * @example\n * // Create a token with time and IP restrictions\n * const restrictedToken = await AccountApiToken(\"restricted-token\", {\n *   name: \"Restricted Access Token\",\n *   policies: [\n *     {\n *       effect: \"allow\",\n *       permissionGroups: [\n *         { id: permissions[\"Worker Routes Edit\"].id }\n *       ],\n *       resources: {\n *         \"com.cloudflare.api.account.worker.route.*\": \"*\"\n *       }\n *     }\n *   ],\n *   notBefore: \"2023-01-01T00:00:00Z\",\n *   expiresOn: \"2023-12-31T23:59:59Z\",\n *   condition: {\n *     requestIp: {\n *       in: [\"192.168.1.0/24\", \"10.0.0.0/8\"],\n *       notIn: [\"192.168.1.100/32\"]\n *     }\n *   }\n * });\n */\nexport const AccountApiToken = Resource(\n  \"cloudflare::AccountApiToken\",\n  async function (\n    this: Context<AccountApiToken>,\n    id: string,\n    props: AccountApiTokenProps\n  ): Promise<AccountApiToken> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    if (this.phase === \"delete\") {\n      // Delete token if we have an ID\n      if (this.output?.id) {\n        try {\n          const deleteResponse = await api.delete(\n            `/accounts/${api.accountId}/tokens/${this.output.id}`\n          );\n\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            const errorData: any = await deleteResponse.json().catch(() => ({\n              errors: [{ message: deleteResponse.statusText }],\n            }));\n            console.error(`Error deleting token '${props.name}':`, errorData);\n          }\n        } catch (error) {\n          console.error(`Error deleting token '${props.name}':`, error);\n        }\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    }\n\n    // Transform our properties to API format\n    const apiPayload = {\n      name: props.name,\n      policies: props.policies.map((policy) => ({\n        effect: policy.effect,\n        permission_groups: policy.permissionGroups.map((pg) => ({\n          id: pg.id,\n          meta: pg.meta || {},\n        })),\n        resources: policy.resources,\n      })),\n      // Format dates for Cloudflare API (removing milliseconds)\n      ...(props.expiresOn\n        ? { expires_on: formatCloudflareDate(props.expiresOn) }\n        : {}),\n      ...(props.notBefore\n        ? { not_before: formatCloudflareDate(props.notBefore) }\n        : {}),\n      ...(props.condition\n        ? {\n            condition: {\n              request_ip: props.condition.requestIp\n                ? {\n                    in: props.condition.requestIp.in || [],\n                    not_in: props.condition.requestIp.notIn || [],\n                  }\n                : undefined,\n            },\n          }\n        : {}),\n    };\n\n    /**\n     * Formats a date string for Cloudflare API by removing milliseconds\n     * Converts from \"2023-01-01T00:00:00.000Z\" to \"2023-01-01T00:00:00Z\"\n     */\n    function formatCloudflareDate(dateStr: string): string {\n      return dateStr.replace(/\\.\\d{3}Z$/, \"Z\");\n    }\n\n    let response;\n    let tokenValue;\n\n    if (this.phase === \"update\" && this.output?.id) {\n      // Update existing token\n      response = await api.put(\n        `/accounts/${api.accountId}/tokens/${this.output.id}`,\n        apiPayload\n      );\n    } else {\n      // Create new token\n      response = await api.post(\n        `/accounts/${api.accountId}/tokens`,\n        apiPayload\n      );\n    }\n\n    if (!response.ok) {\n      const errorData: any = await response.json().catch(() => ({\n        errors: [{ message: response.statusText }],\n      }));\n\n      throw new Error(\n        `Error ${this.phase === \"update\" ? \"updating\" : \"creating\"} token '${props.name}': ${\n          errorData.errors?.[0]?.message || response.statusText\n        }`\n      );\n    }\n\n    const result: { result: CloudflareApiToken } = await response.json();\n    const tokenData = result.result;\n\n    if (tokenData.value) {\n      tokenValue = alchemy.secret(tokenData.value);\n    } else {\n      if (!this.output?.value) {\n        throw new Error(\n          `Token '${props.name}' was created but we have no record of its value. Try deleting and recreating the token.`\n        );\n      }\n      tokenValue = this.output?.value;\n    }\n\n    // Transform API response to our format\n    return this({\n      id: tokenData.id,\n      name: tokenData.name,\n      status: tokenData.status,\n      policies: tokenData.policies.map((policy) => ({\n        effect: policy.effect,\n        permissionGroups: policy.permission_groups.map((pg) => ({\n          id: pg.id,\n          meta: pg.meta,\n        })),\n        resources: policy.resources,\n      })),\n      ...(tokenData.expires_on ? { expiresOn: tokenData.expires_on } : {}),\n      ...(tokenData.not_before ? { notBefore: tokenData.not_before } : {}),\n      ...(tokenData.condition\n        ? {\n            condition: {\n              requestIp: tokenData.condition.request_ip\n                ? {\n                    in: tokenData.condition.request_ip.in || [],\n                    notIn: tokenData.condition.request_ip.not_in || [],\n                  }\n                : undefined,\n            },\n          }\n        : {}),\n      value: tokenValue,\n      accessKeyId: tokenData.id,\n      secretAccessKey: sha256(tokenValue.unencrypted),\n    });\n  }\n);\n\n```\n\n// alchemy/src/cloudflare/account-id.ts\n```ts\nimport { getCloudflareUserInfo, type CloudflareAuthOptions } from \"./auth\";\n\nexport type CloudflareAccountId = string & {\n  readonly __brand: \"CloudflareAccountId\";\n};\n\nexport async function CloudflareAccountId(\n  options: CloudflareAuthOptions\n): Promise<CloudflareAccountId> {\n  const userInfo = await getCloudflareUserInfo(options);\n  return userInfo.accounts[0].id as CloudflareAccountId;\n}\n\n```\n\n// alchemy/src/cloudflare/api-error.ts\n```ts\n/**\n * Custom error class for Cloudflare API errors\n * Includes HTTP status information from the Response\n */\nexport class CloudflareApiError extends Error {\n  /**\n   * HTTP status code\n   */\n  status: number;\n\n  /**\n   * HTTP status text\n   */\n  statusText: string;\n\n  /**\n   * Raw error data from the API\n   */\n  errorData?: any;\n\n  /**\n   * Create a new CloudflareApiError\n   */\n  constructor(message: string, response: Response, errorData?: any) {\n    super(message);\n    this.name = \"CloudflareApiError\";\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.errorData = errorData;\n\n    // Ensure instanceof works correctly\n    Object.setPrototypeOf(this, CloudflareApiError.prototype);\n  }\n}\n\n/**\n * Helper function to handle API errors\n *\n * @param response The fetch Response object\n * @param action The action being performed (e.g., \"creating\", \"deleting\")\n * @param resourceType The type of resource being acted upon (e.g., \"R2 bucket\", \"Worker\")\n * @param resourceName The name/identifier of the specific resource\n * @returns Never returns - always throws an error\n */\nexport async function handleApiError(\n  response: Response,\n  action: string,\n  resourceType: string,\n  resourceName: string\n): Promise<never> {\n  const json: any = await response.json();\n  const errors: { message: string }[] = json.errors || [\n    { message: response.statusText },\n  ];\n  const errorMessage = `Error ${action} ${resourceType} '${resourceName}': ${errors[0]?.message || response.statusText}`;\n\n  throw new CloudflareApiError(errorMessage, response, errors);\n}\n\n```\n\n// alchemy/src/cloudflare/api.ts\n```ts\nimport type { Secret } from \"../secret\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport { getCloudflareAuthHeaders, getCloudflareUserInfo } from \"./auth\";\n\n/**\n * Options for Cloudflare API requests\n */\nexport interface CloudflareApiOptions {\n  /**\n   * Base URL for Cloudflare API\n   *\n   * @default https://api.cloudflare.com/client/v4\n   */\n  baseUrl?: string;\n\n  /**\n   * API Key to use (overrides CLOUDFLARE_API_KEY env var)\n   */\n  apiKey?: Secret;\n\n  /**\n   * API Token to use (overrides CLOUDFLARE_API_TOKEN env var)\n   */\n  apiToken?: Secret;\n\n  /**\n   * Account ID to use (overrides CLOUDFLARE_ACCOUNT_ID env var)\n   * If not provided, will be automatically retrieved from the Cloudflare API\n   */\n  accountId?: string;\n\n  /**\n   * Zone ID to use (overrides CLOUDFLARE_ZONE_ID env var)\n   */\n  zoneId?: string;\n\n  /**\n   * Email to use with API Key authentication\n   * If not provided, will attempt to discover from Cloudflare API\n   */\n  email?: string;\n}\n\n/**\n * Creates a CloudflareApi instance with automatic account ID discovery if not provided\n *\n * @param options API options\n * @returns Promise resolving to a CloudflareApi instance\n */\nexport async function createCloudflareApi(\n  options: Partial<CloudflareApiOptions> = {}\n): Promise<CloudflareApi> {\n  const userInfo = await getCloudflareUserInfo(options);\n  return new CloudflareApi({\n    baseUrl: options.baseUrl,\n    accountId: options.accountId ?? userInfo.accounts[0].id!,\n    email: userInfo.email!,\n    apiKey: userInfo.apiKey,\n    apiToken: userInfo.apiToken,\n    zoneId: options.zoneId,\n  });\n}\n\n/**\n * Cloudflare API client using raw fetch\n */\nexport class CloudflareApi {\n  public readonly accountId: string;\n  public readonly baseUrl: string;\n  /**\n   * Create a new Cloudflare API client\n   * Use createCloudflareApi factory function instead of direct constructor\n   * for automatic account ID discovery.\n   *\n   * @param options API options\n   */\n  constructor(\n    private readonly options: CloudflareApiOptions & {\n      accountId: string;\n    }\n  ) {\n    this.accountId = options.accountId;\n    this.baseUrl = options.baseUrl ?? \"https://api.cloudflare.com/client/v4\";\n  }\n\n  /**\n   * Make a fetch request to the Cloudflare API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n    if (Array.isArray(init.headers)) {\n      init.headers.forEach(([key, value]) => {\n        headers[key] = value;\n      });\n    } else if (init.headers instanceof Headers) {\n      init.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n    } else if (init.headers) {\n      headers = init.headers;\n    }\n    headers = {\n      ...(await getCloudflareAuthHeaders(this.options)),\n      ...headers,\n    };\n\n    // TODO(sam): is this necessary?\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Use withExponentialBackoff for automatic retry on network errors\n    return withExponentialBackoff(\n      () =>\n        fetch(`${this.baseUrl}${path}`, {\n          ...init,\n          headers,\n        }),\n      (error) => {\n        // Only retry on network-related errors\n        const errorMsg = (error as Error).message || \"\";\n        const isNetworkError =\n          errorMsg.includes(\"socket connection was closed\") ||\n          errorMsg.includes(\"ECONNRESET\") ||\n          errorMsg.includes(\"ETIMEDOUT\") ||\n          errorMsg.includes(\"ECONNREFUSED\");\n\n        return isNetworkError;\n      },\n      5, // Maximum 5 attempts (1 initial + 4 retries)\n      1000 // Start with 1s delay, will exponentially increase\n    );\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for HEAD requests\n   */\n  async head(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"HEAD\" });\n  }\n  /**\n   * Helper for POST requests\n   */\n  async post(\n    path: string,\n    body: any,\n    init: RequestInit = {}\n  ): Promise<Response> {\n    const requestBody =\n      body instanceof FormData\n        ? body\n        : typeof body === \"string\"\n          ? body\n          : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(\n    path: string,\n    body: any,\n    init: RequestInit = {}\n  ): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for PATCH requests\n   */\n  async patch(\n    path: string,\n    body: any,\n    init: RequestInit = {}\n  ): Promise<Response> {\n    return this.fetch(path, {\n      ...init,\n      method: \"PATCH\",\n      body: JSON.stringify(body),\n    });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/asset-manifest.ts\n```ts\nexport type AssetManifest = AssetManifestEntry[];\n\nexport interface AssetManifestEntry {\n  source: string;\n  key: string;\n  hash: string;\n  cacheControl: string;\n  contentType?: string;\n}\n\nexport interface FileOption {\n  files: string | string[];\n  cacheControl: string;\n  contentType?: string;\n  ignore?: string[];\n}\n\n```\n\n// alchemy/src/cloudflare/assets.ts\n```ts\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { getContentType } from \"../util/content-type\";\n\n/**\n * Properties for creating or updating Assets\n */\nexport interface AssetsProps {\n  /**\n   * Path to a directory containing static assets to be uploaded\n   * These files will be served by Cloudflare's Workers runtime\n   */\n  path: string;\n}\n\n/**\n * Output returned after Assets creation/update\n */\nexport interface Assets extends Resource<\"cloudflare::Asset\">, AssetsProps {\n  /**\n   * The type of binding\n   */\n  type: \"assets\";\n\n  /**\n   * The ID of the assets bundle\n   */\n  id: string;\n\n  /**\n   * Asset files that were found\n   */\n  files: AssetFile[];\n\n  /**\n   * Time at which the assets were created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the assets were last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Represents a single asset file\n */\nexport interface AssetFile {\n  /**\n   * Path relative to the assets directory\n   */\n  path: string;\n\n  /**\n   * Full filesystem path to the file\n   */\n  filePath: string;\n\n  /**\n   * Content type of the file\n   */\n  contentType: string;\n}\n\n/**\n * Cloudflare Assets represent a collection of static files that can be uploaded and served\n * by Cloudflare Workers.\n *\n * @example\n * // Create a basic assets bundle from a local directory\n * const staticAssets = await Assets(\"static\", {\n *   path: \"./src/assets\"\n * });\n *\n * // Use these assets with a worker\n * const worker = await Worker(\"frontend\", {\n *   name: \"frontend-worker\",\n *   entrypoint: \"./src/worker.ts\",\n *   bindings: {\n *     ASSETS: staticAssets\n *   }\n * });\n */\nexport const Assets = Resource(\n  \"cloudflare::Asset\",\n  {\n    alwaysUpdate: true,\n  },\n  async function (\n    this: Context<Assets>,\n    id: string,\n    props: AssetsProps\n  ): Promise<Assets> {\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    try {\n      // Check if the assets directory exists\n      const stats = await fs.stat(props.path);\n      if (!stats.isDirectory()) {\n        throw new Error(`Assets path ${props.path} is not a directory`);\n      }\n    } catch (error) {\n      throw new Error(\n        `Assets directory ${props.path} does not exist or is not accessible`\n      );\n    }\n\n    // Recursively get all files in the assets directory\n    const filesList = await getFilesRecursively(props.path);\n\n    // Create asset file objects\n    const files: AssetFile[] = filesList.map((filePath) => {\n      const relativePath = path.relative(props.path, filePath);\n      const normalizedPath = relativePath.split(path.sep).join(\"/\"); // Ensure forward slashes for URLs\n\n      return {\n        path: normalizedPath,\n        filePath,\n        contentType: getContentType(filePath),\n      };\n    });\n\n    // Get current timestamp\n    const now = Date.now();\n\n    // Construct the output\n    return this({\n      id,\n      type: \"assets\",\n      path: props.path,\n      files,\n      createdAt: this.output?.createdAt || now,\n      updatedAt: now,\n    });\n  }\n);\n\n// Helper functions for file operations\nasync function getFilesRecursively(dir: string): Promise<string[]> {\n  const files = await fs.readdir(dir, { withFileTypes: true });\n\n  const allFiles = await Promise.all(\n    files.map(async (file) => {\n      const path = `${dir}/${file.name}`;\n      if (file.isDirectory()) {\n        return getFilesRecursively(path);\n      }\n      return path;\n    })\n  );\n\n  return allFiles.flat();\n}\n\n```\n\n// alchemy/src/cloudflare/auth.ts\n```ts\nimport fs from \"node:fs/promises\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport type { Secret } from \"../secret\";\nimport type { CloudflareAccountId } from \"./account-id\";\nimport { handleApiError } from \"./api-error\";\n/**\n * Authentication options for Cloudflare API\n */\nexport interface CloudflareAuthOptions {\n  /**\n   * API Key to use with API Key\n   */\n  apiKey?: Secret;\n\n  /**\n   * API Token to use with API Key\n   */\n  apiToken?: Secret;\n\n  /**\n   * Email to use with API Key\n   * If not provided, will attempt to discover from Cloudflare API\n   */\n  email?: string;\n}\n\nexport interface CloudflareAccount {\n  name: string;\n  id: CloudflareAccountId;\n  type: \"standard\" | \"zero_rating\" | \"full_control\";\n  settings: {\n    enforce_twofactor: boolean;\n    api_access_enabled: null;\n    access_approval_expiry: null;\n    abuse_contact_email: null;\n  };\n  legacy_flags: {\n    enterprise_zone_quota: {\n      maximum: number;\n      current: number;\n      available: number;\n    };\n  };\n}\n\nexport interface CloudflareUserInfo {\n  apiToken?: Secret;\n  apiKey?: Secret;\n  email: string;\n  username: string;\n  accounts: CloudflareAccount[];\n  organizations: CloudflareOrganization[];\n  tokenPermissions: string[] | undefined;\n  first_name: string | null;\n  last_name: string | null;\n  telephone: string | null;\n  country: string | null;\n  zipcode: string | null;\n  two_factor_authentication_enabled: boolean;\n  two_factor_authentication_locked: boolean;\n  has_pro_zones: boolean;\n  has_business_zones: boolean;\n  has_enterprise_zones: boolean;\n  suspended: boolean;\n  betas: string[];\n}\n\nexport interface CloudflareOrganization {\n  id: string;\n  name: string;\n  status: string;\n  permissions: string[];\n  roles: string[];\n}\n\nconst userInfoCache: Record<string, CloudflareUserInfo> = {};\n\nexport async function getCloudflareUserInfo(\n  options: CloudflareAuthOptions\n): Promise<CloudflareUserInfo> {\n  const cacheKey = JSON.stringify({\n    apiKey: options.apiKey?.unencrypted,\n    apiToken: options.apiToken?.unencrypted,\n    email: options.email,\n  });\n  if (userInfoCache[cacheKey]) {\n    return userInfoCache[cacheKey];\n  }\n  const headers = await getCloudflareAuthHeaders(options);\n  const user = await fetch(\"https://api.cloudflare.com/client/v4/user\", {\n    headers,\n  });\n  if (!user.ok) {\n    if (user.status === 403) {\n      throw new Error(\n        \"Cloudflare authentication required. Did you forget to login with `wrangler login` or set CLOUDFLARE_API_TOKEN, CLOUDFLARE_API_KEY, or CLOUDFLARE_EMAIL, or CLOUDFLARE_API_KEY?\"\n      );\n    }\n    await handleApiError(user, \"getting\", \"user\", \"user\");\n  }\n  const accounts = await fetch(\n    \"https://api.cloudflare.com/client/v4/accounts\",\n    {\n      headers,\n    }\n  );\n  const userInfo: CloudflareUserInfo = {\n    ...((await user.json()) as any).result,\n    accounts: ((await accounts.json()) as any).result,\n  };\n  userInfoCache[cacheKey] = userInfo;\n  return userInfo;\n}\n\nexport async function getCloudflareAuthHeaders(\n  options: CloudflareAuthOptions = {}\n): Promise<Record<string, string>> {\n  // Check for API Token (preferred method)\n  const apiToken =\n    options.apiToken?.unencrypted ?? process.env.CLOUDFLARE_API_TOKEN;\n  if (apiToken) {\n    return {\n      Authorization: `Bearer ${apiToken}`,\n    };\n  }\n\n  // Check for API Key\n  const apiKey = options.apiKey?.unencrypted ?? process.env.CLOUDFLARE_API_KEY;\n  if (apiKey) {\n    return {\n      \"X-Auth-Key\": apiKey,\n      \"X-Auth-Email\":\n        options.email ??\n        process.env.CLOUDFLARE_EMAIL ??\n        (await getUserEmailFromApiKey(apiKey)),\n    };\n  }\n\n  const authConfig = await getRefreshedAuthConfig();\n  if (authConfig.oauth_token) {\n    return {\n      Authorization: `Bearer ${authConfig.oauth_token}`,\n    };\n  }\n\n  throw new Error(\n    \"Cloudflare authentication required. Did you forget to login with `wrangler login` or set CLOUDFLARE_API_TOKEN, CLOUDFLARE_API_KEY, or CLOUDFLARE_EMAIL, or CLOUDFLARE_API_KEY?\"\n  );\n}\n\nconst emailCache: Record<string, string> = {};\n\nasync function getUserEmailFromApiKey(apiKey: string): Promise<string> {\n  if (emailCache[apiKey]) {\n    return emailCache[apiKey];\n  }\n\n  try {\n    const baseUrl = \"https://api.cloudflare.com/client/v4\";\n\n    // Call the /user endpoint to get user information\n    const response = await fetch(`${baseUrl}/user`, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Auth-Key\": apiKey,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to get user information: ${response.status} ${response.statusText}`\n      );\n    }\n\n    const data = (await response.json()) as {\n      success: boolean;\n      result: {\n        id: string;\n        email: string;\n        name: string;\n        [key: string]: any;\n      };\n    };\n\n    if (!data.success || !data.result || !data.result.email) {\n      throw new Error(\"Cloudflare API did not return valid user information\");\n    }\n\n    emailCache[apiKey] = data.result.email;\n    return data.result.email;\n  } catch (error) {\n    console.error(\"Error retrieving email from Cloudflare API:\", error);\n    throw new Error(\n      \"Failed to automatically discover email for API Key authentication\"\n    );\n  }\n}\n\nasync function refreshAuthToken(\n  options: WranglerConfig\n): Promise<WranglerConfig> {\n  const response = await fetch(\"https://dash.cloudflare.com/oauth2/token\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    body: new URLSearchParams({\n      grant_type: \"refresh_token\",\n      refresh_token: options.refresh_token!,\n      client_id: \"54d11594-84e4-41aa-b438-e81b8fa78ee7\",\n    }).toString(),\n  });\n\n  if (!response.ok) {\n    throw new Error(\n      `Failed to refresh auth token: ${response.status} ${response.statusText}`\n    );\n  }\n\n  const data: any = await response.json();\n  if (!data.access_token) {\n    throw new Error(\"Failed to refresh auth token - no access token returned\");\n  }\n\n  options.oauth_token = data.access_token;\n  options.refresh_token = data.refresh_token;\n  options.expiration_time = new Date(\n    Date.now() + data.expires_in * 1000\n  ).toISOString();\n  options.scopes = data.scope?.split(\" \") || [];\n\n  return options;\n}\n\ninterface WranglerConfig {\n  path: string;\n  oauth_token?: string;\n  refresh_token?: string;\n  expiration_time?: string;\n  scopes?: string[];\n  /** @deprecated - this field was only provided by the deprecated v1 `wrangler config` command. */\n  api_token?: string;\n}\n\nasync function getRefreshedAuthConfig(): Promise<WranglerConfig> {\n  let authConfig = await readWranglerConfig();\n  if (authConfig.expiration_time) {\n    const expiry = new Date(authConfig.expiration_time);\n    // if expiring in 10s\n    if (expiry.getTime() < Date.now() + 10 * 1000) {\n      authConfig = await refreshAuthToken(authConfig);\n      authConfigCache[authConfig.path] = authConfig;\n      await writeWranglerConfig(authConfig);\n    }\n  }\n  return authConfig;\n}\n\nasync function writeWranglerConfig(config: WranglerConfig) {\n  const TOML = await import(\"@iarna/toml\");\n  const configPath = await findWranglerConfig();\n  config = {\n    ...config,\n  };\n  // @ts-ignore - i put this here\n  delete config.path;\n  const toml = TOML.stringify(config as any);\n  await fs.writeFile(configPath, toml);\n}\n\n// cache the file once per process\nconst authConfigCache: Record<string, WranglerConfig> = {};\n\nasync function readWranglerConfig(): Promise<WranglerConfig> {\n  const configPath = await findWranglerConfig();\n  const config = (authConfigCache[configPath] ??= await parseTOML(\n    await fs.readFile(configPath, \"utf-8\")\n  ));\n  config.path = configPath;\n  return config;\n}\n\nlet wranglerConfigPath: string | undefined;\n\nasync function findWranglerConfig(): Promise<string> {\n  if (wranglerConfigPath) {\n    return wranglerConfigPath;\n  }\n  const environment = process.env.WRANGLER_API_ENVIRONMENT ?? \"production\";\n  const filePath = path.join(\n    \"config\",\n    `${environment === \"production\" ? \"default.toml\" : `${environment}.toml`}`\n  );\n\n  const xdgAppPaths = (await import(\"xdg-app-paths\")).default;\n  //TODO: We should implement a custom path --global-config and/or the WRANGLER_HOME type environment variable\n  const configDir = xdgAppPaths(\".wrangler\").config(); // New XDG compliant config path\n  const legacyConfigDir = path.join(os.homedir(), \".wrangler\"); // Legacy config in user's home directory\n\n  // Check for the .wrangler directory in root if it is not there then use the XDG compliant path.\n  wranglerConfigPath = path.join(\n    (await isDirectory(legacyConfigDir)) ? legacyConfigDir : configDir,\n    filePath\n  );\n  return wranglerConfigPath;\n}\n\nasync function parseTOML(input: string): Promise<any> {\n  const TOML = await import(\"@iarna/toml\");\n  try {\n    // Normalize CRLF to LF to avoid hitting https://github.com/iarna/iarna-toml/issues/33.\n    const normalizedInput = input.replace(/\\r\\n/g, \"\\n\");\n    return TOML.parse(normalizedInput);\n  } catch (err: any) {\n    const { name } = err;\n    if (name !== \"TomlError\") {\n      throw err;\n    }\n    throw new Error(\"TOML parse error\");\n  }\n}\n\nasync function isDirectory(dir: string) {\n  try {\n    return (await fs.stat(dir)).isDirectory();\n  } catch (err) {\n    return false;\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/bindings.ts\n```ts\n/**\n * Type definitions for Cloudflare Worker bindings\n * Based on Cloudflare API documentation:\n * https://developers.cloudflare.com/api/resources/workers/subresources/scripts/methods/update/\n */\nimport type { Secret } from \"../secret\";\nimport type { Assets } from \"./assets\";\nimport type { R2Bucket } from \"./bucket\";\nimport type { DurableObjectNamespace } from \"./durable-object-namespace\";\nimport type { KVNamespace } from \"./kv-namespace\";\nimport type { Worker } from \"./worker\";\n\nexport type Bindings = {\n  [bindingName: string]: Binding;\n};\n\n/**\n * L2 Binding Resources.\n */\nexport type Binding =\n  | DurableObjectNamespace\n  | KVNamespace\n  | Worker\n  | R2Bucket\n  | Secret\n  | string\n  | Assets;\n\nexport function isDurableObjectNamespace(\n  binding: Binding\n): binding is DurableObjectNamespace {\n  return (\n    typeof binding === \"object\" && binding.type === \"durable_object_namespace\"\n  );\n}\n\n/**\n * Check if a binding is an Assets resource\n */\nexport function isAssets(binding: Binding): binding is Assets {\n  return typeof binding === \"object\" && binding.type === \"assets\";\n}\n\n/**\n * Union type for all Worker binding types (API spec)\n */\nexport type WorkerBindingSpec =\n  | WorkerBindingAI\n  | WorkerBindingAnalyticsEngine\n  | WorkerBindingAssets\n  | WorkerBindingBrowserRendering\n  | WorkerBindingD1\n  | WorkerBindingDispatchNamespace\n  | WorkerBindingDurableObjectNamespace\n  | WorkerBindingHyperdrive\n  | WorkerBindingJson\n  | WorkerBindingKVNamespace\n  | WorkerBindingMTLSCertificate\n  | WorkerBindingPlainText\n  | WorkerBindingQueue\n  | WorkerBindingR2Bucket\n  | WorkerBindingSecretText\n  | WorkerBindingService\n  | WorkerBindingStaticContent\n  | WorkerBindingTailConsumer\n  | WorkerBindingVectorize\n  | WorkerBindingVersionMetadata\n  | WorkerBindingWasmModule;\n\n/**\n * AI binding type\n */\nexport interface WorkerBindingAI {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for AI binding */\n  type: \"ai\";\n}\n\n/**\n * Analytics Engine binding type\n */\nexport interface WorkerBindingAnalyticsEngine {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Analytics Engine binding */\n  type: \"analytics_engine\";\n  /** Dataset name */\n  dataset: string;\n}\n\n/**\n * Assets binding type\n */\nexport interface WorkerBindingAssets {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Assets binding */\n  type: \"assets\";\n}\n\n/**\n * Browser Rendering binding type\n */\nexport interface WorkerBindingBrowserRendering {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Browser Rendering binding */\n  type: \"browser_rendering\";\n}\n\n/**\n * D1 database binding type\n */\nexport interface WorkerBindingD1 {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for D1 binding */\n  type: \"d1\";\n  /** D1 database ID */\n  id: string;\n}\n\n/**\n * Dispatch Namespace binding type\n */\nexport interface WorkerBindingDispatchNamespace {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Dispatch Namespace binding */\n  type: \"dispatch_namespace\";\n  /** Namespace identifier */\n  namespace: string;\n  /** Optional outbound service */\n  outbound?: any; // Documentation doesn't specify the exact type\n}\n\n/**\n * Durable Object Namespace binding type\n */\nexport interface WorkerBindingDurableObjectNamespace {\n  /**\n   * The stable ID of the binding\n   * @internal\n   */\n  stableId?: string;\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Durable Object Namespace binding */\n  type: \"durable_object_namespace\";\n  /** Durable Object class name */\n  class_name: string;\n  /** Script name that contains the Durable Object */\n  script_name?: string;\n  /** Environment */\n  environment?: string;\n  /** Namespace ID */\n  namespace_id?: string;\n}\n\n/**\n * Hyperdrive binding type\n */\nexport interface WorkerBindingHyperdrive {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Hyperdrive binding */\n  type: \"hyperdrive\";\n  /** Hyperdrive ID */\n  id: string;\n}\n\n/**\n * JSON binding type\n */\nexport interface WorkerBindingJson {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for JSON binding */\n  type: \"json\";\n  /** JSON value */\n  json: any;\n}\n\n/**\n * KV Namespace binding type\n */\nexport interface WorkerBindingKVNamespace {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for KV Namespace binding */\n  type: \"kv_namespace\";\n  /** KV Namespace ID */\n  namespace_id: string;\n}\n\n/**\n * MTLS Certificate binding type\n */\nexport interface WorkerBindingMTLSCertificate {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for MTLS Certificate binding */\n  type: \"mtls_certificate\";\n  /** Certificate ID */\n  certificate_id: string;\n}\n\n/**\n * Plain Text binding type\n */\nexport interface WorkerBindingPlainText {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Plain Text binding */\n  type: \"plain_text\";\n  /** Text content */\n  text: string;\n}\n\n/**\n * Queue binding type\n */\nexport interface WorkerBindingQueue {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Queue binding */\n  type: \"queue\";\n  /** Queue name */\n  queue_name: string;\n}\n\n/**\n * R2 Bucket binding type\n */\nexport interface WorkerBindingR2Bucket {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for R2 Bucket binding */\n  type: \"r2_bucket\";\n  /** Bucket name */\n  bucket_name: string;\n}\n\n/**\n * Secret Text binding type\n */\nexport interface WorkerBindingSecretText {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Secret Text binding */\n  type: \"secret_text\";\n  /** Secret value */\n  text: string;\n}\n\n/**\n * Service binding type\n */\nexport interface WorkerBindingService {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Service binding */\n  type: \"service\";\n  /** Service name */\n  service: string;\n  /** Environment */\n  environment?: string;\n  /** Service namespace */\n  namespace?: string;\n}\n\n/**\n * Tail Consumer binding type\n */\nexport interface WorkerBindingTailConsumer {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Tail Consumer binding */\n  type: \"tail_consumer\";\n  /** Service name */\n  service: string;\n}\n\n/**\n * Vectorize binding type\n */\nexport interface WorkerBindingVectorize {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Vectorize binding */\n  type: \"vectorize\";\n  /** Index name */\n  index_name: string;\n}\n\n/**\n * Version Metadata binding type\n */\nexport interface WorkerBindingVersionMetadata {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Version Metadata binding */\n  type: \"version_metadata\";\n}\n\n/**\n * WASM Module binding type\n */\nexport interface WorkerBindingWasmModule {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for WASM Module binding */\n  type: \"wasm_module\";\n  /** Module name */\n  module: string;\n}\n\n/**\n * Static content binding for Cloudflare Workers\n * Used for Workers Sites and static assets\n */\nexport interface WorkerBindingStaticContent {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Static Content binding */\n  type: \"static_content\";\n}\n\n```\n\n// alchemy/src/cloudflare/bound.ts\n```ts\nimport type { Secret } from \"../secret\";\nimport type { Assets } from \"./assets\";\nimport type { Binding } from \"./bindings\";\nimport type { R2Bucket as _R2Bucket } from \"./bucket\";\nimport type { DurableObjectNamespace as _DurableObjectNamespace } from \"./durable-object-namespace\";\nimport type { KVNamespace as _KVNamespace } from \"./kv-namespace\";\nimport type { Worker as _Worker } from \"./worker\";\n\nexport type Bound<T extends Binding> = T extends _DurableObjectNamespace\n  ? DurableObjectNamespace\n  : T extends _KVNamespace\n    ? KVNamespace\n    : T extends _Worker\n      ? Worker\n      : T extends _R2Bucket\n        ? R2Bucket\n        : T extends Secret\n          ? string\n          : T extends Assets\n            ? Service\n            : Service;\n\n```\n\n// alchemy/src/cloudflare/bucket.ts\n```ts\nimport { AwsClient } from \"aws4fetch\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { CloudflareApi, createCloudflareApi } from \"./api\";\nimport { CloudflareApiError, handleApiError } from \"./api-error\";\n\n/**\n * Properties for creating or updating an R2 Bucket\n */\nexport interface BucketProps {\n  /**\n   * Name of the bucket\n   * Names can only contain lowercase letters (a-z), numbers (0-9), and hyphens (-)\n   * Cannot begin or end with a hyphen\n   */\n  name: string;\n\n  /**\n   * Optional location hint for the bucket\n   * Indicates the primary geographical location data will be accessed from\n   */\n  locationHint?: string;\n\n  /**\n   * Optional jurisdiction for the bucket\n   * Determines the regulatory jurisdiction the bucket data falls under\n   */\n  jurisdiction?: \"default\" | \"eu\" | \"fedramp\";\n\n  /**\n   * Whether to allow public access through the r2.dev subdomain\n   * Only for development purposes - use custom domains for production\n   */\n  allowPublicAccess?: boolean;\n\n  /**\n   * Whether to delete the bucket.\n   * If set to false, the bucket will remain but the resource will be removed from state\n   *\n   * @default true\n   */\n  delete?: boolean;\n\n  /**\n   * Whether to empty the bucket and delete all objects during resource deletion\n   * @default false\n   */\n  empty?: boolean;\n\n  /**\n   * API Token to use for the bucket\n   */\n  apiToken?: Secret;\n\n  /**\n   * API Key to use for the bucket\n   */\n  apiKey?: Secret;\n\n  /**\n   * Email to use for the bucket\n   */\n  email?: string;\n\n  /**\n   * Account ID to use for the bucket\n   */\n  accountId?: string;\n\n  /**\n   * Access Key to use for the bucket\n   */\n  accessKey?: Secret;\n\n  /**\n   * Secret Access Key to use for the bucket\n   */\n  secretAccessKey?: Secret;\n}\n\n/**\n * Output returned after R2 Bucket creation/update\n */\nexport interface R2Bucket\n  extends Resource<\"cloudflare::R2Bucket\">,\n    BucketProps {\n  /**\n   * Resource type identifier\n   */\n  type: \"r2_bucket\";\n\n  /**\n   * Location of the bucket\n   */\n  location: string;\n\n  /**\n   * Time at which the bucket was created\n   */\n  creationDate: Date;\n}\n\n/**\n * Creates and manages Cloudflare R2 Buckets for object storage.\n *\n * R2 Buckets provide S3-compatible object storage with automatic data replication\n * across multiple regions for high availability and durability.\n *\n * @example\n * // Create a basic R2 bucket with default settings\n * const basicBucket = await R2Bucket(\"my-app-data\", {\n *   name: \"my-app-data\"\n * });\n *\n * @example\n * // Create a bucket with location hint for optimal performance\n * const euBucket = await R2Bucket(\"eu-user-data\", {\n *   name: \"eu-user-data\",\n *   locationHint: \"eu\",\n *   jurisdiction: \"eu\"\n * });\n *\n * @example\n * // Create a development bucket with public access enabled\n * const publicBucket = await R2Bucket(\"public-assets\", {\n *   name: \"public-assets\",\n *   allowPublicAccess: true\n * });\n *\n * @example\n * // Create a FedRAMP compliant bucket for government workloads\n * const fedRampBucket = await R2Bucket(\"gov-data\", {\n *   name: \"gov-data\",\n *   jurisdiction: \"fedramp\"\n * });\n *\n * @example\n * // Create a bucket that will be automatically emptied when deleted\n * // This will delete all objects in the bucket before deleting the bucket itself\n * const temporaryBucket = await R2Bucket(\"temp-storage\", {\n *   name: \"temp-storage\",\n *   empty: true  // All objects will be deleted when this resource is destroyed\n * });\n *\n * @see https://developers.cloudflare.com/r2/buckets/\n */\nexport const R2Bucket = Resource(\n  \"cloudflare::R2Bucket\",\n  async function (\n    this: Context<R2Bucket>,\n    id: string,\n    props: BucketProps\n  ): Promise<R2Bucket> {\n    const api = await createCloudflareApi(props);\n    const bucketName = props.name || this.id;\n\n    if (this.phase === \"delete\") {\n      console.log(\"Deleting R2 bucket:\", bucketName);\n      if (props.delete !== false) {\n        if (props.empty) {\n          console.log(\"Emptying R2 bucket:\", bucketName);\n          const r2Client = await createR2Client({\n            ...props,\n            accountId: api.accountId,\n          });\n          // Empty the bucket first by deleting all objects\n          await emptyBucket(r2Client, bucketName, props.jurisdiction);\n        }\n\n        // Delete R2 bucket\n        console.log(\"Deleting R2 bucket:\", bucketName);\n        await deleteBucket(api, bucketName, props);\n      }\n\n      // Return void (a deleted bucket has no content)\n      return this.destroy();\n    } else {\n      if (this.phase === \"create\") {\n        console.log(\"Creating R2 bucket:\", bucketName);\n        await createBucket(api, bucketName, props);\n      }\n\n      await updatePublicAccess(\n        api,\n        bucketName,\n        props.allowPublicAccess === true,\n        props.jurisdiction\n      );\n\n      return this({\n        name: bucketName,\n        location: props.locationHint || \"default\",\n        creationDate: new Date(),\n        jurisdiction: props.jurisdiction || \"default\",\n        type: \"r2_bucket\",\n        accountId: api.accountId,\n      });\n    }\n  }\n);\n\n/**\n * Configuration for R2 client to connect to Cloudflare R2\n */\nexport interface R2ClientConfig {\n  accountId: string;\n  accessKeyId?: Secret;\n  secretAccessKey?: Secret;\n  jurisdiction?: string;\n}\n\ntype R2Client = AwsClient & { accountId: string };\n\n/**\n * Creates an aws4fetch client configured for Cloudflare R2\n *\n * @see https://developers.cloudflare.com/r2/examples/aws/aws-sdk-js-v3/\n */\nexport function createR2Client(config?: R2ClientConfig): Promise<R2Client> {\n  const accountId = config?.accountId ?? process.env.CLOUDFLARE_ACCOUNT_ID;\n  const accessKeyId =\n    config?.accessKeyId?.unencrypted || process.env.R2_ACCESS_KEY_ID;\n  const secretAccessKey =\n    config?.secretAccessKey?.unencrypted || process.env.R2_SECRET_ACCESS_KEY;\n\n  if (!accountId) {\n    throw new Error(\"CLOUDFLARE_ACCOUNT_ID environment variable is required\");\n  }\n\n  if (!accessKeyId || !secretAccessKey) {\n    throw new Error(\n      \"R2_ACCESS_KEY_ID and R2_SECRET_ACCESS_KEY environment variables are required\"\n    );\n  }\n\n  // Create aws4fetch client with Cloudflare R2 endpoint\n  const client: any = new AwsClient({\n    accessKeyId,\n    secretAccessKey,\n    service: \"s3\",\n    region: \"auto\",\n  });\n  client.accountId = accountId;\n  return client;\n}\n\ninterface CloudflareBucketResponse {\n  result: {\n    name: string;\n    location?: string;\n    creation_date: string;\n  };\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n}\n\n/**\n * Adds jurisdiction header to the headers object if specified in props\n *\n * @param headers Headers object to modify\n * @param props Props or jurisdiction string\n * @returns Modified headers object\n */\nexport function withJurisdiction(\n  headers: Record<string, string> = {},\n  props: BucketProps | { jurisdiction?: string } | string | undefined\n): Record<string, string> {\n  // Clone the headers object to avoid modifying the original\n  const result = { ...headers };\n\n  let jurisdiction: string | undefined;\n  if (typeof props === \"string\") {\n    jurisdiction = props;\n  } else if (props && \"jurisdiction\" in props) {\n    jurisdiction = props.jurisdiction;\n  }\n\n  if (jurisdiction && jurisdiction !== \"default\") {\n    result[\"cf-r2-jurisdiction\"] = jurisdiction;\n  }\n\n  return result;\n}\n\n/**\n * Create a new bucket\n */\nexport async function createBucket(\n  api: CloudflareApi,\n  bucketName: string,\n  props: BucketProps\n): Promise<CloudflareBucketResponse> {\n  // Create new R2 bucket\n  const createPayload: any = {\n    name: bucketName,\n  };\n\n  if (props.locationHint) {\n    createPayload.location_hint = props.locationHint;\n  }\n\n  const headers = withJurisdiction({}, props);\n\n  const createResponse = await api.post(\n    `/accounts/${api.accountId}/r2/buckets`,\n    createPayload,\n    { headers }\n  );\n\n  if (!createResponse.ok) {\n    return await handleApiError(\n      createResponse,\n      \"creating\",\n      \"R2 bucket\",\n      bucketName\n    );\n  }\n\n  return (await createResponse.json()) as CloudflareBucketResponse;\n}\n\n/**\n * Delete a bucket\n */\nexport async function deleteBucket(\n  api: CloudflareApi,\n  bucketName: string,\n  props: BucketProps\n): Promise<void> {\n  // Delete R2 bucket\n  const headers = withJurisdiction({}, props);\n\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/r2/buckets/${bucketName}`,\n    { headers }\n  );\n\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    const errorData: any = await deleteResponse.json().catch(() => ({\n      errors: [{ message: deleteResponse.statusText }],\n    }));\n    throw new CloudflareApiError(\n      `Error deleting R2 bucket '${bucketName}': ${errorData.errors?.[0]?.message || deleteResponse.statusText}`,\n      deleteResponse\n    );\n  }\n}\n\n/**\n * List objects in an R2 bucket\n *\n * @param r2 R2Client instance\n * @param bucketName Name of the bucket\n * @param continuationToken Optional token for pagination\n * @param jurisdiction Optional jurisdiction for the bucket\n * @returns Object containing the list of objects and the next continuation token\n */\nexport async function listObjects(\n  r2: R2Client,\n  bucketName: string,\n  continuationToken?: string,\n  jurisdiction?: string\n): Promise<{ objects: { Key: string }[]; continuationToken?: string }> {\n  // List objects in the bucket\n  const url = new URL(\n    `https://${r2.accountId}.r2.cloudflarestorage.com/${bucketName}`\n  );\n  if (continuationToken) {\n    url.searchParams.set(\"continuation-token\", continuationToken);\n  }\n  url.searchParams.set(\"list-type\", \"2\");\n\n  const headers = withJurisdiction({}, jurisdiction);\n\n  const listResponse = await r2.fetch(url.toString(), { headers });\n  if (!listResponse.ok) {\n    throw new CloudflareApiError(\n      `Failed to list objects: ${listResponse.statusText}`,\n      listResponse\n    );\n  }\n\n  const responseText = await listResponse.text();\n\n  // Extract objects from XML response using regex\n  const keyRegex = /<Key>([^<]+)<\\/Key>/g;\n  const objects: { Key: string }[] = [];\n  let match;\n  while ((match = keyRegex.exec(responseText)) !== null) {\n    objects.push({ Key: match[1] });\n  }\n\n  // Get continuation token if present using regex\n  const tokenMatch =\n    /<NextContinuationToken>([^<]+)<\\/NextContinuationToken>/.exec(\n      responseText\n    );\n  const nextContinuationToken = tokenMatch ? tokenMatch[1] : undefined;\n\n  return { objects, continuationToken: nextContinuationToken };\n}\n\n/**\n * Helper function to empty a bucket by deleting all objects\n */\nexport async function emptyBucket(\n  r2: R2Client,\n  bucketName: string,\n  jurisdiction?: string\n): Promise<void> {\n  let continuationToken: string | undefined;\n  let totalDeleted = 0;\n\n  try {\n    do {\n      // List objects in the bucket\n      const { objects, continuationToken: nextToken } = await listObjects(\n        r2,\n        bucketName,\n        continuationToken,\n        jurisdiction\n      );\n\n      continuationToken = nextToken;\n\n      console.log(`Found ${objects.length} objects in bucket ${bucketName}`);\n\n      // Delete objects in batches\n      if (objects.length > 0) {\n        // Process delete in batches of 1000 (S3 limit)\n        for (let i = 0; i < objects.length; i += 1000) {\n          const batch = objects.slice(i, i + 1000);\n\n          // Create DeleteObjects request XML\n          const deleteXml = `\n            <Delete>\n              ${batch.map((obj) => `<Object><Key>${obj.Key}</Key></Object>`).join(\"\")}\n            </Delete>\n          `;\n\n          const deleteUrl = new URL(\n            `https://${r2.accountId}.r2.cloudflarestorage.com/${bucketName}?delete`\n          );\n\n          console.log(\n            `Deleting ${batch.length} objects from bucket ${bucketName}`\n          );\n\n          const headers = withJurisdiction(\n            { \"Content-Type\": \"application/xml\" },\n            jurisdiction\n          );\n\n          const deleteResponse = await r2.fetch(deleteUrl.toString(), {\n            method: \"POST\",\n            body: deleteXml,\n            headers,\n          });\n\n          if (!deleteResponse.ok) {\n            throw new CloudflareApiError(\n              `Failed to delete objects: ${deleteResponse.statusText}`,\n              deleteResponse\n            );\n          }\n\n          totalDeleted += batch.length;\n        }\n      }\n    } while (continuationToken);\n\n    console.log(\n      `Successfully emptied bucket ${bucketName}, deleted ${totalDeleted} objects total`\n    );\n  } catch (error) {\n    if (error instanceof CloudflareApiError && error.status === 404) {\n      // the bucket was not found\n      return;\n    }\n    console.error(`Failed to empty bucket ${bucketName}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Update public access setting for a bucket\n *\n * This operation is not available through the S3 API for R2,\n * so we still use the Cloudflare API directly.\n */\nexport async function updatePublicAccess(\n  api: CloudflareApi,\n  bucketName: string,\n  allowPublicAccess: boolean,\n  jurisdiction?: string\n): Promise<void> {\n  const headers = withJurisdiction({}, jurisdiction);\n\n  const response = await api.put(\n    `/accounts/${api.accountId}/r2/buckets/${bucketName}/domains/managed`,\n    {\n      enabled: allowPublicAccess,\n    },\n    { headers }\n  );\n\n  if (!response.ok) {\n    await handleApiError(\n      response,\n      \"updating public access for\",\n      \"R2 bucket\",\n      bucketName\n    );\n  }\n}\n\n/**\n * Set CORS configuration for a bucket using aws4fetch\n */\nexport async function setCorsConfiguration(\n  r2: R2Client,\n  bucketName: string,\n  allowedOrigins: string[] = [\"*\"],\n  allowedMethods: string[] = [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\"],\n  allowedHeaders: string[] = [\"*\"],\n  maxAgeSeconds: number = 3600,\n  jurisdiction?: string\n): Promise<void> {\n  try {\n    // Construct CORS XML configuration\n    const corsXml = `\n      <CORSConfiguration>\n        <CORSRule>\n          ${allowedOrigins.map((origin) => `<AllowedOrigin>${origin}</AllowedOrigin>`).join(\"\")}\n          ${allowedMethods.map((method) => `<AllowedMethod>${method}</AllowedMethod>`).join(\"\")}\n          ${allowedHeaders.map((header) => `<AllowedHeader>${header}</AllowedHeader>`).join(\"\")}\n          <ExposeHeader>ETag</ExposeHeader>\n          <MaxAgeSeconds>${maxAgeSeconds}</MaxAgeSeconds>\n        </CORSRule>\n      </CORSConfiguration>\n    `;\n\n    const url = new URL(\n      `https://${r2.accountId}.r2.cloudflarestorage.com/${bucketName}?cors`\n    );\n\n    const headers = withJurisdiction(\n      { \"Content-Type\": \"application/xml\" },\n      jurisdiction\n    );\n\n    const response = await r2.fetch(url.toString(), {\n      method: \"PUT\",\n      body: corsXml,\n      headers,\n    });\n\n    if (!response.ok) {\n      throw new CloudflareApiError(\n        `Failed to set CORS configuration: ${response.statusText}`,\n        response\n      );\n    }\n\n    console.log(`Successfully set CORS configuration for bucket ${bucketName}`);\n  } catch (error) {\n    console.error(\n      `Failed to set CORS configuration for bucket ${bucketName}:`,\n      error\n    );\n    throw error;\n  }\n}\n\n/**\n * Information about an R2 bucket returned by list operations\n */\nexport interface R2BucketInfo {\n  /**\n   * Name of the bucket\n   */\n  Name: string;\n\n  /**\n   * Creation date of the bucket\n   */\n  CreationDate: Date;\n}\n\n/**\n * List all R2 buckets in an account\n *\n * @param api CloudflareApi instance\n * @param options Optional listing options\n * @returns Array of bucket information\n */\nexport async function listBuckets(\n  api: CloudflareApi,\n  options: {\n    nameContains?: string;\n    perPage?: number;\n    cursor?: string;\n    direction?: \"asc\" | \"desc\";\n    jurisdiction?: string;\n  } = {}\n): Promise<R2BucketInfo[]> {\n  // Build query parameters\n  const params = new URLSearchParams();\n\n  if (options.nameContains) {\n    params.append(\"name_contains\", options.nameContains);\n  }\n\n  if (options.perPage) {\n    params.append(\"per_page\", options.perPage.toString());\n  }\n\n  if (options.cursor) {\n    params.append(\"cursor\", options.cursor);\n  }\n\n  if (options.direction) {\n    params.append(\"direction\", options.direction);\n  }\n\n  // Build URL with query parameters\n  const path = `/accounts/${api.accountId}/r2/buckets${params.toString() ? \"?\" + params.toString() : \"\"}`;\n\n  // Set jurisdiction header if provided\n  const headers = withJurisdiction({}, options.jurisdiction);\n\n  // Make the API request\n  const response = await api.get(path, { headers });\n\n  if (!response.ok) {\n    throw new CloudflareApiError(\n      `Failed to list buckets: ${response.statusText}`,\n      response\n    );\n  }\n\n  const data = (await response.json()) as {\n    success: boolean;\n    errors?: Array<{ code: number; message: string }>;\n    result?: {\n      buckets: Array<{\n        name: string;\n        creation_date: string;\n        location?: string;\n      }>;\n    };\n  };\n\n  if (!data.success) {\n    const errorMessage = data.errors?.[0]?.message || \"Unknown error\";\n    throw new Error(`Failed to list buckets: ${errorMessage}`);\n  }\n\n  // Transform API response to R2BucketInfo objects\n  return (data.result?.buckets || []).map((bucket) => ({\n    Name: bucket.name,\n    CreationDate: new Date(bucket.creation_date),\n  }));\n}\n\n```\n\n// alchemy/src/cloudflare/custom-domain.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport {\n  CloudflareApi,\n  createCloudflareApi,\n  type CloudflareApiOptions,\n} from \"./api\";\nimport { handleApiError } from \"./api-error\";\n\n/**\n * Properties for creating or updating a CustomDomain\n */\nexport interface CustomDomainProps extends CloudflareApiOptions {\n  /**\n   * The domain name to bind to the worker\n   */\n  name: string;\n\n  /**\n   * Cloudflare Zone ID for the domain\n   */\n  zoneId: string;\n\n  /**\n   * Name of the worker to bind to the domain\n   */\n  workerName: string;\n\n  /**\n   * Worker environment (defaults to production)\n   * @default \"production\"\n   */\n  environment?: string;\n}\n\n/**\n * Cloudflare Domain object structure from API\n */\ninterface CloudflareDomain {\n  id: string;\n  zone_id: string;\n  zone_name: string;\n  hostname: string;\n  service: string;\n  environment: string;\n}\n\n/**\n * Output returned after CustomDomain creation/update\n */\nexport interface CustomDomain\n  extends Resource<\"cloudflare::CustomDomain\">,\n    CustomDomainProps {\n  /**\n   * The unique identifier for the Cloudflare domain binding.\n   */\n  id: string;\n\n  /**\n   * Time at which the domain binding was created (approximated if not returned by API)\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the domain binding was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Configure custom domain for a Cloudflare Worker using the Cloudflare Custom Domains API\n * This attaches a worker to a specific hostname within a zone.\n *\n * @example\n * // Bind a domain to a standard Cloudflare Worker\n * const apiWorker = await Worker(\"api\", {\n *   name: \"my-api-worker\",\n *   entrypoint: \"./src/api-worker.ts\"\n * });\n *\n * const apiDomain = await CustomDomain(\"api-domain-binding\", {\n *   name: \"api.example.com\",\n *   zoneId: \"YOUR_ZONE_ID\", // Replace with actual Zone ID\n *   workerName: apiWorker.name // Use the name from the Worker resource\n * });\n *\n * @see https://developers.cloudflare.com/api/resources/workers/subresources/domains/\n */\nexport const CustomDomain = Resource(\n  \"cloudflare::CustomDomain\",\n  async function (\n    this: Context<CustomDomain>,\n    logicalId: string, // Changed param name from id to logicalId for clarity\n    props: CustomDomainProps\n  ): Promise<CustomDomain> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    // Validate required properties\n    if (!props.name) {\n      throw new Error(\"Domain name (props.name) is required\");\n    }\n    if (!props.zoneId) {\n      throw new Error(\"Zone ID (props.zoneId) is required\");\n    }\n    if (!props.workerName) {\n      throw new Error(\"Worker name (props.workerName) is required\");\n    }\n\n    if (this.phase === \"delete\") {\n      await deleteCustomDomain(this, api, logicalId, props);\n      return this.destroy();\n    } else {\n      // Create or Update phase\n      return await ensureCustomDomain(this, api, logicalId, props);\n    }\n  }\n);\n\n// Helper function to delete the custom domain binding\nasync function deleteCustomDomain(\n  context: Context<CustomDomain>,\n  api: CloudflareApi,\n  logicalId: string,\n  props: CustomDomainProps\n): Promise<void> {\n  const domainHostname = props.name;\n  const domainIdToDelete = context.output?.id;\n\n  if (!domainIdToDelete) {\n    console.warn(\n      `Cannot delete CustomDomain ${logicalId} (${domainHostname}): Missing domain ID in state. Assuming already deleted.`\n    );\n    return; // Exit early if no ID\n  }\n\n  console.log(\n    `Deleting CustomDomain binding ${domainIdToDelete} for ${domainHostname}`\n  );\n  const response = await api.delete(\n    `/accounts/${api.accountId}/workers/domains/${domainIdToDelete}`\n  );\n\n  console.log(\n    `Delete result for ${domainIdToDelete} (${domainHostname}):`,\n    response.status,\n    response.statusText\n  );\n\n  // 404 is acceptable during deletion for idempotency\n  if (!response.ok && response.status !== 404) {\n    await handleApiError(\n      response,\n      \"deleting\",\n      \"custom domain binding\",\n      domainIdToDelete\n    );\n    // Throw after handling to ensure failure is reported\n    throw new Error(\n      `Failed to delete custom domain binding ${domainIdToDelete}: ${response.statusText}`\n    );\n  }\n}\n\n// Helper function to create or update the custom domain binding\nasync function ensureCustomDomain(\n  context: Context<CustomDomain>,\n  api: CloudflareApi,\n  logicalId: string,\n  props: CustomDomainProps\n): Promise<CustomDomain> {\n  const environment = props.environment || \"production\";\n  const domainHostname = props.name;\n\n  // Check if domain binding already exists for this account\n  console.log(`Checking existing domain bindings for account ${api.accountId}`);\n  const listResponse = await api.get(\n    `/accounts/${api.accountId}/workers/domains`\n  );\n\n  if (!listResponse.ok) {\n    // Fix: Added the 4th argument (resource identifier/context)\n    await handleApiError(\n      listResponse,\n      \"listing\",\n      \"worker domains\",\n      `Account ${api.accountId}`\n    );\n    // If listing fails, we cannot proceed reliably\n    throw new Error(\n      `Failed to list worker domains for account ${api.accountId}: ${listResponse.statusText}`\n    );\n  }\n\n  const listData = (await listResponse.json()) as {\n    result?: CloudflareDomain[];\n    success: boolean;\n  };\n\n  if (!listData.success || !listData.result) {\n    throw new Error(\n      `Failed to parse list worker domains response: ${JSON.stringify(listData)}`\n    );\n  }\n\n  // Find the specific binding by hostname AND zoneId\n  const existingBinding = listData.result.find(\n    (b) => b.hostname === domainHostname && b.zone_id === props.zoneId\n  );\n\n  let currentDomainId = existingBinding?.id;\n  const bindingExists = !!existingBinding;\n\n  console.log(\n    `Domain binding status for ${domainHostname} (Zone: ${props.zoneId}):`,\n    bindingExists\n      ? `Found (ID: ${currentDomainId}, Worker: ${existingBinding.service}, Env: ${existingBinding.environment})`\n      : \"Not found\"\n  );\n\n  // Determine if we need to update (binding exists but has different service or environment)\n  const needsUpdate =\n    bindingExists &&\n    (existingBinding.service !== props.workerName ||\n      existingBinding.environment !== environment);\n\n  let operationPerformed: \"create\" | \"update\" | \"none\" = \"none\";\n  let resultantBinding: CloudflareDomain | undefined = existingBinding;\n\n  // Create or Update the binding using PUT\n  // Cloudflare's PUT /accounts/{account_id}/workers/domains acts as an upsert\n  if (!bindingExists || needsUpdate) {\n    operationPerformed = bindingExists ? \"update\" : \"create\";\n    console.log(\n      `${operationPerformed === \"update\" ? \"Updating\" : \"Creating\"} domain binding: ${domainHostname} (Zone: ${props.zoneId}) → ${props.workerName}:${environment}`\n    );\n\n    const putPayload = {\n      zone_id: props.zoneId,\n      hostname: domainHostname,\n      service: props.workerName,\n      environment: environment,\n    };\n\n    const putResponse = await api.put(\n      `/accounts/${api.accountId}/workers/domains`,\n      putPayload\n    );\n\n    if (!putResponse.ok) {\n      await handleApiError(\n        putResponse,\n        operationPerformed === \"update\" ? \"updating\" : \"creating\",\n        \"custom domain binding\",\n        domainHostname\n      );\n      // Throw after handling to prevent inconsistent state\n      throw new Error(\n        `Failed to ${operationPerformed} custom domain binding: ${putResponse.statusText}`\n      );\n    }\n\n    const putResult = (await putResponse.json()) as {\n      result?: CloudflareDomain;\n      success: boolean;\n    };\n\n    if (!putResult.success || !putResult.result) {\n      throw new Error(\n        `Failed to parse ${operationPerformed} domain binding response: ${JSON.stringify(putResult)}`\n      );\n    }\n\n    resultantBinding = putResult.result;\n    currentDomainId = resultantBinding.id; // Update ID from the PUT response\n    console.log(\n      `Successfully ${operationPerformed}d binding, new ID: ${currentDomainId}`\n    );\n  } else {\n    console.log(\n      `Domain binding already exists and is up to date: ${domainHostname} (ID: ${currentDomainId}) → ${props.workerName}:${environment}`\n    );\n  }\n\n  // Ensure we have the final binding details\n  if (!resultantBinding || !currentDomainId) {\n    // This case should ideally not happen if API calls succeed\n    console.error(\"Error: Could not determine final domain binding state.\", {\n      existingBinding,\n      resultantBinding,\n      currentDomainId,\n    });\n    throw new Error(\n      `Failed to get final state for custom domain ${domainHostname}`\n    );\n  }\n\n  const now = Date.now();\n\n  // Construct the output state\n  return context({\n    ...props, // Include all input props\n    id: currentDomainId, // Use the definitive ID\n    environment: resultantBinding.environment, // Use actual environment from CF\n    createdAt: context.output?.createdAt || now, // Preserve create time or set new\n    updatedAt:\n      operationPerformed !== \"none\" ? now : context.output?.updatedAt || now, // Update time only if changed\n  });\n}\n\n```\n\n// alchemy/src/cloudflare/dns-records.ts\n```ts\nimport type { Context } from \"../context\";\nimport type {\n  DnsRecord as BaseDnsRecord,\n  DnsRecordType,\n  DnsRecordWithMetadata,\n} from \"../dns/record\";\nimport { Resource } from \"../resource\";\nimport {\n  type CloudflareApi,\n  type CloudflareApiOptions,\n  createCloudflareApi,\n} from \"./api\";\nimport type { CloudflareResponse } from \"./response\";\n\n/**\n * Cloudflare DNS Record response format\n */\ninterface CloudflareDnsRecord {\n  id: string;\n  type: string;\n  name: string;\n  content: string;\n  proxiable: boolean;\n  proxied: boolean;\n  ttl: number;\n  locked: boolean;\n  zone_id: string;\n  zone_name: string;\n  created_on: string;\n  modified_on: string;\n  data?: Record<string, unknown>;\n  priority?: number;\n  comment?: string;\n  tags?: string[];\n}\n\n/**\n * Properties for a DNS record\n */\nexport interface DnsRecordProps extends Omit<BaseDnsRecord, \"type\"> {\n  /**\n   * Record type (A, AAAA, CNAME, etc.)\n   */\n  type: DnsRecordType;\n}\n\n/**\n * Output returned after DNS record creation/update\n */\nexport interface DnsRecord extends DnsRecordWithMetadata {}\n\n/**\n * Properties for managing multiple DNS records\n */\nexport interface DnsRecordsProps extends CloudflareApiOptions {\n  /**\n   * Zone ID or domain name where records will be created\n   */\n  zoneId: string;\n\n  /**\n   * Array of DNS records to manage\n   */\n  records: DnsRecordProps[];\n}\n\n/**\n * Output returned after DNS records creation/update\n */\nexport interface DnsRecords extends Resource<\"cloudflare::DnsRecords\"> {\n  /**\n   * Zone ID where records are created\n   */\n  zoneId: string;\n\n  /**\n   * Array of created/updated DNS records\n   */\n  records: DnsRecord[];\n}\n\n/**\n * Manages a batch of DNS records in a Cloudflare zone.\n * Supports creating, updating, and deleting multiple records at once.\n *\n * @example\n * // Create multiple A and CNAME records\n * const dnsRecords = await DnsRecords(\"example.com-dns\", {\n *   zone: \"example.com\",\n *   records: [\n *     {\n *       name: \"www.example.com\",\n *       type: \"A\",\n *       content: \"192.0.2.1\",\n *       proxied: true\n *     },\n *     {\n *       name: \"blog.example.com\",\n *       type: \"CNAME\",\n *       content: \"www.example.com\",\n *       proxied: true\n *     }\n *   ]\n * });\n *\n * @example\n * // Create MX records for email routing\n * const emailRecords = await DnsRecords(\"example.com-email\", {\n *   zone: \"example.com\",\n *   records: [\n *     {\n *       name: \"example.com\",\n *       type: \"MX\",\n *       content: \"aspmx.l.google.com\",\n *       priority: 1\n *     },\n *     {\n *       name: \"example.com\",\n *       type: \"MX\",\n *       content: \"alt1.aspmx.l.google.com\",\n *       priority: 5\n *     }\n *   ]\n * });\n */\nexport const DnsRecords = Resource(\n  \"cloudflare::DnsRecords\",\n  async function (\n    this: Context<DnsRecords>,\n    id: string,\n    props: DnsRecordsProps\n  ): Promise<DnsRecords> {\n    // Create Cloudflare API client\n    const api = await createCloudflareApi(props);\n\n    // Get zone ID if domain name was provided\n    const zoneId = props.zoneId;\n\n    if (this.phase === \"delete\") {\n      if (this.output?.records) {\n        // Delete all existing records\n        await Promise.all(\n          this.output.records.map(async (record) => {\n            try {\n              const response = await api.delete(\n                `/zones/${zoneId}/dns_records/${record.id}`\n              );\n              if (!response.ok && response.status !== 404) {\n                console.error(\n                  `Failed to delete DNS record ${record.name}: ${response.statusText}`\n                );\n              }\n            } catch (error) {\n              console.error(`Error deleting DNS record ${record.name}:`, error);\n            }\n          })\n        );\n      }\n      return this.destroy();\n    }\n\n    if (this.phase === \"update\" && this.output?.records) {\n      // Get current records to compare with desired state\n      const currentRecords = this.output.records;\n      const desiredRecords = props.records;\n\n      // Find records to delete (exist in current but not in desired)\n      const recordsToDelete = currentRecords.filter(\n        (current) =>\n          !desiredRecords.some(\n            (desired) =>\n              desired.name === current.name && desired.type === current.type\n          )\n      );\n\n      // Delete orphaned records\n      await Promise.all(\n        recordsToDelete.map(async (record) => {\n          try {\n            const response = await api.delete(\n              `/zones/${zoneId}/dns_records/${record.id}`\n            );\n            if (!response.ok && response.status !== 404) {\n              console.error(\n                `Failed to delete DNS record ${record.name}: ${response.statusText}`\n              );\n            }\n          } catch (error) {\n            console.error(`Error deleting DNS record ${record.name}:`, error);\n          }\n        })\n      );\n\n      // Update or create records\n      const updatedRecords = await Promise.all(\n        desiredRecords.map(async (desired) => {\n          // Find matching existing record\n          const existing = currentRecords.find(\n            (current) =>\n              current.name === desired.name && current.type === desired.type\n          );\n\n          if (existing) {\n            // Update if content or other properties changed\n            if (\n              existing.content !== desired.content ||\n              existing.ttl !== (desired.ttl || 1) ||\n              existing.proxied !== (desired.proxied || false) ||\n              existing.priority !== desired.priority ||\n              existing.comment !== desired.comment\n            ) {\n              return createOrUpdateRecord(api, zoneId, desired, existing.id);\n            }\n            return existing;\n          } else {\n            // Create new record\n            return createOrUpdateRecord(api, zoneId, desired);\n          }\n        })\n      );\n\n      return this({\n        zoneId,\n        records: updatedRecords,\n      });\n    }\n\n    // Create new records\n    const uniqueRecords = props.records.reduce(\n      (acc, record) => {\n        // For record types that can have multiple entries with the same name (MX, TXT, NS, etc.),\n        // include content and/or priority in the key to avoid deduplication\n        let key = `${record.name}-${record.type}`;\n\n        // If it's a record type that can have multiple entries with the same name, make the key unique\n        if ([\"MX\", \"TXT\", \"NS\", \"SRV\", \"CAA\"].includes(record.type)) {\n          // For MX, include priority in the key\n          if (record.type === \"MX\" || record.type === \"SRV\") {\n            key = `${key}-${record.priority}-${record.content}`;\n          } else {\n            // For other multi-record types, content is the differentiator\n            key = `${key}-${record.content}`;\n          }\n        }\n\n        acc[key] = record;\n        return acc;\n      },\n      {} as Record<string, DnsRecordProps>\n    );\n\n    const createdRecords = await Promise.all(\n      Object.values(uniqueRecords).map(async (record) => {\n        // First check if record exists\n        const listResponse = await api.get(\n          `/zones/${zoneId}/dns_records?type=${record.type}&name=${record.name}`\n        );\n        if (!listResponse.ok) {\n          throw new Error(\n            `Failed to check existing DNS records: ${listResponse.statusText}`\n          );\n        }\n\n        const listResult = (await listResponse.json()) as CloudflareResponse<\n          CloudflareDnsRecord[]\n        >;\n        const existingRecord = listResult.result[0];\n\n        return createOrUpdateRecord(api, zoneId, record, existingRecord?.id);\n      })\n    );\n\n    return this({\n      zoneId,\n      records: createdRecords,\n    });\n  }\n);\n\n/**\n * Create or update a DNS record\n */\nasync function createOrUpdateRecord(\n  api: CloudflareApi,\n  zoneId: string,\n  record: DnsRecordProps,\n  existingId?: string\n): Promise<DnsRecord> {\n  const payload = getRecordPayload(record);\n\n  const response = await (existingId\n    ? api.put(`/zones/${zoneId}/dns_records/${existingId}`, payload)\n    : api.post(`/zones/${zoneId}/dns_records`, payload));\n\n  if (!response.ok) {\n    const errorBody = await response.text();\n\n    // If it's an update operation and the record doesn't exist, fall back to creation\n    if (existingId && response.status === 404) {\n      try {\n        const createResponse = await api.post(\n          `/zones/${zoneId}/dns_records`,\n          payload\n        );\n        if (createResponse.ok) {\n          return convertCloudflareRecord(\n            ((await createResponse.json()) as any).result,\n            zoneId\n          );\n        }\n      } catch (err) {\n        // Fall through to the original error\n      }\n    }\n\n    throw new Error(\n      `Failed to ${existingId ? \"update\" : \"create\"} DNS record ${record.name}: ${response.statusText}\\nResponse: ${errorBody}`\n    );\n  }\n\n  const result =\n    (await response.json()) as CloudflareResponse<CloudflareDnsRecord>;\n  return convertCloudflareRecord(result.result, zoneId);\n}\n\n/**\n * Get the record payload for create/update operations\n */\nfunction getRecordPayload(record: DnsRecordProps) {\n  return {\n    type: record.type,\n    name: record.name,\n    content: record.content,\n    ttl: record.ttl || 1,\n    proxied: record.proxied || false,\n    priority: record.priority,\n    comment: record.comment,\n  };\n}\n\n/**\n * Convert a Cloudflare DNS record response to our DnsRecord type\n */\nfunction convertCloudflareRecord(\n  record: CloudflareDnsRecord,\n  zoneId: string\n): DnsRecord {\n  return {\n    id: record.id,\n    name: record.name,\n    type: record.type as DnsRecordProps[\"type\"],\n    content: record.content,\n    ttl: record.ttl,\n    proxied: record.proxied,\n    priority: record.priority,\n    comment: record.comment,\n    tags: record.tags,\n    createdAt: new Date(record.created_on).getTime(),\n    modifiedAt: new Date(record.modified_on).getTime(),\n    zoneId,\n  };\n}\n\n```\n\n// alchemy/src/cloudflare/durable-object-namespace.ts\n```ts\n/**\n * Properties for creating a Durable Object Namespace\n */\nexport interface DurableObjectNamespaceInput {\n  className: string;\n  scriptName?: string | undefined;\n  environment?: string | undefined;\n  sqlite?: boolean | undefined;\n  namespaceId?: string | undefined;\n}\n\n/**\n * @example\n * // Create a basic Durable Object namespace for stateful chat rooms\n * const rooms = new DurableObjectNamespace(\"chat-rooms\", {\n *   className: \"ChatRoom\"\n * });\n *\n * @example\n * // Create a Durable Object with SQLite storage for user data\n * const users = new DurableObjectNamespace(\"user-store\", {\n *   className: \"User\",\n *   sqlite: true\n * });\n *\n * @example\n * // Create a Durable Object in production for game state management\n * const game = new DurableObjectNamespace(\"game-state\", {\n *   className: \"GameState\",\n *   scriptName: \"game-worker\",\n *   environment: \"production\"\n * });\n */\nexport class DurableObjectNamespace implements DurableObjectNamespaceInput {\n  public readonly type = \"durable_object_namespace\" as const;\n  // alias for bindingName to be consistent with other bindings\n  public readonly className: string;\n  public readonly scriptName?: string | undefined;\n  public readonly environment?: string | undefined;\n  public readonly sqlite?: boolean | undefined;\n  public readonly namespaceId?: string | undefined;\n\n  constructor(\n    public readonly id: string,\n    input: DurableObjectNamespaceInput,\n  ) {\n    this.className = input.className;\n    this.scriptName = input.scriptName;\n    this.environment = input.environment;\n    this.sqlite = input.sqlite;\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/kv-namespace.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport {\n  CloudflareApi,\n  createCloudflareApi,\n  type CloudflareApiOptions,\n} from \"./api\";\nimport { handleApiError } from \"./api-error\";\n\nexport function isKVNamespace(resource: any): resource is KVNamespace {\n  return (\n    resource && typeof resource === \"object\" && resource.type === \"kv_namespace\"\n  );\n}\n\n/**\n * Properties for creating or updating a KV Namespace\n */\nexport interface KVNamespaceProps extends CloudflareApiOptions {\n  /**\n   * Title of the namespace\n   */\n  title: string;\n\n  /**\n   * KV pairs to store in the namespace\n   * Only used for initial setup or updates\n   */\n  values?: KVPair[];\n}\n\n/**\n * Key-value pair to store in a KV Namespace\n */\nexport interface KVPair {\n  /**\n   * Key name\n   */\n  key: string;\n\n  /**\n   * Value to store (string or JSON object)\n   */\n  value: string | object;\n\n  /**\n   * Optional expiration in seconds from now\n   */\n  expiration?: number;\n\n  /**\n   * Optional expiration timestamp in seconds since epoch\n   */\n  expirationTtl?: number;\n\n  /**\n   * Optional metadata for the key\n   */\n  metadata?: any;\n}\n\n/**\n * Output returned after KV Namespace creation/update\n */\nexport interface KVNamespace\n  extends Resource<\"cloudflare::KVNamespace\">,\n    KVNamespaceProps {\n  type: \"kv_namespace\";\n  /**\n   * The ID of the namespace\n   */\n  namespaceId: string;\n\n  /**\n   * Time at which the namespace was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the namespace was last modified\n   */\n  modifiedAt: number;\n}\n\n/**\n * A Cloudflare KV Namespace is a key-value store that can be used to store data for your application.\n *\n * @see https://developers.cloudflare.com/kv/concepts/kv-namespaces/\n *\n * @example\n * // Create a basic KV namespace for storing user data\n * const users = await KVNamespace(\"users\", {\n *   title: \"user-data\"\n * });\n *\n * @example\n * // Create a KV namespace with initial values and TTL\n * const sessions = await KVNamespace(\"sessions\", {\n *   title: \"user-sessions\",\n *   values: [{\n *     key: \"session_123\",\n *     value: { userId: \"user_456\", role: \"admin\" },\n *     expirationTtl: 3600 // Expires in 1 hour\n *   }]\n * });\n *\n * @example\n * // Create a KV namespace with metadata for caching\n * const assets = await KVNamespace(\"assets\", {\n *   title: \"static-assets\",\n *   values: [{\n *     key: \"main.js\",\n *     value: \"content...\",\n *     metadata: {\n *       contentType: \"application/javascript\",\n *       etag: \"abc123\"\n *     }\n *   }]\n * });\n */\nexport const KVNamespace = Resource(\n  \"cloudflare::KVNamespace\",\n  async function (\n    this: Context<KVNamespace>,\n    id: string,\n    props: KVNamespaceProps\n  ) {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    if (this.phase === \"delete\") {\n      // For delete operations, we need to check if the namespace ID exists in the output\n      const namespaceId = this.output?.namespaceId;\n      if (namespaceId) {\n        await deleteKVNamespace(api, namespaceId);\n      }\n\n      // Return minimal output for deleted state\n      return this.destroy();\n    } else {\n      // For create or update operations\n      // If this.phase is \"update\", we expect this.output to exist\n      let namespaceId =\n        this.phase === \"update\" ? this.output?.namespaceId || \"\" : \"\";\n      let createdAt =\n        this.phase === \"update\"\n          ? this.output?.createdAt || Date.now()\n          : Date.now();\n\n      if (this.phase === \"update\" && namespaceId) {\n        // Can't update a KV namespace title directly, just work with existing ID\n      } else {\n        // TODO: if it already exists, then check the tags to see if we own it and continue\n        const { id } = await createKVNamespace(api, props);\n        createdAt = Date.now();\n        namespaceId = id;\n      }\n\n      await insertKVRecords(api, namespaceId, props);\n\n      return this({\n        type: \"kv_namespace\",\n        namespaceId: namespaceId,\n        title: props.title,\n        values: props.values,\n        createdAt: createdAt,\n        modifiedAt: Date.now(),\n      });\n    }\n  }\n);\n\nexport async function createKVNamespace(\n  api: CloudflareApi,\n  props: KVNamespaceProps\n): Promise<{ id: string }> {\n  const createResponse = await api.post(\n    `/accounts/${api.accountId}/storage/kv/namespaces`,\n    {\n      title: props.title,\n    }\n  );\n\n  if (!createResponse.ok) {\n    await handleApiError(createResponse, \"create\", \"kv_namespace\", props.title);\n  }\n\n  return { id: ((await createResponse.json()) as any).result.id };\n}\n\nexport async function deleteKVNamespace(\n  api: CloudflareApi,\n  namespaceId: string\n) {\n  // Delete KV namespace\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/storage/kv/namespaces/${namespaceId}`\n  );\n\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    await handleApiError(deleteResponse, \"delete\", \"kv_namespace\", namespaceId);\n  }\n}\n\nexport async function insertKVRecords(\n  api: CloudflareApi,\n  namespaceId: string,\n  props: KVNamespaceProps\n) {\n  if (props.values && props.values.length > 0) {\n    // Process KV pairs in batches of 10000 (API limit)\n    const BATCH_SIZE = 10000;\n\n    for (let i = 0; i < props.values.length; i += BATCH_SIZE) {\n      const batch = props.values.slice(i, i + BATCH_SIZE);\n\n      const bulkPayload = batch.map((entry) => {\n        const item: any = {\n          key: entry.key,\n          value:\n            typeof entry.value === \"string\"\n              ? entry.value\n              : JSON.stringify(entry.value),\n        };\n\n        if (entry.expiration) {\n          item.expiration = entry.expiration;\n        }\n\n        if (entry.expirationTtl) {\n          item.expiration_ttl = entry.expirationTtl;\n        }\n\n        if (entry.metadata) {\n          item.metadata = entry.metadata;\n        }\n\n        return item;\n      });\n\n      try {\n        await withExponentialBackoff(\n          async () => {\n            const bulkResponse = await api.put(\n              `/accounts/${api.accountId}/storage/kv/namespaces/${namespaceId}/bulk`,\n              bulkPayload\n            );\n\n            if (!bulkResponse.ok) {\n              const errorData: any = await bulkResponse.json().catch(() => ({\n                errors: [{ message: bulkResponse.statusText }],\n              }));\n              const errorMessage =\n                errorData.errors?.[0]?.message || bulkResponse.statusText;\n\n              // Throw error to trigger retry\n              throw new Error(`Error writing KV batch: ${errorMessage}`);\n            }\n\n            return bulkResponse;\n          },\n          (error) => {\n            // Retry on \"namespace not found\" errors as they're likely propagation delays\n            return error.message?.includes(\"not found\");\n          },\n          5, // 5 retry attempts\n          1000 // Start with 1 second delay\n        );\n      } catch (error: any) {\n        console.warn(error.message);\n      }\n    }\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/permission-groups.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { createCloudflareApi, type CloudflareApiOptions } from \"./api\";\n\n/**\n * Cloudflare permission group as returned by the API\n */\nexport interface PermissionGroup {\n  /**\n   * Unique identifier for the permission group\n   */\n  id: string;\n\n  /**\n   * Human-readable name of the permission group\n   */\n  name: string;\n\n  /**\n   * Scopes included in this permission group\n   */\n  scopes: string[];\n}\n\n/**\n * Response from the Cloudflare permission groups API\n */\ninterface PermissionGroupsResponse {\n  result: PermissionGroup[];\n  success: boolean;\n  errors: any[];\n  messages: any[];\n}\n\n/**\n * All Cloudflare permission groups mapped by name to ID\n *\n * @see https://developers.cloudflare.com/r2/api/tokens/#permissions\n */\nexport type PermissionGroups = Resource<\"cloudflare::PermissionGroups\"> & {\n  /**\n   * Admin Read & Write - Allows create, list, delete buckets and edit bucket configurations\n   * plus list, write, and read object access\n   */\n  \"Workers R2 Storage Write\": PermissionGroup;\n\n  /**\n   * Admin Read only - Allows list buckets and view bucket configuration\n   * plus list and read object access\n   */\n  \"Workers R2 Storage Read\": PermissionGroup;\n\n  /**\n   * Object Read & Write - Allows read, write, and list objects in specific buckets\n   */\n  \"Workers R2 Storage Bucket Item Write\": PermissionGroup;\n\n  /**\n   * Object Read only - Allows read and list objects in specific buckets\n   */\n  \"Workers R2 Storage Bucket Item Read\": PermissionGroup;\n\n  /**\n   * Dynamically discovered permission groups\n   */\n  [name: string]: PermissionGroup;\n};\n\n/**\n * Lists all permission groups available for the Cloudflare account\n * and returns a typed map of permission names to their IDs.\n *\n * This is primarily used when creating API tokens for Cloudflare services like R2.\n *\n * Note: Requires a Cloudflare API Key or Token with account read access.\n * The API token must have permission to read token permission groups.\n * The OAuth token from `wrangler login` is NOT sufficient for this operation.\n *\n * @example\n * // Get all permission groups including those for R2\n * const permissions = await PermissionGroups(\"cloudflare-permissions\");\n *\n * // Use with AccountApiToken to create a token with proper permissions\n * const token = await AccountApiToken(\"r2-token\", {\n *   name: \"R2 Read-Only Token\",\n *   policies: [\n *     {\n *       effect: \"allow\",\n *       resources: {\n *         \"com.cloudflare.edge.r2.bucket.abc123_default_my-bucket\": \"*\"\n *       },\n *       permissionGroups: [\n *         {\n *           id: permissions[\"Workers R2 Storage Bucket Item Read\"]\n *         }\n *       ]\n *     }\n *   ]\n * });\n */\nexport const PermissionGroups = Resource(\n  \"cloudflare::PermissionGroups\",\n  async function (\n    this: Context<PermissionGroups>,\n    id: string,\n    options: CloudflareApiOptions = {}\n  ): Promise<PermissionGroups> {\n    // Only create and update phases are supported\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Initialize API client\n    const api = await createCloudflareApi(options);\n\n    // Fetch permission groups from Cloudflare API\n    const response = await api.get(\n      `/accounts/${api.accountId}/tokens/permission_groups`\n    );\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch permission groups: ${response.statusText}`\n      );\n    }\n\n    const data = (await response.json()) as PermissionGroupsResponse;\n\n    if (!data.success || !data.result) {\n      throw new Error(\n        `API returned error: ${data.errors?.[0]?.message || \"Unknown error\"}`\n      );\n    }\n\n    return this(\n      Object.fromEntries(\n        data.result.map((group) => [group.name, group])\n      ) as PermissionGroups\n    );\n  }\n);\n\n```\n\n// alchemy/src/cloudflare/r2-rest-state-store.ts\n```ts\nimport type { Scope } from \"../scope\";\nimport { deserialize, serialize } from \"../serde\";\nimport type { State, StateStore } from \"../state\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport {\n  type CloudflareApi,\n  type CloudflareApiOptions,\n  createCloudflareApi,\n} from \"./api\";\n\n/**\n * Options for CloudflareR2StateStore\n */\nexport interface CloudflareR2StateStoreOptions extends CloudflareApiOptions {\n  /**\n   * The prefix to use for object keys in the R2 bucket\n   * This allows multiple state stores to use the same R2 bucket\n   */\n  prefix?: string;\n\n  /**\n   * The R2 bucket name to use\n   * Required - the bucket must already exist\n   */\n  bucketName: string;\n}\n\n/**\n * State store implementation using Cloudflare R2 API\n * Uses R2 for immediate consistency compared to KV's eventual consistency\n */\nexport class R2RestStateStore implements StateStore {\n  private api: CloudflareApi;\n  private prefix: string;\n  private bucketName: string;\n  private initialized = false;\n\n  /**\n   * Create a new CloudflareR2StateStore\n   *\n   * @param scope The scope this store belongs to\n   * @param options Options for the state store\n   */\n  constructor(\n    public readonly scope: Scope,\n    private readonly options: CloudflareR2StateStoreOptions\n  ) {\n    // Use the scope's chain to build the prefix, similar to how FileSystemStateStore builds its directory\n    const scopePath = scope.chain.join(\"/\");\n    this.prefix = options.prefix\n      ? `${options.prefix}${scopePath}/`\n      : `alchemy/${scopePath}/`;\n\n    if (!options.bucketName) {\n      throw new Error(\"bucketName is required for CloudflareR2StateStore\");\n    }\n    this.bucketName = options.bucketName;\n\n    // We'll initialize the API in init() to allow for async creation\n    this.api = null as any;\n  }\n\n  /**\n   * Initialize the R2 client\n   */\n  async init(): Promise<void> {\n    if (this.initialized) return;\n\n    // Create Cloudflare API client with automatic account discovery\n    this.api = await createCloudflareApi(this.options);\n\n    this.initialized = true;\n  }\n\n  /**\n   * R2 buckets cannot be deleted programmatically via this method\n   */\n  async deinit(): Promise<void> {\n    // We don't delete the bucket here, only via explicit resource deletion\n  }\n\n  /**\n   * List all resources in the state store\n   */\n  async list(): Promise<string[]> {\n    await this.ensureInitialized();\n\n    // Using pagination to get all objects\n    let keys: string[] = [];\n    let cursor: string | null = null;\n\n    do {\n      const params = new URLSearchParams({\n        prefix: this.prefix,\n        limit: \"1000\",\n      });\n\n      if (cursor) {\n        params.append(\"cursor\", cursor);\n      }\n\n      const listPath = `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects?${params.toString()}`;\n\n      const response = await withExponentialBackoff(\n        async () => {\n          const response = await this.api.get(listPath);\n\n          if (!response.ok) {\n            const errorData: any = await response.json().catch(() => ({\n              errors: [{ message: response.statusText }],\n            }));\n            throw new Error(\n              `Error listing R2 objects: ${errorData.errors?.[0]?.message || response.statusText}`\n            );\n          }\n\n          return response;\n        },\n        // Retry on transient errors\n        (error) =>\n          error.message?.includes(\"502\") ||\n          error.message?.includes(\"503\") ||\n          error.message?.includes(\"timeout\"),\n        5, // 5 retry attempts\n        1000 // Start with 1 second delay\n      );\n\n      const data = (await response.json()) as any;\n\n      // The result structure may be under \"result\" key in Cloudflare's API\n      const result = data.result || data;\n      const objects = result.objects || [];\n\n      // Add keys to our list, removing the prefix and converting from storage format\n      keys = keys.concat(\n        objects.map((obj: any) => {\n          const keyName = obj.key || obj.name;\n          return this.convertKeyFromStorage(keyName.slice(this.prefix.length));\n        })\n      );\n\n      // Update cursor for next page if available\n      cursor =\n        result.truncated || result.cursor_pagination\n          ? result.cursor || null\n          : null;\n    } while (cursor);\n\n    return keys;\n  }\n\n  /**\n   * Count the number of items in the state store\n   */\n  async count(): Promise<number> {\n    const keys = await this.list();\n    return keys.length;\n  }\n\n  /**\n   * Get a state by key\n   *\n   * @param key The key to look up\n   * @returns The state or undefined if not found\n   */\n  async get(key: string): Promise<State | undefined> {\n    await this.ensureInitialized();\n\n    try {\n      const response = await withExponentialBackoff(\n        async () => {\n          const response = await this.api.get(\n            `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects/${this.getObjectKey(key)}`\n          );\n\n          if (!response.ok) {\n            if (response.status === 404) {\n              return response;\n            }\n\n            const errorData: any = await response.json().catch(() => ({\n              errors: [{ message: response.statusText }],\n            }));\n            throw new Error(\n              `Error getting R2 object: ${errorData.errors?.[0]?.message || response.statusText}`\n            );\n          }\n\n          return response;\n        },\n        // Retry on transient errors\n        (error) =>\n          error.message?.includes(\"502\") ||\n          error.message?.includes(\"503\") ||\n          error.message?.includes(\"timeout\"),\n        5, // 5 retry attempts\n        1000 // Start with 1 second delay\n      );\n\n      if (response.status === 404) {\n        return undefined;\n      }\n\n      // Parse and deserialize the state data\n      const rawData = await response.json();\n      const state = (await deserialize(this.scope, rawData)) as State;\n\n      // Create a new state object with proper output\n      return {\n        ...state,\n        output: {\n          ...(state.output || {}),\n          Scope: this.scope,\n        },\n      };\n    } catch (error: any) {\n      if (error.message?.includes(\"404\")) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get multiple states by their keys\n   *\n   * @param ids Array of keys to fetch\n   * @returns Record mapping keys to their states\n   */\n  async getBatch(ids: string[]): Promise<Record<string, State>> {\n    const result: Record<string, State> = {};\n\n    // R2 REST API doesn't have a batch get operation, so we need to make multiple requests\n    const promises = ids.map(async (id) => {\n      const state = await this.get(id);\n      if (state) {\n        result[id] = state;\n      }\n    });\n\n    await Promise.all(promises);\n    return result;\n  }\n\n  /**\n   * Get all states in the store\n   *\n   * @returns Record mapping all keys to their states\n   */\n  async all(): Promise<Record<string, State>> {\n    const keys = await this.list();\n    return this.getBatch(keys);\n  }\n\n  /**\n   * Set a state for a key\n   *\n   * @param key The key to set\n   * @param value The state to store\n   */\n  async set(key: string, value: State): Promise<void> {\n    await this.ensureInitialized();\n\n    const objectKey = this.getObjectKey(key);\n\n    // Serialize the state to handle cyclic structures\n    const serializedData = await serialize(this.scope, value);\n\n    // Using withExponentialBackoff for reliability\n    await withExponentialBackoff(\n      async () => {\n        const response = await this.api.put(\n          `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects/${objectKey}`,\n          serializedData,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n          }\n        );\n\n        if (!response.ok) {\n          const errorData: any = await response.json().catch(() => ({\n            errors: [{ message: response.statusText }],\n          }));\n          throw new Error(\n            `Error writing to R2: ${errorData.errors?.[0]?.message || response.statusText}`\n          );\n        }\n\n        return response;\n      },\n      // Retry on transient errors\n      (error) =>\n        error.message?.includes(\"503\") || error.message?.includes(\"timeout\"),\n      5, // 5 retry attempts\n      1000 // Start with 1 second delay\n    );\n  }\n\n  /**\n   * Delete a state by key\n   *\n   * @param key The key to delete\n   */\n  async delete(key: string): Promise<void> {\n    await this.ensureInitialized();\n\n    await withExponentialBackoff(\n      async () => {\n        const response = await this.api.delete(\n          `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects/${this.getObjectKey(key)}`\n        );\n\n        if (!response.ok && response.status !== 404) {\n          const errorData: any = await response.json().catch(() => ({\n            errors: [{ message: response.statusText }],\n          }));\n          throw new Error(\n            `Error deleting from R2: ${errorData.errors?.[0]?.message || response.statusText}`\n          );\n        }\n\n        return response;\n      },\n      // Retry on transient errors\n      (error) =>\n        error.message?.includes(\"502\") ||\n        error.message?.includes(\"503\") ||\n        error.message?.includes(\"timeout\"),\n      5, // 5 retry attempts\n      1000 // Start with 1 second delay\n    );\n  }\n\n  /**\n   * Convert key for storage by replacing slashes with colons\n   * since R2 treats slashes as directory separators\n   *\n   * @param key The original key\n   * @returns Key with slashes replaced by colons\n   */\n  private convertKeyForStorage(key: string): string {\n    return key.replaceAll(\"/\", \":\");\n  }\n\n  /**\n   * Convert key from storage by replacing colons with slashes\n   *\n   * @param key The storage key\n   * @returns Key with colons replaced by slashes\n   */\n  private convertKeyFromStorage(key: string): string {\n    return key.replaceAll(\":\", \"/\");\n  }\n\n  /**\n   * Get the full object key for storage\n   *\n   * @param key The original key\n   * @returns The key with prefix for use in the R2 bucket\n   */\n  private getObjectKey(key: string): string {\n    return `${this.prefix}${this.convertKeyForStorage(key)}`;\n  }\n\n  /**\n   * Ensure the store is initialized before operations\n   */\n  private async ensureInitialized(): Promise<void> {\n    if (!this.initialized) {\n      await this.init();\n    }\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/response.ts\n```ts\n/**\n * Cloudflare API response format\n */\nexport interface CloudflareResponse<T = unknown> {\n  result: T;\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n}\n\n```\n\n// alchemy/src/cloudflare/types.ts\n```ts\n/**\n * Cloudflare API response format\n */\nexport interface CloudflareApiResponse<T> {\n  /**\n   * API response result\n   */\n  result: T;\n\n  /**\n   * Success status\n   */\n  success: boolean;\n\n  /**\n   * Error details if success is false\n   */\n  errors: CloudflareApiError[];\n\n  /**\n   * Response messages\n   */\n  messages: string[];\n\n  /**\n   * Result information (typically for paginated results)\n   */\n  result_info?: {\n    page: number;\n    per_page: number;\n    total_pages: number;\n    count: number;\n    total_count: number;\n  };\n}\n\n/**\n * Cloudflare API error format\n */\nexport interface CloudflareApiError {\n  /**\n   * Error code\n   */\n  code: number;\n\n  /**\n   * Error message\n   */\n  message: string;\n}\n\n/**\n * Helper to extract and handle Cloudflare API errors\n *\n * @param response Fetch response object\n * @returns Formatted error message\n */\nexport async function extractCloudflareError(\n  response: Response,\n): Promise<string> {\n  try {\n    const data = (await response.json()) as CloudflareApiResponse<any>;\n    if (data.errors && data.errors.length > 0) {\n      return data.errors.map((e) => `Error ${e.code}: ${e.message}`).join(\", \");\n    } else {\n      return `HTTP ${response.status}: ${response.statusText}`;\n    }\n  } catch (e) {\n    return `HTTP ${response.status}: ${response.statusText}`;\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/worker-metadata.ts\n```ts\n/**\n * Metadata returned by Cloudflare API for a worker script\n */\nexport interface WorkerScriptMetadata {\n  /**\n   * Worker ID\n   */\n  id: string;\n\n  /**\n   * Default environment information\n   */\n  default_environment?: WorkerDefaultEnvironment;\n\n  /**\n   * Worker creation timestamp\n   */\n  created_on: string;\n\n  /**\n   * Worker last modification timestamp\n   */\n  modified_on: string;\n\n  /**\n   * Worker usage model\n   */\n  usage_model: string;\n\n  /**\n   * Worker environments\n   */\n  environments?: WorkerEnvironment[];\n}\n\n/**\n * Worker script information\n */\nexport interface WorkerScriptInfo {\n  /**\n   * Script creation timestamp\n   */\n  created_on: string;\n\n  /**\n   * Script last modification timestamp\n   */\n  modified_on: string;\n\n  /**\n   * Script ID\n   */\n  id: string;\n\n  /**\n   * Script tag\n   */\n  tag: string;\n\n  /**\n   * Script tags\n   */\n  tags: string[];\n\n  /**\n   * Deployment ID\n   */\n  deployment_id: string;\n\n  /**\n   * Tail consumers\n   */\n  tail_consumers: any;\n\n  /**\n   * Whether logpush is enabled\n   */\n  logpush: boolean;\n\n  /**\n   * Observability settings\n   */\n  observability: {\n    /**\n     * Whether observability is enabled\n     */\n    enabled: boolean;\n\n    /**\n     * Head sampling rate\n     */\n    head_sampling_rate: number | null;\n  };\n\n  /**\n   * Whether the script has assets\n   */\n  has_assets: boolean;\n\n  /**\n   * Whether the script has modules\n   */\n  has_modules: boolean;\n\n  /**\n   * Script etag\n   */\n  etag: string;\n\n  /**\n   * Script handlers\n   */\n  handlers: string[];\n\n  /**\n   * Where the script was last deployed from\n   */\n  last_deployed_from: string;\n\n  /**\n   * Script usage model\n   */\n  usage_model: string;\n}\n\n/**\n * Worker environment information\n */\nexport interface WorkerEnvironment {\n  /**\n   * Environment name\n   */\n  environment: string;\n\n  /**\n   * Environment creation timestamp\n   */\n  created_on: string;\n\n  /**\n   * Environment last modification timestamp\n   */\n  modified_on: string;\n}\n\n/**\n * Default environment with script information\n */\nexport interface WorkerDefaultEnvironment extends WorkerEnvironment {\n  /**\n   * Script information\n   */\n  script: WorkerScriptInfo;\n}\n\n```\n\n// alchemy/src/cloudflare/worker-migration.ts\n```ts\nexport type WorkerMigrations = SingleStepMigration | MultiStepMigration;\n\nexport function isSingleStepMigration(\n  migration: WorkerMigrations,\n): migration is SingleStepMigration {\n  return (\n    \"deleted_classes\" in migration ||\n    \"new_classes\" in migration ||\n    \"new_sqlite_classes\" in migration ||\n    \"renamed_classes\" in migration ||\n    \"transferred_classes\" in migration\n  );\n}\n\nexport interface SingleStepMigration {\n  /**\n   * A list of classes to delete Durable Object namespaces from\n   */\n  deleted_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces from\n   */\n  new_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces with SQLite from\n   */\n  new_sqlite_classes?: string[];\n\n  /**\n   * Tag to set as the latest migration tag\n   */\n  new_tag?: string;\n\n  /**\n   * Tag used to verify against the latest migration tag for this Worker.\n   * If they don't match, the upload is rejected.\n   */\n  old_tag?: string;\n\n  /**\n   * A list of classes with Durable Object namespaces that were renamed\n   */\n  renamed_classes?: RenamedClass[];\n\n  /**\n   * A list of transfers for Durable Object namespaces from a different Worker\n   * and class to a class defined in this Worker\n   */\n  transferred_classes?: TransferredClass[];\n}\n\n/**\n * Represents a renamed class in a Durable Object migration\n */\nexport interface RenamedClass {\n  /**\n   * Original class name\n   */\n  from: string;\n\n  /**\n   * New class name\n   */\n  to: string;\n}\n\n/**\n * Represents a transferred class in a Durable Object migration\n */\nexport interface TransferredClass {\n  /**\n   * Original class name\n   */\n  from: string;\n\n  /**\n   * Original script name\n   */\n  from_script: string;\n\n  /**\n   * New class name in this Worker\n   */\n  to: string;\n}\n\nexport function isMultiStepMigration(\n  migration: WorkerMigrations,\n): migration is MultiStepMigration {\n  return \"steps\" in migration;\n}\n\n/**\n * Represents a multi-step migration for Durable Objects\n */\nexport interface MultiStepMigration {\n  /**\n   * Tag to set as the latest migration tag\n   */\n  new_tag?: string;\n\n  /**\n   * Tag used to verify against the latest migration tag for this Worker.\n   * If they don't match, the upload is rejected.\n   */\n  old_tag?: string;\n\n  /**\n   * Migrations to apply in order\n   */\n  steps: MigrationStep[];\n}\n\n/**\n * Represents a single step in a Durable Object migration\n */\nexport interface MigrationStep {\n  /**\n   * A list of classes to delete Durable Object namespaces from\n   */\n  deleted_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces from\n   */\n  new_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces with SQLite from\n   */\n  new_sqlite_classes?: string[];\n\n  /**\n   * A list of classes with Durable Object namespaces that were renamed\n   */\n  renamed_classes?: RenamedClass[];\n\n  /**\n   * A list of transfers for Durable Object namespaces from a different Worker\n   * and class to a class defined in this Worker\n   */\n  transferred_classes?: TransferredClass[];\n}\n\n```\n\n// alchemy/src/cloudflare/worker.ts\n```ts\nimport * as crypto from \"crypto\";\nimport * as fs from \"fs/promises\";\nimport type { Context } from \"../context\";\nimport { Bundle, type BundleProps } from \"../esbuild/bundle\";\nimport { Resource } from \"../resource\";\nimport { isSecret } from \"../secret\";\nimport { getContentType } from \"../util/content-type\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport { slugify } from \"../util/slugify\";\nimport {\n  type CloudflareApi,\n  type CloudflareApiOptions,\n  createCloudflareApi,\n} from \"./api\";\nimport type { Assets } from \"./assets\";\nimport {\n  type Bindings,\n  type WorkerBindingSpec,\n  isAssets,\n  isDurableObjectNamespace,\n} from \"./bindings\";\nimport type { Bound } from \"./bound\";\nimport type { DurableObjectNamespace } from \"./durable-object-namespace\";\nimport { isKVNamespace } from \"./kv-namespace\";\nimport type { WorkerScriptMetadata } from \"./worker-metadata\";\nimport type { SingleStepMigration } from \"./worker-migration\";\n\n/**\n * Properties for creating or updating a Worker\n */\nexport interface WorkerProps<B extends Bindings = Bindings>\n  extends CloudflareApiOptions {\n  /**\n   * The worker script content (JavaScript or WASM)\n   * One of script, entryPoint, or bundle must be provided\n   */\n  script?: string;\n\n  /**\n   * Path to the entry point file\n   * Will be bundled using esbuild\n   * One of script, entryPoint, or bundle must be provided\n   */\n  entrypoint?: string;\n\n  /**\n   * Bundle options when using entryPoint\n   * Ignored if bundle is provided\n   */\n  bundle?: Omit<BundleProps, \"entryPoint\">;\n\n  /**\n   * Module format for the worker script\n   * 'esm' - ECMAScript modules (default)\n   * 'cjs' - CommonJS modules\n   * @default 'esm'\n   */\n  format?: \"esm\" | \"cjs\";\n\n  /**\n   * Name for the worker\n   * This is mandatory - must be explicitly specified\n   */\n  name: string;\n\n  /**\n   * Bindings to attach to the worker\n   */\n  bindings?: B;\n\n  /**\n   * Environment variables to attach to the worker\n   * These will be converted to plain_text bindings\n   */\n  env?: {\n    [key: string]: string;\n  };\n\n  /**\n   * Whether to enable a workers.dev URL for this worker\n   * If true, the worker will be available at {name}.{subdomain}.workers.dev\n   * @default false\n   */\n  url?: boolean;\n\n  /**\n   * Observability configuration for the worker\n   * Controls whether worker logs are enabled\n   * @default { enabled: true }\n   */\n  observability?: {\n    /**\n     * Whether to enable worker logs\n     * @default true\n     */\n    enabled?: boolean;\n  };\n\n  /**\n   * Migrations to apply to the worker\n   */\n  migrations?: SingleStepMigration;\n\n  /**\n   * Whether to adopt the Worker if it already exists when creating\n   */\n  adopt?: boolean;\n}\n\n/**\n * Output returned after Worker creation/update\n */\nexport interface Worker<B extends Bindings = Bindings>\n  extends Resource<\"cloudflare::Worker\">,\n    Omit<WorkerProps<B>, \"url\"> {\n  type: \"service\";\n\n  /**\n   * The ID of the worker\n   */\n  id: string;\n\n  /**\n   * Time at which the worker was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the worker was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * The worker's URL if enabled\n   * Format: {name}.{subdomain}.workers.dev\n   */\n  url?: string;\n\n  /**\n   * The bindings that were created\n   */\n  bindings: B | undefined;\n\n  // phantom property (for typeof myWorker.Env)\n  Env: {\n    [bindingName in keyof B]: Bound<B[bindingName]>;\n  };\n}\n\n/**\n * A Cloudflare Worker is a serverless function that can be deployed to the Cloudflare network.\n *\n * @example\n * // Create a basic HTTP handler worker with custom domain routing\n * // and workers.dev URL:\n * const api = await Worker(\"api\", {\n *   name: \"api-worker\",\n *   entrypoint: \"./src/api.ts\",\n *   routes: [\"api.example.com/*\"],\n *   url: true\n * });\n *\n * @example\n * // Create a real-time chat worker using Durable Objects\n * // for state management:\n * const chatRooms = new DurableObjectNamespace(\"chat-rooms\");\n * const userStore = new DurableObjectNamespace(\"user-store\");\n *\n * const chat = await Worker(\"chat\", {\n *   name: \"chat-worker\",\n *   entrypoint: \"./src/chat.ts\",\n *   bindings: {\n *     ROOMS: chatRooms,\n *     USERS: userStore\n *   },\n * });\n *\n * @example\n * // Create a worker with KV namespace for caching and data storage:\n * const cache = await KVNamespace(\"cache-store\");\n * const settings = await KVNamespace(\"user-settings\");\n *\n * const cacheWorker = await Worker(\"cache\", {\n *   name: \"cache-worker\",\n *   entrypoint: \"./src/cache.ts\",\n *   bindings: {\n *     CACHE: cache,\n *     SETTINGS: settings\n *   }\n * });\n *\n * @example\n * // Create a worker with R2 bucket for object storage:\n * const uploads = await R2Bucket(\"uploads\", {\n *   name: \"user-uploads\"\n * });\n * const assets = await R2Bucket(\"assets\", {\n *   name: \"static-assets\",\n *   allowPublicAccess: true\n * });\n *\n * const storageWorker = await Worker(\"storage\", {\n *   name: \"storage-worker\",\n *   entrypoint: \"./src/storage.ts\",\n *   bindings: {\n *     UPLOADS: uploads,\n *     ASSETS: assets\n *   }\n * });\n *\n * @example\n * // Create a worker with static assets:\n * const staticAssets = await Assets(\"static\", {\n *   path: \"./src/assets\"\n * });\n *\n * const frontendWorker = await Worker(\"frontend\", {\n *   name: \"frontend-worker\",\n *   entrypoint: \"./src/worker.ts\",\n *   bindings: {\n *     ASSETS: staticAssets\n *   }\n * });\n *\n * @see https://developers.cloudflare.com/workers/\n */\nexport const Worker = Resource(\n  \"cloudflare::Worker\",\n  {\n    alwaysUpdate: true,\n  },\n  async function <const B extends Bindings>(\n    this: Context<Worker<NoInfer<B>>>,\n    id: string,\n    props: WorkerProps<B>\n  ): Promise<Worker<B>> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    // Use the provided name\n    const workerName = props.name;\n\n    // Validate input - we need either script, entryPoint, or bundle\n    if (!props.script && !props.entrypoint) {\n      throw new Error(\"One of script or entryPoint must be provided\");\n    }\n\n    if (this.phase === \"delete\") {\n      await deleteWorker(this, api, workerName);\n      return this.destroy();\n    } else if (this.phase === \"create\") {\n      if (!props.adopt) {\n        await assertWorkerDoesNotExist(this, api, workerName);\n      }\n    }\n\n    const oldBindings = await this.get<Bindings>(\"bindings\");\n\n    // Get the script content - either from props.script, or by bundling\n    const scriptContent = props.script ?? (await bundleWorkerScript(props));\n\n    // Find any assets bindings\n    const assetsBindings: { name: string; assets: Assets }[] = [];\n    if (props.bindings) {\n      for (const [bindingName, binding] of Object.entries(props.bindings)) {\n        if (isAssets(binding)) {\n          assetsBindings.push({ name: bindingName, assets: binding });\n        }\n      }\n    }\n\n    // Upload any assets and get completion tokens\n    let assetUploadResult: AssetUploadResult | undefined;\n    if (assetsBindings.length > 0) {\n      // We'll use the first asset binding for now\n      // In the future, we might want to support multiple asset bindings\n      const assetBinding = assetsBindings[0];\n\n      // Upload the assets and get the completion token\n      assetUploadResult = await uploadAssets(\n        api,\n        workerName,\n        assetBinding.assets\n      );\n    }\n\n    // Prepare metadata with bindings\n    const scriptMetadata = await prepareWorkerMetadata(\n      this,\n      oldBindings,\n      props,\n      assetUploadResult\n    );\n\n    // Upload the worker script\n    await putWorker(api, workerName, scriptContent, scriptMetadata);\n\n    // TODO: it is less than ideal that this can fail, resulting in state problem\n    await this.set(\"bindings\", props.bindings);\n\n    // Handle worker URL if requested\n    const workerUrl = await configureURL(\n      this,\n      api,\n      workerName,\n      props.url ?? false\n    );\n\n    // Get current timestamp\n    const now = Date.now();\n\n    // Construct the output\n    return this({\n      type: \"service\",\n      id,\n      name: workerName,\n      script: scriptContent,\n      format: props.format || \"esm\", // Include format in the output\n      bindings: props.bindings ?? ({} as B),\n      env: props.env,\n      observability: scriptMetadata.observability,\n      createdAt: now,\n      updatedAt: now,\n      url: workerUrl,\n      // phantom property\n      Env: undefined!,\n    });\n  }\n);\n\nasync function deleteWorker<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  api: CloudflareApi,\n  workerName: string\n) {\n  // Delete worker\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/workers/scripts/${workerName}`\n  );\n\n  // Check for success (2xx status code)\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    const errorData: any = await deleteResponse\n      .json()\n      .catch(() => ({ errors: [{ message: deleteResponse.statusText }] }));\n    console.error(\n      \"Error deleting worker:\",\n      errorData.errors?.[0]?.message || deleteResponse.statusText\n    );\n  }\n\n  // Disable the URL if it was enabled\n  if (ctx.output?.url) {\n    try {\n      await api.post(\n        `/accounts/${api.accountId}/workers/scripts/${workerName}/subdomain`,\n        JSON.stringify({ enabled: false }),\n        {\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    } catch (error) {\n      console.warn(\"Failed to disable worker URL during deletion:\", error);\n    }\n  }\n\n  // Return minimal output for deleted state\n  return;\n}\n\nasync function putWorker(\n  api: CloudflareApi,\n  workerName: string,\n  scriptContent: string,\n  scriptMetadata: WorkerMetadata\n) {\n  return withExponentialBackoff(\n    async () => {\n      const scriptName =\n        scriptMetadata.main_module ?? scriptMetadata.body_part!;\n\n      // Create FormData for the upload\n      const formData = new FormData();\n\n      // Add the actual script content as a named file part\n      formData.append(\n        scriptName,\n        new Blob([scriptContent], {\n          type: scriptMetadata.main_module\n            ? \"application/javascript+module\"\n            : \"application/javascript\",\n        }),\n        scriptName\n      );\n\n      // Add metadata as JSON\n      formData.append(\n        \"metadata\",\n        new Blob([JSON.stringify(scriptMetadata)], {\n          type: \"application/json\",\n        })\n      );\n\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n\n      // Upload worker script with bindings\n      const uploadResponse = await api.put(\n        `/accounts/${api.accountId}/workers/scripts/${workerName}`,\n        formData,\n        {\n          headers: {\n            \"Content-Type\": \"multipart/form-data\",\n          },\n        }\n      );\n\n      // Check if the upload was successful\n      if (!uploadResponse.ok) {\n        const errorData: any = await uploadResponse\n          .json()\n          .catch(() => ({ errors: [{ message: uploadResponse.statusText }] }));\n\n        const errorMessage = `Error (HTTP ${uploadResponse.status}) uploading worker script '${workerName}': ${errorData.errors?.[0]?.message || uploadResponse.statusText}`;\n\n        if (\n          uploadResponse.status === 400 &&\n          errorMessage.includes(\"not found\")\n        ) {\n          throw new NotFoundError(errorMessage);\n        }\n        throw new Error(errorMessage);\n      }\n\n      return formData;\n    },\n    (err) => err instanceof NotFoundError,\n    10,\n    100\n  );\n}\n\nclass NotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"NotFoundError\";\n  }\n}\n\ninterface WorkerMetadata {\n  bindings: WorkerBindingSpec[];\n  observability: {\n    enabled: boolean;\n  };\n  migrations?: SingleStepMigration;\n  main_module?: string;\n  body_part?: string;\n  tags?: string[];\n  assets?: {\n    jwt?: string;\n    keep_assets?: boolean;\n    config?: {\n      html_handling?: \"auto-trailing-slash\" | \"none\";\n      not_found_handling?: \"none\" | \"fall-through\";\n    };\n  };\n}\n\ninterface AssetUploadResult {\n  completionToken: string;\n  assetConfig?: {\n    html_handling?: \"auto-trailing-slash\" | \"none\";\n    not_found_handling?: \"none\" | \"fall-through\";\n  };\n}\n\nasync function prepareWorkerMetadata<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  oldBindings: Bindings | undefined,\n  props: WorkerProps,\n  assetUploadResult?: AssetUploadResult\n): Promise<WorkerMetadata> {\n  // Prepare metadata with bindings\n  const meta: WorkerMetadata = {\n    bindings: [],\n    observability: {\n      enabled: props.observability?.enabled !== false,\n    },\n    // TODO(sam): base64 encode instead? 0 collision risk vs readability.\n    tags: [`alchemy:id:${slugify(ctx.fqn)}`],\n    migrations: {\n      new_classes: props.migrations?.new_classes ?? [],\n      deleted_classes: props.migrations?.deleted_classes ?? [],\n      renamed_classes: props.migrations?.renamed_classes ?? [],\n      transferred_classes: props.migrations?.transferred_classes ?? [],\n      new_sqlite_classes: props.migrations?.new_sqlite_classes ?? [],\n    },\n  };\n\n  // If we have asset upload results, add them to the metadata\n  if (assetUploadResult) {\n    meta.assets = {\n      jwt: assetUploadResult.completionToken,\n    };\n\n    if (assetUploadResult.assetConfig) {\n      meta.assets.config = assetUploadResult.assetConfig;\n    }\n  }\n\n  const bindings = (props.bindings ?? {}) as Bindings;\n\n  // Convert bindings to the format expected by the API\n  for (const [bindingName, binding] of Object.entries(bindings)) {\n    // Create a copy of the binding to avoid modifying the original\n\n    if (isKVNamespace(binding)) {\n      meta.bindings.push({\n        type: \"kv_namespace\",\n        name: bindingName,\n        namespace_id: binding.namespaceId,\n      });\n    } else if (typeof binding === \"string\") {\n      meta.bindings.push({\n        type: \"plain_text\",\n        name: bindingName,\n        text: binding,\n      });\n    } else if (binding.type === \"service\") {\n      meta.bindings.push({\n        type: \"service\",\n        name: bindingName,\n        service: binding.id,\n      });\n    } else if (binding.type === \"durable_object_namespace\") {\n      const stableId = binding.id;\n      const className = binding.className;\n\n      meta.bindings.push({\n        type: \"durable_object_namespace\",\n        name: bindingName,\n        class_name: className,\n        script_name: binding.scriptName,\n        environment: binding.environment,\n        namespace_id: binding.namespaceId,\n      });\n\n      const oldBinding: DurableObjectNamespace | undefined = Object.values(\n        oldBindings ?? {}\n      )\n        ?.filter(isDurableObjectNamespace)\n        ?.find((b) => b.id === stableId);\n\n      if (!oldBinding) {\n        if (binding.sqlite) {\n          meta.migrations!.new_sqlite_classes!.push(className);\n        } else {\n          meta.migrations!.new_classes!.push(className);\n        }\n      } else if (oldBinding.className !== className) {\n        meta.migrations!.renamed_classes!.push({\n          from: oldBinding.className,\n          to: className,\n        });\n      }\n    } else if (binding.type === \"r2_bucket\") {\n      meta.bindings.push({\n        type: \"r2_bucket\",\n        name: bindingName,\n        bucket_name: binding.name,\n      });\n    } else if (isAssets(binding)) {\n      meta.bindings.push({\n        type: \"assets\",\n        name: bindingName,\n      });\n    } else if (isSecret(binding)) {\n      meta.bindings.push({\n        type: \"secret_text\",\n        name: bindingName,\n        text: binding.unencrypted,\n      });\n    } else {\n      // @ts-expect-error - we should never reach here\n      throw new Error(`Unsupported binding type: ${binding.type}`);\n    }\n  }\n\n  // Convert env variables to plain_text bindings\n  if (props.env) {\n    for (const [key, value] of Object.entries(props.env)) {\n      meta.bindings.push({\n        name: key,\n        type: \"plain_text\",\n        text: value,\n      });\n    }\n  }\n\n  // Determine if we're using ESM or service worker format\n  const isEsModule = props.format !== \"cjs\"; // Default to ESM unless CJS is specified\n  const scriptName = isEsModule ? \"worker.js\" : \"script\";\n\n  if (isEsModule) {\n    // For ES modules format\n    meta.main_module = scriptName;\n  } else {\n    // For service worker format (CJS)\n    meta.body_part = scriptName;\n  }\n  return meta;\n}\n\nasync function assertWorkerDoesNotExist<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  api: CloudflareApi,\n  workerName: string\n) {\n  const response = await api.get(\n    `/accounts/${api.accountId}/workers/scripts/${workerName}`\n  );\n  if (response.status === 404) {\n    return true;\n  }\n  if (response.status === 200) {\n    const metadata = await getWorkerScriptMetadata(api, workerName);\n\n    if (!metadata) {\n      throw new Error(\n        `Worker exists but failed to fetch metadata: ${response.status} ${response.statusText}`\n      );\n    }\n\n    if (\n      metadata.default_environment?.script.tags.includes(\n        `alchemy:id:${slugify(ctx.fqn)}`\n      )\n    ) {\n      return true;\n    }\n\n    throw new Error(\n      `Worker with name '${workerName}' already exists. Please use a unique name.`\n    );\n  } else {\n    throw new Error(\n      `Error checking if worker exists: ${response.status} ${response.statusText} ${await response.text()}`\n    );\n  }\n}\n\nasync function bundleWorkerScript<B extends Bindings>(props: WorkerProps) {\n  // Get the script content - either from props.script, or by bundling\n\n  // Create and use a Bundle resource with worker-optimized configuration\n  const defaultBundleOptions: Omit<BundleProps, \"entryPoint\"> = {\n    format: props.format === \"cjs\" ? \"cjs\" : \"esm\", // Use the specified format or default to ESM\n    target: \"es2020\",\n    platform: \"browser\",\n    minify: true,\n    options: {\n      keepNames: true, // Important for Durable Object classes\n    },\n  };\n\n  // Merge with user-provided options\n  const bundleOptions = {\n    ...defaultBundleOptions,\n    ...(props.bundle || {}),\n  };\n\n  // Create the bundle\n  const bundle = await Bundle(\"bundle\", {\n    entryPoint: props.entrypoint!,\n    ...bundleOptions,\n    external: [...(bundleOptions.external ?? []), \"cloudflare:workers\"],\n  });\n\n  try {\n    return await fs.readFile(bundle.path, \"utf-8\");\n  } catch (error) {\n    console.error(\"Error reading bundle:\", error);\n    throw new Error(\"Error reading bundle\");\n  }\n}\n\nasync function configureURL<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  api: CloudflareApi,\n  workerName: string,\n  url: boolean\n) {\n  let workerUrl;\n  if (url) {\n    // Enable the workers.dev subdomain for this worker\n    await api.post(\n      `/accounts/${api.accountId}/workers/scripts/${workerName}/subdomain`,\n      { enabled: true, previews_enabled: true },\n      {\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n\n    // Get the account's workers.dev subdomain\n    const subdomainResponse = await api.get(\n      `/accounts/${api.accountId}/workers/subdomain`\n    );\n\n    if (!subdomainResponse.ok) {\n      throw new Error(\n        `Could not fetch workers.dev subdomain: ${subdomainResponse.status} ${subdomainResponse.statusText}`\n      );\n    }\n    const subdomainData: {\n      result: {\n        subdomain: string;\n      };\n    } = await subdomainResponse.json();\n    const subdomain = subdomainData.result?.subdomain;\n\n    if (subdomain) {\n      workerUrl = `https://${workerName}.${subdomain}.workers.dev`;\n\n      // Add a delay when the subdomain is first created.\n      // This is to prevent an issue where a negative cache-hit\n      // causes the subdomain to be unavailable for 30 seconds.\n      if (ctx.phase === \"create\" || !ctx.output?.url) {\n        await new Promise((resolve) => setTimeout(resolve, 3000));\n      }\n    }\n  } else if (url === false && ctx.output?.url) {\n    // Explicitly disable URL if it was previously enabled\n    const response = await api.post(\n      `/accounts/${api.accountId}/workers/scripts/${workerName}/subdomain`,\n      JSON.stringify({ enabled: false }),\n      {\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n    if (!response.ok) {\n      throw new Error(\n        `Failed to disable worker URL: ${response.status} ${response.statusText}`\n      );\n    }\n  }\n  return workerUrl;\n}\n\nasync function getWorkerScriptMetadata(\n  api: CloudflareApi,\n  workerName: string\n): Promise<WorkerScriptMetadata | undefined> {\n  const response = await api.get(\n    `/accounts/${api.accountId}/workers/services/${workerName}`\n  );\n  if (response.status === 404) {\n    return undefined;\n  }\n  if (!response.ok) {\n    throw new Error(\n      `Error getting worker script metadata: ${response.status} ${response.statusText}`\n    );\n  }\n  return ((await response.json()) as any).result as WorkerScriptMetadata;\n}\n\nasync function getWorkerBindings(\n  api: CloudflareApi,\n  workerName: string,\n  environment = \"production\"\n) {\n  const response = await api.get(\n    `/accounts/${api.accountId}/workers/services/${workerName}/environments/${environment}/bindings`,\n    {\n      headers: {\n        Authorization: `Bearer ${process.env.CLOUDFLARE_API_TOKEN}`,\n        \"Content-Type\": \"application/json\",\n      },\n    }\n  );\n\n  if (response.status === 404) {\n    return undefined;\n  }\n\n  if (!response.ok) {\n    throw new Error(\n      `Failed to fetch bindings: ${response.status} ${response.statusText}`\n    );\n  }\n\n  const data: any = await response.json();\n\n  return data.result;\n}\n\n/**\n * Interface for a file's metadata to be uploaded\n */\ninterface FileMetadata {\n  hash: string;\n  size: number;\n}\n\n/**\n * Response from the assets upload session API\n */\ninterface UploadSessionResponse {\n  result: {\n    jwt: string;\n    buckets: string[][];\n  };\n  success: boolean;\n  errors: any[];\n  messages: any[];\n}\n\n/**\n * Response from the file upload API\n */\ninterface UploadResponse {\n  result: {\n    jwt: string;\n    buckets?: string[][];\n  };\n  success: boolean;\n  errors: any[];\n  messages: any[];\n}\n\n/**\n * Uploads assets to Cloudflare and returns a completion token\n *\n * @param api CloudflareApi instance\n * @param workerName Name of the worker\n * @param assets Assets resource containing files to upload\n * @returns Completion token for the assets upload\n */\nasync function uploadAssets(\n  api: CloudflareApi,\n  workerName: string,\n  assets: Assets\n): Promise<AssetUploadResult> {\n  // Generate the file manifest\n  const fileMetadata: Record<string, FileMetadata> = {};\n\n  // Process each file in the assets\n  for (const file of assets.files) {\n    const { hash, size } = await calculateFileMetadata(file.filePath);\n    // Use the relative path as the key, ensuring it starts with a slash\n    const key = file.path.startsWith(\"/\") ? file.path : `/${file.path}`;\n    fileMetadata[key] = { hash, size };\n  }\n\n  // Start the upload session\n  const uploadSessionUrl = `/accounts/${api.accountId}/workers/scripts/${workerName}/assets-upload-session`;\n  const uploadSessionResponse = await api.post(\n    uploadSessionUrl,\n    JSON.stringify({ manifest: fileMetadata }),\n    {\n      headers: { \"Content-Type\": \"application/json\" },\n    }\n  );\n\n  if (!uploadSessionResponse.ok) {\n    throw new Error(\n      `Failed to start assets upload session: ${uploadSessionResponse.status} ${uploadSessionResponse.statusText}`\n    );\n  }\n\n  const sessionData =\n    (await uploadSessionResponse.json()) as UploadSessionResponse;\n\n  // If there are no buckets, assets are already uploaded or empty\n  if (!sessionData.result.buckets || sessionData.result.buckets.length === 0) {\n    return { completionToken: sessionData.result.jwt };\n  }\n\n  // Upload the files in batches as specified by the API\n  let completionToken = sessionData.result.jwt;\n  const buckets = sessionData.result.buckets;\n\n  // Process each bucket of files\n  for (const bucket of buckets) {\n    const formData = new FormData();\n\n    let totalBytes = 0;\n\n    // Add each file in the bucket to the form\n    for (const fileHash of bucket) {\n      // Find the file with this hash\n      const file = assets.files.find((f) => {\n        const filePath = f.path.startsWith(\"/\") ? f.path : `/${f.path}`;\n        return fileMetadata[filePath]?.hash === fileHash;\n      });\n\n      if (!file) {\n        throw new Error(`Could not find file with hash ${fileHash}`);\n      }\n\n      // Read the file content\n      const fileContent = await fs.readFile(file.filePath);\n\n      // Convert to base64 as required by the API when using base64=true\n      const base64Content = fileContent.toString(\"base64\");\n\n      // Add the file to the form with the hash as the key and set the correct content type\n      const blob = new Blob([base64Content], {\n        type: getContentType(file.filePath),\n      });\n      totalBytes += blob.size;\n      formData.append(fileHash, blob, fileHash);\n    }\n\n    // Upload this batch of files\n    const uploadResponse = await api.post(\n      `/accounts/${api.accountId}/workers/assets/upload?base64=true`,\n      formData,\n      {\n        headers: {\n          Authorization: `Bearer ${completionToken}`,\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      }\n    );\n\n    if (!uploadResponse.ok) {\n      throw new Error(\n        `Failed to upload asset files: ${uploadResponse.status} ${uploadResponse.statusText}`\n      );\n    }\n\n    const uploadData = (await uploadResponse.json()) as UploadResponse;\n    // Update the completion token for the next batch\n    if (uploadData.result.jwt) {\n      completionToken = uploadData.result.jwt;\n    }\n  }\n\n  // Return the final completion token\n  return {\n    completionToken,\n    assetConfig: {\n      html_handling: \"auto-trailing-slash\",\n    },\n  };\n}\n\n/**\n * Calculate the SHA-256 hash and size of a file\n *\n * @param filePath Path to the file\n * @returns Hash (first 32 chars of SHA-256) and size of the file\n */\nasync function calculateFileMetadata(\n  filePath: string\n): Promise<{ hash: string; size: number }> {\n  const hash = crypto.createHash(\"sha256\");\n  const fileContent = await fs.readFile(filePath);\n\n  hash.update(fileContent);\n  const fileHash = hash.digest(\"hex\").substring(0, 32); // First 32 chars of hash\n\n  return {\n    hash: fileHash,\n    size: fileContent.length,\n  };\n}\n\n```\n\n// alchemy/src/cloudflare/wrangler.json.ts\n```ts\nimport * as fs from \"fs/promises\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for wrangler.json configuration file\n */\nexport interface WranglerJsonProps {\n  /**\n   * The name of your worker\n   */\n  name: string;\n\n  /**\n   * The directory containing your worker entry point\n   * @default \"src\"\n   */\n  main?: string;\n\n  /**\n   * The entry point for your worker\n   * @default \"index.ts\" or \"index.js\"\n   */\n  entrypoint?: string;\n\n  /**\n   * The directory to store build artifacts\n   * @default \"dist\"\n   */\n  outdir?: string;\n\n  /**\n   * The directory to serve static assets from\n   */\n  assets?: string;\n\n  /**\n   * Minify the worker script\n   * @default true\n   */\n  minify?: boolean;\n\n  /**\n   * Node.js compatibility mode\n   * @default false\n   */\n  node_compat?: boolean;\n\n  /**\n   * First-party worker service bindings\n   */\n  services?: Array<{\n    /**\n     * Binding name\n     */\n    name: string;\n    /**\n     * Service environment\n     */\n    environment?: string;\n  }>;\n\n  /**\n   * Worker environment variables\n   */\n  vars?: Record<string, string>;\n\n  /**\n   * KV Namespace bindings\n   */\n  kv_namespaces?: Array<{\n    /**\n     * Binding name\n     */\n    binding: string;\n    /**\n     * KV namespace ID\n     */\n    id: string;\n    /**\n     * Preview KV namespace ID\n     */\n    preview_id?: string;\n  }>;\n\n  /**\n   * R2 bucket bindings\n   */\n  r2_buckets?: Array<{\n    /**\n     * Binding name\n     */\n    binding: string;\n    /**\n     * Bucket name\n     */\n    bucket_name: string;\n    /**\n     * Preview bucket name\n     */\n    preview_bucket_name?: string;\n  }>;\n\n  /**\n   * D1 database bindings\n   */\n  d1_databases?: Array<{\n    /**\n     * Binding name\n     */\n    binding: string;\n    /**\n     * Database name\n     */\n    database_name: string;\n    /**\n     * Database ID\n     */\n    database_id: string;\n    /**\n     * Preview database ID\n     */\n    preview_database_id?: string;\n  }>;\n\n  /**\n   * Durable Object bindings\n   */\n  durable_objects?: {\n    /**\n     * Durable Object bindings\n     */\n    bindings: Array<{\n      /**\n       * Binding name\n       */\n      name: string;\n      /**\n       * Class name\n       */\n      class_name: string;\n      /**\n       * Script name\n       */\n      script_name?: string;\n      /**\n       * Environment name\n       */\n      environment?: string;\n    }>;\n  };\n\n  /**\n   * Queue bindings\n   */\n  queues?: {\n    /**\n     * Producer bindings\n     */\n    producers?: Array<{\n      /**\n       * Binding name\n       */\n      binding: string;\n      /**\n       * Queue name\n       */\n      queue: string;\n    }>;\n    /**\n     * Consumer configuration\n     */\n    consumers?: Array<{\n      /**\n       * Queue name\n       */\n      queue: string;\n      /**\n       * Maximum batch size\n       */\n      max_batch_size?: number;\n      /**\n       * Maximum batch timeout\n       */\n      max_batch_timeout?: number;\n      /**\n       * Maximum retries\n       */\n      max_retries?: number;\n      /**\n       * Dead letter queue\n       */\n      dead_letter_queue?: string;\n    }>;\n  };\n\n  /**\n   * Analytics Engine bindings\n   */\n  analytics_engine_datasets?: Array<{\n    /**\n     * Binding name\n     */\n    binding: string;\n    /**\n     * Dataset name\n     */\n    dataset?: string;\n  }>;\n\n  /**\n   * Route configuration\n   */\n  routes?: Array<string>;\n\n  /**\n   * Triggers configuration\n   */\n  triggers?: {\n    /**\n     * Cron triggers\n     */\n    crons: Array<string>;\n  };\n\n  /**\n   * Worker compatibility date\n   */\n  compatibility_date?: string;\n\n  /**\n   * Worker compatibility flags\n   */\n  compatibility_flags?: Array<string>;\n\n  /**\n   * Worker usage model\n   * \"bundled\" - Includes resources like CPU and memory. Better for consistent workloads.\n   * \"unbound\" - Pay only for what you use. Better for sporadic workloads.\n   */\n  usage_model?: \"bundled\" | \"unbound\";\n\n  /**\n   * Path to the wrangler.json file\n   * @internal\n   */\n  path?: string;\n}\n\n/**\n * Output returned after WranglerJson creation/update\n */\nexport interface WranglerJson\n  extends Resource<\"cloudflare::WranglerJson\">,\n    WranglerJsonProps {\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Resource for managing wrangler.json configuration files\n */\nexport const WranglerJson = Resource(\n  \"cloudflare::WranglerJson\",\n  async function (\n    this: Context<WranglerJson>,\n    id: string,\n    props: WranglerJsonProps,\n  ): Promise<WranglerJson> {\n    // Default path is wrangler.json in current directory\n    const filePath = props.path || \"wrangler.json\";\n\n    if (this.phase === \"delete\") {\n      try {\n        await fs.unlink(filePath);\n      } catch (error) {\n        // Ignore errors if file doesn't exist\n        if ((error as NodeJS.ErrnoException).code !== \"ENOENT\") {\n          throw error;\n        }\n      }\n      return this.destroy();\n    }\n\n    // Create or update the file\n    const config = {\n      ...props,\n      // Remove internal path property\n      path: undefined,\n    };\n\n    // Write the file\n    await fs.writeFile(filePath, JSON.stringify(config, null, 2));\n\n    // Return the resource\n    return this({\n      ...props,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  },\n);\n\n```\n\n// alchemy/src/cloudflare/zone-settings.ts\n```ts\n/**\n * Common response fields for all settings\n */\nexport interface CloudflareSettingBase {\n  /**\n   * The identifier of the setting\n   */\n  id: string;\n\n  /**\n   * When the setting was last modified\n   */\n  modified_on: string | null;\n\n  /**\n   * Whether the setting can be modified\n   */\n  editable: boolean;\n}\n\n/**\n * Value types for each setting\n */\nexport type SSLValue = \"off\" | \"flexible\" | \"full\" | \"strict\";\nexport type MinTLSVersionValue = \"1.0\" | \"1.1\" | \"1.2\" | \"1.3\";\nexport type TLS13Value = \"on\" | \"off\" | \"zrt\";\nexport type CacheLevelValue = \"aggressive\" | \"basic\" | \"simplified\";\n\n// Boolean setting values\nexport type AlwaysUseHTTPSValue = \"on\" | \"off\";\nexport type AutomaticHTTPSRewritesValue = \"on\" | \"off\";\nexport type BrotliValue = \"on\" | \"off\";\nexport type DevelopmentModeValue = \"on\" | \"off\";\nexport type EarlyHintsValue = \"on\" | \"off\";\nexport type EmailObfuscationValue = \"on\" | \"off\";\nexport type HotlinkProtectionValue = \"on\" | \"off\";\nexport type HTTP2Value = \"on\" | \"off\";\nexport type HTTP3Value = \"on\" | \"off\";\nexport type IPv6Value = \"on\" | \"off\";\nexport type WebSocketsValue = \"on\" | \"off\";\nexport type ZeroRTTValue = \"on\" | \"off\";\n\n/**\n * Common response fields for boolean settings that use \"on\"/\"off\"\n */\nexport interface CloudflareBooleanSetting extends CloudflareSettingBase {\n  /**\n   * The value of the setting\n   */\n  value: \"on\" | \"off\";\n}\n\n/**\n * Advanced DDoS protection setting\n * @see https://developers.cloudflare.com/api/resources/zones/#advanced-ddos\n */\nexport interface AdvancedDDoSSetting extends CloudflareBooleanSetting {\n  id: \"advanced_ddos\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * Always Online setting\n * When enabled, Cloudflare serves limited copies of web pages from the Internet Archive if your server is offline\n */\nexport interface AlwaysOnlineSetting extends CloudflareBooleanSetting {\n  id: \"always_online\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * Always Use HTTPS setting\n * Redirects all HTTP traffic to HTTPS\n */\nexport interface AlwaysUseHTTPSSetting extends CloudflareSettingBase {\n  id: \"always_use_https\";\n  value: AlwaysUseHTTPSValue;\n}\n\n/**\n * Automatic HTTPS Rewrites setting\n * Automatically rewrites HTTP URLs to HTTPS\n */\nexport interface AutomaticHTTPSRewritesSetting extends CloudflareSettingBase {\n  id: \"automatic_https_rewrites\";\n  value: AutomaticHTTPSRewritesValue;\n}\n\n/**\n * Automatic Platform Optimization setting\n */\nexport interface AutomaticPlatformOptimizationSetting\n  extends CloudflareSettingBase {\n  id: \"automatic_platform_optimization\";\n  value: {\n    enabled: boolean;\n    cf: boolean;\n    wordpress: boolean;\n    wordpress_plugin: boolean;\n    cache_by_device_type: boolean;\n  };\n}\n\n/**\n * Brotli compression setting\n */\nexport interface BrotliSetting extends CloudflareSettingBase {\n  id: \"brotli\";\n  value: BrotliValue;\n}\n\n/**\n * Browser Cache TTL setting\n */\nexport interface BrowserCacheTTLSetting extends CloudflareSettingBase {\n  id: \"browser_cache_ttl\";\n  value: number;\n}\n\n/**\n * Browser Check setting\n */\nexport interface BrowserCheckSetting extends CloudflareSettingBase {\n  id: \"browser_check\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * Cache Level setting\n */\nexport interface CacheLevelSetting extends CloudflareSettingBase {\n  id: \"cache_level\";\n  value: CacheLevelValue;\n}\n\n/**\n * Challenge TTL setting\n */\nexport interface ChallengeTTLSetting extends CloudflareSettingBase {\n  id: \"challenge_ttl\";\n  value: number;\n}\n\n/**\n * Ciphers setting\n */\nexport interface CiphersSetting extends CloudflareSettingBase {\n  id: \"ciphers\";\n  value: string[];\n}\n\n/**\n * Development Mode setting\n */\nexport interface DevelopmentModeSetting extends CloudflareSettingBase {\n  id: \"development_mode\";\n  value: DevelopmentModeValue;\n}\n\n/**\n * Early Hints setting\n */\nexport interface EarlyHintsSetting extends CloudflareSettingBase {\n  id: \"early_hints\";\n  value: EarlyHintsValue;\n}\n\n/**\n * Email Obfuscation setting\n */\nexport interface EmailObfuscationSetting extends CloudflareSettingBase {\n  id: \"email_obfuscation\";\n  value: EmailObfuscationValue;\n}\n\n/**\n * Hotlink Protection setting\n */\nexport interface HotlinkProtectionSetting extends CloudflareSettingBase {\n  id: \"hotlink_protection\";\n  value: HotlinkProtectionValue;\n}\n\n/**\n * HTTP/2 setting\n */\nexport interface HTTP2Setting extends CloudflareSettingBase {\n  id: \"http2\";\n  value: HTTP2Value;\n}\n\n/**\n * HTTP/3 setting\n */\nexport interface HTTP3Setting extends CloudflareSettingBase {\n  id: \"http3\";\n  value: HTTP3Value;\n}\n\n/**\n * IP Geolocation setting\n */\nexport interface IPGeolocationSetting extends CloudflareSettingBase {\n  id: \"ip_geolocation\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * IPv6 setting\n */\nexport interface IPv6Setting extends CloudflareSettingBase {\n  id: \"ipv6\";\n  value: IPv6Value;\n}\n\n/**\n * Minimum TLS Version setting\n */\nexport interface MinTLSVersionSetting extends CloudflareSettingBase {\n  id: \"min_tls_version\";\n  value: MinTLSVersionValue;\n}\n\n/**\n * Opportunistic Encryption setting\n */\nexport interface OpportunisticEncryptionSetting extends CloudflareSettingBase {\n  id: \"opportunistic_encryption\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * SSL setting\n */\nexport interface SSLSetting extends CloudflareSettingBase {\n  id: \"ssl\";\n  value: SSLValue;\n  certificate_status?: string;\n  validation_errors?: Array<{\n    message: string;\n  }>;\n}\n\n/**\n * TLS 1.3 setting\n */\nexport interface TLS13Setting extends CloudflareSettingBase {\n  id: \"tls_1_3\";\n  value: TLS13Value;\n}\n\n/**\n * WebSockets setting\n */\nexport interface WebSocketsSetting extends CloudflareSettingBase {\n  id: \"websockets\";\n  value: WebSocketsValue;\n}\n\n/**\n * Zero-RTT setting\n */\nexport interface ZeroRTTSetting extends CloudflareSettingBase {\n  id: \"0rtt\";\n  value: ZeroRTTValue;\n}\n\n/**\n * All possible zone settings\n */\nexport type CloudflareZoneSetting =\n  | AdvancedDDoSSetting\n  | AlwaysOnlineSetting\n  | AlwaysUseHTTPSSetting\n  | AutomaticHTTPSRewritesSetting\n  | AutomaticPlatformOptimizationSetting\n  | BrotliSetting\n  | BrowserCacheTTLSetting\n  | BrowserCheckSetting\n  | CacheLevelSetting\n  | ChallengeTTLSetting\n  | CiphersSetting\n  | DevelopmentModeSetting\n  | EarlyHintsSetting\n  | EmailObfuscationSetting\n  | HotlinkProtectionSetting\n  | HTTP2Setting\n  | HTTP3Setting\n  | IPGeolocationSetting\n  | IPv6Setting\n  | MinTLSVersionSetting\n  | OpportunisticEncryptionSetting\n  | SSLSetting\n  | TLS13Setting\n  | WebSocketsSetting\n  | ZeroRTTSetting;\n\n/**\n * Input for updating a zone setting\n */\nexport interface UpdateZoneSettingParams {\n  /**\n   * The value to set\n   */\n  value: CloudflareZoneSetting[\"value\"];\n}\n\n/**\n * Response for zone settings operations\n */\nexport interface CloudflareZoneSettingResponse {\n  /**\n   * Whether the API call was successful\n   */\n  success: boolean;\n\n  /**\n   * Any error messages\n   */\n  errors: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * Any informational messages\n   */\n  messages: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * The settings that were operated on\n   */\n  result: CloudflareZoneSetting[];\n}\n\n/**\n * Response for a single zone setting operation\n */\nexport interface CloudflareZoneSettingSingleResponse {\n  /**\n   * Whether the API call was successful\n   */\n  success: boolean;\n\n  /**\n   * Any error messages\n   */\n  errors: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * Any informational messages\n   */\n  messages: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * The setting that was operated on\n   */\n  result: CloudflareZoneSetting;\n}\n\n```\n\n// alchemy/src/cloudflare/zone.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { createCloudflareApi, type CloudflareApiOptions } from \"./api\";\nimport type {\n  AlwaysUseHTTPSValue,\n  AutomaticHTTPSRewritesValue,\n  BrotliValue,\n  CloudflareZoneSettingResponse,\n  DevelopmentModeValue,\n  EarlyHintsValue,\n  EmailObfuscationValue,\n  HTTP2Value,\n  HTTP3Value,\n  HotlinkProtectionValue,\n  IPv6Value,\n  MinTLSVersionValue,\n  SSLValue,\n  TLS13Value,\n  UpdateZoneSettingParams,\n  WebSocketsValue,\n  ZeroRTTValue,\n} from \"./zone-settings\";\n\n/**\n * Properties for creating or updating a Zone\n */\nexport interface ZoneProps extends CloudflareApiOptions {\n  /**\n   * The domain name for the zone\n   */\n  name: string;\n\n  /**\n   * The type of zone to create\n   * \"full\" - Full zone implies that DNS is hosted with Cloudflare\n   * \"partial\" - Partial zone is typically a partner-hosted zone or a CNAME setup\n   * \"secondary\" - Secondary zone is a zone that mirrors the primary zone\n   * @default \"full\"\n   */\n  type?: \"full\" | \"partial\" | \"secondary\";\n\n  /**\n   * Whether to jump start the zone\n   * When enabled, Cloudflare will attempt to fetch existing DNS records\n   * @default true\n   */\n  jumpStart?: boolean;\n\n  /**\n   * Settings to apply to the zone\n   */\n  settings?: {\n    /**\n     * Enable SSL/TLS encryption for the zone\n     * \"off\" - SSL disabled\n     * \"flexible\" - Encrypts traffic between browser and Cloudflare\n     * \"full\" - Encrypts traffic between browser and server, allows self-signed certs\n     * \"strict\" - Encrypts traffic between browser and server, requires valid cert\n     */\n    ssl?: SSLValue;\n\n    /**\n     * Enable Always Use HTTPS\n     * Redirects all HTTP traffic to HTTPS\n     * @default \"off\"\n     */\n    alwaysUseHttps?: AlwaysUseHTTPSValue;\n\n    /**\n     * Enable Automatic HTTPS Rewrites\n     * Automatically rewrites HTTP URLs to HTTPS\n     * @default \"off\"\n     */\n    automaticHttpsRewrites?: AutomaticHTTPSRewritesValue;\n\n    /**\n     * Enable TLS 1.3\n     * Enables the latest version of TLS encryption\n     * @default \"off\"\n     */\n    tls13?: TLS13Value;\n\n    /**\n     * Enable Early Hints\n     * Speeds up page loads by serving Link headers\n     * @default \"off\"\n     */\n    earlyHints?: EarlyHintsValue;\n\n    /**\n     * Enable Email Obfuscation\n     * Obfuscates email addresses on the site\n     * @default \"off\"\n     */\n    emailObfuscation?: EmailObfuscationValue;\n\n    /**\n     * Enable Browser Cache TTL\n     * Sets the browser cache TTL in seconds\n     */\n    browserCacheTtl?: number;\n\n    /**\n     * Enable Development Mode\n     * Disables caching and enables real-time updates\n     * @default \"off\"\n     */\n    developmentMode?: DevelopmentModeValue;\n\n    /**\n     * Enable HTTP/2\n     * @default \"on\"\n     */\n    http2?: HTTP2Value;\n\n    /**\n     * Enable HTTP/3\n     * @default \"on\"\n     */\n    http3?: HTTP3Value;\n\n    /**\n     * Enable IPv6\n     * @default \"on\"\n     */\n    ipv6?: IPv6Value;\n\n    /**\n     * Enable WebSockets\n     * @default \"on\"\n     */\n    websockets?: WebSocketsValue;\n\n    /**\n     * Enable Zero-RTT\n     * @default \"off\"\n     */\n    zeroRtt?: ZeroRTTValue;\n\n    /**\n     * Enable Brotli compression\n     * @default \"on\"\n     */\n    brotli?: BrotliValue;\n\n    /**\n     * Enable Hotlink Protection\n     * @default \"off\"\n     */\n    hotlinkProtection?: HotlinkProtectionValue;\n\n    /**\n     * Minimum TLS Version\n     * @default \"1.0\"\n     */\n    minTlsVersion?: MinTLSVersionValue;\n  };\n}\n\n/**\n * Output returned after Zone creation/update\n */\nexport interface Zone extends Resource<\"cloudflare::Zone\"> {\n  /**\n   * The ID of the zone\n   */\n  id: string;\n\n  /**\n   * The domain name for the zone\n   */\n  name: string;\n\n  /**\n   * The type of zone\n   */\n  type: \"full\" | \"partial\" | \"secondary\";\n\n  /**\n   * The status of the zone\n   */\n  status: string;\n\n  /**\n   * Whether the zone is paused\n   */\n  paused: boolean;\n\n  /**\n   * The account ID the zone belongs to\n   */\n  accountId: string;\n\n  /**\n   * The nameservers assigned to the zone\n   */\n  nameservers: string[];\n\n  /**\n   * The original nameservers for the zone\n   */\n  originalNameservers: string[] | null;\n\n  /**\n   * Time at which the zone was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the zone was last modified\n   */\n  modifiedAt: number;\n\n  /**\n   * Time at which the zone was activated\n   */\n  activatedAt: number | null;\n\n  /**\n   * The zone's current settings\n   */\n  settings: {\n    ssl: SSLValue;\n    alwaysUseHttps: AlwaysUseHTTPSValue;\n    automaticHttpsRewrites: AutomaticHTTPSRewritesValue;\n    tls13: TLS13Value;\n    earlyHints: EarlyHintsValue;\n    emailObfuscation: EmailObfuscationValue;\n    browserCacheTtl: number;\n    developmentMode: DevelopmentModeValue;\n    http2: HTTP2Value;\n    http3: HTTP3Value;\n    ipv6: IPv6Value;\n    websockets: WebSocketsValue;\n    zeroRtt: ZeroRTTValue;\n    brotli: BrotliValue;\n    hotlinkProtection: HotlinkProtectionValue;\n    minTlsVersion: MinTLSVersionValue;\n  };\n}\n\n/**\n * A Cloudflare Zone represents a domain and its configuration settings on Cloudflare.\n * Zones allow you to manage DNS, SSL/TLS, caching, security and other settings for a domain.\n *\n * @example\n * // Create a basic zone with default settings\n * const basicZone = await Zone(\"example.com\", {\n *   name: \"example.com\",\n *   type: \"full\",\n *   jumpStart: true\n * });\n *\n * @example\n * // Create a zone with enhanced security settings\n * const secureZone = await Zone(\"secure.example.com\", {\n *   name: \"secure.example.com\",\n *   type: \"full\",\n *   settings: {\n *     ssl: \"strict\",\n *     alwaysUseHttps: \"on\",\n *     automaticHttpsRewrites: \"on\",\n *     minTlsVersion: \"1.3\",\n *     tls13: \"zrt\"\n *   }\n * });\n *\n * @example\n * // Create a zone with optimized performance settings\n * const fastZone = await Zone(\"fast.example.com\", {\n *   name: \"fast.example.com\",\n *   settings: {\n *     browserCacheTtl: 7200,\n *     brotli: \"on\",\n *     zeroRtt: \"on\",\n *     http2: \"on\",\n *     http3: \"on\",\n *     earlyHints: \"on\"\n *   }\n * });\n *\n * @example\n * // Create a development zone with specific features\n * const devZone = await Zone(\"dev.example.com\", {\n *   name: \"dev.example.com\",\n *   settings: {\n *     developmentMode: \"on\",\n *     emailObfuscation: \"on\",\n *     hotlinkProtection: \"on\",\n *     ipv6: \"on\",\n *     websockets: \"on\"\n *   }\n * });\n *\n * @see https://developers.cloudflare.com/dns/zone-setups/\n */\nexport const Zone = Resource(\n  \"cloudflare::Zone\",\n  async function (\n    this: Context<Zone>,\n    id: string,\n    props: ZoneProps\n  ): Promise<Zone> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    if (this.phase === \"delete\") {\n      if (this.output?.id) {\n        // Delete zone\n        const deleteResponse = await api.delete(`/zones/${this.output.id}`);\n\n        if (!deleteResponse.ok && deleteResponse.status !== 404) {\n          const errorData: any = await deleteResponse.json().catch(() => ({\n            errors: [{ message: deleteResponse.statusText }],\n          }));\n          throw new Error(\n            `Error deleting zone '${props.name}': ${errorData.errors?.[0]?.message || deleteResponse.statusText}`\n          );\n        }\n      } else {\n        console.warn(`Zone '${props.name}' not found, skipping delete`);\n      }\n      return this.destroy();\n    }\n\n    if (this.phase === \"update\" && this.output?.id) {\n      // Get zone details to verify it exists\n      const response = await api.get(`/zones/${this.output.id}`);\n\n      if (!response.ok) {\n        throw new Error(\n          `Error getting zone '${props.name}': ${response.statusText}`\n        );\n      }\n\n      const zoneData = ((await response.json()) as { result: CloudflareZone })\n        .result;\n\n      // Update zone settings if provided\n      if (props.settings) {\n        await updateZoneSettings(api, this.output.id, props.settings);\n        // Add a small delay to ensure settings are propagated\n        await new Promise((resolve) => setTimeout(resolve, 2000));\n      }\n\n      return this({\n        id: zoneData.id,\n        name: zoneData.name,\n        type: zoneData.type,\n        status: zoneData.status,\n        paused: zoneData.paused,\n        accountId: zoneData.account.id,\n        nameservers: zoneData.name_servers,\n        originalNameservers: zoneData.original_name_servers,\n        createdAt: new Date(zoneData.created_on).getTime(),\n        modifiedAt: new Date(zoneData.modified_on).getTime(),\n        activatedAt: zoneData.activated_on\n          ? new Date(zoneData.activated_on).getTime()\n          : null,\n        settings: await getZoneSettings(api, zoneData.id),\n      });\n    } else {\n      // Create new zone\n\n      const response = await api.post(\"/zones\", {\n        name: props.name,\n        type: props.type || \"full\",\n        jump_start: props.jumpStart !== false,\n        account: {\n          id: api.accountId,\n        },\n      });\n\n      const body = await response.text();\n      let zoneData;\n      if (!response.ok) {\n        if (response.status === 400 && body.includes(\"already exists\")) {\n          // Zone already exists, fetch it instead\n          console.warn(\n            `Zone '${props.name}' already exists during Zone create, adopting it...`\n          );\n          const getResponse = await api.get(`/zones?name=${props.name}`);\n\n          if (!getResponse.ok) {\n            throw new Error(\n              `Error fetching existing zone '${props.name}': ${getResponse.statusText}`\n            );\n          }\n\n          const zones = (\n            (await getResponse.json()) as { result: CloudflareZone[] }\n          ).result;\n          if (zones.length === 0) {\n            throw new Error(\n              `Zone '${props.name}' does not exist, but the name is reserved for another user.`\n            );\n          }\n          zoneData = zones[0];\n        } else {\n          throw new Error(\n            `Error creating zone '${props.name}': ${response.statusText}\\n${body}`\n          );\n        }\n      } else {\n        zoneData = (JSON.parse(body) as { result: CloudflareZone }).result;\n      }\n\n      // Update zone settings if provided\n      if (props.settings) {\n        await updateZoneSettings(api, zoneData.id, props.settings);\n        // Add a small delay to ensure settings are propagated\n        await new Promise((resolve) => setTimeout(resolve, 2000));\n      }\n\n      return this({\n        id: zoneData.id,\n        name: zoneData.name,\n        type: zoneData.type,\n        status: zoneData.status,\n        paused: zoneData.paused,\n        accountId: zoneData.account.id,\n        nameservers: zoneData.name_servers,\n        originalNameservers: zoneData.original_name_servers,\n        createdAt: new Date(zoneData.created_on).getTime(),\n        modifiedAt: new Date(zoneData.modified_on).getTime(),\n        activatedAt: zoneData.activated_on\n          ? new Date(zoneData.activated_on).getTime()\n          : null,\n        settings: await getZoneSettings(api, zoneData.id),\n      });\n    }\n  }\n);\n\n/**\n * Helper function to update zone settings\n */\nasync function updateZoneSettings(\n  api: any,\n  zoneId: string,\n  settings: ZoneProps[\"settings\"]\n): Promise<void> {\n  if (!settings) return;\n\n  const settingsMap = {\n    ssl: \"ssl\",\n    alwaysUseHttps: \"always_use_https\",\n    automaticHttpsRewrites: \"automatic_https_rewrites\",\n    tls13: \"tls_1_3\",\n    earlyHints: \"early_hints\",\n    emailObfuscation: \"email_obfuscation\",\n    browserCacheTtl: \"browser_cache_ttl\",\n    developmentMode: \"development_mode\",\n    http2: \"http2\",\n    http3: \"http3\",\n    ipv6: \"ipv6\",\n    websockets: \"websockets\",\n    zeroRtt: \"0rtt\",\n    brotli: \"brotli\",\n    hotlinkProtection: \"hotlink_protection\",\n    minTlsVersion: \"min_tls_version\",\n  };\n\n  await Promise.all(\n    Object.entries(settings)\n      .filter(([_, value]) => value !== undefined)\n      .map(async ([key, value]) => {\n        const settingId = settingsMap[key as keyof typeof settings];\n        if (!settingId) return;\n\n        const response = await api.patch(\n          `/zones/${zoneId}/settings/${settingId}`,\n          {\n            value,\n          } as UpdateZoneSettingParams\n        );\n\n        if (!response.ok) {\n          const data = await response.text();\n          if (response.status === 400 && data.includes(\"already enabled\")) {\n            console.warn(`Warning: Setting '${key}' already enabled`);\n            return;\n          }\n          throw new Error(\n            `Failed to update zone setting ${key}: ${response.statusText}`\n          );\n        }\n      })\n  );\n}\n\n/**\n * Helper function to get current zone settings\n */\nasync function getZoneSettings(\n  api: any,\n  zoneId: string\n): Promise<Zone[\"settings\"]> {\n  const settingsResponse = await api.get(`/zones/${zoneId}/settings`);\n\n  if (!settingsResponse.ok) {\n    throw new Error(\n      `Failed to fetch zone settings: ${settingsResponse.status} ${settingsResponse.statusText}`\n    );\n  }\n\n  const result =\n    (await settingsResponse.json()) as CloudflareZoneSettingResponse;\n  const settingsData = result.result;\n\n  // Helper to get setting value with default\n  const getSetting = <T>(id: string, defaultValue: T): T => {\n    const setting = settingsData.find((s: any) => s.id === id);\n    return (setting?.value as T) ?? defaultValue;\n  };\n\n  return {\n    ssl: getSetting(\"ssl\", \"off\"),\n    alwaysUseHttps: getSetting(\"always_use_https\", \"off\"),\n    automaticHttpsRewrites: getSetting(\"automatic_https_rewrites\", \"off\"),\n    tls13: getSetting(\"tls_1_3\", \"off\"),\n    earlyHints: getSetting(\"early_hints\", \"off\"),\n    emailObfuscation: getSetting(\"email_obfuscation\", \"off\"),\n    browserCacheTtl: getSetting(\"browser_cache_ttl\", 14400),\n    developmentMode: getSetting(\"development_mode\", \"off\"),\n    http2: getSetting(\"http2\", \"on\"),\n    http3: getSetting(\"http3\", \"on\"),\n    ipv6: getSetting(\"ipv6\", \"on\"),\n    websockets: getSetting(\"websockets\", \"on\"),\n    zeroRtt: getSetting(\"0rtt\", \"off\"),\n    brotli: getSetting(\"brotli\", \"on\"),\n    hotlinkProtection: getSetting(\"hotlink_protection\", \"off\"),\n    minTlsVersion: getSetting(\"min_tls_version\", \"1.0\"),\n  };\n}\n\n/**\n * Cloudflare Zone response format\n */\nexport interface CloudflareZone {\n  id: string;\n  name: string;\n  type: \"full\" | \"partial\" | \"secondary\";\n  status: string;\n  paused: boolean;\n  account: {\n    id: string;\n  };\n  name_servers: string[];\n  original_name_servers: string[] | null;\n  created_on: string;\n  modified_on: string;\n  activated_on: string | null;\n}\n\n```",
    "content": "# Assets\n\nThe Assets component lets you add [static assets](https://developers.cloudflare.com/workers/configuration/sites/) to your Cloudflare Workers.\n\n## Minimal Example\n\nCreate a basic assets bundle from a local directory:\n\n```ts\nimport { Assets } from \"alchemy/cloudflare\";\n\nconst staticAssets = await Assets(\"static\", {\n  path: \"./src/assets\"\n});\n```\n\n## Bind to a Worker\n\nUse the assets with a Cloudflare Worker:\n\n```ts\nimport { Worker, Assets } from \"alchemy/cloudflare\";\n\nconst staticAssets = await Assets(\"static\", {\n  path: \"./src/assets\"\n});\n\nconst worker = await Worker(\"frontend\", {\n  name: \"frontend-worker\", \n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    ASSETS: staticAssets\n  }\n});\n```",
    "messages": [
      {
        "role": "user",
        "content": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         cloudflare Service:\n[bound.ts](alchemy/src/cloudflare/bound.ts)\n\n[custom-domain.ts](alchemy/src/cloudflare/custom-domain.ts)\n\n[durable-object-namespace.ts](alchemy/src/cloudflare/durable-object-namespace.ts)\n\n[api-error.ts](alchemy/src/cloudflare/api-error.ts)\n\n[bindings.ts](alchemy/src/cloudflare/bindings.ts)\n\n[zone.ts](alchemy/src/cloudflare/zone.ts)\n\n[assets.ts](alchemy/src/cloudflare/assets.ts)\n\n[account-id.ts](alchemy/src/cloudflare/account-id.ts)\n\n[dns-records.ts](alchemy/src/cloudflare/dns-records.ts)\n\n[api.ts](alchemy/src/cloudflare/api.ts)\n\n[worker-metadata.ts](alchemy/src/cloudflare/worker-metadata.ts)\n\n[types.ts](alchemy/src/cloudflare/types.ts)\n\n[response.ts](alchemy/src/cloudflare/response.ts)\n\n[zone-settings.ts](alchemy/src/cloudflare/zone-settings.ts)\n\n[r2-rest-state-store.ts](alchemy/src/cloudflare/r2-rest-state-store.ts)\n\n[permission-groups.ts](alchemy/src/cloudflare/permission-groups.ts)\n\n[wrangler.json.ts](alchemy/src/cloudflare/wrangler.json.ts)\n\n[bucket.ts](alchemy/src/cloudflare/bucket.ts)\n\n[kv-namespace.ts](alchemy/src/cloudflare/kv-namespace.ts)\n\n[account-api-token.ts](alchemy/src/cloudflare/account-api-token.ts)\n\n[worker-migration.ts](alchemy/src/cloudflare/worker-migration.ts)\n\n[auth.ts](alchemy/src/cloudflare/auth.ts)\n\n[worker.ts](alchemy/src/cloudflare/worker.ts)\n\n[asset-manifest.ts](alchemy/src/cloudflare/asset-manifest.ts)\n\nWrite concise documentation for the \"        Assets\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         Assets\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         Assets } from \"alchemy/        cloudflare\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         Assets } from \"alchemy/        cloudflare\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        # Bind to a Worker\n(if it is a Cloudflare Resource)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport { Worker,         Assets } from \"alchemy/        cloudflare\";\n\nconst myResource = await         Assets(\"my-resource\", {\n  // ...\n});\n\nawait Worker(\"my-worker\", {\n  name: \"my-worker\",\n  script: \"console.log('Hello, world!')\",\n  bindings: {\n    myResource,\n  },\n});\n```\n\n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Creating Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroying Resources\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value 😵‍💫\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n// env.d.ts\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n### 4. Scope-Based Destruction\n\n```typescript\n// Destroy all resources in a scope\nimport { destroy } from \"alchemy\";\nconst scope = alchemy.scope(\"temporary\");\nconst tempFile = await File(\"temp.txt\", { ... });\n\nawait destroy(scope);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// Clean up test resources reliably with try/finally\nconst scope = alchemy.scope(\"test\");\ntry {\n  // Create test resources\n} finally {\n  await destroy(scope);\n}\n```\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\n├── dev (Stage Scope)\n│   ├── api (Nested Scope)\n│   └── database (Resource)\n└── prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/cloudflare/account-api-token.ts\n```ts\nimport { alchemy } from \"../alchemy\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { Secret } from \"../secret\";\nimport { sha256 } from \"../util/sha256\";\nimport { createCloudflareApi, type CloudflareApiOptions } from \"./api\";\n\n/**\n * Permission group for a token policy\n */\nexport interface TokenPolicyPermissionGroup {\n  /**\n   * ID of the permission group\n   */\n  id: string;\n\n  /**\n   * Optional metadata for the permission group\n   */\n  meta?: Record<string, any>;\n}\n\n/**\n * Policy that defines what the token can access\n */\nexport interface TokenPolicy {\n  /**\n   * Effect of the policy\n   */\n  effect: \"allow\" | \"deny\";\n\n  /**\n   * Permission groups to include in the policy\n   */\n  permissionGroups: TokenPolicyPermissionGroup[];\n\n  /**\n   * Resources the policy applies to\n   */\n  resources: Record<string, string>;\n}\n\n/**\n * Condition for token usage (e.g., IP restrictions)\n */\nexport interface TokenCondition {\n  /**\n   * IP address conditions\n   */\n  requestIp?: {\n    /**\n     * IP ranges to allow\n     */\n    in?: string[];\n\n    /**\n     * IP ranges to deny\n     */\n    notIn?: string[];\n  };\n}\n\n/**\n * Properties for creating or updating an Account API Token\n */\nexport interface AccountApiTokenProps extends CloudflareApiOptions {\n  /**\n   * Name of the token\n   */\n  name: string;\n\n  /**\n   * Policies that define what the token can access\n   */\n  policies: TokenPolicy[];\n\n  /**\n   * Optional expiration date for the token (ISO format)\n   */\n  expiresOn?: string;\n\n  /**\n   * Optional \"not before\" date (token is not valid before this date) (ISO format)\n   */\n  notBefore?: string;\n\n  /**\n   * Optional conditions for token use (like IP restrictions)\n   */\n  condition?: TokenCondition;\n}\n\n/**\n * Cloudflare API token format as returned by the API\n */\ninterface CloudflareApiToken {\n  id: string;\n  name: string;\n  status: string;\n  policies: {\n    effect: \"allow\" | \"deny\";\n    permission_groups: {\n      id: string;\n      meta: Record<string, any>;\n    }[];\n    resources: Record<string, string>;\n  }[];\n  expires_on?: string;\n  not_before?: string;\n  condition?: {\n    request_ip?: {\n      in?: string[];\n      not_in?: string[];\n    };\n  };\n  value?: string;\n}\n\n/**\n * Output returned after Account API Token creation/update\n */\nexport interface AccountApiToken\n  extends Resource<\"cloudflare::AccountApiToken\">,\n    AccountApiTokenProps {\n  /**\n   * The ID of the token\n   *\n   * Equiv. to ACCESS_KEY_ID\n   */\n  id: string;\n\n  /**\n   * Status of the token\n   */\n  status: string;\n\n  /**\n   * Actual token value (only available on creation)\n   * Stored as a Secret for security\n   *\n   * Equiv. to SECRET_ACCESS_KEY\n   */\n  value?: Secret;\n\n  /**\n   * Access key ID for the token\n   *\n   * An alias of {@link id}\n   */\n  accessKeyId: string;\n\n  /**\n   * Secret access key for the token\n   *\n   * The SHA-256 hash of the token {@link value}\n   *\n   * @see https://developers.cloudflare.com/r2/api/tokens/#get-s3-api-credentials-from-an-api-token\n   */\n  secretAccessKey: string;\n}\n\n/**\n * Creates a Cloudflare Account API Token with specified permissions.\n *\n * Note: Requires a Cloudflare API Key or Token with admin-level account access.\n * The OAuth token from `wrangler login` is NOT sufficient for this operation.\n * You must use an API token with permission to manage account API tokens.\n *\n * @see https://developers.cloudflare.com/api/resources/accounts/subresources/tokens/methods/create/\n *\n * @example\n * // First, fetch all permission groups\n * const permissions = await PermissionGroups(\"cloudflare-permissions\", {\n *   accountId: cfAccountId,\n * });\n *\n * // Create a token with read-only permissions for specific zones\n * const readOnlyToken = await AccountApiToken(\"readonly-token\", {\n *   name: \"Readonly Zone Token\",\n *   policies: [\n *     {\n *       effect: \"allow\",\n *       permissionGroups: [\n *         { id: permissions[\"Zone Read\"].id },\n *         { id: permissions[\"Analytics Read\"].id }\n *       ],\n *       resources: {\n *         \"com.cloudflare.api.account.zone.22b1de5f1c0e4b3ea97bb1e963b06a43\": \"*\",\n *         \"com.cloudflare.api.account.zone.eb78d65290b24279ba6f44721b3ea3c4\": \"*\"\n *       }\n *     }\n *   ],\n *   expiresOn: \"2024-12-31T23:59:59Z\"\n * });\n *\n * @example\n * // Create a token with time and IP restrictions\n * const restrictedToken = await AccountApiToken(\"restricted-token\", {\n *   name: \"Restricted Access Token\",\n *   policies: [\n *     {\n *       effect: \"allow\",\n *       permissionGroups: [\n *         { id: permissions[\"Worker Routes Edit\"].id }\n *       ],\n *       resources: {\n *         \"com.cloudflare.api.account.worker.route.*\": \"*\"\n *       }\n *     }\n *   ],\n *   notBefore: \"2023-01-01T00:00:00Z\",\n *   expiresOn: \"2023-12-31T23:59:59Z\",\n *   condition: {\n *     requestIp: {\n *       in: [\"192.168.1.0/24\", \"10.0.0.0/8\"],\n *       notIn: [\"192.168.1.100/32\"]\n *     }\n *   }\n * });\n */\nexport const AccountApiToken = Resource(\n  \"cloudflare::AccountApiToken\",\n  async function (\n    this: Context<AccountApiToken>,\n    id: string,\n    props: AccountApiTokenProps\n  ): Promise<AccountApiToken> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    if (this.phase === \"delete\") {\n      // Delete token if we have an ID\n      if (this.output?.id) {\n        try {\n          const deleteResponse = await api.delete(\n            `/accounts/${api.accountId}/tokens/${this.output.id}`\n          );\n\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            const errorData: any = await deleteResponse.json().catch(() => ({\n              errors: [{ message: deleteResponse.statusText }],\n            }));\n            console.error(`Error deleting token '${props.name}':`, errorData);\n          }\n        } catch (error) {\n          console.error(`Error deleting token '${props.name}':`, error);\n        }\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    }\n\n    // Transform our properties to API format\n    const apiPayload = {\n      name: props.name,\n      policies: props.policies.map((policy) => ({\n        effect: policy.effect,\n        permission_groups: policy.permissionGroups.map((pg) => ({\n          id: pg.id,\n          meta: pg.meta || {},\n        })),\n        resources: policy.resources,\n      })),\n      // Format dates for Cloudflare API (removing milliseconds)\n      ...(props.expiresOn\n        ? { expires_on: formatCloudflareDate(props.expiresOn) }\n        : {}),\n      ...(props.notBefore\n        ? { not_before: formatCloudflareDate(props.notBefore) }\n        : {}),\n      ...(props.condition\n        ? {\n            condition: {\n              request_ip: props.condition.requestIp\n                ? {\n                    in: props.condition.requestIp.in || [],\n                    not_in: props.condition.requestIp.notIn || [],\n                  }\n                : undefined,\n            },\n          }\n        : {}),\n    };\n\n    /**\n     * Formats a date string for Cloudflare API by removing milliseconds\n     * Converts from \"2023-01-01T00:00:00.000Z\" to \"2023-01-01T00:00:00Z\"\n     */\n    function formatCloudflareDate(dateStr: string): string {\n      return dateStr.replace(/\\.\\d{3}Z$/, \"Z\");\n    }\n\n    let response;\n    let tokenValue;\n\n    if (this.phase === \"update\" && this.output?.id) {\n      // Update existing token\n      response = await api.put(\n        `/accounts/${api.accountId}/tokens/${this.output.id}`,\n        apiPayload\n      );\n    } else {\n      // Create new token\n      response = await api.post(\n        `/accounts/${api.accountId}/tokens`,\n        apiPayload\n      );\n    }\n\n    if (!response.ok) {\n      const errorData: any = await response.json().catch(() => ({\n        errors: [{ message: response.statusText }],\n      }));\n\n      throw new Error(\n        `Error ${this.phase === \"update\" ? \"updating\" : \"creating\"} token '${props.name}': ${\n          errorData.errors?.[0]?.message || response.statusText\n        }`\n      );\n    }\n\n    const result: { result: CloudflareApiToken } = await response.json();\n    const tokenData = result.result;\n\n    if (tokenData.value) {\n      tokenValue = alchemy.secret(tokenData.value);\n    } else {\n      if (!this.output?.value) {\n        throw new Error(\n          `Token '${props.name}' was created but we have no record of its value. Try deleting and recreating the token.`\n        );\n      }\n      tokenValue = this.output?.value;\n    }\n\n    // Transform API response to our format\n    return this({\n      id: tokenData.id,\n      name: tokenData.name,\n      status: tokenData.status,\n      policies: tokenData.policies.map((policy) => ({\n        effect: policy.effect,\n        permissionGroups: policy.permission_groups.map((pg) => ({\n          id: pg.id,\n          meta: pg.meta,\n        })),\n        resources: policy.resources,\n      })),\n      ...(tokenData.expires_on ? { expiresOn: tokenData.expires_on } : {}),\n      ...(tokenData.not_before ? { notBefore: tokenData.not_before } : {}),\n      ...(tokenData.condition\n        ? {\n            condition: {\n              requestIp: tokenData.condition.request_ip\n                ? {\n                    in: tokenData.condition.request_ip.in || [],\n                    notIn: tokenData.condition.request_ip.not_in || [],\n                  }\n                : undefined,\n            },\n          }\n        : {}),\n      value: tokenValue,\n      accessKeyId: tokenData.id,\n      secretAccessKey: sha256(tokenValue.unencrypted),\n    });\n  }\n);\n\n```\n\n// alchemy/src/cloudflare/account-id.ts\n```ts\nimport { getCloudflareUserInfo, type CloudflareAuthOptions } from \"./auth\";\n\nexport type CloudflareAccountId = string & {\n  readonly __brand: \"CloudflareAccountId\";\n};\n\nexport async function CloudflareAccountId(\n  options: CloudflareAuthOptions\n): Promise<CloudflareAccountId> {\n  const userInfo = await getCloudflareUserInfo(options);\n  return userInfo.accounts[0].id as CloudflareAccountId;\n}\n\n```\n\n// alchemy/src/cloudflare/api-error.ts\n```ts\n/**\n * Custom error class for Cloudflare API errors\n * Includes HTTP status information from the Response\n */\nexport class CloudflareApiError extends Error {\n  /**\n   * HTTP status code\n   */\n  status: number;\n\n  /**\n   * HTTP status text\n   */\n  statusText: string;\n\n  /**\n   * Raw error data from the API\n   */\n  errorData?: any;\n\n  /**\n   * Create a new CloudflareApiError\n   */\n  constructor(message: string, response: Response, errorData?: any) {\n    super(message);\n    this.name = \"CloudflareApiError\";\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.errorData = errorData;\n\n    // Ensure instanceof works correctly\n    Object.setPrototypeOf(this, CloudflareApiError.prototype);\n  }\n}\n\n/**\n * Helper function to handle API errors\n *\n * @param response The fetch Response object\n * @param action The action being performed (e.g., \"creating\", \"deleting\")\n * @param resourceType The type of resource being acted upon (e.g., \"R2 bucket\", \"Worker\")\n * @param resourceName The name/identifier of the specific resource\n * @returns Never returns - always throws an error\n */\nexport async function handleApiError(\n  response: Response,\n  action: string,\n  resourceType: string,\n  resourceName: string\n): Promise<never> {\n  const json: any = await response.json();\n  const errors: { message: string }[] = json.errors || [\n    { message: response.statusText },\n  ];\n  const errorMessage = `Error ${action} ${resourceType} '${resourceName}': ${errors[0]?.message || response.statusText}`;\n\n  throw new CloudflareApiError(errorMessage, response, errors);\n}\n\n```\n\n// alchemy/src/cloudflare/api.ts\n```ts\nimport type { Secret } from \"../secret\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport { getCloudflareAuthHeaders, getCloudflareUserInfo } from \"./auth\";\n\n/**\n * Options for Cloudflare API requests\n */\nexport interface CloudflareApiOptions {\n  /**\n   * Base URL for Cloudflare API\n   *\n   * @default https://api.cloudflare.com/client/v4\n   */\n  baseUrl?: string;\n\n  /**\n   * API Key to use (overrides CLOUDFLARE_API_KEY env var)\n   */\n  apiKey?: Secret;\n\n  /**\n   * API Token to use (overrides CLOUDFLARE_API_TOKEN env var)\n   */\n  apiToken?: Secret;\n\n  /**\n   * Account ID to use (overrides CLOUDFLARE_ACCOUNT_ID env var)\n   * If not provided, will be automatically retrieved from the Cloudflare API\n   */\n  accountId?: string;\n\n  /**\n   * Zone ID to use (overrides CLOUDFLARE_ZONE_ID env var)\n   */\n  zoneId?: string;\n\n  /**\n   * Email to use with API Key authentication\n   * If not provided, will attempt to discover from Cloudflare API\n   */\n  email?: string;\n}\n\n/**\n * Creates a CloudflareApi instance with automatic account ID discovery if not provided\n *\n * @param options API options\n * @returns Promise resolving to a CloudflareApi instance\n */\nexport async function createCloudflareApi(\n  options: Partial<CloudflareApiOptions> = {}\n): Promise<CloudflareApi> {\n  const userInfo = await getCloudflareUserInfo(options);\n  return new CloudflareApi({\n    baseUrl: options.baseUrl,\n    accountId: options.accountId ?? userInfo.accounts[0].id!,\n    email: userInfo.email!,\n    apiKey: userInfo.apiKey,\n    apiToken: userInfo.apiToken,\n    zoneId: options.zoneId,\n  });\n}\n\n/**\n * Cloudflare API client using raw fetch\n */\nexport class CloudflareApi {\n  public readonly accountId: string;\n  public readonly baseUrl: string;\n  /**\n   * Create a new Cloudflare API client\n   * Use createCloudflareApi factory function instead of direct constructor\n   * for automatic account ID discovery.\n   *\n   * @param options API options\n   */\n  constructor(\n    private readonly options: CloudflareApiOptions & {\n      accountId: string;\n    }\n  ) {\n    this.accountId = options.accountId;\n    this.baseUrl = options.baseUrl ?? \"https://api.cloudflare.com/client/v4\";\n  }\n\n  /**\n   * Make a fetch request to the Cloudflare API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n    if (Array.isArray(init.headers)) {\n      init.headers.forEach(([key, value]) => {\n        headers[key] = value;\n      });\n    } else if (init.headers instanceof Headers) {\n      init.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n    } else if (init.headers) {\n      headers = init.headers;\n    }\n    headers = {\n      ...(await getCloudflareAuthHeaders(this.options)),\n      ...headers,\n    };\n\n    // TODO(sam): is this necessary?\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Use withExponentialBackoff for automatic retry on network errors\n    return withExponentialBackoff(\n      () =>\n        fetch(`${this.baseUrl}${path}`, {\n          ...init,\n          headers,\n        }),\n      (error) => {\n        // Only retry on network-related errors\n        const errorMsg = (error as Error).message || \"\";\n        const isNetworkError =\n          errorMsg.includes(\"socket connection was closed\") ||\n          errorMsg.includes(\"ECONNRESET\") ||\n          errorMsg.includes(\"ETIMEDOUT\") ||\n          errorMsg.includes(\"ECONNREFUSED\");\n\n        return isNetworkError;\n      },\n      5, // Maximum 5 attempts (1 initial + 4 retries)\n      1000 // Start with 1s delay, will exponentially increase\n    );\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for HEAD requests\n   */\n  async head(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"HEAD\" });\n  }\n  /**\n   * Helper for POST requests\n   */\n  async post(\n    path: string,\n    body: any,\n    init: RequestInit = {}\n  ): Promise<Response> {\n    const requestBody =\n      body instanceof FormData\n        ? body\n        : typeof body === \"string\"\n          ? body\n          : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(\n    path: string,\n    body: any,\n    init: RequestInit = {}\n  ): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for PATCH requests\n   */\n  async patch(\n    path: string,\n    body: any,\n    init: RequestInit = {}\n  ): Promise<Response> {\n    return this.fetch(path, {\n      ...init,\n      method: \"PATCH\",\n      body: JSON.stringify(body),\n    });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/asset-manifest.ts\n```ts\nexport type AssetManifest = AssetManifestEntry[];\n\nexport interface AssetManifestEntry {\n  source: string;\n  key: string;\n  hash: string;\n  cacheControl: string;\n  contentType?: string;\n}\n\nexport interface FileOption {\n  files: string | string[];\n  cacheControl: string;\n  contentType?: string;\n  ignore?: string[];\n}\n\n```\n\n// alchemy/src/cloudflare/assets.ts\n```ts\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { getContentType } from \"../util/content-type\";\n\n/**\n * Properties for creating or updating Assets\n */\nexport interface AssetsProps {\n  /**\n   * Path to a directory containing static assets to be uploaded\n   * These files will be served by Cloudflare's Workers runtime\n   */\n  path: string;\n}\n\n/**\n * Output returned after Assets creation/update\n */\nexport interface Assets extends Resource<\"cloudflare::Asset\">, AssetsProps {\n  /**\n   * The type of binding\n   */\n  type: \"assets\";\n\n  /**\n   * The ID of the assets bundle\n   */\n  id: string;\n\n  /**\n   * Asset files that were found\n   */\n  files: AssetFile[];\n\n  /**\n   * Time at which the assets were created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the assets were last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Represents a single asset file\n */\nexport interface AssetFile {\n  /**\n   * Path relative to the assets directory\n   */\n  path: string;\n\n  /**\n   * Full filesystem path to the file\n   */\n  filePath: string;\n\n  /**\n   * Content type of the file\n   */\n  contentType: string;\n}\n\n/**\n * Cloudflare Assets represent a collection of static files that can be uploaded and served\n * by Cloudflare Workers.\n *\n * @example\n * // Create a basic assets bundle from a local directory\n * const staticAssets = await Assets(\"static\", {\n *   path: \"./src/assets\"\n * });\n *\n * // Use these assets with a worker\n * const worker = await Worker(\"frontend\", {\n *   name: \"frontend-worker\",\n *   entrypoint: \"./src/worker.ts\",\n *   bindings: {\n *     ASSETS: staticAssets\n *   }\n * });\n */\nexport const Assets = Resource(\n  \"cloudflare::Asset\",\n  {\n    alwaysUpdate: true,\n  },\n  async function (\n    this: Context<Assets>,\n    id: string,\n    props: AssetsProps\n  ): Promise<Assets> {\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    try {\n      // Check if the assets directory exists\n      const stats = await fs.stat(props.path);\n      if (!stats.isDirectory()) {\n        throw new Error(`Assets path ${props.path} is not a directory`);\n      }\n    } catch (error) {\n      throw new Error(\n        `Assets directory ${props.path} does not exist or is not accessible`\n      );\n    }\n\n    // Recursively get all files in the assets directory\n    const filesList = await getFilesRecursively(props.path);\n\n    // Create asset file objects\n    const files: AssetFile[] = filesList.map((filePath) => {\n      const relativePath = path.relative(props.path, filePath);\n      const normalizedPath = relativePath.split(path.sep).join(\"/\"); // Ensure forward slashes for URLs\n\n      return {\n        path: normalizedPath,\n        filePath,\n        contentType: getContentType(filePath),\n      };\n    });\n\n    // Get current timestamp\n    const now = Date.now();\n\n    // Construct the output\n    return this({\n      id,\n      type: \"assets\",\n      path: props.path,\n      files,\n      createdAt: this.output?.createdAt || now,\n      updatedAt: now,\n    });\n  }\n);\n\n// Helper functions for file operations\nasync function getFilesRecursively(dir: string): Promise<string[]> {\n  const files = await fs.readdir(dir, { withFileTypes: true });\n\n  const allFiles = await Promise.all(\n    files.map(async (file) => {\n      const path = `${dir}/${file.name}`;\n      if (file.isDirectory()) {\n        return getFilesRecursively(path);\n      }\n      return path;\n    })\n  );\n\n  return allFiles.flat();\n}\n\n```\n\n// alchemy/src/cloudflare/auth.ts\n```ts\nimport fs from \"node:fs/promises\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport type { Secret } from \"../secret\";\nimport type { CloudflareAccountId } from \"./account-id\";\nimport { handleApiError } from \"./api-error\";\n/**\n * Authentication options for Cloudflare API\n */\nexport interface CloudflareAuthOptions {\n  /**\n   * API Key to use with API Key\n   */\n  apiKey?: Secret;\n\n  /**\n   * API Token to use with API Key\n   */\n  apiToken?: Secret;\n\n  /**\n   * Email to use with API Key\n   * If not provided, will attempt to discover from Cloudflare API\n   */\n  email?: string;\n}\n\nexport interface CloudflareAccount {\n  name: string;\n  id: CloudflareAccountId;\n  type: \"standard\" | \"zero_rating\" | \"full_control\";\n  settings: {\n    enforce_twofactor: boolean;\n    api_access_enabled: null;\n    access_approval_expiry: null;\n    abuse_contact_email: null;\n  };\n  legacy_flags: {\n    enterprise_zone_quota: {\n      maximum: number;\n      current: number;\n      available: number;\n    };\n  };\n}\n\nexport interface CloudflareUserInfo {\n  apiToken?: Secret;\n  apiKey?: Secret;\n  email: string;\n  username: string;\n  accounts: CloudflareAccount[];\n  organizations: CloudflareOrganization[];\n  tokenPermissions: string[] | undefined;\n  first_name: string | null;\n  last_name: string | null;\n  telephone: string | null;\n  country: string | null;\n  zipcode: string | null;\n  two_factor_authentication_enabled: boolean;\n  two_factor_authentication_locked: boolean;\n  has_pro_zones: boolean;\n  has_business_zones: boolean;\n  has_enterprise_zones: boolean;\n  suspended: boolean;\n  betas: string[];\n}\n\nexport interface CloudflareOrganization {\n  id: string;\n  name: string;\n  status: string;\n  permissions: string[];\n  roles: string[];\n}\n\nconst userInfoCache: Record<string, CloudflareUserInfo> = {};\n\nexport async function getCloudflareUserInfo(\n  options: CloudflareAuthOptions\n): Promise<CloudflareUserInfo> {\n  const cacheKey = JSON.stringify({\n    apiKey: options.apiKey?.unencrypted,\n    apiToken: options.apiToken?.unencrypted,\n    email: options.email,\n  });\n  if (userInfoCache[cacheKey]) {\n    return userInfoCache[cacheKey];\n  }\n  const headers = await getCloudflareAuthHeaders(options);\n  const user = await fetch(\"https://api.cloudflare.com/client/v4/user\", {\n    headers,\n  });\n  if (!user.ok) {\n    if (user.status === 403) {\n      throw new Error(\n        \"Cloudflare authentication required. Did you forget to login with `wrangler login` or set CLOUDFLARE_API_TOKEN, CLOUDFLARE_API_KEY, or CLOUDFLARE_EMAIL, or CLOUDFLARE_API_KEY?\"\n      );\n    }\n    await handleApiError(user, \"getting\", \"user\", \"user\");\n  }\n  const accounts = await fetch(\n    \"https://api.cloudflare.com/client/v4/accounts\",\n    {\n      headers,\n    }\n  );\n  const userInfo: CloudflareUserInfo = {\n    ...((await user.json()) as any).result,\n    accounts: ((await accounts.json()) as any).result,\n  };\n  userInfoCache[cacheKey] = userInfo;\n  return userInfo;\n}\n\nexport async function getCloudflareAuthHeaders(\n  options: CloudflareAuthOptions = {}\n): Promise<Record<string, string>> {\n  // Check for API Token (preferred method)\n  const apiToken =\n    options.apiToken?.unencrypted ?? process.env.CLOUDFLARE_API_TOKEN;\n  if (apiToken) {\n    return {\n      Authorization: `Bearer ${apiToken}`,\n    };\n  }\n\n  // Check for API Key\n  const apiKey = options.apiKey?.unencrypted ?? process.env.CLOUDFLARE_API_KEY;\n  if (apiKey) {\n    return {\n      \"X-Auth-Key\": apiKey,\n      \"X-Auth-Email\":\n        options.email ??\n        process.env.CLOUDFLARE_EMAIL ??\n        (await getUserEmailFromApiKey(apiKey)),\n    };\n  }\n\n  const authConfig = await getRefreshedAuthConfig();\n  if (authConfig.oauth_token) {\n    return {\n      Authorization: `Bearer ${authConfig.oauth_token}`,\n    };\n  }\n\n  throw new Error(\n    \"Cloudflare authentication required. Did you forget to login with `wrangler login` or set CLOUDFLARE_API_TOKEN, CLOUDFLARE_API_KEY, or CLOUDFLARE_EMAIL, or CLOUDFLARE_API_KEY?\"\n  );\n}\n\nconst emailCache: Record<string, string> = {};\n\nasync function getUserEmailFromApiKey(apiKey: string): Promise<string> {\n  if (emailCache[apiKey]) {\n    return emailCache[apiKey];\n  }\n\n  try {\n    const baseUrl = \"https://api.cloudflare.com/client/v4\";\n\n    // Call the /user endpoint to get user information\n    const response = await fetch(`${baseUrl}/user`, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Auth-Key\": apiKey,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to get user information: ${response.status} ${response.statusText}`\n      );\n    }\n\n    const data = (await response.json()) as {\n      success: boolean;\n      result: {\n        id: string;\n        email: string;\n        name: string;\n        [key: string]: any;\n      };\n    };\n\n    if (!data.success || !data.result || !data.result.email) {\n      throw new Error(\"Cloudflare API did not return valid user information\");\n    }\n\n    emailCache[apiKey] = data.result.email;\n    return data.result.email;\n  } catch (error) {\n    console.error(\"Error retrieving email from Cloudflare API:\", error);\n    throw new Error(\n      \"Failed to automatically discover email for API Key authentication\"\n    );\n  }\n}\n\nasync function refreshAuthToken(\n  options: WranglerConfig\n): Promise<WranglerConfig> {\n  const response = await fetch(\"https://dash.cloudflare.com/oauth2/token\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    body: new URLSearchParams({\n      grant_type: \"refresh_token\",\n      refresh_token: options.refresh_token!,\n      client_id: \"54d11594-84e4-41aa-b438-e81b8fa78ee7\",\n    }).toString(),\n  });\n\n  if (!response.ok) {\n    throw new Error(\n      `Failed to refresh auth token: ${response.status} ${response.statusText}`\n    );\n  }\n\n  const data: any = await response.json();\n  if (!data.access_token) {\n    throw new Error(\"Failed to refresh auth token - no access token returned\");\n  }\n\n  options.oauth_token = data.access_token;\n  options.refresh_token = data.refresh_token;\n  options.expiration_time = new Date(\n    Date.now() + data.expires_in * 1000\n  ).toISOString();\n  options.scopes = data.scope?.split(\" \") || [];\n\n  return options;\n}\n\ninterface WranglerConfig {\n  path: string;\n  oauth_token?: string;\n  refresh_token?: string;\n  expiration_time?: string;\n  scopes?: string[];\n  /** @deprecated - this field was only provided by the deprecated v1 `wrangler config` command. */\n  api_token?: string;\n}\n\nasync function getRefreshedAuthConfig(): Promise<WranglerConfig> {\n  let authConfig = await readWranglerConfig();\n  if (authConfig.expiration_time) {\n    const expiry = new Date(authConfig.expiration_time);\n    // if expiring in 10s\n    if (expiry.getTime() < Date.now() + 10 * 1000) {\n      authConfig = await refreshAuthToken(authConfig);\n      authConfigCache[authConfig.path] = authConfig;\n      await writeWranglerConfig(authConfig);\n    }\n  }\n  return authConfig;\n}\n\nasync function writeWranglerConfig(config: WranglerConfig) {\n  const TOML = await import(\"@iarna/toml\");\n  const configPath = await findWranglerConfig();\n  config = {\n    ...config,\n  };\n  // @ts-ignore - i put this here\n  delete config.path;\n  const toml = TOML.stringify(config as any);\n  await fs.writeFile(configPath, toml);\n}\n\n// cache the file once per process\nconst authConfigCache: Record<string, WranglerConfig> = {};\n\nasync function readWranglerConfig(): Promise<WranglerConfig> {\n  const configPath = await findWranglerConfig();\n  const config = (authConfigCache[configPath] ??= await parseTOML(\n    await fs.readFile(configPath, \"utf-8\")\n  ));\n  config.path = configPath;\n  return config;\n}\n\nlet wranglerConfigPath: string | undefined;\n\nasync function findWranglerConfig(): Promise<string> {\n  if (wranglerConfigPath) {\n    return wranglerConfigPath;\n  }\n  const environment = process.env.WRANGLER_API_ENVIRONMENT ?? \"production\";\n  const filePath = path.join(\n    \"config\",\n    `${environment === \"production\" ? \"default.toml\" : `${environment}.toml`}`\n  );\n\n  const xdgAppPaths = (await import(\"xdg-app-paths\")).default;\n  //TODO: We should implement a custom path --global-config and/or the WRANGLER_HOME type environment variable\n  const configDir = xdgAppPaths(\".wrangler\").config(); // New XDG compliant config path\n  const legacyConfigDir = path.join(os.homedir(), \".wrangler\"); // Legacy config in user's home directory\n\n  // Check for the .wrangler directory in root if it is not there then use the XDG compliant path.\n  wranglerConfigPath = path.join(\n    (await isDirectory(legacyConfigDir)) ? legacyConfigDir : configDir,\n    filePath\n  );\n  return wranglerConfigPath;\n}\n\nasync function parseTOML(input: string): Promise<any> {\n  const TOML = await import(\"@iarna/toml\");\n  try {\n    // Normalize CRLF to LF to avoid hitting https://github.com/iarna/iarna-toml/issues/33.\n    const normalizedInput = input.replace(/\\r\\n/g, \"\\n\");\n    return TOML.parse(normalizedInput);\n  } catch (err: any) {\n    const { name } = err;\n    if (name !== \"TomlError\") {\n      throw err;\n    }\n    throw new Error(\"TOML parse error\");\n  }\n}\n\nasync function isDirectory(dir: string) {\n  try {\n    return (await fs.stat(dir)).isDirectory();\n  } catch (err) {\n    return false;\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/bindings.ts\n```ts\n/**\n * Type definitions for Cloudflare Worker bindings\n * Based on Cloudflare API documentation:\n * https://developers.cloudflare.com/api/resources/workers/subresources/scripts/methods/update/\n */\nimport type { Secret } from \"../secret\";\nimport type { Assets } from \"./assets\";\nimport type { R2Bucket } from \"./bucket\";\nimport type { DurableObjectNamespace } from \"./durable-object-namespace\";\nimport type { KVNamespace } from \"./kv-namespace\";\nimport type { Worker } from \"./worker\";\n\nexport type Bindings = {\n  [bindingName: string]: Binding;\n};\n\n/**\n * L2 Binding Resources.\n */\nexport type Binding =\n  | DurableObjectNamespace\n  | KVNamespace\n  | Worker\n  | R2Bucket\n  | Secret\n  | string\n  | Assets;\n\nexport function isDurableObjectNamespace(\n  binding: Binding\n): binding is DurableObjectNamespace {\n  return (\n    typeof binding === \"object\" && binding.type === \"durable_object_namespace\"\n  );\n}\n\n/**\n * Check if a binding is an Assets resource\n */\nexport function isAssets(binding: Binding): binding is Assets {\n  return typeof binding === \"object\" && binding.type === \"assets\";\n}\n\n/**\n * Union type for all Worker binding types (API spec)\n */\nexport type WorkerBindingSpec =\n  | WorkerBindingAI\n  | WorkerBindingAnalyticsEngine\n  | WorkerBindingAssets\n  | WorkerBindingBrowserRendering\n  | WorkerBindingD1\n  | WorkerBindingDispatchNamespace\n  | WorkerBindingDurableObjectNamespace\n  | WorkerBindingHyperdrive\n  | WorkerBindingJson\n  | WorkerBindingKVNamespace\n  | WorkerBindingMTLSCertificate\n  | WorkerBindingPlainText\n  | WorkerBindingQueue\n  | WorkerBindingR2Bucket\n  | WorkerBindingSecretText\n  | WorkerBindingService\n  | WorkerBindingStaticContent\n  | WorkerBindingTailConsumer\n  | WorkerBindingVectorize\n  | WorkerBindingVersionMetadata\n  | WorkerBindingWasmModule;\n\n/**\n * AI binding type\n */\nexport interface WorkerBindingAI {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for AI binding */\n  type: \"ai\";\n}\n\n/**\n * Analytics Engine binding type\n */\nexport interface WorkerBindingAnalyticsEngine {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Analytics Engine binding */\n  type: \"analytics_engine\";\n  /** Dataset name */\n  dataset: string;\n}\n\n/**\n * Assets binding type\n */\nexport interface WorkerBindingAssets {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Assets binding */\n  type: \"assets\";\n}\n\n/**\n * Browser Rendering binding type\n */\nexport interface WorkerBindingBrowserRendering {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Browser Rendering binding */\n  type: \"browser_rendering\";\n}\n\n/**\n * D1 database binding type\n */\nexport interface WorkerBindingD1 {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for D1 binding */\n  type: \"d1\";\n  /** D1 database ID */\n  id: string;\n}\n\n/**\n * Dispatch Namespace binding type\n */\nexport interface WorkerBindingDispatchNamespace {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Dispatch Namespace binding */\n  type: \"dispatch_namespace\";\n  /** Namespace identifier */\n  namespace: string;\n  /** Optional outbound service */\n  outbound?: any; // Documentation doesn't specify the exact type\n}\n\n/**\n * Durable Object Namespace binding type\n */\nexport interface WorkerBindingDurableObjectNamespace {\n  /**\n   * The stable ID of the binding\n   * @internal\n   */\n  stableId?: string;\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Durable Object Namespace binding */\n  type: \"durable_object_namespace\";\n  /** Durable Object class name */\n  class_name: string;\n  /** Script name that contains the Durable Object */\n  script_name?: string;\n  /** Environment */\n  environment?: string;\n  /** Namespace ID */\n  namespace_id?: string;\n}\n\n/**\n * Hyperdrive binding type\n */\nexport interface WorkerBindingHyperdrive {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Hyperdrive binding */\n  type: \"hyperdrive\";\n  /** Hyperdrive ID */\n  id: string;\n}\n\n/**\n * JSON binding type\n */\nexport interface WorkerBindingJson {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for JSON binding */\n  type: \"json\";\n  /** JSON value */\n  json: any;\n}\n\n/**\n * KV Namespace binding type\n */\nexport interface WorkerBindingKVNamespace {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for KV Namespace binding */\n  type: \"kv_namespace\";\n  /** KV Namespace ID */\n  namespace_id: string;\n}\n\n/**\n * MTLS Certificate binding type\n */\nexport interface WorkerBindingMTLSCertificate {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for MTLS Certificate binding */\n  type: \"mtls_certificate\";\n  /** Certificate ID */\n  certificate_id: string;\n}\n\n/**\n * Plain Text binding type\n */\nexport interface WorkerBindingPlainText {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Plain Text binding */\n  type: \"plain_text\";\n  /** Text content */\n  text: string;\n}\n\n/**\n * Queue binding type\n */\nexport interface WorkerBindingQueue {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Queue binding */\n  type: \"queue\";\n  /** Queue name */\n  queue_name: string;\n}\n\n/**\n * R2 Bucket binding type\n */\nexport interface WorkerBindingR2Bucket {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for R2 Bucket binding */\n  type: \"r2_bucket\";\n  /** Bucket name */\n  bucket_name: string;\n}\n\n/**\n * Secret Text binding type\n */\nexport interface WorkerBindingSecretText {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Secret Text binding */\n  type: \"secret_text\";\n  /** Secret value */\n  text: string;\n}\n\n/**\n * Service binding type\n */\nexport interface WorkerBindingService {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Service binding */\n  type: \"service\";\n  /** Service name */\n  service: string;\n  /** Environment */\n  environment?: string;\n  /** Service namespace */\n  namespace?: string;\n}\n\n/**\n * Tail Consumer binding type\n */\nexport interface WorkerBindingTailConsumer {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Tail Consumer binding */\n  type: \"tail_consumer\";\n  /** Service name */\n  service: string;\n}\n\n/**\n * Vectorize binding type\n */\nexport interface WorkerBindingVectorize {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Vectorize binding */\n  type: \"vectorize\";\n  /** Index name */\n  index_name: string;\n}\n\n/**\n * Version Metadata binding type\n */\nexport interface WorkerBindingVersionMetadata {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Version Metadata binding */\n  type: \"version_metadata\";\n}\n\n/**\n * WASM Module binding type\n */\nexport interface WorkerBindingWasmModule {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for WASM Module binding */\n  type: \"wasm_module\";\n  /** Module name */\n  module: string;\n}\n\n/**\n * Static content binding for Cloudflare Workers\n * Used for Workers Sites and static assets\n */\nexport interface WorkerBindingStaticContent {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Static Content binding */\n  type: \"static_content\";\n}\n\n```\n\n// alchemy/src/cloudflare/bound.ts\n```ts\nimport type { Secret } from \"../secret\";\nimport type { Assets } from \"./assets\";\nimport type { Binding } from \"./bindings\";\nimport type { R2Bucket as _R2Bucket } from \"./bucket\";\nimport type { DurableObjectNamespace as _DurableObjectNamespace } from \"./durable-object-namespace\";\nimport type { KVNamespace as _KVNamespace } from \"./kv-namespace\";\nimport type { Worker as _Worker } from \"./worker\";\n\nexport type Bound<T extends Binding> = T extends _DurableObjectNamespace\n  ? DurableObjectNamespace\n  : T extends _KVNamespace\n    ? KVNamespace\n    : T extends _Worker\n      ? Worker\n      : T extends _R2Bucket\n        ? R2Bucket\n        : T extends Secret\n          ? string\n          : T extends Assets\n            ? Service\n            : Service;\n\n```\n\n// alchemy/src/cloudflare/bucket.ts\n```ts\nimport { AwsClient } from \"aws4fetch\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { CloudflareApi, createCloudflareApi } from \"./api\";\nimport { CloudflareApiError, handleApiError } from \"./api-error\";\n\n/**\n * Properties for creating or updating an R2 Bucket\n */\nexport interface BucketProps {\n  /**\n   * Name of the bucket\n   * Names can only contain lowercase letters (a-z), numbers (0-9), and hyphens (-)\n   * Cannot begin or end with a hyphen\n   */\n  name: string;\n\n  /**\n   * Optional location hint for the bucket\n   * Indicates the primary geographical location data will be accessed from\n   */\n  locationHint?: string;\n\n  /**\n   * Optional jurisdiction for the bucket\n   * Determines the regulatory jurisdiction the bucket data falls under\n   */\n  jurisdiction?: \"default\" | \"eu\" | \"fedramp\";\n\n  /**\n   * Whether to allow public access through the r2.dev subdomain\n   * Only for development purposes - use custom domains for production\n   */\n  allowPublicAccess?: boolean;\n\n  /**\n   * Whether to delete the bucket.\n   * If set to false, the bucket will remain but the resource will be removed from state\n   *\n   * @default true\n   */\n  delete?: boolean;\n\n  /**\n   * Whether to empty the bucket and delete all objects during resource deletion\n   * @default false\n   */\n  empty?: boolean;\n\n  /**\n   * API Token to use for the bucket\n   */\n  apiToken?: Secret;\n\n  /**\n   * API Key to use for the bucket\n   */\n  apiKey?: Secret;\n\n  /**\n   * Email to use for the bucket\n   */\n  email?: string;\n\n  /**\n   * Account ID to use for the bucket\n   */\n  accountId?: string;\n\n  /**\n   * Access Key to use for the bucket\n   */\n  accessKey?: Secret;\n\n  /**\n   * Secret Access Key to use for the bucket\n   */\n  secretAccessKey?: Secret;\n}\n\n/**\n * Output returned after R2 Bucket creation/update\n */\nexport interface R2Bucket\n  extends Resource<\"cloudflare::R2Bucket\">,\n    BucketProps {\n  /**\n   * Resource type identifier\n   */\n  type: \"r2_bucket\";\n\n  /**\n   * Location of the bucket\n   */\n  location: string;\n\n  /**\n   * Time at which the bucket was created\n   */\n  creationDate: Date;\n}\n\n/**\n * Creates and manages Cloudflare R2 Buckets for object storage.\n *\n * R2 Buckets provide S3-compatible object storage with automatic data replication\n * across multiple regions for high availability and durability.\n *\n * @example\n * // Create a basic R2 bucket with default settings\n * const basicBucket = await R2Bucket(\"my-app-data\", {\n *   name: \"my-app-data\"\n * });\n *\n * @example\n * // Create a bucket with location hint for optimal performance\n * const euBucket = await R2Bucket(\"eu-user-data\", {\n *   name: \"eu-user-data\",\n *   locationHint: \"eu\",\n *   jurisdiction: \"eu\"\n * });\n *\n * @example\n * // Create a development bucket with public access enabled\n * const publicBucket = await R2Bucket(\"public-assets\", {\n *   name: \"public-assets\",\n *   allowPublicAccess: true\n * });\n *\n * @example\n * // Create a FedRAMP compliant bucket for government workloads\n * const fedRampBucket = await R2Bucket(\"gov-data\", {\n *   name: \"gov-data\",\n *   jurisdiction: \"fedramp\"\n * });\n *\n * @example\n * // Create a bucket that will be automatically emptied when deleted\n * // This will delete all objects in the bucket before deleting the bucket itself\n * const temporaryBucket = await R2Bucket(\"temp-storage\", {\n *   name: \"temp-storage\",\n *   empty: true  // All objects will be deleted when this resource is destroyed\n * });\n *\n * @see https://developers.cloudflare.com/r2/buckets/\n */\nexport const R2Bucket = Resource(\n  \"cloudflare::R2Bucket\",\n  async function (\n    this: Context<R2Bucket>,\n    id: string,\n    props: BucketProps\n  ): Promise<R2Bucket> {\n    const api = await createCloudflareApi(props);\n    const bucketName = props.name || this.id;\n\n    if (this.phase === \"delete\") {\n      console.log(\"Deleting R2 bucket:\", bucketName);\n      if (props.delete !== false) {\n        if (props.empty) {\n          console.log(\"Emptying R2 bucket:\", bucketName);\n          const r2Client = await createR2Client({\n            ...props,\n            accountId: api.accountId,\n          });\n          // Empty the bucket first by deleting all objects\n          await emptyBucket(r2Client, bucketName, props.jurisdiction);\n        }\n\n        // Delete R2 bucket\n        console.log(\"Deleting R2 bucket:\", bucketName);\n        await deleteBucket(api, bucketName, props);\n      }\n\n      // Return void (a deleted bucket has no content)\n      return this.destroy();\n    } else {\n      if (this.phase === \"create\") {\n        console.log(\"Creating R2 bucket:\", bucketName);\n        await createBucket(api, bucketName, props);\n      }\n\n      await updatePublicAccess(\n        api,\n        bucketName,\n        props.allowPublicAccess === true,\n        props.jurisdiction\n      );\n\n      return this({\n        name: bucketName,\n        location: props.locationHint || \"default\",\n        creationDate: new Date(),\n        jurisdiction: props.jurisdiction || \"default\",\n        type: \"r2_bucket\",\n        accountId: api.accountId,\n      });\n    }\n  }\n);\n\n/**\n * Configuration for R2 client to connect to Cloudflare R2\n */\nexport interface R2ClientConfig {\n  accountId: string;\n  accessKeyId?: Secret;\n  secretAccessKey?: Secret;\n  jurisdiction?: string;\n}\n\ntype R2Client = AwsClient & { accountId: string };\n\n/**\n * Creates an aws4fetch client configured for Cloudflare R2\n *\n * @see https://developers.cloudflare.com/r2/examples/aws/aws-sdk-js-v3/\n */\nexport function createR2Client(config?: R2ClientConfig): Promise<R2Client> {\n  const accountId = config?.accountId ?? process.env.CLOUDFLARE_ACCOUNT_ID;\n  const accessKeyId =\n    config?.accessKeyId?.unencrypted || process.env.R2_ACCESS_KEY_ID;\n  const secretAccessKey =\n    config?.secretAccessKey?.unencrypted || process.env.R2_SECRET_ACCESS_KEY;\n\n  if (!accountId) {\n    throw new Error(\"CLOUDFLARE_ACCOUNT_ID environment variable is required\");\n  }\n\n  if (!accessKeyId || !secretAccessKey) {\n    throw new Error(\n      \"R2_ACCESS_KEY_ID and R2_SECRET_ACCESS_KEY environment variables are required\"\n    );\n  }\n\n  // Create aws4fetch client with Cloudflare R2 endpoint\n  const client: any = new AwsClient({\n    accessKeyId,\n    secretAccessKey,\n    service: \"s3\",\n    region: \"auto\",\n  });\n  client.accountId = accountId;\n  return client;\n}\n\ninterface CloudflareBucketResponse {\n  result: {\n    name: string;\n    location?: string;\n    creation_date: string;\n  };\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n}\n\n/**\n * Adds jurisdiction header to the headers object if specified in props\n *\n * @param headers Headers object to modify\n * @param props Props or jurisdiction string\n * @returns Modified headers object\n */\nexport function withJurisdiction(\n  headers: Record<string, string> = {},\n  props: BucketProps | { jurisdiction?: string } | string | undefined\n): Record<string, string> {\n  // Clone the headers object to avoid modifying the original\n  const result = { ...headers };\n\n  let jurisdiction: string | undefined;\n  if (typeof props === \"string\") {\n    jurisdiction = props;\n  } else if (props && \"jurisdiction\" in props) {\n    jurisdiction = props.jurisdiction;\n  }\n\n  if (jurisdiction && jurisdiction !== \"default\") {\n    result[\"cf-r2-jurisdiction\"] = jurisdiction;\n  }\n\n  return result;\n}\n\n/**\n * Create a new bucket\n */\nexport async function createBucket(\n  api: CloudflareApi,\n  bucketName: string,\n  props: BucketProps\n): Promise<CloudflareBucketResponse> {\n  // Create new R2 bucket\n  const createPayload: any = {\n    name: bucketName,\n  };\n\n  if (props.locationHint) {\n    createPayload.location_hint = props.locationHint;\n  }\n\n  const headers = withJurisdiction({}, props);\n\n  const createResponse = await api.post(\n    `/accounts/${api.accountId}/r2/buckets`,\n    createPayload,\n    { headers }\n  );\n\n  if (!createResponse.ok) {\n    return await handleApiError(\n      createResponse,\n      \"creating\",\n      \"R2 bucket\",\n      bucketName\n    );\n  }\n\n  return (await createResponse.json()) as CloudflareBucketResponse;\n}\n\n/**\n * Delete a bucket\n */\nexport async function deleteBucket(\n  api: CloudflareApi,\n  bucketName: string,\n  props: BucketProps\n): Promise<void> {\n  // Delete R2 bucket\n  const headers = withJurisdiction({}, props);\n\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/r2/buckets/${bucketName}`,\n    { headers }\n  );\n\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    const errorData: any = await deleteResponse.json().catch(() => ({\n      errors: [{ message: deleteResponse.statusText }],\n    }));\n    throw new CloudflareApiError(\n      `Error deleting R2 bucket '${bucketName}': ${errorData.errors?.[0]?.message || deleteResponse.statusText}`,\n      deleteResponse\n    );\n  }\n}\n\n/**\n * List objects in an R2 bucket\n *\n * @param r2 R2Client instance\n * @param bucketName Name of the bucket\n * @param continuationToken Optional token for pagination\n * @param jurisdiction Optional jurisdiction for the bucket\n * @returns Object containing the list of objects and the next continuation token\n */\nexport async function listObjects(\n  r2: R2Client,\n  bucketName: string,\n  continuationToken?: string,\n  jurisdiction?: string\n): Promise<{ objects: { Key: string }[]; continuationToken?: string }> {\n  // List objects in the bucket\n  const url = new URL(\n    `https://${r2.accountId}.r2.cloudflarestorage.com/${bucketName}`\n  );\n  if (continuationToken) {\n    url.searchParams.set(\"continuation-token\", continuationToken);\n  }\n  url.searchParams.set(\"list-type\", \"2\");\n\n  const headers = withJurisdiction({}, jurisdiction);\n\n  const listResponse = await r2.fetch(url.toString(), { headers });\n  if (!listResponse.ok) {\n    throw new CloudflareApiError(\n      `Failed to list objects: ${listResponse.statusText}`,\n      listResponse\n    );\n  }\n\n  const responseText = await listResponse.text();\n\n  // Extract objects from XML response using regex\n  const keyRegex = /<Key>([^<]+)<\\/Key>/g;\n  const objects: { Key: string }[] = [];\n  let match;\n  while ((match = keyRegex.exec(responseText)) !== null) {\n    objects.push({ Key: match[1] });\n  }\n\n  // Get continuation token if present using regex\n  const tokenMatch =\n    /<NextContinuationToken>([^<]+)<\\/NextContinuationToken>/.exec(\n      responseText\n    );\n  const nextContinuationToken = tokenMatch ? tokenMatch[1] : undefined;\n\n  return { objects, continuationToken: nextContinuationToken };\n}\n\n/**\n * Helper function to empty a bucket by deleting all objects\n */\nexport async function emptyBucket(\n  r2: R2Client,\n  bucketName: string,\n  jurisdiction?: string\n): Promise<void> {\n  let continuationToken: string | undefined;\n  let totalDeleted = 0;\n\n  try {\n    do {\n      // List objects in the bucket\n      const { objects, continuationToken: nextToken } = await listObjects(\n        r2,\n        bucketName,\n        continuationToken,\n        jurisdiction\n      );\n\n      continuationToken = nextToken;\n\n      console.log(`Found ${objects.length} objects in bucket ${bucketName}`);\n\n      // Delete objects in batches\n      if (objects.length > 0) {\n        // Process delete in batches of 1000 (S3 limit)\n        for (let i = 0; i < objects.length; i += 1000) {\n          const batch = objects.slice(i, i + 1000);\n\n          // Create DeleteObjects request XML\n          const deleteXml = `\n            <Delete>\n              ${batch.map((obj) => `<Object><Key>${obj.Key}</Key></Object>`).join(\"\")}\n            </Delete>\n          `;\n\n          const deleteUrl = new URL(\n            `https://${r2.accountId}.r2.cloudflarestorage.com/${bucketName}?delete`\n          );\n\n          console.log(\n            `Deleting ${batch.length} objects from bucket ${bucketName}`\n          );\n\n          const headers = withJurisdiction(\n            { \"Content-Type\": \"application/xml\" },\n            jurisdiction\n          );\n\n          const deleteResponse = await r2.fetch(deleteUrl.toString(), {\n            method: \"POST\",\n            body: deleteXml,\n            headers,\n          });\n\n          if (!deleteResponse.ok) {\n            throw new CloudflareApiError(\n              `Failed to delete objects: ${deleteResponse.statusText}`,\n              deleteResponse\n            );\n          }\n\n          totalDeleted += batch.length;\n        }\n      }\n    } while (continuationToken);\n\n    console.log(\n      `Successfully emptied bucket ${bucketName}, deleted ${totalDeleted} objects total`\n    );\n  } catch (error) {\n    if (error instanceof CloudflareApiError && error.status === 404) {\n      // the bucket was not found\n      return;\n    }\n    console.error(`Failed to empty bucket ${bucketName}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Update public access setting for a bucket\n *\n * This operation is not available through the S3 API for R2,\n * so we still use the Cloudflare API directly.\n */\nexport async function updatePublicAccess(\n  api: CloudflareApi,\n  bucketName: string,\n  allowPublicAccess: boolean,\n  jurisdiction?: string\n): Promise<void> {\n  const headers = withJurisdiction({}, jurisdiction);\n\n  const response = await api.put(\n    `/accounts/${api.accountId}/r2/buckets/${bucketName}/domains/managed`,\n    {\n      enabled: allowPublicAccess,\n    },\n    { headers }\n  );\n\n  if (!response.ok) {\n    await handleApiError(\n      response,\n      \"updating public access for\",\n      \"R2 bucket\",\n      bucketName\n    );\n  }\n}\n\n/**\n * Set CORS configuration for a bucket using aws4fetch\n */\nexport async function setCorsConfiguration(\n  r2: R2Client,\n  bucketName: string,\n  allowedOrigins: string[] = [\"*\"],\n  allowedMethods: string[] = [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\"],\n  allowedHeaders: string[] = [\"*\"],\n  maxAgeSeconds: number = 3600,\n  jurisdiction?: string\n): Promise<void> {\n  try {\n    // Construct CORS XML configuration\n    const corsXml = `\n      <CORSConfiguration>\n        <CORSRule>\n          ${allowedOrigins.map((origin) => `<AllowedOrigin>${origin}</AllowedOrigin>`).join(\"\")}\n          ${allowedMethods.map((method) => `<AllowedMethod>${method}</AllowedMethod>`).join(\"\")}\n          ${allowedHeaders.map((header) => `<AllowedHeader>${header}</AllowedHeader>`).join(\"\")}\n          <ExposeHeader>ETag</ExposeHeader>\n          <MaxAgeSeconds>${maxAgeSeconds}</MaxAgeSeconds>\n        </CORSRule>\n      </CORSConfiguration>\n    `;\n\n    const url = new URL(\n      `https://${r2.accountId}.r2.cloudflarestorage.com/${bucketName}?cors`\n    );\n\n    const headers = withJurisdiction(\n      { \"Content-Type\": \"application/xml\" },\n      jurisdiction\n    );\n\n    const response = await r2.fetch(url.toString(), {\n      method: \"PUT\",\n      body: corsXml,\n      headers,\n    });\n\n    if (!response.ok) {\n      throw new CloudflareApiError(\n        `Failed to set CORS configuration: ${response.statusText}`,\n        response\n      );\n    }\n\n    console.log(`Successfully set CORS configuration for bucket ${bucketName}`);\n  } catch (error) {\n    console.error(\n      `Failed to set CORS configuration for bucket ${bucketName}:`,\n      error\n    );\n    throw error;\n  }\n}\n\n/**\n * Information about an R2 bucket returned by list operations\n */\nexport interface R2BucketInfo {\n  /**\n   * Name of the bucket\n   */\n  Name: string;\n\n  /**\n   * Creation date of the bucket\n   */\n  CreationDate: Date;\n}\n\n/**\n * List all R2 buckets in an account\n *\n * @param api CloudflareApi instance\n * @param options Optional listing options\n * @returns Array of bucket information\n */\nexport async function listBuckets(\n  api: CloudflareApi,\n  options: {\n    nameContains?: string;\n    perPage?: number;\n    cursor?: string;\n    direction?: \"asc\" | \"desc\";\n    jurisdiction?: string;\n  } = {}\n): Promise<R2BucketInfo[]> {\n  // Build query parameters\n  const params = new URLSearchParams();\n\n  if (options.nameContains) {\n    params.append(\"name_contains\", options.nameContains);\n  }\n\n  if (options.perPage) {\n    params.append(\"per_page\", options.perPage.toString());\n  }\n\n  if (options.cursor) {\n    params.append(\"cursor\", options.cursor);\n  }\n\n  if (options.direction) {\n    params.append(\"direction\", options.direction);\n  }\n\n  // Build URL with query parameters\n  const path = `/accounts/${api.accountId}/r2/buckets${params.toString() ? \"?\" + params.toString() : \"\"}`;\n\n  // Set jurisdiction header if provided\n  const headers = withJurisdiction({}, options.jurisdiction);\n\n  // Make the API request\n  const response = await api.get(path, { headers });\n\n  if (!response.ok) {\n    throw new CloudflareApiError(\n      `Failed to list buckets: ${response.statusText}`,\n      response\n    );\n  }\n\n  const data = (await response.json()) as {\n    success: boolean;\n    errors?: Array<{ code: number; message: string }>;\n    result?: {\n      buckets: Array<{\n        name: string;\n        creation_date: string;\n        location?: string;\n      }>;\n    };\n  };\n\n  if (!data.success) {\n    const errorMessage = data.errors?.[0]?.message || \"Unknown error\";\n    throw new Error(`Failed to list buckets: ${errorMessage}`);\n  }\n\n  // Transform API response to R2BucketInfo objects\n  return (data.result?.buckets || []).map((bucket) => ({\n    Name: bucket.name,\n    CreationDate: new Date(bucket.creation_date),\n  }));\n}\n\n```\n\n// alchemy/src/cloudflare/custom-domain.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport {\n  CloudflareApi,\n  createCloudflareApi,\n  type CloudflareApiOptions,\n} from \"./api\";\nimport { handleApiError } from \"./api-error\";\n\n/**\n * Properties for creating or updating a CustomDomain\n */\nexport interface CustomDomainProps extends CloudflareApiOptions {\n  /**\n   * The domain name to bind to the worker\n   */\n  name: string;\n\n  /**\n   * Cloudflare Zone ID for the domain\n   */\n  zoneId: string;\n\n  /**\n   * Name of the worker to bind to the domain\n   */\n  workerName: string;\n\n  /**\n   * Worker environment (defaults to production)\n   * @default \"production\"\n   */\n  environment?: string;\n}\n\n/**\n * Cloudflare Domain object structure from API\n */\ninterface CloudflareDomain {\n  id: string;\n  zone_id: string;\n  zone_name: string;\n  hostname: string;\n  service: string;\n  environment: string;\n}\n\n/**\n * Output returned after CustomDomain creation/update\n */\nexport interface CustomDomain\n  extends Resource<\"cloudflare::CustomDomain\">,\n    CustomDomainProps {\n  /**\n   * The unique identifier for the Cloudflare domain binding.\n   */\n  id: string;\n\n  /**\n   * Time at which the domain binding was created (approximated if not returned by API)\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the domain binding was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Configure custom domain for a Cloudflare Worker using the Cloudflare Custom Domains API\n * This attaches a worker to a specific hostname within a zone.\n *\n * @example\n * // Bind a domain to a standard Cloudflare Worker\n * const apiWorker = await Worker(\"api\", {\n *   name: \"my-api-worker\",\n *   entrypoint: \"./src/api-worker.ts\"\n * });\n *\n * const apiDomain = await CustomDomain(\"api-domain-binding\", {\n *   name: \"api.example.com\",\n *   zoneId: \"YOUR_ZONE_ID\", // Replace with actual Zone ID\n *   workerName: apiWorker.name // Use the name from the Worker resource\n * });\n *\n * @see https://developers.cloudflare.com/api/resources/workers/subresources/domains/\n */\nexport const CustomDomain = Resource(\n  \"cloudflare::CustomDomain\",\n  async function (\n    this: Context<CustomDomain>,\n    logicalId: string, // Changed param name from id to logicalId for clarity\n    props: CustomDomainProps\n  ): Promise<CustomDomain> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    // Validate required properties\n    if (!props.name) {\n      throw new Error(\"Domain name (props.name) is required\");\n    }\n    if (!props.zoneId) {\n      throw new Error(\"Zone ID (props.zoneId) is required\");\n    }\n    if (!props.workerName) {\n      throw new Error(\"Worker name (props.workerName) is required\");\n    }\n\n    if (this.phase === \"delete\") {\n      await deleteCustomDomain(this, api, logicalId, props);\n      return this.destroy();\n    } else {\n      // Create or Update phase\n      return await ensureCustomDomain(this, api, logicalId, props);\n    }\n  }\n);\n\n// Helper function to delete the custom domain binding\nasync function deleteCustomDomain(\n  context: Context<CustomDomain>,\n  api: CloudflareApi,\n  logicalId: string,\n  props: CustomDomainProps\n): Promise<void> {\n  const domainHostname = props.name;\n  const domainIdToDelete = context.output?.id;\n\n  if (!domainIdToDelete) {\n    console.warn(\n      `Cannot delete CustomDomain ${logicalId} (${domainHostname}): Missing domain ID in state. Assuming already deleted.`\n    );\n    return; // Exit early if no ID\n  }\n\n  console.log(\n    `Deleting CustomDomain binding ${domainIdToDelete} for ${domainHostname}`\n  );\n  const response = await api.delete(\n    `/accounts/${api.accountId}/workers/domains/${domainIdToDelete}`\n  );\n\n  console.log(\n    `Delete result for ${domainIdToDelete} (${domainHostname}):`,\n    response.status,\n    response.statusText\n  );\n\n  // 404 is acceptable during deletion for idempotency\n  if (!response.ok && response.status !== 404) {\n    await handleApiError(\n      response,\n      \"deleting\",\n      \"custom domain binding\",\n      domainIdToDelete\n    );\n    // Throw after handling to ensure failure is reported\n    throw new Error(\n      `Failed to delete custom domain binding ${domainIdToDelete}: ${response.statusText}`\n    );\n  }\n}\n\n// Helper function to create or update the custom domain binding\nasync function ensureCustomDomain(\n  context: Context<CustomDomain>,\n  api: CloudflareApi,\n  logicalId: string,\n  props: CustomDomainProps\n): Promise<CustomDomain> {\n  const environment = props.environment || \"production\";\n  const domainHostname = props.name;\n\n  // Check if domain binding already exists for this account\n  console.log(`Checking existing domain bindings for account ${api.accountId}`);\n  const listResponse = await api.get(\n    `/accounts/${api.accountId}/workers/domains`\n  );\n\n  if (!listResponse.ok) {\n    // Fix: Added the 4th argument (resource identifier/context)\n    await handleApiError(\n      listResponse,\n      \"listing\",\n      \"worker domains\",\n      `Account ${api.accountId}`\n    );\n    // If listing fails, we cannot proceed reliably\n    throw new Error(\n      `Failed to list worker domains for account ${api.accountId}: ${listResponse.statusText}`\n    );\n  }\n\n  const listData = (await listResponse.json()) as {\n    result?: CloudflareDomain[];\n    success: boolean;\n  };\n\n  if (!listData.success || !listData.result) {\n    throw new Error(\n      `Failed to parse list worker domains response: ${JSON.stringify(listData)}`\n    );\n  }\n\n  // Find the specific binding by hostname AND zoneId\n  const existingBinding = listData.result.find(\n    (b) => b.hostname === domainHostname && b.zone_id === props.zoneId\n  );\n\n  let currentDomainId = existingBinding?.id;\n  const bindingExists = !!existingBinding;\n\n  console.log(\n    `Domain binding status for ${domainHostname} (Zone: ${props.zoneId}):`,\n    bindingExists\n      ? `Found (ID: ${currentDomainId}, Worker: ${existingBinding.service}, Env: ${existingBinding.environment})`\n      : \"Not found\"\n  );\n\n  // Determine if we need to update (binding exists but has different service or environment)\n  const needsUpdate =\n    bindingExists &&\n    (existingBinding.service !== props.workerName ||\n      existingBinding.environment !== environment);\n\n  let operationPerformed: \"create\" | \"update\" | \"none\" = \"none\";\n  let resultantBinding: CloudflareDomain | undefined = existingBinding;\n\n  // Create or Update the binding using PUT\n  // Cloudflare's PUT /accounts/{account_id}/workers/domains acts as an upsert\n  if (!bindingExists || needsUpdate) {\n    operationPerformed = bindingExists ? \"update\" : \"create\";\n    console.log(\n      `${operationPerformed === \"update\" ? \"Updating\" : \"Creating\"} domain binding: ${domainHostname} (Zone: ${props.zoneId}) → ${props.workerName}:${environment}`\n    );\n\n    const putPayload = {\n      zone_id: props.zoneId,\n      hostname: domainHostname,\n      service: props.workerName,\n      environment: environment,\n    };\n\n    const putResponse = await api.put(\n      `/accounts/${api.accountId}/workers/domains`,\n      putPayload\n    );\n\n    if (!putResponse.ok) {\n      await handleApiError(\n        putResponse,\n        operationPerformed === \"update\" ? \"updating\" : \"creating\",\n        \"custom domain binding\",\n        domainHostname\n      );\n      // Throw after handling to prevent inconsistent state\n      throw new Error(\n        `Failed to ${operationPerformed} custom domain binding: ${putResponse.statusText}`\n      );\n    }\n\n    const putResult = (await putResponse.json()) as {\n      result?: CloudflareDomain;\n      success: boolean;\n    };\n\n    if (!putResult.success || !putResult.result) {\n      throw new Error(\n        `Failed to parse ${operationPerformed} domain binding response: ${JSON.stringify(putResult)}`\n      );\n    }\n\n    resultantBinding = putResult.result;\n    currentDomainId = resultantBinding.id; // Update ID from the PUT response\n    console.log(\n      `Successfully ${operationPerformed}d binding, new ID: ${currentDomainId}`\n    );\n  } else {\n    console.log(\n      `Domain binding already exists and is up to date: ${domainHostname} (ID: ${currentDomainId}) → ${props.workerName}:${environment}`\n    );\n  }\n\n  // Ensure we have the final binding details\n  if (!resultantBinding || !currentDomainId) {\n    // This case should ideally not happen if API calls succeed\n    console.error(\"Error: Could not determine final domain binding state.\", {\n      existingBinding,\n      resultantBinding,\n      currentDomainId,\n    });\n    throw new Error(\n      `Failed to get final state for custom domain ${domainHostname}`\n    );\n  }\n\n  const now = Date.now();\n\n  // Construct the output state\n  return context({\n    ...props, // Include all input props\n    id: currentDomainId, // Use the definitive ID\n    environment: resultantBinding.environment, // Use actual environment from CF\n    createdAt: context.output?.createdAt || now, // Preserve create time or set new\n    updatedAt:\n      operationPerformed !== \"none\" ? now : context.output?.updatedAt || now, // Update time only if changed\n  });\n}\n\n```\n\n// alchemy/src/cloudflare/dns-records.ts\n```ts\nimport type { Context } from \"../context\";\nimport type {\n  DnsRecord as BaseDnsRecord,\n  DnsRecordType,\n  DnsRecordWithMetadata,\n} from \"../dns/record\";\nimport { Resource } from \"../resource\";\nimport {\n  type CloudflareApi,\n  type CloudflareApiOptions,\n  createCloudflareApi,\n} from \"./api\";\nimport type { CloudflareResponse } from \"./response\";\n\n/**\n * Cloudflare DNS Record response format\n */\ninterface CloudflareDnsRecord {\n  id: string;\n  type: string;\n  name: string;\n  content: string;\n  proxiable: boolean;\n  proxied: boolean;\n  ttl: number;\n  locked: boolean;\n  zone_id: string;\n  zone_name: string;\n  created_on: string;\n  modified_on: string;\n  data?: Record<string, unknown>;\n  priority?: number;\n  comment?: string;\n  tags?: string[];\n}\n\n/**\n * Properties for a DNS record\n */\nexport interface DnsRecordProps extends Omit<BaseDnsRecord, \"type\"> {\n  /**\n   * Record type (A, AAAA, CNAME, etc.)\n   */\n  type: DnsRecordType;\n}\n\n/**\n * Output returned after DNS record creation/update\n */\nexport interface DnsRecord extends DnsRecordWithMetadata {}\n\n/**\n * Properties for managing multiple DNS records\n */\nexport interface DnsRecordsProps extends CloudflareApiOptions {\n  /**\n   * Zone ID or domain name where records will be created\n   */\n  zoneId: string;\n\n  /**\n   * Array of DNS records to manage\n   */\n  records: DnsRecordProps[];\n}\n\n/**\n * Output returned after DNS records creation/update\n */\nexport interface DnsRecords extends Resource<\"cloudflare::DnsRecords\"> {\n  /**\n   * Zone ID where records are created\n   */\n  zoneId: string;\n\n  /**\n   * Array of created/updated DNS records\n   */\n  records: DnsRecord[];\n}\n\n/**\n * Manages a batch of DNS records in a Cloudflare zone.\n * Supports creating, updating, and deleting multiple records at once.\n *\n * @example\n * // Create multiple A and CNAME records\n * const dnsRecords = await DnsRecords(\"example.com-dns\", {\n *   zone: \"example.com\",\n *   records: [\n *     {\n *       name: \"www.example.com\",\n *       type: \"A\",\n *       content: \"192.0.2.1\",\n *       proxied: true\n *     },\n *     {\n *       name: \"blog.example.com\",\n *       type: \"CNAME\",\n *       content: \"www.example.com\",\n *       proxied: true\n *     }\n *   ]\n * });\n *\n * @example\n * // Create MX records for email routing\n * const emailRecords = await DnsRecords(\"example.com-email\", {\n *   zone: \"example.com\",\n *   records: [\n *     {\n *       name: \"example.com\",\n *       type: \"MX\",\n *       content: \"aspmx.l.google.com\",\n *       priority: 1\n *     },\n *     {\n *       name: \"example.com\",\n *       type: \"MX\",\n *       content: \"alt1.aspmx.l.google.com\",\n *       priority: 5\n *     }\n *   ]\n * });\n */\nexport const DnsRecords = Resource(\n  \"cloudflare::DnsRecords\",\n  async function (\n    this: Context<DnsRecords>,\n    id: string,\n    props: DnsRecordsProps\n  ): Promise<DnsRecords> {\n    // Create Cloudflare API client\n    const api = await createCloudflareApi(props);\n\n    // Get zone ID if domain name was provided\n    const zoneId = props.zoneId;\n\n    if (this.phase === \"delete\") {\n      if (this.output?.records) {\n        // Delete all existing records\n        await Promise.all(\n          this.output.records.map(async (record) => {\n            try {\n              const response = await api.delete(\n                `/zones/${zoneId}/dns_records/${record.id}`\n              );\n              if (!response.ok && response.status !== 404) {\n                console.error(\n                  `Failed to delete DNS record ${record.name}: ${response.statusText}`\n                );\n              }\n            } catch (error) {\n              console.error(`Error deleting DNS record ${record.name}:`, error);\n            }\n          })\n        );\n      }\n      return this.destroy();\n    }\n\n    if (this.phase === \"update\" && this.output?.records) {\n      // Get current records to compare with desired state\n      const currentRecords = this.output.records;\n      const desiredRecords = props.records;\n\n      // Find records to delete (exist in current but not in desired)\n      const recordsToDelete = currentRecords.filter(\n        (current) =>\n          !desiredRecords.some(\n            (desired) =>\n              desired.name === current.name && desired.type === current.type\n          )\n      );\n\n      // Delete orphaned records\n      await Promise.all(\n        recordsToDelete.map(async (record) => {\n          try {\n            const response = await api.delete(\n              `/zones/${zoneId}/dns_records/${record.id}`\n            );\n            if (!response.ok && response.status !== 404) {\n              console.error(\n                `Failed to delete DNS record ${record.name}: ${response.statusText}`\n              );\n            }\n          } catch (error) {\n            console.error(`Error deleting DNS record ${record.name}:`, error);\n          }\n        })\n      );\n\n      // Update or create records\n      const updatedRecords = await Promise.all(\n        desiredRecords.map(async (desired) => {\n          // Find matching existing record\n          const existing = currentRecords.find(\n            (current) =>\n              current.name === desired.name && current.type === desired.type\n          );\n\n          if (existing) {\n            // Update if content or other properties changed\n            if (\n              existing.content !== desired.content ||\n              existing.ttl !== (desired.ttl || 1) ||\n              existing.proxied !== (desired.proxied || false) ||\n              existing.priority !== desired.priority ||\n              existing.comment !== desired.comment\n            ) {\n              return createOrUpdateRecord(api, zoneId, desired, existing.id);\n            }\n            return existing;\n          } else {\n            // Create new record\n            return createOrUpdateRecord(api, zoneId, desired);\n          }\n        })\n      );\n\n      return this({\n        zoneId,\n        records: updatedRecords,\n      });\n    }\n\n    // Create new records\n    const uniqueRecords = props.records.reduce(\n      (acc, record) => {\n        // For record types that can have multiple entries with the same name (MX, TXT, NS, etc.),\n        // include content and/or priority in the key to avoid deduplication\n        let key = `${record.name}-${record.type}`;\n\n        // If it's a record type that can have multiple entries with the same name, make the key unique\n        if ([\"MX\", \"TXT\", \"NS\", \"SRV\", \"CAA\"].includes(record.type)) {\n          // For MX, include priority in the key\n          if (record.type === \"MX\" || record.type === \"SRV\") {\n            key = `${key}-${record.priority}-${record.content}`;\n          } else {\n            // For other multi-record types, content is the differentiator\n            key = `${key}-${record.content}`;\n          }\n        }\n\n        acc[key] = record;\n        return acc;\n      },\n      {} as Record<string, DnsRecordProps>\n    );\n\n    const createdRecords = await Promise.all(\n      Object.values(uniqueRecords).map(async (record) => {\n        // First check if record exists\n        const listResponse = await api.get(\n          `/zones/${zoneId}/dns_records?type=${record.type}&name=${record.name}`\n        );\n        if (!listResponse.ok) {\n          throw new Error(\n            `Failed to check existing DNS records: ${listResponse.statusText}`\n          );\n        }\n\n        const listResult = (await listResponse.json()) as CloudflareResponse<\n          CloudflareDnsRecord[]\n        >;\n        const existingRecord = listResult.result[0];\n\n        return createOrUpdateRecord(api, zoneId, record, existingRecord?.id);\n      })\n    );\n\n    return this({\n      zoneId,\n      records: createdRecords,\n    });\n  }\n);\n\n/**\n * Create or update a DNS record\n */\nasync function createOrUpdateRecord(\n  api: CloudflareApi,\n  zoneId: string,\n  record: DnsRecordProps,\n  existingId?: string\n): Promise<DnsRecord> {\n  const payload = getRecordPayload(record);\n\n  const response = await (existingId\n    ? api.put(`/zones/${zoneId}/dns_records/${existingId}`, payload)\n    : api.post(`/zones/${zoneId}/dns_records`, payload));\n\n  if (!response.ok) {\n    const errorBody = await response.text();\n\n    // If it's an update operation and the record doesn't exist, fall back to creation\n    if (existingId && response.status === 404) {\n      try {\n        const createResponse = await api.post(\n          `/zones/${zoneId}/dns_records`,\n          payload\n        );\n        if (createResponse.ok) {\n          return convertCloudflareRecord(\n            ((await createResponse.json()) as any).result,\n            zoneId\n          );\n        }\n      } catch (err) {\n        // Fall through to the original error\n      }\n    }\n\n    throw new Error(\n      `Failed to ${existingId ? \"update\" : \"create\"} DNS record ${record.name}: ${response.statusText}\\nResponse: ${errorBody}`\n    );\n  }\n\n  const result =\n    (await response.json()) as CloudflareResponse<CloudflareDnsRecord>;\n  return convertCloudflareRecord(result.result, zoneId);\n}\n\n/**\n * Get the record payload for create/update operations\n */\nfunction getRecordPayload(record: DnsRecordProps) {\n  return {\n    type: record.type,\n    name: record.name,\n    content: record.content,\n    ttl: record.ttl || 1,\n    proxied: record.proxied || false,\n    priority: record.priority,\n    comment: record.comment,\n  };\n}\n\n/**\n * Convert a Cloudflare DNS record response to our DnsRecord type\n */\nfunction convertCloudflareRecord(\n  record: CloudflareDnsRecord,\n  zoneId: string\n): DnsRecord {\n  return {\n    id: record.id,\n    name: record.name,\n    type: record.type as DnsRecordProps[\"type\"],\n    content: record.content,\n    ttl: record.ttl,\n    proxied: record.proxied,\n    priority: record.priority,\n    comment: record.comment,\n    tags: record.tags,\n    createdAt: new Date(record.created_on).getTime(),\n    modifiedAt: new Date(record.modified_on).getTime(),\n    zoneId,\n  };\n}\n\n```\n\n// alchemy/src/cloudflare/durable-object-namespace.ts\n```ts\n/**\n * Properties for creating a Durable Object Namespace\n */\nexport interface DurableObjectNamespaceInput {\n  className: string;\n  scriptName?: string | undefined;\n  environment?: string | undefined;\n  sqlite?: boolean | undefined;\n  namespaceId?: string | undefined;\n}\n\n/**\n * @example\n * // Create a basic Durable Object namespace for stateful chat rooms\n * const rooms = new DurableObjectNamespace(\"chat-rooms\", {\n *   className: \"ChatRoom\"\n * });\n *\n * @example\n * // Create a Durable Object with SQLite storage for user data\n * const users = new DurableObjectNamespace(\"user-store\", {\n *   className: \"User\",\n *   sqlite: true\n * });\n *\n * @example\n * // Create a Durable Object in production for game state management\n * const game = new DurableObjectNamespace(\"game-state\", {\n *   className: \"GameState\",\n *   scriptName: \"game-worker\",\n *   environment: \"production\"\n * });\n */\nexport class DurableObjectNamespace implements DurableObjectNamespaceInput {\n  public readonly type = \"durable_object_namespace\" as const;\n  // alias for bindingName to be consistent with other bindings\n  public readonly className: string;\n  public readonly scriptName?: string | undefined;\n  public readonly environment?: string | undefined;\n  public readonly sqlite?: boolean | undefined;\n  public readonly namespaceId?: string | undefined;\n\n  constructor(\n    public readonly id: string,\n    input: DurableObjectNamespaceInput,\n  ) {\n    this.className = input.className;\n    this.scriptName = input.scriptName;\n    this.environment = input.environment;\n    this.sqlite = input.sqlite;\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/kv-namespace.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport {\n  CloudflareApi,\n  createCloudflareApi,\n  type CloudflareApiOptions,\n} from \"./api\";\nimport { handleApiError } from \"./api-error\";\n\nexport function isKVNamespace(resource: any): resource is KVNamespace {\n  return (\n    resource && typeof resource === \"object\" && resource.type === \"kv_namespace\"\n  );\n}\n\n/**\n * Properties for creating or updating a KV Namespace\n */\nexport interface KVNamespaceProps extends CloudflareApiOptions {\n  /**\n   * Title of the namespace\n   */\n  title: string;\n\n  /**\n   * KV pairs to store in the namespace\n   * Only used for initial setup or updates\n   */\n  values?: KVPair[];\n}\n\n/**\n * Key-value pair to store in a KV Namespace\n */\nexport interface KVPair {\n  /**\n   * Key name\n   */\n  key: string;\n\n  /**\n   * Value to store (string or JSON object)\n   */\n  value: string | object;\n\n  /**\n   * Optional expiration in seconds from now\n   */\n  expiration?: number;\n\n  /**\n   * Optional expiration timestamp in seconds since epoch\n   */\n  expirationTtl?: number;\n\n  /**\n   * Optional metadata for the key\n   */\n  metadata?: any;\n}\n\n/**\n * Output returned after KV Namespace creation/update\n */\nexport interface KVNamespace\n  extends Resource<\"cloudflare::KVNamespace\">,\n    KVNamespaceProps {\n  type: \"kv_namespace\";\n  /**\n   * The ID of the namespace\n   */\n  namespaceId: string;\n\n  /**\n   * Time at which the namespace was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the namespace was last modified\n   */\n  modifiedAt: number;\n}\n\n/**\n * A Cloudflare KV Namespace is a key-value store that can be used to store data for your application.\n *\n * @see https://developers.cloudflare.com/kv/concepts/kv-namespaces/\n *\n * @example\n * // Create a basic KV namespace for storing user data\n * const users = await KVNamespace(\"users\", {\n *   title: \"user-data\"\n * });\n *\n * @example\n * // Create a KV namespace with initial values and TTL\n * const sessions = await KVNamespace(\"sessions\", {\n *   title: \"user-sessions\",\n *   values: [{\n *     key: \"session_123\",\n *     value: { userId: \"user_456\", role: \"admin\" },\n *     expirationTtl: 3600 // Expires in 1 hour\n *   }]\n * });\n *\n * @example\n * // Create a KV namespace with metadata for caching\n * const assets = await KVNamespace(\"assets\", {\n *   title: \"static-assets\",\n *   values: [{\n *     key: \"main.js\",\n *     value: \"content...\",\n *     metadata: {\n *       contentType: \"application/javascript\",\n *       etag: \"abc123\"\n *     }\n *   }]\n * });\n */\nexport const KVNamespace = Resource(\n  \"cloudflare::KVNamespace\",\n  async function (\n    this: Context<KVNamespace>,\n    id: string,\n    props: KVNamespaceProps\n  ) {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    if (this.phase === \"delete\") {\n      // For delete operations, we need to check if the namespace ID exists in the output\n      const namespaceId = this.output?.namespaceId;\n      if (namespaceId) {\n        await deleteKVNamespace(api, namespaceId);\n      }\n\n      // Return minimal output for deleted state\n      return this.destroy();\n    } else {\n      // For create or update operations\n      // If this.phase is \"update\", we expect this.output to exist\n      let namespaceId =\n        this.phase === \"update\" ? this.output?.namespaceId || \"\" : \"\";\n      let createdAt =\n        this.phase === \"update\"\n          ? this.output?.createdAt || Date.now()\n          : Date.now();\n\n      if (this.phase === \"update\" && namespaceId) {\n        // Can't update a KV namespace title directly, just work with existing ID\n      } else {\n        // TODO: if it already exists, then check the tags to see if we own it and continue\n        const { id } = await createKVNamespace(api, props);\n        createdAt = Date.now();\n        namespaceId = id;\n      }\n\n      await insertKVRecords(api, namespaceId, props);\n\n      return this({\n        type: \"kv_namespace\",\n        namespaceId: namespaceId,\n        title: props.title,\n        values: props.values,\n        createdAt: createdAt,\n        modifiedAt: Date.now(),\n      });\n    }\n  }\n);\n\nexport async function createKVNamespace(\n  api: CloudflareApi,\n  props: KVNamespaceProps\n): Promise<{ id: string }> {\n  const createResponse = await api.post(\n    `/accounts/${api.accountId}/storage/kv/namespaces`,\n    {\n      title: props.title,\n    }\n  );\n\n  if (!createResponse.ok) {\n    await handleApiError(createResponse, \"create\", \"kv_namespace\", props.title);\n  }\n\n  return { id: ((await createResponse.json()) as any).result.id };\n}\n\nexport async function deleteKVNamespace(\n  api: CloudflareApi,\n  namespaceId: string\n) {\n  // Delete KV namespace\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/storage/kv/namespaces/${namespaceId}`\n  );\n\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    await handleApiError(deleteResponse, \"delete\", \"kv_namespace\", namespaceId);\n  }\n}\n\nexport async function insertKVRecords(\n  api: CloudflareApi,\n  namespaceId: string,\n  props: KVNamespaceProps\n) {\n  if (props.values && props.values.length > 0) {\n    // Process KV pairs in batches of 10000 (API limit)\n    const BATCH_SIZE = 10000;\n\n    for (let i = 0; i < props.values.length; i += BATCH_SIZE) {\n      const batch = props.values.slice(i, i + BATCH_SIZE);\n\n      const bulkPayload = batch.map((entry) => {\n        const item: any = {\n          key: entry.key,\n          value:\n            typeof entry.value === \"string\"\n              ? entry.value\n              : JSON.stringify(entry.value),\n        };\n\n        if (entry.expiration) {\n          item.expiration = entry.expiration;\n        }\n\n        if (entry.expirationTtl) {\n          item.expiration_ttl = entry.expirationTtl;\n        }\n\n        if (entry.metadata) {\n          item.metadata = entry.metadata;\n        }\n\n        return item;\n      });\n\n      try {\n        await withExponentialBackoff(\n          async () => {\n            const bulkResponse = await api.put(\n              `/accounts/${api.accountId}/storage/kv/namespaces/${namespaceId}/bulk`,\n              bulkPayload\n            );\n\n            if (!bulkResponse.ok) {\n              const errorData: any = await bulkResponse.json().catch(() => ({\n                errors: [{ message: bulkResponse.statusText }],\n              }));\n              const errorMessage =\n                errorData.errors?.[0]?.message || bulkResponse.statusText;\n\n              // Throw error to trigger retry\n              throw new Error(`Error writing KV batch: ${errorMessage}`);\n            }\n\n            return bulkResponse;\n          },\n          (error) => {\n            // Retry on \"namespace not found\" errors as they're likely propagation delays\n            return error.message?.includes(\"not found\");\n          },\n          5, // 5 retry attempts\n          1000 // Start with 1 second delay\n        );\n      } catch (error: any) {\n        console.warn(error.message);\n      }\n    }\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/permission-groups.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { createCloudflareApi, type CloudflareApiOptions } from \"./api\";\n\n/**\n * Cloudflare permission group as returned by the API\n */\nexport interface PermissionGroup {\n  /**\n   * Unique identifier for the permission group\n   */\n  id: string;\n\n  /**\n   * Human-readable name of the permission group\n   */\n  name: string;\n\n  /**\n   * Scopes included in this permission group\n   */\n  scopes: string[];\n}\n\n/**\n * Response from the Cloudflare permission groups API\n */\ninterface PermissionGroupsResponse {\n  result: PermissionGroup[];\n  success: boolean;\n  errors: any[];\n  messages: any[];\n}\n\n/**\n * All Cloudflare permission groups mapped by name to ID\n *\n * @see https://developers.cloudflare.com/r2/api/tokens/#permissions\n */\nexport type PermissionGroups = Resource<\"cloudflare::PermissionGroups\"> & {\n  /**\n   * Admin Read & Write - Allows create, list, delete buckets and edit bucket configurations\n   * plus list, write, and read object access\n   */\n  \"Workers R2 Storage Write\": PermissionGroup;\n\n  /**\n   * Admin Read only - Allows list buckets and view bucket configuration\n   * plus list and read object access\n   */\n  \"Workers R2 Storage Read\": PermissionGroup;\n\n  /**\n   * Object Read & Write - Allows read, write, and list objects in specific buckets\n   */\n  \"Workers R2 Storage Bucket Item Write\": PermissionGroup;\n\n  /**\n   * Object Read only - Allows read and list objects in specific buckets\n   */\n  \"Workers R2 Storage Bucket Item Read\": PermissionGroup;\n\n  /**\n   * Dynamically discovered permission groups\n   */\n  [name: string]: PermissionGroup;\n};\n\n/**\n * Lists all permission groups available for the Cloudflare account\n * and returns a typed map of permission names to their IDs.\n *\n * This is primarily used when creating API tokens for Cloudflare services like R2.\n *\n * Note: Requires a Cloudflare API Key or Token with account read access.\n * The API token must have permission to read token permission groups.\n * The OAuth token from `wrangler login` is NOT sufficient for this operation.\n *\n * @example\n * // Get all permission groups including those for R2\n * const permissions = await PermissionGroups(\"cloudflare-permissions\");\n *\n * // Use with AccountApiToken to create a token with proper permissions\n * const token = await AccountApiToken(\"r2-token\", {\n *   name: \"R2 Read-Only Token\",\n *   policies: [\n *     {\n *       effect: \"allow\",\n *       resources: {\n *         \"com.cloudflare.edge.r2.bucket.abc123_default_my-bucket\": \"*\"\n *       },\n *       permissionGroups: [\n *         {\n *           id: permissions[\"Workers R2 Storage Bucket Item Read\"]\n *         }\n *       ]\n *     }\n *   ]\n * });\n */\nexport const PermissionGroups = Resource(\n  \"cloudflare::PermissionGroups\",\n  async function (\n    this: Context<PermissionGroups>,\n    id: string,\n    options: CloudflareApiOptions = {}\n  ): Promise<PermissionGroups> {\n    // Only create and update phases are supported\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Initialize API client\n    const api = await createCloudflareApi(options);\n\n    // Fetch permission groups from Cloudflare API\n    const response = await api.get(\n      `/accounts/${api.accountId}/tokens/permission_groups`\n    );\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch permission groups: ${response.statusText}`\n      );\n    }\n\n    const data = (await response.json()) as PermissionGroupsResponse;\n\n    if (!data.success || !data.result) {\n      throw new Error(\n        `API returned error: ${data.errors?.[0]?.message || \"Unknown error\"}`\n      );\n    }\n\n    return this(\n      Object.fromEntries(\n        data.result.map((group) => [group.name, group])\n      ) as PermissionGroups\n    );\n  }\n);\n\n```\n\n// alchemy/src/cloudflare/r2-rest-state-store.ts\n```ts\nimport type { Scope } from \"../scope\";\nimport { deserialize, serialize } from \"../serde\";\nimport type { State, StateStore } from \"../state\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport {\n  type CloudflareApi,\n  type CloudflareApiOptions,\n  createCloudflareApi,\n} from \"./api\";\n\n/**\n * Options for CloudflareR2StateStore\n */\nexport interface CloudflareR2StateStoreOptions extends CloudflareApiOptions {\n  /**\n   * The prefix to use for object keys in the R2 bucket\n   * This allows multiple state stores to use the same R2 bucket\n   */\n  prefix?: string;\n\n  /**\n   * The R2 bucket name to use\n   * Required - the bucket must already exist\n   */\n  bucketName: string;\n}\n\n/**\n * State store implementation using Cloudflare R2 API\n * Uses R2 for immediate consistency compared to KV's eventual consistency\n */\nexport class R2RestStateStore implements StateStore {\n  private api: CloudflareApi;\n  private prefix: string;\n  private bucketName: string;\n  private initialized = false;\n\n  /**\n   * Create a new CloudflareR2StateStore\n   *\n   * @param scope The scope this store belongs to\n   * @param options Options for the state store\n   */\n  constructor(\n    public readonly scope: Scope,\n    private readonly options: CloudflareR2StateStoreOptions\n  ) {\n    // Use the scope's chain to build the prefix, similar to how FileSystemStateStore builds its directory\n    const scopePath = scope.chain.join(\"/\");\n    this.prefix = options.prefix\n      ? `${options.prefix}${scopePath}/`\n      : `alchemy/${scopePath}/`;\n\n    if (!options.bucketName) {\n      throw new Error(\"bucketName is required for CloudflareR2StateStore\");\n    }\n    this.bucketName = options.bucketName;\n\n    // We'll initialize the API in init() to allow for async creation\n    this.api = null as any;\n  }\n\n  /**\n   * Initialize the R2 client\n   */\n  async init(): Promise<void> {\n    if (this.initialized) return;\n\n    // Create Cloudflare API client with automatic account discovery\n    this.api = await createCloudflareApi(this.options);\n\n    this.initialized = true;\n  }\n\n  /**\n   * R2 buckets cannot be deleted programmatically via this method\n   */\n  async deinit(): Promise<void> {\n    // We don't delete the bucket here, only via explicit resource deletion\n  }\n\n  /**\n   * List all resources in the state store\n   */\n  async list(): Promise<string[]> {\n    await this.ensureInitialized();\n\n    // Using pagination to get all objects\n    let keys: string[] = [];\n    let cursor: string | null = null;\n\n    do {\n      const params = new URLSearchParams({\n        prefix: this.prefix,\n        limit: \"1000\",\n      });\n\n      if (cursor) {\n        params.append(\"cursor\", cursor);\n      }\n\n      const listPath = `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects?${params.toString()}`;\n\n      const response = await withExponentialBackoff(\n        async () => {\n          const response = await this.api.get(listPath);\n\n          if (!response.ok) {\n            const errorData: any = await response.json().catch(() => ({\n              errors: [{ message: response.statusText }],\n            }));\n            throw new Error(\n              `Error listing R2 objects: ${errorData.errors?.[0]?.message || response.statusText}`\n            );\n          }\n\n          return response;\n        },\n        // Retry on transient errors\n        (error) =>\n          error.message?.includes(\"502\") ||\n          error.message?.includes(\"503\") ||\n          error.message?.includes(\"timeout\"),\n        5, // 5 retry attempts\n        1000 // Start with 1 second delay\n      );\n\n      const data = (await response.json()) as any;\n\n      // The result structure may be under \"result\" key in Cloudflare's API\n      const result = data.result || data;\n      const objects = result.objects || [];\n\n      // Add keys to our list, removing the prefix and converting from storage format\n      keys = keys.concat(\n        objects.map((obj: any) => {\n          const keyName = obj.key || obj.name;\n          return this.convertKeyFromStorage(keyName.slice(this.prefix.length));\n        })\n      );\n\n      // Update cursor for next page if available\n      cursor =\n        result.truncated || result.cursor_pagination\n          ? result.cursor || null\n          : null;\n    } while (cursor);\n\n    return keys;\n  }\n\n  /**\n   * Count the number of items in the state store\n   */\n  async count(): Promise<number> {\n    const keys = await this.list();\n    return keys.length;\n  }\n\n  /**\n   * Get a state by key\n   *\n   * @param key The key to look up\n   * @returns The state or undefined if not found\n   */\n  async get(key: string): Promise<State | undefined> {\n    await this.ensureInitialized();\n\n    try {\n      const response = await withExponentialBackoff(\n        async () => {\n          const response = await this.api.get(\n            `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects/${this.getObjectKey(key)}`\n          );\n\n          if (!response.ok) {\n            if (response.status === 404) {\n              return response;\n            }\n\n            const errorData: any = await response.json().catch(() => ({\n              errors: [{ message: response.statusText }],\n            }));\n            throw new Error(\n              `Error getting R2 object: ${errorData.errors?.[0]?.message || response.statusText}`\n            );\n          }\n\n          return response;\n        },\n        // Retry on transient errors\n        (error) =>\n          error.message?.includes(\"502\") ||\n          error.message?.includes(\"503\") ||\n          error.message?.includes(\"timeout\"),\n        5, // 5 retry attempts\n        1000 // Start with 1 second delay\n      );\n\n      if (response.status === 404) {\n        return undefined;\n      }\n\n      // Parse and deserialize the state data\n      const rawData = await response.json();\n      const state = (await deserialize(this.scope, rawData)) as State;\n\n      // Create a new state object with proper output\n      return {\n        ...state,\n        output: {\n          ...(state.output || {}),\n          Scope: this.scope,\n        },\n      };\n    } catch (error: any) {\n      if (error.message?.includes(\"404\")) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get multiple states by their keys\n   *\n   * @param ids Array of keys to fetch\n   * @returns Record mapping keys to their states\n   */\n  async getBatch(ids: string[]): Promise<Record<string, State>> {\n    const result: Record<string, State> = {};\n\n    // R2 REST API doesn't have a batch get operation, so we need to make multiple requests\n    const promises = ids.map(async (id) => {\n      const state = await this.get(id);\n      if (state) {\n        result[id] = state;\n      }\n    });\n\n    await Promise.all(promises);\n    return result;\n  }\n\n  /**\n   * Get all states in the store\n   *\n   * @returns Record mapping all keys to their states\n   */\n  async all(): Promise<Record<string, State>> {\n    const keys = await this.list();\n    return this.getBatch(keys);\n  }\n\n  /**\n   * Set a state for a key\n   *\n   * @param key The key to set\n   * @param value The state to store\n   */\n  async set(key: string, value: State): Promise<void> {\n    await this.ensureInitialized();\n\n    const objectKey = this.getObjectKey(key);\n\n    // Serialize the state to handle cyclic structures\n    const serializedData = await serialize(this.scope, value);\n\n    // Using withExponentialBackoff for reliability\n    await withExponentialBackoff(\n      async () => {\n        const response = await this.api.put(\n          `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects/${objectKey}`,\n          serializedData,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n          }\n        );\n\n        if (!response.ok) {\n          const errorData: any = await response.json().catch(() => ({\n            errors: [{ message: response.statusText }],\n          }));\n          throw new Error(\n            `Error writing to R2: ${errorData.errors?.[0]?.message || response.statusText}`\n          );\n        }\n\n        return response;\n      },\n      // Retry on transient errors\n      (error) =>\n        error.message?.includes(\"503\") || error.message?.includes(\"timeout\"),\n      5, // 5 retry attempts\n      1000 // Start with 1 second delay\n    );\n  }\n\n  /**\n   * Delete a state by key\n   *\n   * @param key The key to delete\n   */\n  async delete(key: string): Promise<void> {\n    await this.ensureInitialized();\n\n    await withExponentialBackoff(\n      async () => {\n        const response = await this.api.delete(\n          `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects/${this.getObjectKey(key)}`\n        );\n\n        if (!response.ok && response.status !== 404) {\n          const errorData: any = await response.json().catch(() => ({\n            errors: [{ message: response.statusText }],\n          }));\n          throw new Error(\n            `Error deleting from R2: ${errorData.errors?.[0]?.message || response.statusText}`\n          );\n        }\n\n        return response;\n      },\n      // Retry on transient errors\n      (error) =>\n        error.message?.includes(\"502\") ||\n        error.message?.includes(\"503\") ||\n        error.message?.includes(\"timeout\"),\n      5, // 5 retry attempts\n      1000 // Start with 1 second delay\n    );\n  }\n\n  /**\n   * Convert key for storage by replacing slashes with colons\n   * since R2 treats slashes as directory separators\n   *\n   * @param key The original key\n   * @returns Key with slashes replaced by colons\n   */\n  private convertKeyForStorage(key: string): string {\n    return key.replaceAll(\"/\", \":\");\n  }\n\n  /**\n   * Convert key from storage by replacing colons with slashes\n   *\n   * @param key The storage key\n   * @returns Key with colons replaced by slashes\n   */\n  private convertKeyFromStorage(key: string): string {\n    return key.replaceAll(\":\", \"/\");\n  }\n\n  /**\n   * Get the full object key for storage\n   *\n   * @param key The original key\n   * @returns The key with prefix for use in the R2 bucket\n   */\n  private getObjectKey(key: string): string {\n    return `${this.prefix}${this.convertKeyForStorage(key)}`;\n  }\n\n  /**\n   * Ensure the store is initialized before operations\n   */\n  private async ensureInitialized(): Promise<void> {\n    if (!this.initialized) {\n      await this.init();\n    }\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/response.ts\n```ts\n/**\n * Cloudflare API response format\n */\nexport interface CloudflareResponse<T = unknown> {\n  result: T;\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n}\n\n```\n\n// alchemy/src/cloudflare/types.ts\n```ts\n/**\n * Cloudflare API response format\n */\nexport interface CloudflareApiResponse<T> {\n  /**\n   * API response result\n   */\n  result: T;\n\n  /**\n   * Success status\n   */\n  success: boolean;\n\n  /**\n   * Error details if success is false\n   */\n  errors: CloudflareApiError[];\n\n  /**\n   * Response messages\n   */\n  messages: string[];\n\n  /**\n   * Result information (typically for paginated results)\n   */\n  result_info?: {\n    page: number;\n    per_page: number;\n    total_pages: number;\n    count: number;\n    total_count: number;\n  };\n}\n\n/**\n * Cloudflare API error format\n */\nexport interface CloudflareApiError {\n  /**\n   * Error code\n   */\n  code: number;\n\n  /**\n   * Error message\n   */\n  message: string;\n}\n\n/**\n * Helper to extract and handle Cloudflare API errors\n *\n * @param response Fetch response object\n * @returns Formatted error message\n */\nexport async function extractCloudflareError(\n  response: Response,\n): Promise<string> {\n  try {\n    const data = (await response.json()) as CloudflareApiResponse<any>;\n    if (data.errors && data.errors.length > 0) {\n      return data.errors.map((e) => `Error ${e.code}: ${e.message}`).join(\", \");\n    } else {\n      return `HTTP ${response.status}: ${response.statusText}`;\n    }\n  } catch (e) {\n    return `HTTP ${response.status}: ${response.statusText}`;\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/worker-metadata.ts\n```ts\n/**\n * Metadata returned by Cloudflare API for a worker script\n */\nexport interface WorkerScriptMetadata {\n  /**\n   * Worker ID\n   */\n  id: string;\n\n  /**\n   * Default environment information\n   */\n  default_environment?: WorkerDefaultEnvironment;\n\n  /**\n   * Worker creation timestamp\n   */\n  created_on: string;\n\n  /**\n   * Worker last modification timestamp\n   */\n  modified_on: string;\n\n  /**\n   * Worker usage model\n   */\n  usage_model: string;\n\n  /**\n   * Worker environments\n   */\n  environments?: WorkerEnvironment[];\n}\n\n/**\n * Worker script information\n */\nexport interface WorkerScriptInfo {\n  /**\n   * Script creation timestamp\n   */\n  created_on: string;\n\n  /**\n   * Script last modification timestamp\n   */\n  modified_on: string;\n\n  /**\n   * Script ID\n   */\n  id: string;\n\n  /**\n   * Script tag\n   */\n  tag: string;\n\n  /**\n   * Script tags\n   */\n  tags: string[];\n\n  /**\n   * Deployment ID\n   */\n  deployment_id: string;\n\n  /**\n   * Tail consumers\n   */\n  tail_consumers: any;\n\n  /**\n   * Whether logpush is enabled\n   */\n  logpush: boolean;\n\n  /**\n   * Observability settings\n   */\n  observability: {\n    /**\n     * Whether observability is enabled\n     */\n    enabled: boolean;\n\n    /**\n     * Head sampling rate\n     */\n    head_sampling_rate: number | null;\n  };\n\n  /**\n   * Whether the script has assets\n   */\n  has_assets: boolean;\n\n  /**\n   * Whether the script has modules\n   */\n  has_modules: boolean;\n\n  /**\n   * Script etag\n   */\n  etag: string;\n\n  /**\n   * Script handlers\n   */\n  handlers: string[];\n\n  /**\n   * Where the script was last deployed from\n   */\n  last_deployed_from: string;\n\n  /**\n   * Script usage model\n   */\n  usage_model: string;\n}\n\n/**\n * Worker environment information\n */\nexport interface WorkerEnvironment {\n  /**\n   * Environment name\n   */\n  environment: string;\n\n  /**\n   * Environment creation timestamp\n   */\n  created_on: string;\n\n  /**\n   * Environment last modification timestamp\n   */\n  modified_on: string;\n}\n\n/**\n * Default environment with script information\n */\nexport interface WorkerDefaultEnvironment extends WorkerEnvironment {\n  /**\n   * Script information\n   */\n  script: WorkerScriptInfo;\n}\n\n```\n\n// alchemy/src/cloudflare/worker-migration.ts\n```ts\nexport type WorkerMigrations = SingleStepMigration | MultiStepMigration;\n\nexport function isSingleStepMigration(\n  migration: WorkerMigrations,\n): migration is SingleStepMigration {\n  return (\n    \"deleted_classes\" in migration ||\n    \"new_classes\" in migration ||\n    \"new_sqlite_classes\" in migration ||\n    \"renamed_classes\" in migration ||\n    \"transferred_classes\" in migration\n  );\n}\n\nexport interface SingleStepMigration {\n  /**\n   * A list of classes to delete Durable Object namespaces from\n   */\n  deleted_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces from\n   */\n  new_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces with SQLite from\n   */\n  new_sqlite_classes?: string[];\n\n  /**\n   * Tag to set as the latest migration tag\n   */\n  new_tag?: string;\n\n  /**\n   * Tag used to verify against the latest migration tag for this Worker.\n   * If they don't match, the upload is rejected.\n   */\n  old_tag?: string;\n\n  /**\n   * A list of classes with Durable Object namespaces that were renamed\n   */\n  renamed_classes?: RenamedClass[];\n\n  /**\n   * A list of transfers for Durable Object namespaces from a different Worker\n   * and class to a class defined in this Worker\n   */\n  transferred_classes?: TransferredClass[];\n}\n\n/**\n * Represents a renamed class in a Durable Object migration\n */\nexport interface RenamedClass {\n  /**\n   * Original class name\n   */\n  from: string;\n\n  /**\n   * New class name\n   */\n  to: string;\n}\n\n/**\n * Represents a transferred class in a Durable Object migration\n */\nexport interface TransferredClass {\n  /**\n   * Original class name\n   */\n  from: string;\n\n  /**\n   * Original script name\n   */\n  from_script: string;\n\n  /**\n   * New class name in this Worker\n   */\n  to: string;\n}\n\nexport function isMultiStepMigration(\n  migration: WorkerMigrations,\n): migration is MultiStepMigration {\n  return \"steps\" in migration;\n}\n\n/**\n * Represents a multi-step migration for Durable Objects\n */\nexport interface MultiStepMigration {\n  /**\n   * Tag to set as the latest migration tag\n   */\n  new_tag?: string;\n\n  /**\n   * Tag used to verify against the latest migration tag for this Worker.\n   * If they don't match, the upload is rejected.\n   */\n  old_tag?: string;\n\n  /**\n   * Migrations to apply in order\n   */\n  steps: MigrationStep[];\n}\n\n/**\n * Represents a single step in a Durable Object migration\n */\nexport interface MigrationStep {\n  /**\n   * A list of classes to delete Durable Object namespaces from\n   */\n  deleted_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces from\n   */\n  new_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces with SQLite from\n   */\n  new_sqlite_classes?: string[];\n\n  /**\n   * A list of classes with Durable Object namespaces that were renamed\n   */\n  renamed_classes?: RenamedClass[];\n\n  /**\n   * A list of transfers for Durable Object namespaces from a different Worker\n   * and class to a class defined in this Worker\n   */\n  transferred_classes?: TransferredClass[];\n}\n\n```\n\n// alchemy/src/cloudflare/worker.ts\n```ts\nimport * as crypto from \"crypto\";\nimport * as fs from \"fs/promises\";\nimport type { Context } from \"../context\";\nimport { Bundle, type BundleProps } from \"../esbuild/bundle\";\nimport { Resource } from \"../resource\";\nimport { isSecret } from \"../secret\";\nimport { getContentType } from \"../util/content-type\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport { slugify } from \"../util/slugify\";\nimport {\n  type CloudflareApi,\n  type CloudflareApiOptions,\n  createCloudflareApi,\n} from \"./api\";\nimport type { Assets } from \"./assets\";\nimport {\n  type Bindings,\n  type WorkerBindingSpec,\n  isAssets,\n  isDurableObjectNamespace,\n} from \"./bindings\";\nimport type { Bound } from \"./bound\";\nimport type { DurableObjectNamespace } from \"./durable-object-namespace\";\nimport { isKVNamespace } from \"./kv-namespace\";\nimport type { WorkerScriptMetadata } from \"./worker-metadata\";\nimport type { SingleStepMigration } from \"./worker-migration\";\n\n/**\n * Properties for creating or updating a Worker\n */\nexport interface WorkerProps<B extends Bindings = Bindings>\n  extends CloudflareApiOptions {\n  /**\n   * The worker script content (JavaScript or WASM)\n   * One of script, entryPoint, or bundle must be provided\n   */\n  script?: string;\n\n  /**\n   * Path to the entry point file\n   * Will be bundled using esbuild\n   * One of script, entryPoint, or bundle must be provided\n   */\n  entrypoint?: string;\n\n  /**\n   * Bundle options when using entryPoint\n   * Ignored if bundle is provided\n   */\n  bundle?: Omit<BundleProps, \"entryPoint\">;\n\n  /**\n   * Module format for the worker script\n   * 'esm' - ECMAScript modules (default)\n   * 'cjs' - CommonJS modules\n   * @default 'esm'\n   */\n  format?: \"esm\" | \"cjs\";\n\n  /**\n   * Name for the worker\n   * This is mandatory - must be explicitly specified\n   */\n  name: string;\n\n  /**\n   * Bindings to attach to the worker\n   */\n  bindings?: B;\n\n  /**\n   * Environment variables to attach to the worker\n   * These will be converted to plain_text bindings\n   */\n  env?: {\n    [key: string]: string;\n  };\n\n  /**\n   * Whether to enable a workers.dev URL for this worker\n   * If true, the worker will be available at {name}.{subdomain}.workers.dev\n   * @default false\n   */\n  url?: boolean;\n\n  /**\n   * Observability configuration for the worker\n   * Controls whether worker logs are enabled\n   * @default { enabled: true }\n   */\n  observability?: {\n    /**\n     * Whether to enable worker logs\n     * @default true\n     */\n    enabled?: boolean;\n  };\n\n  /**\n   * Migrations to apply to the worker\n   */\n  migrations?: SingleStepMigration;\n\n  /**\n   * Whether to adopt the Worker if it already exists when creating\n   */\n  adopt?: boolean;\n}\n\n/**\n * Output returned after Worker creation/update\n */\nexport interface Worker<B extends Bindings = Bindings>\n  extends Resource<\"cloudflare::Worker\">,\n    Omit<WorkerProps<B>, \"url\"> {\n  type: \"service\";\n\n  /**\n   * The ID of the worker\n   */\n  id: string;\n\n  /**\n   * Time at which the worker was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the worker was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * The worker's URL if enabled\n   * Format: {name}.{subdomain}.workers.dev\n   */\n  url?: string;\n\n  /**\n   * The bindings that were created\n   */\n  bindings: B | undefined;\n\n  // phantom property (for typeof myWorker.Env)\n  Env: {\n    [bindingName in keyof B]: Bound<B[bindingName]>;\n  };\n}\n\n/**\n * A Cloudflare Worker is a serverless function that can be deployed to the Cloudflare network.\n *\n * @example\n * // Create a basic HTTP handler worker with custom domain routing\n * // and workers.dev URL:\n * const api = await Worker(\"api\", {\n *   name: \"api-worker\",\n *   entrypoint: \"./src/api.ts\",\n *   routes: [\"api.example.com/*\"],\n *   url: true\n * });\n *\n * @example\n * // Create a real-time chat worker using Durable Objects\n * // for state management:\n * const chatRooms = new DurableObjectNamespace(\"chat-rooms\");\n * const userStore = new DurableObjectNamespace(\"user-store\");\n *\n * const chat = await Worker(\"chat\", {\n *   name: \"chat-worker\",\n *   entrypoint: \"./src/chat.ts\",\n *   bindings: {\n *     ROOMS: chatRooms,\n *     USERS: userStore\n *   },\n * });\n *\n * @example\n * // Create a worker with KV namespace for caching and data storage:\n * const cache = await KVNamespace(\"cache-store\");\n * const settings = await KVNamespace(\"user-settings\");\n *\n * const cacheWorker = await Worker(\"cache\", {\n *   name: \"cache-worker\",\n *   entrypoint: \"./src/cache.ts\",\n *   bindings: {\n *     CACHE: cache,\n *     SETTINGS: settings\n *   }\n * });\n *\n * @example\n * // Create a worker with R2 bucket for object storage:\n * const uploads = await R2Bucket(\"uploads\", {\n *   name: \"user-uploads\"\n * });\n * const assets = await R2Bucket(\"assets\", {\n *   name: \"static-assets\",\n *   allowPublicAccess: true\n * });\n *\n * const storageWorker = await Worker(\"storage\", {\n *   name: \"storage-worker\",\n *   entrypoint: \"./src/storage.ts\",\n *   bindings: {\n *     UPLOADS: uploads,\n *     ASSETS: assets\n *   }\n * });\n *\n * @example\n * // Create a worker with static assets:\n * const staticAssets = await Assets(\"static\", {\n *   path: \"./src/assets\"\n * });\n *\n * const frontendWorker = await Worker(\"frontend\", {\n *   name: \"frontend-worker\",\n *   entrypoint: \"./src/worker.ts\",\n *   bindings: {\n *     ASSETS: staticAssets\n *   }\n * });\n *\n * @see https://developers.cloudflare.com/workers/\n */\nexport const Worker = Resource(\n  \"cloudflare::Worker\",\n  {\n    alwaysUpdate: true,\n  },\n  async function <const B extends Bindings>(\n    this: Context<Worker<NoInfer<B>>>,\n    id: string,\n    props: WorkerProps<B>\n  ): Promise<Worker<B>> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    // Use the provided name\n    const workerName = props.name;\n\n    // Validate input - we need either script, entryPoint, or bundle\n    if (!props.script && !props.entrypoint) {\n      throw new Error(\"One of script or entryPoint must be provided\");\n    }\n\n    if (this.phase === \"delete\") {\n      await deleteWorker(this, api, workerName);\n      return this.destroy();\n    } else if (this.phase === \"create\") {\n      if (!props.adopt) {\n        await assertWorkerDoesNotExist(this, api, workerName);\n      }\n    }\n\n    const oldBindings = await this.get<Bindings>(\"bindings\");\n\n    // Get the script content - either from props.script, or by bundling\n    const scriptContent = props.script ?? (await bundleWorkerScript(props));\n\n    // Find any assets bindings\n    const assetsBindings: { name: string; assets: Assets }[] = [];\n    if (props.bindings) {\n      for (const [bindingName, binding] of Object.entries(props.bindings)) {\n        if (isAssets(binding)) {\n          assetsBindings.push({ name: bindingName, assets: binding });\n        }\n      }\n    }\n\n    // Upload any assets and get completion tokens\n    let assetUploadResult: AssetUploadResult | undefined;\n    if (assetsBindings.length > 0) {\n      // We'll use the first asset binding for now\n      // In the future, we might want to support multiple asset bindings\n      const assetBinding = assetsBindings[0];\n\n      // Upload the assets and get the completion token\n      assetUploadResult = await uploadAssets(\n        api,\n        workerName,\n        assetBinding.assets\n      );\n    }\n\n    // Prepare metadata with bindings\n    const scriptMetadata = await prepareWorkerMetadata(\n      this,\n      oldBindings,\n      props,\n      assetUploadResult\n    );\n\n    // Upload the worker script\n    await putWorker(api, workerName, scriptContent, scriptMetadata);\n\n    // TODO: it is less than ideal that this can fail, resulting in state problem\n    await this.set(\"bindings\", props.bindings);\n\n    // Handle worker URL if requested\n    const workerUrl = await configureURL(\n      this,\n      api,\n      workerName,\n      props.url ?? false\n    );\n\n    // Get current timestamp\n    const now = Date.now();\n\n    // Construct the output\n    return this({\n      type: \"service\",\n      id,\n      name: workerName,\n      script: scriptContent,\n      format: props.format || \"esm\", // Include format in the output\n      bindings: props.bindings ?? ({} as B),\n      env: props.env,\n      observability: scriptMetadata.observability,\n      createdAt: now,\n      updatedAt: now,\n      url: workerUrl,\n      // phantom property\n      Env: undefined!,\n    });\n  }\n);\n\nasync function deleteWorker<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  api: CloudflareApi,\n  workerName: string\n) {\n  // Delete worker\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/workers/scripts/${workerName}`\n  );\n\n  // Check for success (2xx status code)\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    const errorData: any = await deleteResponse\n      .json()\n      .catch(() => ({ errors: [{ message: deleteResponse.statusText }] }));\n    console.error(\n      \"Error deleting worker:\",\n      errorData.errors?.[0]?.message || deleteResponse.statusText\n    );\n  }\n\n  // Disable the URL if it was enabled\n  if (ctx.output?.url) {\n    try {\n      await api.post(\n        `/accounts/${api.accountId}/workers/scripts/${workerName}/subdomain`,\n        JSON.stringify({ enabled: false }),\n        {\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    } catch (error) {\n      console.warn(\"Failed to disable worker URL during deletion:\", error);\n    }\n  }\n\n  // Return minimal output for deleted state\n  return;\n}\n\nasync function putWorker(\n  api: CloudflareApi,\n  workerName: string,\n  scriptContent: string,\n  scriptMetadata: WorkerMetadata\n) {\n  return withExponentialBackoff(\n    async () => {\n      const scriptName =\n        scriptMetadata.main_module ?? scriptMetadata.body_part!;\n\n      // Create FormData for the upload\n      const formData = new FormData();\n\n      // Add the actual script content as a named file part\n      formData.append(\n        scriptName,\n        new Blob([scriptContent], {\n          type: scriptMetadata.main_module\n            ? \"application/javascript+module\"\n            : \"application/javascript\",\n        }),\n        scriptName\n      );\n\n      // Add metadata as JSON\n      formData.append(\n        \"metadata\",\n        new Blob([JSON.stringify(scriptMetadata)], {\n          type: \"application/json\",\n        })\n      );\n\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n\n      // Upload worker script with bindings\n      const uploadResponse = await api.put(\n        `/accounts/${api.accountId}/workers/scripts/${workerName}`,\n        formData,\n        {\n          headers: {\n            \"Content-Type\": \"multipart/form-data\",\n          },\n        }\n      );\n\n      // Check if the upload was successful\n      if (!uploadResponse.ok) {\n        const errorData: any = await uploadResponse\n          .json()\n          .catch(() => ({ errors: [{ message: uploadResponse.statusText }] }));\n\n        const errorMessage = `Error (HTTP ${uploadResponse.status}) uploading worker script '${workerName}': ${errorData.errors?.[0]?.message || uploadResponse.statusText}`;\n\n        if (\n          uploadResponse.status === 400 &&\n          errorMessage.includes(\"not found\")\n        ) {\n          throw new NotFoundError(errorMessage);\n        }\n        throw new Error(errorMessage);\n      }\n\n      return formData;\n    },\n    (err) => err instanceof NotFoundError,\n    10,\n    100\n  );\n}\n\nclass NotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"NotFoundError\";\n  }\n}\n\ninterface WorkerMetadata {\n  bindings: WorkerBindingSpec[];\n  observability: {\n    enabled: boolean;\n  };\n  migrations?: SingleStepMigration;\n  main_module?: string;\n  body_part?: string;\n  tags?: string[];\n  assets?: {\n    jwt?: string;\n    keep_assets?: boolean;\n    config?: {\n      html_handling?: \"auto-trailing-slash\" | \"none\";\n      not_found_handling?: \"none\" | \"fall-through\";\n    };\n  };\n}\n\ninterface AssetUploadResult {\n  completionToken: string;\n  assetConfig?: {\n    html_handling?: \"auto-trailing-slash\" | \"none\";\n    not_found_handling?: \"none\" | \"fall-through\";\n  };\n}\n\nasync function prepareWorkerMetadata<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  oldBindings: Bindings | undefined,\n  props: WorkerProps,\n  assetUploadResult?: AssetUploadResult\n): Promise<WorkerMetadata> {\n  // Prepare metadata with bindings\n  const meta: WorkerMetadata = {\n    bindings: [],\n    observability: {\n      enabled: props.observability?.enabled !== false,\n    },\n    // TODO(sam): base64 encode instead? 0 collision risk vs readability.\n    tags: [`alchemy:id:${slugify(ctx.fqn)}`],\n    migrations: {\n      new_classes: props.migrations?.new_classes ?? [],\n      deleted_classes: props.migrations?.deleted_classes ?? [],\n      renamed_classes: props.migrations?.renamed_classes ?? [],\n      transferred_classes: props.migrations?.transferred_classes ?? [],\n      new_sqlite_classes: props.migrations?.new_sqlite_classes ?? [],\n    },\n  };\n\n  // If we have asset upload results, add them to the metadata\n  if (assetUploadResult) {\n    meta.assets = {\n      jwt: assetUploadResult.completionToken,\n    };\n\n    if (assetUploadResult.assetConfig) {\n      meta.assets.config = assetUploadResult.assetConfig;\n    }\n  }\n\n  const bindings = (props.bindings ?? {}) as Bindings;\n\n  // Convert bindings to the format expected by the API\n  for (const [bindingName, binding] of Object.entries(bindings)) {\n    // Create a copy of the binding to avoid modifying the original\n\n    if (isKVNamespace(binding)) {\n      meta.bindings.push({\n        type: \"kv_namespace\",\n        name: bindingName,\n        namespace_id: binding.namespaceId,\n      });\n    } else if (typeof binding === \"string\") {\n      meta.bindings.push({\n        type: \"plain_text\",\n        name: bindingName,\n        text: binding,\n      });\n    } else if (binding.type === \"service\") {\n      meta.bindings.push({\n        type: \"service\",\n        name: bindingName,\n        service: binding.id,\n      });\n    } else if (binding.type === \"durable_object_namespace\") {\n      const stableId = binding.id;\n      const className = binding.className;\n\n      meta.bindings.push({\n        type: \"durable_object_namespace\",\n        name: bindingName,\n        class_name: className,\n        script_name: binding.scriptName,\n        environment: binding.environment,\n        namespace_id: binding.namespaceId,\n      });\n\n      const oldBinding: DurableObjectNamespace | undefined = Object.values(\n        oldBindings ?? {}\n      )\n        ?.filter(isDurableObjectNamespace)\n        ?.find((b) => b.id === stableId);\n\n      if (!oldBinding) {\n        if (binding.sqlite) {\n          meta.migrations!.new_sqlite_classes!.push(className);\n        } else {\n          meta.migrations!.new_classes!.push(className);\n        }\n      } else if (oldBinding.className !== className) {\n        meta.migrations!.renamed_classes!.push({\n          from: oldBinding.className,\n          to: className,\n        });\n      }\n    } else if (binding.type === \"r2_bucket\") {\n      meta.bindings.push({\n        type: \"r2_bucket\",\n        name: bindingName,\n        bucket_name: binding.name,\n      });\n    } else if (isAssets(binding)) {\n      meta.bindings.push({\n        type: \"assets\",\n        name: bindingName,\n      });\n    } else if (isSecret(binding)) {\n      meta.bindings.push({\n        type: \"secret_text\",\n        name: bindingName,\n        text: binding.unencrypted,\n      });\n    } else {\n      // @ts-expect-error - we should never reach here\n      throw new Error(`Unsupported binding type: ${binding.type}`);\n    }\n  }\n\n  // Convert env variables to plain_text bindings\n  if (props.env) {\n    for (const [key, value] of Object.entries(props.env)) {\n      meta.bindings.push({\n        name: key,\n        type: \"plain_text\",\n        text: value,\n      });\n    }\n  }\n\n  // Determine if we're using ESM or service worker format\n  const isEsModule = props.format !== \"cjs\"; // Default to ESM unless CJS is specified\n  const scriptName = isEsModule ? \"worker.js\" : \"script\";\n\n  if (isEsModule) {\n    // For ES modules format\n    meta.main_module = scriptName;\n  } else {\n    // For service worker format (CJS)\n    meta.body_part = scriptName;\n  }\n  return meta;\n}\n\nasync function assertWorkerDoesNotExist<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  api: CloudflareApi,\n  workerName: string\n) {\n  const response = await api.get(\n    `/accounts/${api.accountId}/workers/scripts/${workerName}`\n  );\n  if (response.status === 404) {\n    return true;\n  }\n  if (response.status === 200) {\n    const metadata = await getWorkerScriptMetadata(api, workerName);\n\n    if (!metadata) {\n      throw new Error(\n        `Worker exists but failed to fetch metadata: ${response.status} ${response.statusText}`\n      );\n    }\n\n    if (\n      metadata.default_environment?.script.tags.includes(\n        `alchemy:id:${slugify(ctx.fqn)}`\n      )\n    ) {\n      return true;\n    }\n\n    throw new Error(\n      `Worker with name '${workerName}' already exists. Please use a unique name.`\n    );\n  } else {\n    throw new Error(\n      `Error checking if worker exists: ${response.status} ${response.statusText} ${await response.text()}`\n    );\n  }\n}\n\nasync function bundleWorkerScript<B extends Bindings>(props: WorkerProps) {\n  // Get the script content - either from props.script, or by bundling\n\n  // Create and use a Bundle resource with worker-optimized configuration\n  const defaultBundleOptions: Omit<BundleProps, \"entryPoint\"> = {\n    format: props.format === \"cjs\" ? \"cjs\" : \"esm\", // Use the specified format or default to ESM\n    target: \"es2020\",\n    platform: \"browser\",\n    minify: true,\n    options: {\n      keepNames: true, // Important for Durable Object classes\n    },\n  };\n\n  // Merge with user-provided options\n  const bundleOptions = {\n    ...defaultBundleOptions,\n    ...(props.bundle || {}),\n  };\n\n  // Create the bundle\n  const bundle = await Bundle(\"bundle\", {\n    entryPoint: props.entrypoint!,\n    ...bundleOptions,\n    external: [...(bundleOptions.external ?? []), \"cloudflare:workers\"],\n  });\n\n  try {\n    return await fs.readFile(bundle.path, \"utf-8\");\n  } catch (error) {\n    console.error(\"Error reading bundle:\", error);\n    throw new Error(\"Error reading bundle\");\n  }\n}\n\nasync function configureURL<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  api: CloudflareApi,\n  workerName: string,\n  url: boolean\n) {\n  let workerUrl;\n  if (url) {\n    // Enable the workers.dev subdomain for this worker\n    await api.post(\n      `/accounts/${api.accountId}/workers/scripts/${workerName}/subdomain`,\n      { enabled: true, previews_enabled: true },\n      {\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n\n    // Get the account's workers.dev subdomain\n    const subdomainResponse = await api.get(\n      `/accounts/${api.accountId}/workers/subdomain`\n    );\n\n    if (!subdomainResponse.ok) {\n      throw new Error(\n        `Could not fetch workers.dev subdomain: ${subdomainResponse.status} ${subdomainResponse.statusText}`\n      );\n    }\n    const subdomainData: {\n      result: {\n        subdomain: string;\n      };\n    } = await subdomainResponse.json();\n    const subdomain = subdomainData.result?.subdomain;\n\n    if (subdomain) {\n      workerUrl = `https://${workerName}.${subdomain}.workers.dev`;\n\n      // Add a delay when the subdomain is first created.\n      // This is to prevent an issue where a negative cache-hit\n      // causes the subdomain to be unavailable for 30 seconds.\n      if (ctx.phase === \"create\" || !ctx.output?.url) {\n        await new Promise((resolve) => setTimeout(resolve, 3000));\n      }\n    }\n  } else if (url === false && ctx.output?.url) {\n    // Explicitly disable URL if it was previously enabled\n    const response = await api.post(\n      `/accounts/${api.accountId}/workers/scripts/${workerName}/subdomain`,\n      JSON.stringify({ enabled: false }),\n      {\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n    if (!response.ok) {\n      throw new Error(\n        `Failed to disable worker URL: ${response.status} ${response.statusText}`\n      );\n    }\n  }\n  return workerUrl;\n}\n\nasync function getWorkerScriptMetadata(\n  api: CloudflareApi,\n  workerName: string\n): Promise<WorkerScriptMetadata | undefined> {\n  const response = await api.get(\n    `/accounts/${api.accountId}/workers/services/${workerName}`\n  );\n  if (response.status === 404) {\n    return undefined;\n  }\n  if (!response.ok) {\n    throw new Error(\n      `Error getting worker script metadata: ${response.status} ${response.statusText}`\n    );\n  }\n  return ((await response.json()) as any).result as WorkerScriptMetadata;\n}\n\nasync function getWorkerBindings(\n  api: CloudflareApi,\n  workerName: string,\n  environment = \"production\"\n) {\n  const response = await api.get(\n    `/accounts/${api.accountId}/workers/services/${workerName}/environments/${environment}/bindings`,\n    {\n      headers: {\n        Authorization: `Bearer ${process.env.CLOUDFLARE_API_TOKEN}`,\n        \"Content-Type\": \"application/json\",\n      },\n    }\n  );\n\n  if (response.status === 404) {\n    return undefined;\n  }\n\n  if (!response.ok) {\n    throw new Error(\n      `Failed to fetch bindings: ${response.status} ${response.statusText}`\n    );\n  }\n\n  const data: any = await response.json();\n\n  return data.result;\n}\n\n/**\n * Interface for a file's metadata to be uploaded\n */\ninterface FileMetadata {\n  hash: string;\n  size: number;\n}\n\n/**\n * Response from the assets upload session API\n */\ninterface UploadSessionResponse {\n  result: {\n    jwt: string;\n    buckets: string[][];\n  };\n  success: boolean;\n  errors: any[];\n  messages: any[];\n}\n\n/**\n * Response from the file upload API\n */\ninterface UploadResponse {\n  result: {\n    jwt: string;\n    buckets?: string[][];\n  };\n  success: boolean;\n  errors: any[];\n  messages: any[];\n}\n\n/**\n * Uploads assets to Cloudflare and returns a completion token\n *\n * @param api CloudflareApi instance\n * @param workerName Name of the worker\n * @param assets Assets resource containing files to upload\n * @returns Completion token for the assets upload\n */\nasync function uploadAssets(\n  api: CloudflareApi,\n  workerName: string,\n  assets: Assets\n): Promise<AssetUploadResult> {\n  // Generate the file manifest\n  const fileMetadata: Record<string, FileMetadata> = {};\n\n  // Process each file in the assets\n  for (const file of assets.files) {\n    const { hash, size } = await calculateFileMetadata(file.filePath);\n    // Use the relative path as the key, ensuring it starts with a slash\n    const key = file.path.startsWith(\"/\") ? file.path : `/${file.path}`;\n    fileMetadata[key] = { hash, size };\n  }\n\n  // Start the upload session\n  const uploadSessionUrl = `/accounts/${api.accountId}/workers/scripts/${workerName}/assets-upload-session`;\n  const uploadSessionResponse = await api.post(\n    uploadSessionUrl,\n    JSON.stringify({ manifest: fileMetadata }),\n    {\n      headers: { \"Content-Type\": \"application/json\" },\n    }\n  );\n\n  if (!uploadSessionResponse.ok) {\n    throw new Error(\n      `Failed to start assets upload session: ${uploadSessionResponse.status} ${uploadSessionResponse.statusText}`\n    );\n  }\n\n  const sessionData =\n    (await uploadSessionResponse.json()) as UploadSessionResponse;\n\n  // If there are no buckets, assets are already uploaded or empty\n  if (!sessionData.result.buckets || sessionData.result.buckets.length === 0) {\n    return { completionToken: sessionData.result.jwt };\n  }\n\n  // Upload the files in batches as specified by the API\n  let completionToken = sessionData.result.jwt;\n  const buckets = sessionData.result.buckets;\n\n  // Process each bucket of files\n  for (const bucket of buckets) {\n    const formData = new FormData();\n\n    let totalBytes = 0;\n\n    // Add each file in the bucket to the form\n    for (const fileHash of bucket) {\n      // Find the file with this hash\n      const file = assets.files.find((f) => {\n        const filePath = f.path.startsWith(\"/\") ? f.path : `/${f.path}`;\n        return fileMetadata[filePath]?.hash === fileHash;\n      });\n\n      if (!file) {\n        throw new Error(`Could not find file with hash ${fileHash}`);\n      }\n\n      // Read the file content\n      const fileContent = await fs.readFile(file.filePath);\n\n      // Convert to base64 as required by the API when using base64=true\n      const base64Content = fileContent.toString(\"base64\");\n\n      // Add the file to the form with the hash as the key and set the correct content type\n      const blob = new Blob([base64Content], {\n        type: getContentType(file.filePath),\n      });\n      totalBytes += blob.size;\n      formData.append(fileHash, blob, fileHash);\n    }\n\n    // Upload this batch of files\n    const uploadResponse = await api.post(\n      `/accounts/${api.accountId}/workers/assets/upload?base64=true`,\n      formData,\n      {\n        headers: {\n          Authorization: `Bearer ${completionToken}`,\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      }\n    );\n\n    if (!uploadResponse.ok) {\n      throw new Error(\n        `Failed to upload asset files: ${uploadResponse.status} ${uploadResponse.statusText}`\n      );\n    }\n\n    const uploadData = (await uploadResponse.json()) as UploadResponse;\n    // Update the completion token for the next batch\n    if (uploadData.result.jwt) {\n      completionToken = uploadData.result.jwt;\n    }\n  }\n\n  // Return the final completion token\n  return {\n    completionToken,\n    assetConfig: {\n      html_handling: \"auto-trailing-slash\",\n    },\n  };\n}\n\n/**\n * Calculate the SHA-256 hash and size of a file\n *\n * @param filePath Path to the file\n * @returns Hash (first 32 chars of SHA-256) and size of the file\n */\nasync function calculateFileMetadata(\n  filePath: string\n): Promise<{ hash: string; size: number }> {\n  const hash = crypto.createHash(\"sha256\");\n  const fileContent = await fs.readFile(filePath);\n\n  hash.update(fileContent);\n  const fileHash = hash.digest(\"hex\").substring(0, 32); // First 32 chars of hash\n\n  return {\n    hash: fileHash,\n    size: fileContent.length,\n  };\n}\n\n```\n\n// alchemy/src/cloudflare/wrangler.json.ts\n```ts\nimport * as fs from \"fs/promises\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for wrangler.json configuration file\n */\nexport interface WranglerJsonProps {\n  /**\n   * The name of your worker\n   */\n  name: string;\n\n  /**\n   * The directory containing your worker entry point\n   * @default \"src\"\n   */\n  main?: string;\n\n  /**\n   * The entry point for your worker\n   * @default \"index.ts\" or \"index.js\"\n   */\n  entrypoint?: string;\n\n  /**\n   * The directory to store build artifacts\n   * @default \"dist\"\n   */\n  outdir?: string;\n\n  /**\n   * The directory to serve static assets from\n   */\n  assets?: string;\n\n  /**\n   * Minify the worker script\n   * @default true\n   */\n  minify?: boolean;\n\n  /**\n   * Node.js compatibility mode\n   * @default false\n   */\n  node_compat?: boolean;\n\n  /**\n   * First-party worker service bindings\n   */\n  services?: Array<{\n    /**\n     * Binding name\n     */\n    name: string;\n    /**\n     * Service environment\n     */\n    environment?: string;\n  }>;\n\n  /**\n   * Worker environment variables\n   */\n  vars?: Record<string, string>;\n\n  /**\n   * KV Namespace bindings\n   */\n  kv_namespaces?: Array<{\n    /**\n     * Binding name\n     */\n    binding: string;\n    /**\n     * KV namespace ID\n     */\n    id: string;\n    /**\n     * Preview KV namespace ID\n     */\n    preview_id?: string;\n  }>;\n\n  /**\n   * R2 bucket bindings\n   */\n  r2_buckets?: Array<{\n    /**\n     * Binding name\n     */\n    binding: string;\n    /**\n     * Bucket name\n     */\n    bucket_name: string;\n    /**\n     * Preview bucket name\n     */\n    preview_bucket_name?: string;\n  }>;\n\n  /**\n   * D1 database bindings\n   */\n  d1_databases?: Array<{\n    /**\n     * Binding name\n     */\n    binding: string;\n    /**\n     * Database name\n     */\n    database_name: string;\n    /**\n     * Database ID\n     */\n    database_id: string;\n    /**\n     * Preview database ID\n     */\n    preview_database_id?: string;\n  }>;\n\n  /**\n   * Durable Object bindings\n   */\n  durable_objects?: {\n    /**\n     * Durable Object bindings\n     */\n    bindings: Array<{\n      /**\n       * Binding name\n       */\n      name: string;\n      /**\n       * Class name\n       */\n      class_name: string;\n      /**\n       * Script name\n       */\n      script_name?: string;\n      /**\n       * Environment name\n       */\n      environment?: string;\n    }>;\n  };\n\n  /**\n   * Queue bindings\n   */\n  queues?: {\n    /**\n     * Producer bindings\n     */\n    producers?: Array<{\n      /**\n       * Binding name\n       */\n      binding: string;\n      /**\n       * Queue name\n       */\n      queue: string;\n    }>;\n    /**\n     * Consumer configuration\n     */\n    consumers?: Array<{\n      /**\n       * Queue name\n       */\n      queue: string;\n      /**\n       * Maximum batch size\n       */\n      max_batch_size?: number;\n      /**\n       * Maximum batch timeout\n       */\n      max_batch_timeout?: number;\n      /**\n       * Maximum retries\n       */\n      max_retries?: number;\n      /**\n       * Dead letter queue\n       */\n      dead_letter_queue?: string;\n    }>;\n  };\n\n  /**\n   * Analytics Engine bindings\n   */\n  analytics_engine_datasets?: Array<{\n    /**\n     * Binding name\n     */\n    binding: string;\n    /**\n     * Dataset name\n     */\n    dataset?: string;\n  }>;\n\n  /**\n   * Route configuration\n   */\n  routes?: Array<string>;\n\n  /**\n   * Triggers configuration\n   */\n  triggers?: {\n    /**\n     * Cron triggers\n     */\n    crons: Array<string>;\n  };\n\n  /**\n   * Worker compatibility date\n   */\n  compatibility_date?: string;\n\n  /**\n   * Worker compatibility flags\n   */\n  compatibility_flags?: Array<string>;\n\n  /**\n   * Worker usage model\n   * \"bundled\" - Includes resources like CPU and memory. Better for consistent workloads.\n   * \"unbound\" - Pay only for what you use. Better for sporadic workloads.\n   */\n  usage_model?: \"bundled\" | \"unbound\";\n\n  /**\n   * Path to the wrangler.json file\n   * @internal\n   */\n  path?: string;\n}\n\n/**\n * Output returned after WranglerJson creation/update\n */\nexport interface WranglerJson\n  extends Resource<\"cloudflare::WranglerJson\">,\n    WranglerJsonProps {\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Resource for managing wrangler.json configuration files\n */\nexport const WranglerJson = Resource(\n  \"cloudflare::WranglerJson\",\n  async function (\n    this: Context<WranglerJson>,\n    id: string,\n    props: WranglerJsonProps,\n  ): Promise<WranglerJson> {\n    // Default path is wrangler.json in current directory\n    const filePath = props.path || \"wrangler.json\";\n\n    if (this.phase === \"delete\") {\n      try {\n        await fs.unlink(filePath);\n      } catch (error) {\n        // Ignore errors if file doesn't exist\n        if ((error as NodeJS.ErrnoException).code !== \"ENOENT\") {\n          throw error;\n        }\n      }\n      return this.destroy();\n    }\n\n    // Create or update the file\n    const config = {\n      ...props,\n      // Remove internal path property\n      path: undefined,\n    };\n\n    // Write the file\n    await fs.writeFile(filePath, JSON.stringify(config, null, 2));\n\n    // Return the resource\n    return this({\n      ...props,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  },\n);\n\n```\n\n// alchemy/src/cloudflare/zone-settings.ts\n```ts\n/**\n * Common response fields for all settings\n */\nexport interface CloudflareSettingBase {\n  /**\n   * The identifier of the setting\n   */\n  id: string;\n\n  /**\n   * When the setting was last modified\n   */\n  modified_on: string | null;\n\n  /**\n   * Whether the setting can be modified\n   */\n  editable: boolean;\n}\n\n/**\n * Value types for each setting\n */\nexport type SSLValue = \"off\" | \"flexible\" | \"full\" | \"strict\";\nexport type MinTLSVersionValue = \"1.0\" | \"1.1\" | \"1.2\" | \"1.3\";\nexport type TLS13Value = \"on\" | \"off\" | \"zrt\";\nexport type CacheLevelValue = \"aggressive\" | \"basic\" | \"simplified\";\n\n// Boolean setting values\nexport type AlwaysUseHTTPSValue = \"on\" | \"off\";\nexport type AutomaticHTTPSRewritesValue = \"on\" | \"off\";\nexport type BrotliValue = \"on\" | \"off\";\nexport type DevelopmentModeValue = \"on\" | \"off\";\nexport type EarlyHintsValue = \"on\" | \"off\";\nexport type EmailObfuscationValue = \"on\" | \"off\";\nexport type HotlinkProtectionValue = \"on\" | \"off\";\nexport type HTTP2Value = \"on\" | \"off\";\nexport type HTTP3Value = \"on\" | \"off\";\nexport type IPv6Value = \"on\" | \"off\";\nexport type WebSocketsValue = \"on\" | \"off\";\nexport type ZeroRTTValue = \"on\" | \"off\";\n\n/**\n * Common response fields for boolean settings that use \"on\"/\"off\"\n */\nexport interface CloudflareBooleanSetting extends CloudflareSettingBase {\n  /**\n   * The value of the setting\n   */\n  value: \"on\" | \"off\";\n}\n\n/**\n * Advanced DDoS protection setting\n * @see https://developers.cloudflare.com/api/resources/zones/#advanced-ddos\n */\nexport interface AdvancedDDoSSetting extends CloudflareBooleanSetting {\n  id: \"advanced_ddos\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * Always Online setting\n * When enabled, Cloudflare serves limited copies of web pages from the Internet Archive if your server is offline\n */\nexport interface AlwaysOnlineSetting extends CloudflareBooleanSetting {\n  id: \"always_online\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * Always Use HTTPS setting\n * Redirects all HTTP traffic to HTTPS\n */\nexport interface AlwaysUseHTTPSSetting extends CloudflareSettingBase {\n  id: \"always_use_https\";\n  value: AlwaysUseHTTPSValue;\n}\n\n/**\n * Automatic HTTPS Rewrites setting\n * Automatically rewrites HTTP URLs to HTTPS\n */\nexport interface AutomaticHTTPSRewritesSetting extends CloudflareSettingBase {\n  id: \"automatic_https_rewrites\";\n  value: AutomaticHTTPSRewritesValue;\n}\n\n/**\n * Automatic Platform Optimization setting\n */\nexport interface AutomaticPlatformOptimizationSetting\n  extends CloudflareSettingBase {\n  id: \"automatic_platform_optimization\";\n  value: {\n    enabled: boolean;\n    cf: boolean;\n    wordpress: boolean;\n    wordpress_plugin: boolean;\n    cache_by_device_type: boolean;\n  };\n}\n\n/**\n * Brotli compression setting\n */\nexport interface BrotliSetting extends CloudflareSettingBase {\n  id: \"brotli\";\n  value: BrotliValue;\n}\n\n/**\n * Browser Cache TTL setting\n */\nexport interface BrowserCacheTTLSetting extends CloudflareSettingBase {\n  id: \"browser_cache_ttl\";\n  value: number;\n}\n\n/**\n * Browser Check setting\n */\nexport interface BrowserCheckSetting extends CloudflareSettingBase {\n  id: \"browser_check\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * Cache Level setting\n */\nexport interface CacheLevelSetting extends CloudflareSettingBase {\n  id: \"cache_level\";\n  value: CacheLevelValue;\n}\n\n/**\n * Challenge TTL setting\n */\nexport interface ChallengeTTLSetting extends CloudflareSettingBase {\n  id: \"challenge_ttl\";\n  value: number;\n}\n\n/**\n * Ciphers setting\n */\nexport interface CiphersSetting extends CloudflareSettingBase {\n  id: \"ciphers\";\n  value: string[];\n}\n\n/**\n * Development Mode setting\n */\nexport interface DevelopmentModeSetting extends CloudflareSettingBase {\n  id: \"development_mode\";\n  value: DevelopmentModeValue;\n}\n\n/**\n * Early Hints setting\n */\nexport interface EarlyHintsSetting extends CloudflareSettingBase {\n  id: \"early_hints\";\n  value: EarlyHintsValue;\n}\n\n/**\n * Email Obfuscation setting\n */\nexport interface EmailObfuscationSetting extends CloudflareSettingBase {\n  id: \"email_obfuscation\";\n  value: EmailObfuscationValue;\n}\n\n/**\n * Hotlink Protection setting\n */\nexport interface HotlinkProtectionSetting extends CloudflareSettingBase {\n  id: \"hotlink_protection\";\n  value: HotlinkProtectionValue;\n}\n\n/**\n * HTTP/2 setting\n */\nexport interface HTTP2Setting extends CloudflareSettingBase {\n  id: \"http2\";\n  value: HTTP2Value;\n}\n\n/**\n * HTTP/3 setting\n */\nexport interface HTTP3Setting extends CloudflareSettingBase {\n  id: \"http3\";\n  value: HTTP3Value;\n}\n\n/**\n * IP Geolocation setting\n */\nexport interface IPGeolocationSetting extends CloudflareSettingBase {\n  id: \"ip_geolocation\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * IPv6 setting\n */\nexport interface IPv6Setting extends CloudflareSettingBase {\n  id: \"ipv6\";\n  value: IPv6Value;\n}\n\n/**\n * Minimum TLS Version setting\n */\nexport interface MinTLSVersionSetting extends CloudflareSettingBase {\n  id: \"min_tls_version\";\n  value: MinTLSVersionValue;\n}\n\n/**\n * Opportunistic Encryption setting\n */\nexport interface OpportunisticEncryptionSetting extends CloudflareSettingBase {\n  id: \"opportunistic_encryption\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * SSL setting\n */\nexport interface SSLSetting extends CloudflareSettingBase {\n  id: \"ssl\";\n  value: SSLValue;\n  certificate_status?: string;\n  validation_errors?: Array<{\n    message: string;\n  }>;\n}\n\n/**\n * TLS 1.3 setting\n */\nexport interface TLS13Setting extends CloudflareSettingBase {\n  id: \"tls_1_3\";\n  value: TLS13Value;\n}\n\n/**\n * WebSockets setting\n */\nexport interface WebSocketsSetting extends CloudflareSettingBase {\n  id: \"websockets\";\n  value: WebSocketsValue;\n}\n\n/**\n * Zero-RTT setting\n */\nexport interface ZeroRTTSetting extends CloudflareSettingBase {\n  id: \"0rtt\";\n  value: ZeroRTTValue;\n}\n\n/**\n * All possible zone settings\n */\nexport type CloudflareZoneSetting =\n  | AdvancedDDoSSetting\n  | AlwaysOnlineSetting\n  | AlwaysUseHTTPSSetting\n  | AutomaticHTTPSRewritesSetting\n  | AutomaticPlatformOptimizationSetting\n  | BrotliSetting\n  | BrowserCacheTTLSetting\n  | BrowserCheckSetting\n  | CacheLevelSetting\n  | ChallengeTTLSetting\n  | CiphersSetting\n  | DevelopmentModeSetting\n  | EarlyHintsSetting\n  | EmailObfuscationSetting\n  | HotlinkProtectionSetting\n  | HTTP2Setting\n  | HTTP3Setting\n  | IPGeolocationSetting\n  | IPv6Setting\n  | MinTLSVersionSetting\n  | OpportunisticEncryptionSetting\n  | SSLSetting\n  | TLS13Setting\n  | WebSocketsSetting\n  | ZeroRTTSetting;\n\n/**\n * Input for updating a zone setting\n */\nexport interface UpdateZoneSettingParams {\n  /**\n   * The value to set\n   */\n  value: CloudflareZoneSetting[\"value\"];\n}\n\n/**\n * Response for zone settings operations\n */\nexport interface CloudflareZoneSettingResponse {\n  /**\n   * Whether the API call was successful\n   */\n  success: boolean;\n\n  /**\n   * Any error messages\n   */\n  errors: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * Any informational messages\n   */\n  messages: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * The settings that were operated on\n   */\n  result: CloudflareZoneSetting[];\n}\n\n/**\n * Response for a single zone setting operation\n */\nexport interface CloudflareZoneSettingSingleResponse {\n  /**\n   * Whether the API call was successful\n   */\n  success: boolean;\n\n  /**\n   * Any error messages\n   */\n  errors: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * Any informational messages\n   */\n  messages: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * The setting that was operated on\n   */\n  result: CloudflareZoneSetting;\n}\n\n```\n\n// alchemy/src/cloudflare/zone.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { createCloudflareApi, type CloudflareApiOptions } from \"./api\";\nimport type {\n  AlwaysUseHTTPSValue,\n  AutomaticHTTPSRewritesValue,\n  BrotliValue,\n  CloudflareZoneSettingResponse,\n  DevelopmentModeValue,\n  EarlyHintsValue,\n  EmailObfuscationValue,\n  HTTP2Value,\n  HTTP3Value,\n  HotlinkProtectionValue,\n  IPv6Value,\n  MinTLSVersionValue,\n  SSLValue,\n  TLS13Value,\n  UpdateZoneSettingParams,\n  WebSocketsValue,\n  ZeroRTTValue,\n} from \"./zone-settings\";\n\n/**\n * Properties for creating or updating a Zone\n */\nexport interface ZoneProps extends CloudflareApiOptions {\n  /**\n   * The domain name for the zone\n   */\n  name: string;\n\n  /**\n   * The type of zone to create\n   * \"full\" - Full zone implies that DNS is hosted with Cloudflare\n   * \"partial\" - Partial zone is typically a partner-hosted zone or a CNAME setup\n   * \"secondary\" - Secondary zone is a zone that mirrors the primary zone\n   * @default \"full\"\n   */\n  type?: \"full\" | \"partial\" | \"secondary\";\n\n  /**\n   * Whether to jump start the zone\n   * When enabled, Cloudflare will attempt to fetch existing DNS records\n   * @default true\n   */\n  jumpStart?: boolean;\n\n  /**\n   * Settings to apply to the zone\n   */\n  settings?: {\n    /**\n     * Enable SSL/TLS encryption for the zone\n     * \"off\" - SSL disabled\n     * \"flexible\" - Encrypts traffic between browser and Cloudflare\n     * \"full\" - Encrypts traffic between browser and server, allows self-signed certs\n     * \"strict\" - Encrypts traffic between browser and server, requires valid cert\n     */\n    ssl?: SSLValue;\n\n    /**\n     * Enable Always Use HTTPS\n     * Redirects all HTTP traffic to HTTPS\n     * @default \"off\"\n     */\n    alwaysUseHttps?: AlwaysUseHTTPSValue;\n\n    /**\n     * Enable Automatic HTTPS Rewrites\n     * Automatically rewrites HTTP URLs to HTTPS\n     * @default \"off\"\n     */\n    automaticHttpsRewrites?: AutomaticHTTPSRewritesValue;\n\n    /**\n     * Enable TLS 1.3\n     * Enables the latest version of TLS encryption\n     * @default \"off\"\n     */\n    tls13?: TLS13Value;\n\n    /**\n     * Enable Early Hints\n     * Speeds up page loads by serving Link headers\n     * @default \"off\"\n     */\n    earlyHints?: EarlyHintsValue;\n\n    /**\n     * Enable Email Obfuscation\n     * Obfuscates email addresses on the site\n     * @default \"off\"\n     */\n    emailObfuscation?: EmailObfuscationValue;\n\n    /**\n     * Enable Browser Cache TTL\n     * Sets the browser cache TTL in seconds\n     */\n    browserCacheTtl?: number;\n\n    /**\n     * Enable Development Mode\n     * Disables caching and enables real-time updates\n     * @default \"off\"\n     */\n    developmentMode?: DevelopmentModeValue;\n\n    /**\n     * Enable HTTP/2\n     * @default \"on\"\n     */\n    http2?: HTTP2Value;\n\n    /**\n     * Enable HTTP/3\n     * @default \"on\"\n     */\n    http3?: HTTP3Value;\n\n    /**\n     * Enable IPv6\n     * @default \"on\"\n     */\n    ipv6?: IPv6Value;\n\n    /**\n     * Enable WebSockets\n     * @default \"on\"\n     */\n    websockets?: WebSocketsValue;\n\n    /**\n     * Enable Zero-RTT\n     * @default \"off\"\n     */\n    zeroRtt?: ZeroRTTValue;\n\n    /**\n     * Enable Brotli compression\n     * @default \"on\"\n     */\n    brotli?: BrotliValue;\n\n    /**\n     * Enable Hotlink Protection\n     * @default \"off\"\n     */\n    hotlinkProtection?: HotlinkProtectionValue;\n\n    /**\n     * Minimum TLS Version\n     * @default \"1.0\"\n     */\n    minTlsVersion?: MinTLSVersionValue;\n  };\n}\n\n/**\n * Output returned after Zone creation/update\n */\nexport interface Zone extends Resource<\"cloudflare::Zone\"> {\n  /**\n   * The ID of the zone\n   */\n  id: string;\n\n  /**\n   * The domain name for the zone\n   */\n  name: string;\n\n  /**\n   * The type of zone\n   */\n  type: \"full\" | \"partial\" | \"secondary\";\n\n  /**\n   * The status of the zone\n   */\n  status: string;\n\n  /**\n   * Whether the zone is paused\n   */\n  paused: boolean;\n\n  /**\n   * The account ID the zone belongs to\n   */\n  accountId: string;\n\n  /**\n   * The nameservers assigned to the zone\n   */\n  nameservers: string[];\n\n  /**\n   * The original nameservers for the zone\n   */\n  originalNameservers: string[] | null;\n\n  /**\n   * Time at which the zone was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the zone was last modified\n   */\n  modifiedAt: number;\n\n  /**\n   * Time at which the zone was activated\n   */\n  activatedAt: number | null;\n\n  /**\n   * The zone's current settings\n   */\n  settings: {\n    ssl: SSLValue;\n    alwaysUseHttps: AlwaysUseHTTPSValue;\n    automaticHttpsRewrites: AutomaticHTTPSRewritesValue;\n    tls13: TLS13Value;\n    earlyHints: EarlyHintsValue;\n    emailObfuscation: EmailObfuscationValue;\n    browserCacheTtl: number;\n    developmentMode: DevelopmentModeValue;\n    http2: HTTP2Value;\n    http3: HTTP3Value;\n    ipv6: IPv6Value;\n    websockets: WebSocketsValue;\n    zeroRtt: ZeroRTTValue;\n    brotli: BrotliValue;\n    hotlinkProtection: HotlinkProtectionValue;\n    minTlsVersion: MinTLSVersionValue;\n  };\n}\n\n/**\n * A Cloudflare Zone represents a domain and its configuration settings on Cloudflare.\n * Zones allow you to manage DNS, SSL/TLS, caching, security and other settings for a domain.\n *\n * @example\n * // Create a basic zone with default settings\n * const basicZone = await Zone(\"example.com\", {\n *   name: \"example.com\",\n *   type: \"full\",\n *   jumpStart: true\n * });\n *\n * @example\n * // Create a zone with enhanced security settings\n * const secureZone = await Zone(\"secure.example.com\", {\n *   name: \"secure.example.com\",\n *   type: \"full\",\n *   settings: {\n *     ssl: \"strict\",\n *     alwaysUseHttps: \"on\",\n *     automaticHttpsRewrites: \"on\",\n *     minTlsVersion: \"1.3\",\n *     tls13: \"zrt\"\n *   }\n * });\n *\n * @example\n * // Create a zone with optimized performance settings\n * const fastZone = await Zone(\"fast.example.com\", {\n *   name: \"fast.example.com\",\n *   settings: {\n *     browserCacheTtl: 7200,\n *     brotli: \"on\",\n *     zeroRtt: \"on\",\n *     http2: \"on\",\n *     http3: \"on\",\n *     earlyHints: \"on\"\n *   }\n * });\n *\n * @example\n * // Create a development zone with specific features\n * const devZone = await Zone(\"dev.example.com\", {\n *   name: \"dev.example.com\",\n *   settings: {\n *     developmentMode: \"on\",\n *     emailObfuscation: \"on\",\n *     hotlinkProtection: \"on\",\n *     ipv6: \"on\",\n *     websockets: \"on\"\n *   }\n * });\n *\n * @see https://developers.cloudflare.com/dns/zone-setups/\n */\nexport const Zone = Resource(\n  \"cloudflare::Zone\",\n  async function (\n    this: Context<Zone>,\n    id: string,\n    props: ZoneProps\n  ): Promise<Zone> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    if (this.phase === \"delete\") {\n      if (this.output?.id) {\n        // Delete zone\n        const deleteResponse = await api.delete(`/zones/${this.output.id}`);\n\n        if (!deleteResponse.ok && deleteResponse.status !== 404) {\n          const errorData: any = await deleteResponse.json().catch(() => ({\n            errors: [{ message: deleteResponse.statusText }],\n          }));\n          throw new Error(\n            `Error deleting zone '${props.name}': ${errorData.errors?.[0]?.message || deleteResponse.statusText}`\n          );\n        }\n      } else {\n        console.warn(`Zone '${props.name}' not found, skipping delete`);\n      }\n      return this.destroy();\n    }\n\n    if (this.phase === \"update\" && this.output?.id) {\n      // Get zone details to verify it exists\n      const response = await api.get(`/zones/${this.output.id}`);\n\n      if (!response.ok) {\n        throw new Error(\n          `Error getting zone '${props.name}': ${response.statusText}`\n        );\n      }\n\n      const zoneData = ((await response.json()) as { result: CloudflareZone })\n        .result;\n\n      // Update zone settings if provided\n      if (props.settings) {\n        await updateZoneSettings(api, this.output.id, props.settings);\n        // Add a small delay to ensure settings are propagated\n        await new Promise((resolve) => setTimeout(resolve, 2000));\n      }\n\n      return this({\n        id: zoneData.id,\n        name: zoneData.name,\n        type: zoneData.type,\n        status: zoneData.status,\n        paused: zoneData.paused,\n        accountId: zoneData.account.id,\n        nameservers: zoneData.name_servers,\n        originalNameservers: zoneData.original_name_servers,\n        createdAt: new Date(zoneData.created_on).getTime(),\n        modifiedAt: new Date(zoneData.modified_on).getTime(),\n        activatedAt: zoneData.activated_on\n          ? new Date(zoneData.activated_on).getTime()\n          : null,\n        settings: await getZoneSettings(api, zoneData.id),\n      });\n    } else {\n      // Create new zone\n\n      const response = await api.post(\"/zones\", {\n        name: props.name,\n        type: props.type || \"full\",\n        jump_start: props.jumpStart !== false,\n        account: {\n          id: api.accountId,\n        },\n      });\n\n      const body = await response.text();\n      let zoneData;\n      if (!response.ok) {\n        if (response.status === 400 && body.includes(\"already exists\")) {\n          // Zone already exists, fetch it instead\n          console.warn(\n            `Zone '${props.name}' already exists during Zone create, adopting it...`\n          );\n          const getResponse = await api.get(`/zones?name=${props.name}`);\n\n          if (!getResponse.ok) {\n            throw new Error(\n              `Error fetching existing zone '${props.name}': ${getResponse.statusText}`\n            );\n          }\n\n          const zones = (\n            (await getResponse.json()) as { result: CloudflareZone[] }\n          ).result;\n          if (zones.length === 0) {\n            throw new Error(\n              `Zone '${props.name}' does not exist, but the name is reserved for another user.`\n            );\n          }\n          zoneData = zones[0];\n        } else {\n          throw new Error(\n            `Error creating zone '${props.name}': ${response.statusText}\\n${body}`\n          );\n        }\n      } else {\n        zoneData = (JSON.parse(body) as { result: CloudflareZone }).result;\n      }\n\n      // Update zone settings if provided\n      if (props.settings) {\n        await updateZoneSettings(api, zoneData.id, props.settings);\n        // Add a small delay to ensure settings are propagated\n        await new Promise((resolve) => setTimeout(resolve, 2000));\n      }\n\n      return this({\n        id: zoneData.id,\n        name: zoneData.name,\n        type: zoneData.type,\n        status: zoneData.status,\n        paused: zoneData.paused,\n        accountId: zoneData.account.id,\n        nameservers: zoneData.name_servers,\n        originalNameservers: zoneData.original_name_servers,\n        createdAt: new Date(zoneData.created_on).getTime(),\n        modifiedAt: new Date(zoneData.modified_on).getTime(),\n        activatedAt: zoneData.activated_on\n          ? new Date(zoneData.activated_on).getTime()\n          : null,\n        settings: await getZoneSettings(api, zoneData.id),\n      });\n    }\n  }\n);\n\n/**\n * Helper function to update zone settings\n */\nasync function updateZoneSettings(\n  api: any,\n  zoneId: string,\n  settings: ZoneProps[\"settings\"]\n): Promise<void> {\n  if (!settings) return;\n\n  const settingsMap = {\n    ssl: \"ssl\",\n    alwaysUseHttps: \"always_use_https\",\n    automaticHttpsRewrites: \"automatic_https_rewrites\",\n    tls13: \"tls_1_3\",\n    earlyHints: \"early_hints\",\n    emailObfuscation: \"email_obfuscation\",\n    browserCacheTtl: \"browser_cache_ttl\",\n    developmentMode: \"development_mode\",\n    http2: \"http2\",\n    http3: \"http3\",\n    ipv6: \"ipv6\",\n    websockets: \"websockets\",\n    zeroRtt: \"0rtt\",\n    brotli: \"brotli\",\n    hotlinkProtection: \"hotlink_protection\",\n    minTlsVersion: \"min_tls_version\",\n  };\n\n  await Promise.all(\n    Object.entries(settings)\n      .filter(([_, value]) => value !== undefined)\n      .map(async ([key, value]) => {\n        const settingId = settingsMap[key as keyof typeof settings];\n        if (!settingId) return;\n\n        const response = await api.patch(\n          `/zones/${zoneId}/settings/${settingId}`,\n          {\n            value,\n          } as UpdateZoneSettingParams\n        );\n\n        if (!response.ok) {\n          const data = await response.text();\n          if (response.status === 400 && data.includes(\"already enabled\")) {\n            console.warn(`Warning: Setting '${key}' already enabled`);\n            return;\n          }\n          throw new Error(\n            `Failed to update zone setting ${key}: ${response.statusText}`\n          );\n        }\n      })\n  );\n}\n\n/**\n * Helper function to get current zone settings\n */\nasync function getZoneSettings(\n  api: any,\n  zoneId: string\n): Promise<Zone[\"settings\"]> {\n  const settingsResponse = await api.get(`/zones/${zoneId}/settings`);\n\n  if (!settingsResponse.ok) {\n    throw new Error(\n      `Failed to fetch zone settings: ${settingsResponse.status} ${settingsResponse.statusText}`\n    );\n  }\n\n  const result =\n    (await settingsResponse.json()) as CloudflareZoneSettingResponse;\n  const settingsData = result.result;\n\n  // Helper to get setting value with default\n  const getSetting = <T>(id: string, defaultValue: T): T => {\n    const setting = settingsData.find((s: any) => s.id === id);\n    return (setting?.value as T) ?? defaultValue;\n  };\n\n  return {\n    ssl: getSetting(\"ssl\", \"off\"),\n    alwaysUseHttps: getSetting(\"always_use_https\", \"off\"),\n    automaticHttpsRewrites: getSetting(\"automatic_https_rewrites\", \"off\"),\n    tls13: getSetting(\"tls_1_3\", \"off\"),\n    earlyHints: getSetting(\"early_hints\", \"off\"),\n    emailObfuscation: getSetting(\"email_obfuscation\", \"off\"),\n    browserCacheTtl: getSetting(\"browser_cache_ttl\", 14400),\n    developmentMode: getSetting(\"development_mode\", \"off\"),\n    http2: getSetting(\"http2\", \"on\"),\n    http3: getSetting(\"http3\", \"on\"),\n    ipv6: getSetting(\"ipv6\", \"on\"),\n    websockets: getSetting(\"websockets\", \"on\"),\n    zeroRtt: getSetting(\"0rtt\", \"off\"),\n    brotli: getSetting(\"brotli\", \"on\"),\n    hotlinkProtection: getSetting(\"hotlink_protection\", \"off\"),\n    minTlsVersion: getSetting(\"min_tls_version\", \"1.0\"),\n  };\n}\n\n/**\n * Cloudflare Zone response format\n */\nexport interface CloudflareZone {\n  id: string;\n  name: string;\n  type: \"full\" | \"partial\" | \"secondary\";\n  status: string;\n  paused: boolean;\n  account: {\n    id: string;\n  };\n  name_servers: string[];\n  original_name_servers: string[] | null;\n  created_on: string;\n  modified_on: string;\n  activated_on: string | null;\n}\n\n```"
      },
      {
        "role": "assistant",
        "content": "# Assets\n\nThe Assets component lets you add [static assets](https://developers.cloudflare.com/workers/configuration/sites/) to your Cloudflare Workers.\n\n## Minimal Example\n\nCreate a basic assets bundle from a local directory:\n\n```ts\nimport { Assets } from \"alchemy/cloudflare\";\n\nconst staticAssets = await Assets(\"static\", {\n  path: \"./src/assets\"\n});\n```\n\n## Bind to a Worker\n\nUse the assets with a Cloudflare Worker:\n\n```ts\nimport { Worker, Assets } from \"alchemy/cloudflare\";\n\nconst staticAssets = await Assets(\"static\", {\n  path: \"./src/assets\"\n});\n\nconst worker = await Worker(\"frontend\", {\n  name: \"frontend-worker\", \n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    ASSETS: staticAssets\n  }\n});\n```"
      }
    ],
    "createdAt": 1744512957818,
    "updatedAt": 1744512957818,
    "file": {
      "path": "alchemy-web/docs/providers/cloudflare/assets.md",
      "content": "# Assets\n\nThe Assets component lets you add [static assets](https://developers.cloudflare.com/workers/configuration/sites/) to your Cloudflare Workers.\n\n## Minimal Example\n\nCreate a basic assets bundle from a local directory:\n\n```ts\nimport { Assets } from \"alchemy/cloudflare\";\n\nconst staticAssets = await Assets(\"static\", {\n  path: \"./src/assets\"\n});\n```\n\n## Bind to a Worker\n\nUse the assets with a Cloudflare Worker:\n\n```ts\nimport { Worker, Assets } from \"alchemy/cloudflare\";\n\nconst staticAssets = await Assets(\"static\", {\n  path: \"./src/assets\"\n});\n\nconst worker = await Worker(\"frontend\", {\n  name: \"frontend-worker\", \n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    ASSETS: staticAssets\n  }\n});\n```",
      "Kind": "fs::File",
      "ID": "docs/cloudflare/Assets-file",
      "FQN": "github:alchemy/prod/docs/docs/cloudflare/Assets/docs/cloudflare/Assets-file",
      "Seq": 0
    },
    "Kind": "docs::Document",
    "ID": "docs/cloudflare/Assets",
    "FQN": "github:alchemy/prod/docs/docs/cloudflare/Assets",
    "Seq": 14
  },
  "props": {
    "title": "Assets",
    "path": "alchemy-web/docs/providers/cloudflare/assets.md",
    "freeze": true,
    "model": {
      "id": "claude-3-5-sonnet-latest",
      "provider": "anthropic"
    },
    "prompt": "You are a technical writer writing API documentation for an Alchemy IaC Resource.\nSee [README.md](./README.md) to understand the overview of Alchemy.\nSee [.cursorrules](./.cursorrules) to better understand the structure and convention of an Alchemy Resource.\n\nRelevant files for the         cloudflare Service:\n[bound.ts](alchemy/src/cloudflare/bound.ts)\n\n[custom-domain.ts](alchemy/src/cloudflare/custom-domain.ts)\n\n[durable-object-namespace.ts](alchemy/src/cloudflare/durable-object-namespace.ts)\n\n[api-error.ts](alchemy/src/cloudflare/api-error.ts)\n\n[workflow.ts](alchemy/src/cloudflare/workflow.ts)\n\n[bindings.ts](alchemy/src/cloudflare/bindings.ts)\n\n[zone.ts](alchemy/src/cloudflare/zone.ts)\n\n[pipeline.ts](alchemy/src/cloudflare/pipeline.ts)\n\n[assets.ts](alchemy/src/cloudflare/assets.ts)\n\n[account-id.ts](alchemy/src/cloudflare/account-id.ts)\n\n[dns-records.ts](alchemy/src/cloudflare/dns-records.ts)\n\n[api.ts](alchemy/src/cloudflare/api.ts)\n\n[d1-database.ts](alchemy/src/cloudflare/d1-database.ts)\n\n[worker-metadata.ts](alchemy/src/cloudflare/worker-metadata.ts)\n\n[types.ts](alchemy/src/cloudflare/types.ts)\n\n[vite-site.ts](alchemy/src/cloudflare/vite-site.ts)\n\n[response.ts](alchemy/src/cloudflare/response.ts)\n\n[zone-settings.ts](alchemy/src/cloudflare/zone-settings.ts)\n\n[r2-rest-state-store.ts](alchemy/src/cloudflare/r2-rest-state-store.ts)\n\n[permission-groups.ts](alchemy/src/cloudflare/permission-groups.ts)\n\n[wrangler.json.ts](alchemy/src/cloudflare/wrangler.json.ts)\n\n[bucket.ts](alchemy/src/cloudflare/bucket.ts)\n\n[kv-namespace.ts](alchemy/src/cloudflare/kv-namespace.ts)\n\n[account-api-token.ts](alchemy/src/cloudflare/account-api-token.ts)\n\n[worker-migration.ts](alchemy/src/cloudflare/worker-migration.ts)\n\n[auth.ts](alchemy/src/cloudflare/auth.ts)\n\n[worker.ts](alchemy/src/cloudflare/worker.ts)\n\n[queue.ts](alchemy/src/cloudflare/queue.ts)\n\n[asset-manifest.ts](alchemy/src/cloudflare/asset-manifest.ts)\n\nWrite concise documentation for the \"        Assets\" Resource.\n\n> [!CAUTION]\n> Avoid the temptation to over explain or over describe. Focus on concise, simple, high value snippets. One heading and 0-1 descriptions per snippet.\n\n> [!TIP]\n> Make sure the examples follow a natural progression from the minimal example to logical next steps of how the Resource might be used.\n\nEach document must follow the following format:\n\n#         Assets\n\n(simple description with an external link to the provider's website)\ne.g.\nThe Efs component lets you add [Amazon Elastic File System (EFS)](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html) to your app.\n\n# Minimal Example\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         Assets } from \"alchemy/        cloudflare\";\n\n(example)\n```\n\n# (one heading per variation)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport {         Assets } from \"alchemy/        cloudflare\";\n\n(example)\n```\n\nBefore writing the document, think through:\n1. What is the minimal, most common example use case for this resource?\n2. What are the variations (e.g. combination of different options) that are also commonly used, e.g. specifying the memory size of a lambda function.\n3. Make sure to draw from the examples and your understanding of Alchemy.\n\nRefer to alchemy docs to understand the context of how this documentation is consumed:\n- [what-is-alchemy.md](./alchemy-web/docs/what-is-alchemy.md)\n- [getting-started.md](./alchemy-web/docs/getting-started.md)\n- [bindings.md](alchemy-web/docs/concepts/bindings.md)\n\n[secret.md](alchemy-web/docs/concepts/secret.md)\n\n[scope.md](alchemy-web/docs/concepts/scope.md)\n\n[state.md](alchemy-web/docs/concepts/state.md)\n\n[testing.md](alchemy-web/docs/concepts/testing.md)\n\n[destroy.md](alchemy-web/docs/concepts/destroy.md)\n\n[resource.md](alchemy-web/docs/concepts/resource.md)\n\n        # Bind to a Worker\n(if it is a Cloudflare Resource)\n\n(brief 1-2 sentences of what it does)\n\n```ts\nimport { Worker,         Assets } from \"alchemy/        cloudflare\";\n\nconst myResource = await         Assets(\"my-resource\", {\n  // ...\n});\n\nawait Worker(\"my-worker\", {\n  name: \"my-worker\",\n  script: \"console.log('Hello, world!')\",\n  bindings: {\n    myResource,\n  },\n});\n```\n\n      \n// ./.cursorrules\n```\nAlways use bun to install dependencies.\n\nAll dependencies must be peer dependencies.\n\nAlways use alchemy.secret() instead of new Secret() to create secrets.\n\n# Running Tests with Bun\n\nWe use Bun for testing. Here's how to run tests:\n\n```bash\n# Run all tests\nbun test\n\n# Run tests in a specific file\nbun test alchemy/test/stripe/price.test.ts\n\n# Run a specific test in a specific file\nbun test --test-name-pattern=\"create and update price\" alchemy/test/stripe/price.test.ts\n```\n\nFor resource tests, create a dedicated test file for each resource type following the pattern `alchemy/test/service-name/resource-name.test.ts`.\n\n# Creating a New Service Resource\n\nThis guide provides step-by-step instructions for creating a new resource for a service (like Stripe's Price, Product, or Webhook resources).\n\n## Step 1: Create the Resource File\n\nCreate a new file in the service directory with kebab-case naming:\n\n```\nalchemy/src/{{service-name}}/{{resource-name}}.ts\n```\n\nExample: `alchemy/src/stripe/price.ts`\n\n## Step 2: Define Resource Interfaces\n\nStart by importing dependencies and defining the resource interfaces:\n\n```typescript\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\n\n/**\n * Properties for creating or updating a {{ResourceName}}\n */\nexport interface {{ResourceName}}Props {\n  /**\n   * {{Property description}}\n   */\n  propertyName: string;\n\n  /**\n   * {{Property description}}\n   */\n  anotherProperty?: number;\n\n  // Add all required and optional properties\n  // Include JSDoc comments for each property\n}\n\n/**\n * Output returned after {{ResourceName}} creation/update\n * IMPORTANT: The interface name MUST match the exported resource name\n * For example, if your resource is exported as \"Product\", this interface\n * should be named \"Product\" (not \"ProductOutput\")\n * \n */\nexport interface {{ResourceName}} extends Resource<\"{{service-name}}::{{ResourceName}}\"> {{ResourceName}}Props {\n  /**\n   * The ID of the resource\n   */\n  id: string;\n\n  /**\n   * Time at which the object was created\n   */\n  createdAt: number;\n\n  // Add all additional properties returned by the service\n  // Include JSDoc comments for each property\n}\n```\n\n## Step 3: API Client Implementation\n\nCreate a minimal API client that wraps fetch calls without excessive abstraction:\n\n```typescript\n/**\n * Options for {{ServiceName}} API requests\n */\nexport interface {{ServiceName}}ApiOptions {\n  /**\n   * API key or token to use (overrides environment variable)\n   */\n  apiKey?: string;\n\n  /**\n   * Account or project ID (overrides environment variable)\n   */\n  accountId?: string;\n}\n\n/**\n * Minimal API client using raw fetch\n */\nexport class {{ServiceName}}Api {\n  /** Base URL for API */\n  readonly baseUrl: string;\n\n  /** API key or token */\n  readonly apiKey: string;\n\n  /** Account ID */\n  readonly accountId: string;\n\n  /**\n   * Create a new API client\n   *\n   * @param options API options\n   */\n  constructor(options: {{ServiceName}}ApiOptions = {}) {\n    // Initialize with environment variables or provided values\n    this.baseUrl = \"https://api.{{service-name}}.com/v1\";\n    this.apiKey = options.apiKey || process.env.{{SERVICE_API_KEY}} || '';\n    this.accountId = options.accountId || process.env.{{SERVICE_ACCOUNT_ID}} || '';\n\n    // Validate required configuration\n    if (!this.apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n  }\n\n  /**\n   * Make a request to the API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    // Set up authentication headers\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${this.apiKey}`\n    };\n\n    // Add headers from init if provided\n    if (init.headers) {\n      const initHeaders = init.headers as Record<string, string>;\n      Object.keys(initHeaders).forEach(key => {\n        headers[key] = initHeaders[key];\n      });\n    }\n\n    // For FormData, remove Content-Type\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Make the request\n    return fetch(`${this.baseUrl}${path}`, {\n      ...init,\n      headers\n    });\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for POST requests\n   */\n  async post(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(path: string, body: any, init: RequestInit = {}): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n```\n\n## Step 4: Implement the Resource\n\nCreate the resource with the pseudo-class pattern using `this` with Context type. The exported const MUST match the output interface name:\n\n```typescript\n/**\n * (Resource description)\n * \n * (followed by examples for distinct use-cases of the Resource)\n * \n * @example\n * // Create a basic table with just a hash key for simple \n * // key-value lookups:\n * const basicTable = await DynamoTable(\"users\", {\n *   hashKey: {\n *     name: \"userId\",\n *     type: \"string\"\n *   }\n * });\n * \n * @example\n * // Create a time-series table with hash and sort key \n * // for efficient range queries:\n * const timeSeriesTable = await DynamoTable(\"events\", {\n *   hashKey: {\n *     name: \"deviceId\",\n *     type: \"string\"\n *   },\n *   sortKey: {\n *     name: \"timestamp\",\n *     type: \"number\"\n *   }\n * });\n * \n * @example\n * // Create a table with a global secondary index \n * // for alternate access patterns:\n * const ordersTable = await DynamoTable(\"orders\", {\n *   hashKey: {\n *     name: \"orderId\",\n *     type: \"string\"\n *   },\n *   globalSecondaryIndexes: [{\n *     indexName: \"by-customer\",\n *     hashKey: {\n *       name: \"customerId\",\n *       type: \"string\"\n *     },\n *     sortKey: {\n *       name: \"orderDate\",\n *       type: \"string\"\n *     }\n *   }]\n * });\n * \n * @example\n * // Create a one-time fixed price for a product:\n * const oneTimePrice = await Price(\"basic-license\", {\n *   currency: \"usd\",\n *   unitAmount: 2999,\n *   product: \"prod_xyz\"\n * });\n * \n * @example\n * // Create a recurring subscription price with fixed \n * // monthly billing:\n * const subscriptionPrice = await Price(\"pro-monthly\", {\n *   currency: \"usd\",\n *   unitAmount: 1499,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"licensed\"\n *   }\n * });\n * \n * @example\n * // Create a metered price for usage-based billing:\n * const meteredPrice = await Price(\"storage\", {\n *   currency: \"usd\",\n *   unitAmount: 25,\n *   product: \"prod_xyz\",\n *   recurring: {\n *     interval: \"month\",\n *     usageType: \"metered\",\n *     aggregateUsage: \"sum\"\n *   }\n * });\n */\nexport const {{ResourceName}} = Resource(\n  \"{{service-name}}::{{ResourceName}}\",\n  async function(this: Context<{{ResourceName}}>, id: string, props: {{ResourceName}}Props): Promise<{{ResourceName}}> {\n    // Get API key from environment\n    const apiKey = process.env.{{SERVICE_API_KEY}};\n    if (!apiKey) {\n      throw new Error(\"{{SERVICE_API_KEY}} environment variable is required\");\n    }\n\n    // Initialize API client\n    const api = new {{ServiceName}}Api();\n\n    if (this.phase === \"delete\") {\n      try {\n        if (this.output?.id) {\n          // Delete resource\n          const deleteResponse = await api.delete(`/accounts/${api.accountId}/resources/${this.output.id}`);\n\n          // Check response status directly instead of relying on exceptions\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            console.error(\"Error deleting resource:\", deleteResponse.statusText);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error deleting resource:\", error);\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    } else {\n      try {\n        let response;\n\n        if (this.phase === \"update\" && this.output?.id) {\n          // Update existing resource\n          response = await api.put(\n            `/accounts/${api.accountId}/resources/${this.output.id}`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        } else {\n          // Create new resource\n          response = await api.post(\n            `/accounts/${api.accountId}/resources`,\n            {\n              // Map props to API-expected format\n              name: props.name,\n              description: props.description\n            }\n          );\n        }\n\n        // Check response status directly\n        if (!response.ok) {\n          throw new Error(`API error: ${response.statusText}`);\n        }\n\n        // Parse response JSON\n        const data = await response.json();\n        const resource = data.result || data;\n\n        // Return the resource using this() to construct output\n        return this({\n          id: resource.id,\n          name: resource.name,\n          description: resource.description,\n          createdAt: resource.created_at || Date.now(),\n          // Include all other required properties from the interface\n          ...props // Include any additional properties from props\n        });\n      } catch (error) {\n        console.error(\"Error creating/updating resource:\", error);\n        throw error;\n      }\n    }\n  }\n);\n```\n\n### Important Notes on Resource Implementation\n\n1. **Pseudo-Class Pattern**: The resource is implemented as a constant that matches the interface name, creating a pseudo-class construct:\n\n   ```typescript\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n2. **Context Type**: The implementation function uses `this: Context<T>` to provide type-safe access to the resource context.\n\n3. **Phase Handling**:\n\n   - Use `this.phase` to check the current operation phase (\"create\", \"update\", or \"delete\")\n   - For deletion, return `this.destroy()`\n   - For creation/update, return `this({...})` with the resource properties\n\n4. **Output Construction**:\n\n   - Use `this({...})` to construct the resource output\n   - Include all required properties from the interface\n   - Spread the props object to include any additional properties\n\n5. **Error Handling**:\n   - Check response status codes directly\n   - Preserve original error details when possible\n   - Log errors before rethrowing\n\n## Step 5: Export from Service Index\n\nCreate or update the service index file to export the new resource:\n\n```typescript\n// alchemy/src/{{service-name}}/index.ts\nexport * from \"./{{resource-name}}\";\n```\n\n## Step 6: Update Package.json\n\nAdd the service to package.json exports if not already present:\n\n```json\n\"exports\": {\n  // ... existing exports\n  \"./{{service-name}}\": \"./lib/{{service-name}}/index.js\"\n}\n```\n\nAdd the service SDK as a peer dependency if not already present:\n\n```json\n\"peerDependencies\": {\n  // ... existing dependencies\n  \"{{service-sdk}}\": \"^x.y.z\"\n}\n```\n\n## Step 7: Create Tests\n\nCreate a test file that uses direct API interaction for verification:\n\n```typescript\n// alchemy/test/{{service-name}}/{{resource-name}}.test.ts\nimport { describe, expect } from \"bun:test\";\nimport { alchemy } from \"../../src/alchemy\";\nimport { destroy } from \"../../src/destroy\";\nimport { {{ResourceName}} } from \"../../src/{{service-name}}/{{resource-name}}\";\nimport { {{ServiceName}}Api } from \"../../src/{{service-name}}/api\";\nimport { BRANCH_PREFIX } from \"../util\";\n// must import this or else alchemy.test won't exist\nimport \"../../src/test/bun\";\n\nconst api = new {{ServiceName}}Api();\n\nconst test = alchemy.test(import.meta);\n\ndescribe(\"{{ResourceName}} Resource\", () => {\n  // Use BRANCH_PREFIX for deterministic, non-colliding resource names\n  const testId = `${BRANCH_PREFIX}-test-resource`;\n\n  test(\"create, update, and delete resource\", async (scope) => {\n    let resource: {{ResourceName}} | undefined;\n    try {\n      // Create a test resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Test Resource ${testId}`,\n        description: \"This is a test resource\"\n      });\n\n      expect(resource.id).toBeTruthy();\n      expect(resource.name).toEqual(`Test Resource ${testId}`);\n\n      // Verify resource was created by querying the API directly\n      const getResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      expect(getResponse.status).toEqual(200);\n\n      const responseData = await getResponse.json();\n      expect(responseData.result.name).toEqual(`Test Resource ${testId}`);\n\n      // Update the resource\n      resource = await {{ResourceName}}(testId, {\n        name: `Updated Resource ${testId}`,\n        description: \"This is an updated test resource\"\n      });\n\n      expect(resource.id).toEqual(resource.id);\n      expect(resource.name).toEqual(`Updated Resource ${testId}`);\n\n      // Verify resource was updated\n      const getUpdatedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource.id}`);\n      const updatedData = await getUpdatedResponse.json();\n      expect(updatedData.result.name).toEqual(`Updated Resource ${testId}`);\n    } catch(err) {\n      // log the error or else it's silently swallowed by destroy errors\n      console.log(err);\n      throw err;\n    } finally {\n      // Always clean up, even if test assertions fail\n      await destroy(scope);\n\n      // Verify resource was deleted\n      const getDeletedResponse = await api.get(`/accounts/${api.accountId}/resources/${resource?.id}`);\n      expect(getDeletedResponse.status).toEqual(404);\n    }\n  });\n});\n```\n\n### Important Notes on Testing\n\n1. **Test Scope**: Use `alchemy.test(import.meta)` to create a test with proper scope management.\n\n2. **Resource Cleanup**:\n\n   - Use `try/finally` to ensure resources are cleaned up\n   - Call `destroy(scope)` to clean up all resources created in the test\n   - Verify resources are properly deleted after cleanup\n\n3. **Direct API Verification**:\n\n   - Use the service's API client to verify changes directly\n   - Check both successful operations and cleanup\n   - Verify resource state after each operation\n\n4. **Naming Convention**:\n\n   - Use `BRANCH_PREFIX` for unique test resource names\n   - Follow the pattern: `${BRANCH_PREFIX}-test-resource-type`\n   - Keep names consistent and descriptive\n\n5. **Error Handling**:\n   - Let test failures propagate for visibility\n   - Catch errors only in cleanup to ensure proper resource deletion\n   - Log cleanup errors but don't throw\n\n## Resource Naming Convention\n\nWhen implementing resources, follow this important naming convention:\n\n1. The output interface must have the same name as the exported resource. For example:\n\n   - If your resource constant is `export const Product = Resource(...)`,\n   - Then your output interface must be named \"Product\" (not \"ProductOutput\")\n\n2. The name of the interface and the exported constant create a pseudo-class construct:\n\n   ```typescript\n   // This naming pattern allows the resource to work correctly with type system\n   export interface Product extends ProductProps {...}\n   export const Product = Resource(...);\n   ```\n\n3. Always use this pattern for consistency across resources.\n\n## API Design Principles\n\nWhen implementing resources that interact with external APIs, follow these design principles:\n\n1. **Minimal abstraction**: Use a thin wrapper around fetch rather than complex SDK clients.\n\n2. **Explicit path construction**: Construct API paths explicitly at the call site instead of using helper methods:\n\n   ```typescript\n   // DO THIS:\n   await api.get(`/accounts/${api.accountId}/resources/${resourceId}`);\n\n   // NOT THIS:\n   await api.get(api.accountPath(`/resources/${resourceId}`));\n   ```\n\n3. **Direct HTTP status handling**: Check response status codes directly rather than relying on exceptions:\n\n   ```typescript\n   // DO THIS:\n   const response = await api.get(`/path/to/resource`);\n   if (!response.ok) {\n     // Handle error case\n   }\n\n   // NOT THIS:\n   try {\n     const data = await api.get(`/path/to/resource`);\n   } catch (error) {\n     // Handle error\n   }\n   ```\n\n4. **Explicit JSON parsing**: Parse JSON responses explicitly where needed:\n\n   ```typescript\n   const response = await api.get(`/path/to/resource`);\n   if (response.ok) {\n     const data = await response.json();\n     // Process data\n   }\n   ```\n\n5. **Public properties over helper methods**: Expose properties like `api.accountId` publicly to construct URLs instead of creating helper methods.\n\n6. **Minimal error transformation**: Report errors with minimal transformation to preserve original error details.\n\n## Using Raw Fetch Calls Instead of SDKs\n\nAlways prefer using raw fetch calls instead of service SDKs unless explicitly instructed not to by the user. This approach:\n\n- Reduces dependency bloat\n- Minimizes version compatibility issues\n- Gives you more control over the request/response cycle\n- Often results in smaller bundle sizes\n\nFor both implementation and tests, directly interact with APIs using fetch.\n\n## Resource Implementation Pattern\n\nAlchemy resources follow an async/await pattern with a pseudo-class implementation. Key concepts:\n\n1. **Async/Await Pattern**:\n\n   - Resources are implemented as async functions\n   - Direct use of async/await for all operations\n   - No Input<T>/Output<T> wrappers needed\n\n2. **Pseudo-Class Structure**:\n\n   ```typescript\n   // Define the props interface\n   export interface ResourceProps {\n     name: string;\n     // ... other properties\n   }\n\n   // Define the resource interface extending props\n   export interface Resource extends ResourceProps {\n     id: string;\n     createdAt: number;\n     // ... other properties\n   }\n\n   // Implement the resource\n   export const Resource = Resource(\n     \"service::Resource\",\n     async function (\n       this: Context<Resource>,\n       id: string,\n       props: ResourceProps\n     ): Promise<Resource> {\n       // Implementation\n     }\n   );\n   ```\n\n3. **Context Usage**:\n\n   - Access context through `this: Context<T>`\n   - Use `this.phase` for operation type (\"create\", \"update\", \"delete\")\n   - Use `this.output` for current resource state\n   - Use `this({...})` to construct resource output\n   - Use `this.destroy()` for deletion\n\n4. **Phase Handling**:\n\n   ```typescript\n   if (this.phase === \"delete\") {\n     // Handle deletion\n     return this.destroy();\n   } else if (this.phase === \"update\") {\n     // Handle update\n     return this({ ...updatedProps });\n   } else {\n     // Handle create\n     return this({ ...newProps });\n   }\n   ```\n\n5. **Resource Construction**:\n\n   ```typescript\n   // Construct resource output\n   return this({\n     id: resourceId,\n     ...props,\n     // Add computed properties\n     createdAt: Date.now(),\n   });\n   ```\n\n6. **Error Handling**:\n   ```typescript\n   try {\n     // Resource operations\n   } catch (error) {\n     console.error(\"Operation failed:\", error);\n     throw error; // Propagate errors\n   }\n   ```\n\n```\n\n// ./alchemy-web/docs/getting-started.md\n```md\n# Getting Started with Alchemy\n\n> [!TIP]\n> Read [What is Alchemy](./what-is-alchemy.md) to get an overview of Alchemy and how it's different than tradtional IaC\n\n## Installation\n\nStart by installing the Alchemy library using Bun (or your preferred package manager):\n\n```bash\nbun add alchemy\n```\n\n## Create Your First Alchemy App\n\nCreate a file named `alchemy.run.ts` in your project directory and follow these steps:\n\n> [!TIP]\n> `alchemy.run.ts` is just a convention - you can run Alchemy in any script or JavaScript environment.\n\n### Step 1: Initialize the Alchemy Application Scope\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Initialize the Alchemy application scope\nconst app = await alchemy(\"my-first-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n});\n```\n\n> [!NOTE]\n> Learn more about Alchemy scopes in [Concepts: Scope](./concepts/scope.md)\n\n### Step 2: Instantiate a Resource\n\nA Resource is just an async function that takes a unique id (e.g. `config`) and some properties.\n\n```typescript\nimport { File } from \"alchemy/fs\";\n\n// Create a file resource\nconst hello = await File(\"hello\", {\n  path: \"./hello.txt\",\n  content: \"hello world\"\n});\n\nconsole.log(`Created file at: ${hello.path}`);\n```\n\n> [!NOTE]\n> Learn more about Alchemy resources in [Concepts: Resource](./concepts/resource.md)\n\n### Step 3: Finalize the Application\n\nAt the end of our script, call `finalize`.\n\n```typescript\n// Finalize the app to apply changes\nawait app.finalize();\n```\n\nThis is necessary for deleting what are called \"orphaned resources\" (more on that below).\n\n> [!NOTE]\n> Learn more about finalization and destroying resources in [Concepts: Destroy](./concepts/destroy.md)\n\n## Run the Script\n\nNow we simply run the script. Alchemy is just pure TypeScript, so you can run it with any JS engine, e.g. `bun`:\n\n```bash\nbun ./alchemy.run.ts\n```\n\nYou will see output similar to:\n\n```\nCreate:  \"my-first-app/dev/hello\"\nCreated: \"my-first-app/dev/hello\"\n```\n\nThis indicates that Alchemy has:\n1. Identified that the resource needs to be created\n2. Successfully created the resource\n\nWe now have a `./hello.txt` file in our project:\n```\nhello world\n```\n\n> [!TIP]\n> If you're familiar with other IaC tools, this should feel similar to `terraform apply`, `pulumi up`, `cdk deploy` or `sst deploy`\n\n## Understanding State\n\nAfter running your app, Alchemy creates a `.alchemy` directory to store state:\n\n```sh\n.alchemy/\n  my-first-app/         # app\n    dev/                # stage\n      hello.txt.json  # resource\n```\n\nState files help Alchemy determine whether to create, update, delete, or skip resources on subsequent runs.\n\nIf you run the same script again without changes, you'll see no operations performed because the state hasn't changed.\n\n> [!NOTE]\n> Learn more about Alchemy state in [Concepts: State](./concepts/state.md)\n\n## Update our File\n\nLet's now update our `alchemy.run.ts` script to change the content of the file:\n\n```ts\nconst hello = await File(\"hello\", {\n  // path: \"./hello.txt\",\n  path: \"./hello-world.txt\",\n  // content: \"hello world\"\n  content: \"Hello, world!\"\n});\n```\n\nNow, when we re-run the script, we'll see:\n```\nUpdate:  \"my-first-app/dev/hello\"\nUpdated: \"my-first-app/dev/hello\"\n```\n\nAnd now the `hello.txt` file is gone and replaced with `hello-world.txt` with different content:\n```\nHello, World\n```\n\nNotice how we didn't have to write any code to delete the old file?\n\nIn a nutshell, that's the point of Infrastructure-as-Code - we just write code that creates the state we want and Alchemy takes care of deciding what to create, update or delete and in what order.\n\n## Destroy the Resource\n\nLet's now comment out the `File` and run it again.\n\n```typescript\n// const hello = await File(\"hello\", {\n//   path: \"./hello-world.txt\",\n//   content: \"Hello, world!\"\n// });\n```\n\n> [!CAUTION]\n> Now, before we run our script again, you need to first add a \"naked\" impot of `alchemy/fs` at the top of our `alchemy.run.ts` script.\n> ```typescript\n> import \"alchemy/fs\"\n> ```\n> If you forget this, you would get an error\n> `Cannot destroy resource \"my-first-app/dev/hello\" type fs::File - no provider found. You may need to import the provider in your alchemy.config.ts.`\n> \n> This is because IDEs usually remove unused imports. If you don't import the resource, the delete handler won't be registered which Alchemy needs to delete the resource.\n\nThe output should look like:\n\n```\nDelete:  \"my-first-app/dev/hello\"\nDeleted: \"my-first-app/dev/hello\"\n```\n\nAnd the `hello-world.txt` file is now gone.\n\n> [!NOTE]\n> You can read more about how to destroy resoruces and stacks in [Concepts: Destroy](./concepts/destroy.md)\n\n## Next Steps\n\nThis was a very simple example using the local file system. Now, you might want to do something more interesting like deploy some Cloudflare resources or build your own!\n\n- [Deploy a ViteJS site to Cloudflare](./guides/cloudflare-vitejs)\n- [Build your own Custom Resource](./guides/custom-resources.md)\n\n```\n\n// ./alchemy-web/docs/what-is-alchemy.md\n```md\n# What is Alchemy\n\nAlchemy is an embeddable, zero-dependency, Infrastructure-as-Code (IaC) library written in pure TypeScript that runs anywhere that JavaScript runs - including the browser, serverless functions or even durable workflows.\n\n## What is Infrastructure as Code?\n\nInfrastructure-as-Code is the practice of using code to define your infrastructure configuration instead of manually creating it. \n\nLet's say you need a database. Instead of clicking through a cloud console or executing a CLI command, you simply write:\n\n```typescript\nconst database = await Database(\"main\", { \n  engine: \"postgres\",\n  size: \"small\"\n});\n\n// Access properties directly\nconsole.log(database.connectionString);\n```\n\nRun this code, and the actual database gets created. Run it twice without changes, and nothing happens. Change the size to `\"medium\"` and run it again - your database will be updated. Remove the code and run it again, the database will be deleted.\n\nYour code is the blueprint for repeatable infrastructure. Alchemy keeps track of all the resources and handles the synchronization between your code and the real world.\n\n## How is Alchemy different than traditonal IaC?\n\nUnlike similar tools like Terraform, Pulumi, SST and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code. \n\nThe Terraform, Pulumi and SST ecosystem are all tied together. SST is on top of Pulumi, which is again on top of Terraform. Terraform and Pulumi are implemented in Go and generate TypeScript \"wrappers\" that depend on a separate Go process.\n\nThe AWS CDK genereates CloudFormation JSON, depends on a managed service to run and only supports AWS services. Extending CloudFormation requires you deploy a Lambda Function (which is an ordeal).\n\nAll together, IaC without Alchemy is a clunky, heavy, opinionated toolchain that mostly works against you as a user. Alchemy simplifies the entire stack down to pure async functions.\n\n## Zero Dependencies\n\nAlchemy adopts a philosophy of zero-dependencies and web standards so that it can run anywhere with minimal impact on bundle size.\n\nAll you gotta do is install `alchemy` and you're good to go.\n\n```sh\nbun add alchemy\n```\n\n## Just Async Functions\n\nResources in Alchemy are implemented with async functions instead of complex class abstractions with sharp edge gotchas, inter-process-communication or hosted services.\n\nThis means you can create resources in any async environment and gain access to its physical properties immediately:\n\n```typescript\n// Create a resource by awaiting a function\nconst worker = await Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nconsole.log(worker.workerName) // string\n```\n\nContrast this with Pulumi which relies on a complex graph abstraction:\n```ts\nconst worker = new Worker(\"api\", {\n  name: \"my-api\",\n  entrypoint: \"./src/index.ts\"\n});\n\nworker.workerName // Output<string>\n\n// requires a complex abstraction just to log a value 😵‍💫\npulumi.export(worker.workerName)\n```\n\n## Runs Anywhere\n\nAlchemy works in any JavaScript environment including browsers, serverless functions, and durable workflows.\n\n```typescript\n// Browser environment\nconst app = await alchemy(\"my-browser-app\");\n\n// Lambda function\nexport const handler = async () => {\n  await alchemy.run(\"customer-id\", async () => {\n    await Worker(..)\n  })\n};\n```\n\n## Transparent State\n\nState is stored as plain JSON files you can inspect, edit, and version control.\n\n```json\n// .alchemy/my-app/prod/api.json\n{\n  \"provider\": \"cloudflare::Worker\",\n  \"status\": \"created\",\n  \"output\": {\n    \"id\": \"my-api\",\n    \"url\": \"https://my-api.workers.dev\"\n  },\n  \"props\": {\n    \"name\": \"my-api\",\n    \"entrypoint\": \"./src/index.ts\"\n  }\n}\n```\n\n> [!NOTE]\n> You usually don't want to edit these files, but when things go wrong, having state that is easy to understand and change is useful.\n\n## Pluggable State\n\nAlchemy supports custom state backends including file systems, cloud storage, or databases.\n\n```typescript\n// Use Cloudflare R2 for state\nconst app = await alchemy(\"my-app\", {\n  stateStore: (scope) => new R2StateStore(scope, {\n    bucketName: \"my-state-bucket\"\n  })\n});\n```\n\nBy default, Alchemy assumes you want to store state files locally for development purposes, but since Alchemy can run anywhere - you may want to store state in the the browser, or a Cloudflare Durable Object!\n\n[Learn more about custom state stores](./guides/custom-state-store.md)\n\n## Direct API Integration\n\n> `fetch` is all you need\n\nAlchemy resources call service APIs directly using `fetch`, instead of using SDKs that often come with heavy dependencies and runtime requirements.\n\n```typescript\n// Resource implementation using direct API calls\nif (this.phase === \"delete\") {\n  await fetch(`https://api.example.com/resources/${this.output.id}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": `Bearer ${apiKey}` }\n  });\n  return this.destroy();\n}\n```\n\n## Custom Resources in Minutes\n\nCreate new resource types with a simple function that implements create, update, and delete operations.\n\n```typescript\nexport const Database = Resource(\n  \"myservice::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete logic\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update logic\n      return this({ id: \"db-123\", ...props });\n    } else {\n      // Create logic\n      return this({ id: \"db-123\", ...props });\n    }\n  }\n);\n```\n\n## Optimized for AI\n\nAlchemy provides a `.cursorrules` file to help AI tools generate resource implementations at 90% accuracy on the first try.\n\n```typescript\n// 1. Copy Alchemy's .cursorrules into your repo\n// 2. Ask AI: \"Create a resource for Neon Database\"\n// 3. Get a working implementation in seconds\n\n// Result: Complete implementation with proper lifecycle handling\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    // Full resource implementation generated by AI\n  }\n);\n```\n\n[Learn more about AI-generated resources](./guides/custom-resources.md)\n\n## Fast Deployments\n\nAlchemy deployments are fast because they run directly in JavaScript without spawning external processes or slow toolchains.\n\n```typescript\n// No IPC, no Go toolchains, no CloudFormation waiting\n// Just direct JavaScript execution calling APIs\n// $ time bun ./alchemy.run.ts\n// real    0m1.234s\n```\n\n## Flexible Scoping\n\nAlchemy organizes resources with a hierarchical scope system that supports infinite nesting and isolation.\n\n```typescript\n// Root and stage scopes\nconst app = await alchemy(\"my-app\", { \n  stage: \"prod\",\n  password: \"prod-secret\"  // Encryption password for this scope\n});\n```\n\n## Secure Secrets\n\nAlchemy encrypts sensitive values in state files.\n\n```typescript\n// Define a secret\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\n// Use it in a resource\nconst worker = await Worker(\"api\", {\n  bindings: { API_KEY: apiKey }\n});\n\n// In state files, it's encrypted\n// \"API_KEY\": { \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\" }\n```\n\n## Scoped Encryption and State\n\nEach scope can have a different encryption password and state store.\n\n```ts\n// Nested scopes can have different passwords and state stores\nawait alchemy.run(\"backend\", { \n  password: \"backend-secret\",\n  stateStore: new DatabaseStateStore()\n}, async (scope) => {\n  // Create resources in this scope\n  await Worker(\"api\", { /* ... */ });\n  \n  // Deeper nesting works too\n  await alchemy.run(\"database\", async () => {\n    await Database(\"main\", { /* ... */ });\n  });\n});\n```\n\n## Application Examples\n\nAlchemy works for a wide range of infrastructure use cases.\n\n```typescript\n// Cloudflare Workers and Static Sites\nconst assets = await Assets(\"Assets\", {\n  path: \"./dist\"\n})\n\nconst site = await Worker(\"Website\", {\n  name: \"my-app\",\n  bindings: {\n    ASSETS: assets\n  }\n});\n\n// AWS Lambda Functions\nconst func = await Function(\"api\", {\n  handler: \"src/lambda.handler\",\n  environment: { TABLE_NAME: table.name }\n});\n\n// Third-party APIs like Stripe\nconst product = await Product(\"pro-plan\", {\n  name: \"Pro Plan\",\n  description: \"Professional subscription tier\"\n});\n```\n\n## Getting Started\n\nReady to try Alchemy? Check out our [Getting Started guide](./getting-started.md) to build your first Alchemy app.\n\n```\n\n// ./README.md\n```md\n# Alchemy\n\nAlchemy is an embeddable, zero-dependency, TypeScript-native Infrastructure-as-Code (IaC) library for modeling Resources that are Created, Updated and Deleted automatically.\n\nUnlike similar tools like Pulumi, Terraform, and CloudFormation, Alchemy is implemented in pure ESM-native TypeScript code with zero dependencies.\n\nResources are simple memoized async functions that can run in any JavaScript runtime, including the browser, serverless functions and durable workflows.\n\n```ts\nimport alchemy from \"alchemy\";\n\n// initialize the app (with default state $USER)\nconst app = await alchemy(\"cloudflare-worker\");\n\n// create a Cloudflare Worker\nexport const worker = await Worker(\"worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/index.ts\",\n  bindings: {\n    COUNTER: counter,\n    STORAGE: storage,\n    AUTH_STORE: authStore,\n    GITHUB_CLIENT_ID: alchemy.secret(process.env.GITHUB_CLIENT_ID),\n    GITHUB_CLIENT_SECRET: alchemy.secret(process.env.GITHUB_CLIENT_SECRET),\n  },\n});\n\n// finalize the alchemy app (triggering deletion of orphaned resources)\nawait app.finalize();\n```\n\n# Features\n\n- **JS-native** - no second language, toolchains, dependencies, processes, services, etc. to lug around.\n- **Async-native** - resources are just async functions - no complex abstraction to learn.\n- **ESM-native** - built exclusively on ESM, with a slight preference for modern JS runtimes like Bun.\n- **Embeddable** - runs in any JavaScript/TypeScript environment, including the browser!\n- **Extensible** - implement your own resources with a simple function.\n- **AI-first** - alchemy actively encourages you to use LLMs to create/copy/fork/modify resources to fit your needs. No more waiting around for a provider to be implemented, just do it yourself in a few minutes.\n- **No dependencies** - the `alchemy` core package has 0 required dependencies.\n- **No service** - state files are stored locally in your project and can be easily inspected, modified, checked into your repo, etc.\n- **No strong opinions** - structure your codebase however you want, store state anywhere - we don't care!\n\n# Examples\n\n- CloudFlare ViteJS Website + API Backend with Durable Objects: [examples/cloudflare-vite/](./examples/cloudflare-vite/alchemy.run.ts)\n- Deploy an AWS Lambda Function with a DynamoDB Table and IAM Role: [examples/aws-app/](./examples/aws-app/alchemy.run.ts)\n\n# Getting Started\n\nSee the [Getting Started Guide](https://alchemy.run/docs/getting-started.html).\n\n```\n\n// alchemy-web/docs/concepts/bindings.md\n```md\n---\norder: 100\n---\n\n# Bindings\n\nBindings allow resources to connect to each other in a type-safe way. In Alchemy, bindings are most commonly used with Cloudflare Workers to give them access to other resources.\n\n## What are Bindings?\n\nBindings expose resources to your code at runtime. For example, they allow a Cloudflare Worker to access:\n\n- KV Namespaces\n- Durable Objects\n- R2 Buckets\n- Secrets and variables\n\n## Using Bindings in Workers\n\n```typescript\n// alchemy.run.ts\nimport { Worker, KVNamespace } from \"alchemy/cloudflare\";\n\n// Create a KV namespace\nconst myKV = await KVNamespace(\"MY_KV\", {\n  title: \"my-kv-namespace\"\n});\n\n// Bind the KV namespace to a worker\nconst myWorker = await Worker(\"my-worker\", {\n  name: \"my-worker\",\n  entrypoint: \"./src/worker.ts\",\n  bindings: {\n    MY_KV: myKV,\n    API_KEY: \"secret-key\",\n    DEBUG_MODE: true\n  }\n});\n```\n\nThe worker can then access these bindings through the `env` parameter:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: any, ctx: any) {\n    // Access the KV namespace binding\n    const value = await env.MY_KV.get(\"key\");\n    \n    // Access other bindings\n    const apiKey = env.API_KEY;\n    const isDebug = env.DEBUG_MODE;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Type-Safe Bindings\n\nTo make bindings type-safe, create an `env.d.ts` file:\n\n```typescript\n/// <reference types=\"./env.d.ts\" />\n\nimport type { myWorker } from \"./alchemy.run\";\n\nexport type WorkerEnv = typeof myWorker.Env;\n\ndeclare module \"cloudflare:workers\" {\n  namespace Cloudflare {\n    export interface Env extends WorkerEnv {}\n  }\n}\n```\n\nThen, use the type in your worker:\n\n```typescript\n// src/worker.ts\nexport default {\n  async fetch(request: Request, env: Cloudflare.Env, ctx: any) {\n    // Type-safe access to bindings\n    const value = await env.MY_KV.get(\"key\");\n    const apiKey = env.API_KEY;\n    \n    return new Response(`Value: ${value}`);\n  }\n};\n```\n\n## Binding Types\n\nAlchemy supports several binding types:\n\n| Binding Type | Description | Example |\n|--------------|-------------|---------|\n| KV Namespace | Key-value storage | `MY_KV: myKV` |\n| Durable Object | Stateful objects | `COUNTER: counter` |\n| R2 Bucket | Object storage | `STORAGE: bucket` |\n| Secret | Sensitive value | `API_KEY: alchemy.secret(\"key\")` |\n| Variable | Plain text value | `DEBUG: \"true\"` |\n\n## Binding Resources vs Values\n\nAlchemy handles bindings differently based on what's being bound:\n\n```typescript\nconst worker = await Worker(\"worker\", {\n  // ...\n  bindings: {\n    // Resource bindings (automatically set up in Cloudflare)\n    KV_STORE: kvNamespace,\n    COUNTER: durableObject,\n    BUCKET: r2Bucket,\n    \n    // Value bindings (passed as environment variables)\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DEBUG: \"true\",\n    VERSION: \"1.0.0\"\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/destroy.md\n```md\n---\norder: 9\n---\n# Destroy\n\nResource destruction in Alchemy removes resources from both your state file and the underlying infrastructure.\n\n## Resource vs. Application Destruction\n\n### Application Destruction\n```typescript\n// Destroys all resources in the application\nconst app = await alchemy(\"my-app\", {\n  phase: \"destroy\"  // or process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n```\nUse for: Complete teardown of environments, cleaning up all infrastructure managed by the app.\n\n### Resource/Scope Destruction\n```typescript\n// Destroys only the specified resource(s)\nawait destroy(myResource);  // Single resource\nawait destroy(scope);       // All resources in scope\n```\nUse for: Targeted cleanup of specific resources or test resources without affecting the rest of your app.\n\n## Ways to Destroy Resources\n\n### 1. Code Removal\n\n```typescript\n// Remove or comment out resource declarations to destroy them\n// const myFile = await File(\"config.json\", { ... });\n```\n\n### 2. Using the --destroy Flag\n\n```typescript\n// In alchemy.run.ts\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\"\n});\n\n// Run with: bun ./alchemy.run.ts --destroy\n```\n\n### 3. Programmatic Destruction\n\n```typescript\n// Destroy a specific resource\nimport { destroy } from \"alchemy\";\nawait destroy(myFile);\n```\n\n## Destruction Order\n\nResources are destroyed in dependency order: dependents first, then dependencies.\n\n## Best Practices\n\n```typescript\n// When implementing custom resources, handle deletion phase\nif (this.phase === \"delete\") {\n  await api.delete(`/resources/${this.output.id}`);\n  return this.destroy();\n}\n```\n\n```\n\n// alchemy-web/docs/concepts/resource.md\n```md\n---\norder: 1\n---\n\n# Resource\n\nResources are the core building blocks of Alchemy. Each resource represents a piece of infrastructure or configuration that can be created, updated, and deleted automatically.\n\n## What is a Resource?\n\nA Resource is simply a memoized async function that implemented a lifecycle handler for three phases:\n1. `create` - what to do when first creating the resource\n2. `update` - what to do when updating a resource\n3. `delete` - what to when deleting a resource\n\n## Resource ID\n\nWhen creating a resource, you always pass an `id` that is unique within the Resource's [Scope](../concepts/scope.md).\n\n```ts\nawait MyResource(\"id\")\n```\n\nThis ID is what Alchemy uses to track the state of the resource and trigger the appropriate create/update/delete phase.\n\n## Resource Props\n\nEach Resource has an interface for its \"input properties\"\n\n```typescript\nexport interface DatabaseProps {\n  name: string;\n  branchId: string;\n  projectId: string;\n  // Other properties...\n}\n```\n\n## Resource Instance\n\nEach Resource has an interface for its \"output attributes\":\n\n```typescript\nexport interface Database extends Resource<\"neon::Database\">, DatabaseProps {\n  id: string;\n  createdAt: number;\n  // Additional properties...\n}\n```\n\n> [!CAUTION]\n> This interface must extend `Resource<..>`\n\n## Resource Provider\n\nEach Resource exports a \"Provider\" function with a globally unique name and an implementation of the lifecycle handler logic.\n\n```typescript\nexport const Database = Resource(\n  \"neon::Database\",\n  async function(this: Context<Database>, id: string, props: DatabaseProps): Promise<Database> {\n    if (this.phase === \"delete\") {\n      // Delete resource logic\n      // ...\n      return this.destroy();\n    } else if (this.phase === \"update\") {\n      // Update resource logic\n      // ...\n      return this({/* updated resource */});\n    } else {\n      // Create resource logic\n      // ...\n      return this({/* new resource */});\n    }\n  }\n);\n```\n\n> [!TIP]\n> By Convention, the name of this exported `const` should match the name of your Resource's interface.\n\nLet's break this down a bit futher, since it may seem confusing at first.\n\n## Resource FQN\n\nEach Resource has a globally unique name (aka. fully qualified name), e.g `\"neon:Database\"`:\n\n```ts\nexport const Database = Resource(\"neon::Database\"),\n```\n\nAlchemy and uses this FQN to delete orphaned resources (stored in your [State](../concepts/state.md) files) by looking up the corresponding \"provider\".\n\n## Lifecycle Function\n\nThe Resource's lifecycle handler is defined using an `async function` declaration with 3 required arguments:\n\n```ts\nasync function(\n  // the resource's state/context is bound to `this`\n  this: Context<Database>, \n  // the id of the resource (unique within a SCope)\n  id: string, \n  // the input properties\n  props: DatabaseProps\n): Promise<Database>\n```\n\n> [!CAUTION]\n> It must be function declaration (not an arrow function) because the Resource's context is passed through as the `this: Context<Database>` parameter.\n\n## Lifecycle Phases\n\nThe lifecycle handler is a simple function that handles the 3 phases: `\"create\"`, `\"update\"` or `\"delete\"`:\n\n```ts\nif (this.phase === \"delete\") {\n  // Delete resource logic\n  // ...\n  return this.destroy();\n} else if (this.phase === \"update\") {\n  // Update resource logic\n  // ...\n  return this({/* updated properties */});\n} else {\n  // Create resource logic\n  // ...\n  return this({/* initial properties */});\n}\n```\n\n## `this.destroy()`\n\nWhen a resource is being deleted, you must return `this.destroy()` to signal that the resource deletion process is complete.\n\n> [!TIP]\n> This also enables type inference since `this.destroy()` returns `never`, so the type of the resource can be inferred from the return type of the function.\n\n## `this({..})`\n\nTo construct the resource (including your properites and Alchemy's intrinsic properties), call `this(props)` with your output properties:\n\n```ts\nreturn this({/* updated properties */});\n```\n\nWhat's going on here? `this` is a function? Huh?\n\nAlchemy resources are implemented with pure functions, but are designed to emulate classes (except with an async constructor that implements a CRUD lifecycle handler).\n\n`this` is analagous to `super` in a standard class:\n```ts\nreturn super({/* updated properties */});\n```\n\n> [!TIP]\n> If this syntax freaks you out too much, it is also aliased as `this.create`:\n> ```ts\n> return this.create({/* updated properties */});\n> ```\n\n## Testing\n\nSee the [Testing](./testing.md) documentation for a comprehensive walkthrough on how to test your own resources.\n```\n\n// alchemy-web/docs/concepts/scope.md\n```md\n---\norder: 2\n---\n\n# Scope\n\nScopes in Alchemy are hierarchical containers that organize resources and other scopes, similar to a file system.\n\n```typescript\n// Scope hierarchy\napp (Application Scope)\n├── dev (Stage Scope)\n│   ├── api (Nested Scope)\n│   └── database (Resource)\n└── prod (Stage Scope)\n```\n\n## Application Scope\n\nThe top-level scope created using the `alchemy()` function:\n\n```typescript\nimport alchemy from \"alchemy\";\n\n// Create root scope\nconst app = await alchemy(\"my-app\");\n\n// Create a resource in this scope\nconst file = await File(\"config\", { path: \"./config.json\", content: \"{}\" });\n```\n\nState directory structure:\n```\n.alchemy/\n  my-app/  # Application scope\n    $USER/ # Default stage (username)\n      config.json\n```\n\n## Stage Scope\n\nA scope directly under the application scope for separating environments:\n\n```typescript\n// Create app with explicit stage\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\"\n});\n\n// Resource in prod stage\nconst database = await Database(\"main\", { /* props */ });\n```\n\n```\n.alchemy/\n  my-app/\n    prod/  ## Stage scope\n      main.json\n```\n\n## Resource Scope\n\nEach resource gets its own scope for managing child resources:\n\n```typescript\nexport const WebApp = Resource(\n  \"my::WebApp\",\n  async function (this, id, props) {\n    // Child resources automatically scoped to this WebApp\n    const database = await Database(\"db\", {});\n    const apiGateway = await ApiGateway(\"api\", {});\n    \n    return this({\n      id,\n      url: apiGateway.url,\n      dbConnectionString: database.connectionString\n    });\n  }\n);\n\n// Usage\nconst app = await WebApp(\"my-app\", {});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-app.json\n      my-app/  # Resource scope\n        db.json\n        api.json\n```\n\n## Nested Scope\n\nCreate custom nested scopes to organize related resources:\n\n```typescript\n// Create nested scopes\nawait alchemy.run(\"backend\", async () => {\n  await ApiGateway(\"api\", {});\n  await Function(\"handler\", {});\n});\n\nawait alchemy.run(\"frontend\", async () => {\n  await Bucket(\"assets\", {});\n});\n```\n\n```\n.alchemy/\n  my-app/\n    dev/\n      backend/\n        api.json\n        handler.json\n      frontend/\n        assets.json\n```\n\n## Scope Finalization\n\nWhen finalized, scopes delete any orphaned resources (resources in state but not in code):\n\n```typescript\nconst app = await alchemy(\"my-app\");\n\nawait Bucket(\"assets\", {});\n// If a previously existing resource is removed from code,\n// it will be deleted during finalization\n\nawait app.finalize(); // Manual finalization\n```\n\nApplication scopes need manual finalization, but nested scopes finalize automatically when their execution completes. \n\n## Test Scope\n\nAlchemy provides isolated test scopes that automatically clean up after tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport \"../../src/test/bun\";\n\n// Create test scope from filename\nconst test = alchemy.test(import.meta);\n\n// Each test gets an isolated sub-scope\ntest(\"create resource\", async (scope) => {\n  const resource = await Resource(\"test-resource\", {});\n  expect(resource.id).toBeTruthy();\n  // Resources auto-cleaned when test completes\n});\n```\n\nExample from Cloudflare Worker tests:\n\n```typescript\nimport { alchemy } from \"../../src/alchemy\";\nimport { Worker } from \"../../src/cloudflare/worker\";\nimport \"../../src/test/bun\";\nimport { BRANCH_PREFIX } from \"../util\";\n\nconst test = alchemy.test(import.meta, { prefix: BRANCH_PREFIX });\n\ndescribe(\"Worker Resource\", () => {\n  test(\"create worker\", async (scope) => {\n    const worker = await Worker(`${BRANCH_PREFIX}-test-worker`, {\n      script: \"// Worker code\",\n      format: \"esm\",\n    });\n    \n    expect(worker.id).toBeTruthy();\n  });\n});\n```\n\nFor more details on testing with Alchemy, see [Testing in Alchemy](./testing.md).\n\n```\n\n// alchemy-web/docs/concepts/secret.md\n```md\n---\norder: 4\n---\n\n# Secret\n\nAlchemy provides built-in mechanisms for handling sensitive data securely. This guide explains how to manage secrets in your Alchemy resources.\n\n## What are Secrets?\n\nSecrets in Alchemy are sensitive values that need special handling to prevent exposure in logs, state files, or source code. Examples include:\n\n- API keys and tokens\n- Passwords and credentials\n- Private certificates\n- Connection strings with credentials\n\n## Encryption Password\n\nSecrets are encrypted using a password that you provide when initializing your Alchemy app:\n\n```typescript\nconst app = await alchemy(\"my-app\", {\n  stage: \"dev\",\n  password: process.env.SECRET_PASSPHRASE,\n});\n```\n\n> [!IMPORTANT]\n> Always store your encryption password securely and never commit it to source control.\n\n## Using the alchemy.secret() Function\n\nThe primary way to handle secrets in Alchemy is with the `alchemy.secret()` function:\n\n```typescript\n// Create a secret from an environment variable\nconst apiKey = alchemy.secret(process.env.API_KEY);\n```\n\nWhen a secret is stored in state, it is automatically encrypted:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n## Multiple Secret Values\n\nYou can create multiple secrets in your application:\n\n```typescript\n// Create multiple secrets from environment variables\nconst apiKey = alchemy.secret(process.env.API_KEY);\nconst databaseUrl = alchemy.secret(process.env.DATABASE_URL);\nconst jwtSecret = alchemy.secret(process.env.JWT_SECRET);\n```\n\n## Using Secrets in Resources\n\nSecrets can be passed to resources like Cloudflare Workers. First, define your worker script:\n\n```typescript\n// worker-script.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    \n    if (url.pathname.startsWith('/env/')) {\n      const varName = url.pathname.split('/env/')[1];\n      const value = env[varName];\n      return new Response(value || 'undefined', { \n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n    }\n    \n    return new Response('Secret is safe: ' + env.API_KEY, { status: 200 });\n  }\n};\n```\n\nThen use the script and bind the secrets:\n\n```typescript\n// Use the script with secrets\nconst worker = await Worker(\"multi-secret-worker\", {\n  name: \"multi-secret-worker\",\n  script: workerScript,\n  format: \"esm\",\n  bindings: {\n    API_KEY: alchemy.secret(process.env.API_KEY),\n    DATABASE_URL: alchemy.secret(process.env.DATABASE_URL),\n    JWT_SECRET: alchemy.secret(process.env.JWT_SECRET)\n  }\n});\n```\n\n```\n\n// alchemy-web/docs/concepts/state.md\n```md\n---\norder: 3\n---\n\n# State\n\nAlchemy uses a transparent and pluggable state management system to track resource lifecycles and enable idempotent operations. It's designed to be simple, with multiple backend options ranging from local files to cloud storage.\n\n## What is State in Alchemy?\n\nState in Alchemy consists of resource data that tracks the current status, properties, and outputs of each resource. By default, it's stored in JSON files in a `.alchemy` directory, organized by app and stage:\n\n```\n.alchemy/\n  my-app/\n    dev/\n      my-resource.json\n      my-other-resource.json\n```\n\n## State File Structure\n\nEach state file contains the full information about a resource:\n\n```json\n{\n  \"provider\": \"service::ResourceName\",\n  \"data\": {},\n  \"status\": \"updated\",\n  \"output\": {\n    \"id\": \"resource-123\",\n    \"name\": \"My Resource\",\n    \"createdAt\": 1679012345678\n  },\n  \"props\": {\n    \"name\": \"My Resource\",\n    \"description\": \"This is a test resource\"\n  }\n}\n```\n\nThe state file includes:\n\n- **provider**: The resource type identifier\n- **data**: Internal provider-specific data\n- **status**: Current lifecycle status (created, updated, deleted)\n- **output**: The resource's current output values\n- **props**: The resource's input properties\n\n## How Alchemy Uses State\n\nAlchemy uses state to determine the appropriate action for each resource:\n\n1. **No state file**: The resource is created\n2. **State exists + props unchanged**: The resource is skipped\n3. **State exists + props changed**: The resource is updated\n4. **Resource removed from code**: The resource is deleted\n\nThis approach enables idempotent operations - running the same code multiple times produces the same result, avoiding duplicate resource creation.\n\n## State Location\n\nBy default, Alchemy stores state files in the `.alchemy` directory in your project root. This approach has several benefits:\n\n- **Transparency**: State files are plain JSON and can be inspected and modified manually\n- **Versioning**: State can be committed to source control with your code\n- **Portability**: No external service dependencies required\n\n## State Inspection\n\nState files can be directly inspected:\n\n```bash\ncat .alchemy/my-app/dev/my-resource.json\n```\n\nThis transparency helps with debugging and understanding what Alchemy is doing.\n\n## Customizing State Storage\n\nAlchemy supports multiple state storage backends. You can use the default file system store or integrate with cloud services like Cloudflare R2:\n\n```typescript\n// Example with Cloudflare R2 state store\nconst app = await alchemy(\"my-app\", {\n  stage: \"prod\",\n  phase: process.argv.includes(\"--destroy\") ? \"destroy\" : \"up\",\n  stateStore: (scope) => new R2RestStateStore(scope, {\n    apiKey: alchemy.secret(process.env.CLOUDFLARE_API_KEY),\n    email: process.env.CLOUDFLARE_EMAIL,\n    bucketName: process.env.CLOUDFLARE_BUCKET_NAME!,\n  })\n});\n```\n\n> [!TIP]\n> Learn how to implement your own state storage in [Custom State Stores Guide](../guides/custom-state-store.md)\n\n## Security and Secrets\n\nState files may contain sensitive information. Alchemy provides a mechanism to encrypt sensitive values using the `alchemy.secret()` function:\n\n```typescript\nconst apiKey = alchemy.secret(process.env.API_KEY);\n\nawait ApiResource(\"my-api\", {\n  key: apiKey\n});\n```\n\nSecrets are encrypted in state files:\n\n```json\n{\n  \"props\": {\n    \"key\": {\n      \"@secret\": \"Tgz3e/WAscu4U1oanm5S4YXH...\"\n    }\n  }\n}\n```\n\n> [!IMPORTANT]\n> Always use `alchemy.secret()` for sensitive values to prevent them from being stored in plain text.\n\n> [!NOTE]\n> Learn more about secrets management in [Concepts: Secrets](./secret.md)\n\n```\n\n// alchemy-web/docs/concepts/testing.md\n```md\n---\norder: 5\n---\n\n# Testing\n\nAlchemy resources are easy to test since they're just functions, but Alchemy also offers a simple `alchemy.test` utility to help isolate your [Scopes](../concepts/scope.md) for each test suite.\n\n## Test Setup\n\nImport alchemy's test utility and your resource:\n\n```typescript\nimport { describe, expect } from \"bun:test\";\nimport alchemy, { destroy } from \"alchemy\";\nimport { Database } from \"../src/neon/database\";\n\n// make sure to augment `alchemy` by importing your preferred testing utility\nimport \"alchemy/test/bun\";\n```\n\n## Test Scope Creation\n\nCreate a `test` function at the top of your test suite:\n\n```typescript\n// Create test scope using filename\nconst test = alchemy.test(import.meta);\n```\n\nWe pass `import.meta` so that all the resources created in this test suite will be isolated from other tests.\n\n## Resource Test Implementation\n\nNow, create a test as you ordinarily would:\n\n```typescript\ntest(\"create, update, and delete database\", async (scope) => {\n  // ..\n});\n```\n\nNote how our test is passed a `scope` value - we'll use that at the end to clean up our resources.\n\nInside our test, we can simple create and update our resources, make assertions, etc.:\n```ts\n// Create resource\nlet database = await Database(testId, {\n  name: `${testId}-db`,\n  // Other required properties...\n});\n\n// Test assertions\nexpect(database.id).toBeTruthy();\n\n// Update resource\ndatabase = await Database(testId, {\n  // Updated properties...\n});\n```\n\nFinally, wrap all of this in a `try-finally` so that we can ensure our test resources are cleaned up.\n\n```ts\ntry {\n  // (create, update and assertions)\n} finally {\n  // delete all resources\n  await destroy(scope);\n  \n  // Verify resource was deleted if you want to\n}\n```\n\n> [!TIP]\n> It's recommended to use a `try-finally` so that you can assert the resource was actually deleted. \n\n\n```\n\n// alchemy/src/cloudflare/account-api-token.ts\n```ts\nimport { alchemy } from \"../alchemy\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { Secret } from \"../secret\";\nimport { sha256 } from \"../util/sha256\";\nimport { createCloudflareApi, type CloudflareApiOptions } from \"./api\";\n\n/**\n * Permission group for a token policy\n */\nexport interface TokenPolicyPermissionGroup {\n  /**\n   * ID of the permission group\n   */\n  id: string;\n\n  /**\n   * Optional metadata for the permission group\n   */\n  meta?: Record<string, any>;\n}\n\n/**\n * Policy that defines what the token can access\n */\nexport interface TokenPolicy {\n  /**\n   * Effect of the policy\n   */\n  effect: \"allow\" | \"deny\";\n\n  /**\n   * Permission groups to include in the policy\n   */\n  permissionGroups: TokenPolicyPermissionGroup[];\n\n  /**\n   * Resources the policy applies to\n   */\n  resources: Record<string, string>;\n}\n\n/**\n * Condition for token usage (e.g., IP restrictions)\n */\nexport interface TokenCondition {\n  /**\n   * IP address conditions\n   */\n  requestIp?: {\n    /**\n     * IP ranges to allow\n     */\n    in?: string[];\n\n    /**\n     * IP ranges to deny\n     */\n    notIn?: string[];\n  };\n}\n\n/**\n * Properties for creating or updating an Account API Token\n */\nexport interface AccountApiTokenProps extends CloudflareApiOptions {\n  /**\n   * Name of the token\n   */\n  name: string;\n\n  /**\n   * Policies that define what the token can access\n   */\n  policies: TokenPolicy[];\n\n  /**\n   * Optional expiration date for the token (ISO format)\n   */\n  expiresOn?: string;\n\n  /**\n   * Optional \"not before\" date (token is not valid before this date) (ISO format)\n   */\n  notBefore?: string;\n\n  /**\n   * Optional conditions for token use (like IP restrictions)\n   */\n  condition?: TokenCondition;\n}\n\n/**\n * Cloudflare API token format as returned by the API\n */\ninterface CloudflareApiToken {\n  id: string;\n  name: string;\n  status: string;\n  policies: {\n    effect: \"allow\" | \"deny\";\n    permission_groups: {\n      id: string;\n      meta: Record<string, any>;\n    }[];\n    resources: Record<string, string>;\n  }[];\n  expires_on?: string;\n  not_before?: string;\n  condition?: {\n    request_ip?: {\n      in?: string[];\n      not_in?: string[];\n    };\n  };\n  value?: string;\n}\n\n/**\n * Output returned after Account API Token creation/update\n */\nexport interface AccountApiToken\n  extends Resource<\"cloudflare::AccountApiToken\">,\n    AccountApiTokenProps {\n  /**\n   * The ID of the token\n   *\n   * Equiv. to ACCESS_KEY_ID\n   */\n  id: string;\n\n  /**\n   * Status of the token\n   */\n  status: string;\n\n  /**\n   * Actual token value (only available on creation)\n   * Stored as a Secret for security\n   *\n   * Equiv. to SECRET_ACCESS_KEY\n   */\n  value?: Secret;\n\n  /**\n   * Access key ID for the token\n   *\n   * An alias of {@link id}\n   */\n  accessKeyId: string;\n\n  /**\n   * Secret access key for the token\n   *\n   * The SHA-256 hash of the token {@link value}\n   *\n   * @see https://developers.cloudflare.com/r2/api/tokens/#get-s3-api-credentials-from-an-api-token\n   */\n  secretAccessKey: string;\n}\n\n/**\n * Creates a Cloudflare Account API Token with specified permissions.\n *\n * Note: Requires a Cloudflare API Key or Token with admin-level account access.\n * The OAuth token from `wrangler login` is NOT sufficient for this operation.\n * You must use an API token with permission to manage account API tokens.\n *\n * @see https://developers.cloudflare.com/api/resources/accounts/subresources/tokens/methods/create/\n *\n * @example\n * // First, fetch all permission groups\n * const permissions = await PermissionGroups(\"cloudflare-permissions\", {\n *   accountId: cfAccountId,\n * });\n *\n * // Create a token with read-only permissions for specific zones\n * const readOnlyToken = await AccountApiToken(\"readonly-token\", {\n *   name: \"Readonly Zone Token\",\n *   policies: [\n *     {\n *       effect: \"allow\",\n *       permissionGroups: [\n *         { id: permissions[\"Zone Read\"].id },\n *         { id: permissions[\"Analytics Read\"].id }\n *       ],\n *       resources: {\n *         \"com.cloudflare.api.account.zone.22b1de5f1c0e4b3ea97bb1e963b06a43\": \"*\",\n *         \"com.cloudflare.api.account.zone.eb78d65290b24279ba6f44721b3ea3c4\": \"*\"\n *       }\n *     }\n *   ],\n *   expiresOn: \"2024-12-31T23:59:59Z\"\n * });\n *\n * @example\n * // Create a token with time and IP restrictions\n * const restrictedToken = await AccountApiToken(\"restricted-token\", {\n *   name: \"Restricted Access Token\",\n *   policies: [\n *     {\n *       effect: \"allow\",\n *       permissionGroups: [\n *         { id: permissions[\"Worker Routes Edit\"].id }\n *       ],\n *       resources: {\n *         \"com.cloudflare.api.account.worker.route.*\": \"*\"\n *       }\n *     }\n *   ],\n *   notBefore: \"2023-01-01T00:00:00Z\",\n *   expiresOn: \"2023-12-31T23:59:59Z\",\n *   condition: {\n *     requestIp: {\n *       in: [\"192.168.1.0/24\", \"10.0.0.0/8\"],\n *       notIn: [\"192.168.1.100/32\"]\n *     }\n *   }\n * });\n */\nexport const AccountApiToken = Resource(\n  \"cloudflare::AccountApiToken\",\n  async function (\n    this: Context<AccountApiToken>,\n    id: string,\n    props: AccountApiTokenProps\n  ): Promise<AccountApiToken> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    if (this.phase === \"delete\") {\n      // Delete token if we have an ID\n      if (this.output?.id) {\n        try {\n          const deleteResponse = await api.delete(\n            `/accounts/${api.accountId}/tokens/${this.output.id}`\n          );\n\n          if (!deleteResponse.ok && deleteResponse.status !== 404) {\n            const errorData: any = await deleteResponse.json().catch(() => ({\n              errors: [{ message: deleteResponse.statusText }],\n            }));\n            console.error(`Error deleting token '${props.name}':`, errorData);\n          }\n        } catch (error) {\n          console.error(`Error deleting token '${props.name}':`, error);\n        }\n      }\n\n      // Return destroyed state\n      return this.destroy();\n    }\n\n    // Transform our properties to API format\n    const apiPayload = {\n      name: props.name,\n      policies: props.policies.map((policy) => ({\n        effect: policy.effect,\n        permission_groups: policy.permissionGroups.map((pg) => ({\n          id: pg.id,\n          meta: pg.meta || {},\n        })),\n        resources: policy.resources,\n      })),\n      // Format dates for Cloudflare API (removing milliseconds)\n      ...(props.expiresOn\n        ? { expires_on: formatCloudflareDate(props.expiresOn) }\n        : {}),\n      ...(props.notBefore\n        ? { not_before: formatCloudflareDate(props.notBefore) }\n        : {}),\n      ...(props.condition\n        ? {\n            condition: {\n              request_ip: props.condition.requestIp\n                ? {\n                    in: props.condition.requestIp.in || [],\n                    not_in: props.condition.requestIp.notIn || [],\n                  }\n                : undefined,\n            },\n          }\n        : {}),\n    };\n\n    /**\n     * Formats a date string for Cloudflare API by removing milliseconds\n     * Converts from \"2023-01-01T00:00:00.000Z\" to \"2023-01-01T00:00:00Z\"\n     */\n    function formatCloudflareDate(dateStr: string): string {\n      return dateStr.replace(/\\.\\d{3}Z$/, \"Z\");\n    }\n\n    let response;\n    let tokenValue;\n\n    if (this.phase === \"update\" && this.output?.id) {\n      // Update existing token\n      response = await api.put(\n        `/accounts/${api.accountId}/tokens/${this.output.id}`,\n        apiPayload\n      );\n    } else {\n      // Create new token\n      response = await api.post(\n        `/accounts/${api.accountId}/tokens`,\n        apiPayload\n      );\n    }\n\n    if (!response.ok) {\n      const errorData: any = await response.json().catch(() => ({\n        errors: [{ message: response.statusText }],\n      }));\n\n      throw new Error(\n        `Error ${this.phase === \"update\" ? \"updating\" : \"creating\"} token '${props.name}': ${\n          errorData.errors?.[0]?.message || response.statusText\n        }`\n      );\n    }\n\n    const result: { result: CloudflareApiToken } = await response.json();\n    const tokenData = result.result;\n\n    if (tokenData.value) {\n      tokenValue = alchemy.secret(tokenData.value);\n    } else {\n      if (!this.output?.value) {\n        throw new Error(\n          `Token '${props.name}' was created but we have no record of its value. Try deleting and recreating the token.`\n        );\n      }\n      tokenValue = this.output?.value;\n    }\n\n    // Transform API response to our format\n    return this({\n      id: tokenData.id,\n      name: tokenData.name,\n      status: tokenData.status,\n      policies: tokenData.policies.map((policy) => ({\n        effect: policy.effect,\n        permissionGroups: policy.permission_groups.map((pg) => ({\n          id: pg.id,\n          meta: pg.meta,\n        })),\n        resources: policy.resources,\n      })),\n      ...(tokenData.expires_on ? { expiresOn: tokenData.expires_on } : {}),\n      ...(tokenData.not_before ? { notBefore: tokenData.not_before } : {}),\n      ...(tokenData.condition\n        ? {\n            condition: {\n              requestIp: tokenData.condition.request_ip\n                ? {\n                    in: tokenData.condition.request_ip.in || [],\n                    notIn: tokenData.condition.request_ip.not_in || [],\n                  }\n                : undefined,\n            },\n          }\n        : {}),\n      value: tokenValue,\n      accessKeyId: tokenData.id,\n      secretAccessKey: sha256(tokenValue.unencrypted),\n    });\n  }\n);\n\n```\n\n// alchemy/src/cloudflare/account-id.ts\n```ts\nimport { getCloudflareUserInfo, type CloudflareAuthOptions } from \"./auth\";\n\nexport type CloudflareAccountId = string & {\n  readonly __brand: \"CloudflareAccountId\";\n};\n\nexport async function CloudflareAccountId(\n  options: CloudflareAuthOptions\n): Promise<CloudflareAccountId> {\n  const userInfo = await getCloudflareUserInfo(options);\n  return userInfo.accounts[0].id as CloudflareAccountId;\n}\n\n```\n\n// alchemy/src/cloudflare/api-error.ts\n```ts\n/**\n * Custom error class for Cloudflare API errors\n * Includes HTTP status information from the Response\n */\nexport class CloudflareApiError extends Error {\n  /**\n   * HTTP status code\n   */\n  status: number;\n\n  /**\n   * HTTP status text\n   */\n  statusText: string;\n\n  /**\n   * Raw error data from the API\n   */\n  errorData?: any;\n\n  /**\n   * Create a new CloudflareApiError\n   */\n  constructor(message: string, response: Response, errorData?: any) {\n    super(message);\n    this.name = \"CloudflareApiError\";\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.errorData = errorData;\n\n    // Ensure instanceof works correctly\n    Object.setPrototypeOf(this, CloudflareApiError.prototype);\n  }\n}\n\n/**\n * Helper function to handle API errors\n *\n * @param response The fetch Response object\n * @param action The action being performed (e.g., \"creating\", \"deleting\")\n * @param resourceType The type of resource being acted upon (e.g., \"R2 bucket\", \"Worker\")\n * @param resourceName The name/identifier of the specific resource\n * @returns Never returns - always throws an error\n */\nexport async function handleApiError(\n  response: Response,\n  action: string,\n  resourceType: string,\n  resourceName: string\n): Promise<never> {\n  const text = await response.text();\n  let json: any;\n  try {\n    json = JSON.parse(text);\n  } catch (error) {\n    json = { errors: [{ message: text }] };\n  }\n  const errors: { message: string }[] = json?.errors || [\n    { message: response.statusText },\n  ];\n  const errorMessage = `Error ${action} ${resourceType} '${resourceName}': ${errors[0]?.message || response.statusText}`;\n  throw new CloudflareApiError(errorMessage, response, errors);\n}\n\n```\n\n// alchemy/src/cloudflare/api.ts\n```ts\nimport type { Secret } from \"../secret\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport { getCloudflareAuthHeaders, getCloudflareUserInfo } from \"./auth\";\n\n/**\n * Options for Cloudflare API requests\n */\nexport interface CloudflareApiOptions {\n  /**\n   * Base URL for Cloudflare API\n   *\n   * @default https://api.cloudflare.com/client/v4\n   */\n  baseUrl?: string;\n\n  /**\n   * API Key to use (overrides CLOUDFLARE_API_KEY env var)\n   */\n  apiKey?: Secret;\n\n  /**\n   * API Token to use (overrides CLOUDFLARE_API_TOKEN env var)\n   */\n  apiToken?: Secret;\n\n  /**\n   * Account ID to use (overrides CLOUDFLARE_ACCOUNT_ID env var)\n   * If not provided, will be automatically retrieved from the Cloudflare API\n   */\n  accountId?: string;\n\n  /**\n   * Zone ID to use (overrides CLOUDFLARE_ZONE_ID env var)\n   */\n  zoneId?: string;\n\n  /**\n   * Email to use with API Key authentication\n   * If not provided, will attempt to discover from Cloudflare API\n   */\n  email?: string;\n}\n\n/**\n * Creates a CloudflareApi instance with automatic account ID discovery if not provided\n *\n * @param options API options\n * @returns Promise resolving to a CloudflareApi instance\n */\nexport async function createCloudflareApi(\n  options: Partial<CloudflareApiOptions> = {}\n): Promise<CloudflareApi> {\n  const userInfo = await getCloudflareUserInfo(options);\n  return new CloudflareApi({\n    baseUrl: options.baseUrl,\n    accountId: options.accountId ?? userInfo.accounts[0].id!,\n    email: userInfo.email!,\n    apiKey: userInfo.apiKey,\n    apiToken: userInfo.apiToken,\n    zoneId: options.zoneId,\n  });\n}\n\n/**\n * Cloudflare API client using raw fetch\n */\nexport class CloudflareApi {\n  public readonly accountId: string;\n  public readonly baseUrl: string;\n  /**\n   * Create a new Cloudflare API client\n   * Use createCloudflareApi factory function instead of direct constructor\n   * for automatic account ID discovery.\n   *\n   * @param options API options\n   */\n  constructor(\n    private readonly options: CloudflareApiOptions & {\n      accountId: string;\n    }\n  ) {\n    this.accountId = options.accountId;\n    this.baseUrl = options.baseUrl ?? \"https://api.cloudflare.com/client/v4\";\n  }\n\n  /**\n   * Make a fetch request to the Cloudflare API\n   *\n   * @param path API path (without base URL)\n   * @param init Fetch init options\n   * @returns Raw Response object from fetch\n   */\n  async fetch(path: string, init: RequestInit = {}): Promise<Response> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n    if (Array.isArray(init.headers)) {\n      init.headers.forEach(([key, value]) => {\n        headers[key] = value;\n      });\n    } else if (init.headers instanceof Headers) {\n      init.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n    } else if (init.headers) {\n      headers = init.headers;\n    }\n    headers = {\n      ...(await getCloudflareAuthHeaders(this.options)),\n      ...headers,\n    };\n\n    // TODO(sam): is this necessary?\n    if (init.body instanceof FormData) {\n      delete headers[\"Content-Type\"];\n    }\n\n    // Use withExponentialBackoff for automatic retry on network errors\n    return withExponentialBackoff(\n      () =>\n        fetch(`${this.baseUrl}${path}`, {\n          ...init,\n          headers,\n        }),\n      (error) => {\n        // Only retry on network-related errors\n        const errorMsg = (error as Error).message || \"\";\n        const isNetworkError =\n          errorMsg.includes(\"socket connection was closed\") ||\n          errorMsg.includes(\"ECONNRESET\") ||\n          errorMsg.includes(\"ETIMEDOUT\") ||\n          errorMsg.includes(\"ECONNREFUSED\");\n\n        return isNetworkError;\n      },\n      5, // Maximum 5 attempts (1 initial + 4 retries)\n      1000 // Start with 1s delay, will exponentially increase\n    );\n  }\n\n  /**\n   * Helper for GET requests\n   */\n  async get(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"GET\" });\n  }\n\n  /**\n   * Helper for HEAD requests\n   */\n  async head(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"HEAD\" });\n  }\n  /**\n   * Helper for POST requests\n   */\n  async post(\n    path: string,\n    body: any,\n    init: RequestInit = {}\n  ): Promise<Response> {\n    const requestBody =\n      body instanceof FormData\n        ? body\n        : typeof body === \"string\"\n          ? body\n          : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"POST\", body: requestBody });\n  }\n\n  /**\n   * Helper for PUT requests\n   */\n  async put(\n    path: string,\n    body: any,\n    init: RequestInit = {}\n  ): Promise<Response> {\n    const requestBody = body instanceof FormData ? body : JSON.stringify(body);\n    return this.fetch(path, { ...init, method: \"PUT\", body: requestBody });\n  }\n\n  /**\n   * Helper for PATCH requests\n   */\n  async patch(\n    path: string,\n    body: any,\n    init: RequestInit = {}\n  ): Promise<Response> {\n    return this.fetch(path, {\n      ...init,\n      method: \"PATCH\",\n      body: JSON.stringify(body),\n    });\n  }\n\n  /**\n   * Helper for DELETE requests\n   */\n  async delete(path: string, init: RequestInit = {}): Promise<Response> {\n    return this.fetch(path, { ...init, method: \"DELETE\" });\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/asset-manifest.ts\n```ts\nexport type AssetManifest = AssetManifestEntry[];\n\nexport interface AssetManifestEntry {\n  source: string;\n  key: string;\n  hash: string;\n  cacheControl: string;\n  contentType?: string;\n}\n\nexport interface FileOption {\n  files: string | string[];\n  cacheControl: string;\n  contentType?: string;\n  ignore?: string[];\n}\n\n```\n\n// alchemy/src/cloudflare/assets.ts\n```ts\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { getContentType } from \"../util/content-type\";\n\n/**\n * Properties for creating or updating Assets\n */\nexport interface AssetsProps {\n  /**\n   * Path to a directory containing static assets to be uploaded\n   * These files will be served by Cloudflare's Workers runtime\n   */\n  path: string;\n}\n\n/**\n * Output returned after Assets creation/update\n */\nexport interface Assets extends Resource<\"cloudflare::Asset\">, AssetsProps {\n  /**\n   * The type of binding\n   */\n  type: \"assets\";\n\n  /**\n   * The ID of the assets bundle\n   */\n  id: string;\n\n  /**\n   * Asset files that were found\n   */\n  files: AssetFile[];\n\n  /**\n   * Time at which the assets were created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the assets were last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Represents a single asset file\n */\nexport interface AssetFile {\n  /**\n   * Path relative to the assets directory\n   */\n  path: string;\n\n  /**\n   * Full filesystem path to the file\n   */\n  filePath: string;\n\n  /**\n   * Content type of the file\n   */\n  contentType: string;\n}\n\n/**\n * Cloudflare Assets represent a collection of static files that can be uploaded and served\n * by Cloudflare Workers.\n *\n * @example\n * // Create a basic assets bundle from a local directory\n * const staticAssets = await Assets(\"static\", {\n *   path: \"./src/assets\"\n * });\n *\n * // Use these assets with a worker\n * const worker = await Worker(\"frontend\", {\n *   name: \"frontend-worker\",\n *   entrypoint: \"./src/worker.ts\",\n *   bindings: {\n *     ASSETS: staticAssets\n *   }\n * });\n */\nexport const Assets = Resource(\n  \"cloudflare::Asset\",\n  {\n    alwaysUpdate: true,\n  },\n  async function (\n    this: Context<Assets>,\n    id: string,\n    props: AssetsProps\n  ): Promise<Assets> {\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    try {\n      // Check if the assets directory exists\n      const stats = await fs.stat(props.path);\n      if (!stats.isDirectory()) {\n        throw new Error(`Assets path ${props.path} is not a directory`);\n      }\n    } catch (error) {\n      throw new Error(\n        `Assets directory ${props.path} does not exist or is not accessible`\n      );\n    }\n\n    // Recursively get all files in the assets directory\n    const filesList = await getFilesRecursively(props.path);\n\n    // Create asset file objects\n    const files: AssetFile[] = filesList.map((filePath) => {\n      const relativePath = path.relative(props.path, filePath);\n      const normalizedPath = relativePath.split(path.sep).join(\"/\"); // Ensure forward slashes for URLs\n\n      return {\n        path: normalizedPath,\n        filePath,\n        contentType: getContentType(filePath),\n      };\n    });\n\n    // Get current timestamp\n    const now = Date.now();\n\n    // Construct the output\n    return this({\n      id,\n      type: \"assets\",\n      path: props.path,\n      files,\n      createdAt: this.output?.createdAt || now,\n      updatedAt: now,\n    });\n  }\n);\n\n// Helper functions for file operations\nasync function getFilesRecursively(dir: string): Promise<string[]> {\n  const files = await fs.readdir(dir, { withFileTypes: true });\n\n  const allFiles = await Promise.all(\n    files.map(async (file) => {\n      const path = `${dir}/${file.name}`;\n      if (file.isDirectory()) {\n        return getFilesRecursively(path);\n      }\n      return path;\n    })\n  );\n\n  return allFiles.flat();\n}\n\n```\n\n// alchemy/src/cloudflare/auth.ts\n```ts\nimport fs from \"node:fs/promises\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport type { Secret } from \"../secret\";\nimport type { CloudflareAccountId } from \"./account-id\";\nimport { handleApiError } from \"./api-error\";\n/**\n * Authentication options for Cloudflare API\n */\nexport interface CloudflareAuthOptions {\n  /**\n   * API Key to use with API Key\n   */\n  apiKey?: Secret;\n\n  /**\n   * API Token to use with API Key\n   */\n  apiToken?: Secret;\n\n  /**\n   * Email to use with API Key\n   * If not provided, will attempt to discover from Cloudflare API\n   */\n  email?: string;\n}\n\nexport interface CloudflareAccount {\n  name: string;\n  id: CloudflareAccountId;\n  type: \"standard\" | \"zero_rating\" | \"full_control\";\n  settings: {\n    enforce_twofactor: boolean;\n    api_access_enabled: null;\n    access_approval_expiry: null;\n    abuse_contact_email: null;\n  };\n  legacy_flags: {\n    enterprise_zone_quota: {\n      maximum: number;\n      current: number;\n      available: number;\n    };\n  };\n}\n\nexport interface CloudflareUserInfo {\n  apiToken?: Secret;\n  apiKey?: Secret;\n  email: string;\n  username: string;\n  accounts: CloudflareAccount[];\n  organizations: CloudflareOrganization[];\n  tokenPermissions: string[] | undefined;\n  first_name: string | null;\n  last_name: string | null;\n  telephone: string | null;\n  country: string | null;\n  zipcode: string | null;\n  two_factor_authentication_enabled: boolean;\n  two_factor_authentication_locked: boolean;\n  has_pro_zones: boolean;\n  has_business_zones: boolean;\n  has_enterprise_zones: boolean;\n  suspended: boolean;\n  betas: string[];\n}\n\nexport interface CloudflareOrganization {\n  id: string;\n  name: string;\n  status: string;\n  permissions: string[];\n  roles: string[];\n}\n\nconst userInfoCache: Record<string, CloudflareUserInfo> = {};\n\nexport async function getCloudflareUserInfo(\n  options: CloudflareAuthOptions\n): Promise<CloudflareUserInfo> {\n  const cacheKey = JSON.stringify({\n    apiKey: options.apiKey?.unencrypted,\n    apiToken: options.apiToken?.unencrypted,\n    email: options.email,\n  });\n  if (userInfoCache[cacheKey]) {\n    return userInfoCache[cacheKey];\n  }\n  const headers = await getCloudflareAuthHeaders(options);\n  const user = await fetch(\"https://api.cloudflare.com/client/v4/user\", {\n    headers,\n  });\n  if (!user.ok) {\n    if (user.status === 403) {\n      throw new Error(\n        \"Cloudflare authentication required. Did you forget to login with `wrangler login` or set CLOUDFLARE_API_TOKEN, CLOUDFLARE_API_KEY, or CLOUDFLARE_EMAIL, or CLOUDFLARE_API_KEY?\"\n      );\n    }\n    await handleApiError(user, \"getting\", \"user\", \"user\");\n  }\n  const accounts = await fetch(\n    \"https://api.cloudflare.com/client/v4/accounts\",\n    {\n      headers,\n    }\n  );\n  const userInfo: CloudflareUserInfo = {\n    ...((await user.json()) as any).result,\n    accounts: ((await accounts.json()) as any).result,\n  };\n  userInfoCache[cacheKey] = userInfo;\n  return userInfo;\n}\n\nexport async function getCloudflareAuthHeaders(\n  options: CloudflareAuthOptions = {}\n): Promise<Record<string, string>> {\n  // Check for API Token (preferred method)\n  const apiToken =\n    options.apiToken?.unencrypted ?? process.env.CLOUDFLARE_API_TOKEN;\n  if (apiToken) {\n    return {\n      Authorization: `Bearer ${apiToken}`,\n    };\n  }\n\n  // Check for API Key\n  const apiKey = options.apiKey?.unencrypted ?? process.env.CLOUDFLARE_API_KEY;\n  if (apiKey) {\n    return {\n      \"X-Auth-Key\": apiKey,\n      \"X-Auth-Email\":\n        options.email ??\n        process.env.CLOUDFLARE_EMAIL ??\n        (await getUserEmailFromApiKey(apiKey)),\n    };\n  }\n\n  const authConfig = await getRefreshedAuthConfig();\n  if (authConfig.oauth_token) {\n    return {\n      Authorization: `Bearer ${authConfig.oauth_token}`,\n    };\n  }\n\n  throw new Error(\n    \"Cloudflare authentication required. Did you forget to login with `wrangler login` or set CLOUDFLARE_API_TOKEN, CLOUDFLARE_API_KEY, or CLOUDFLARE_EMAIL, or CLOUDFLARE_API_KEY?\"\n  );\n}\n\nconst emailCache: Record<string, string> = {};\n\nasync function getUserEmailFromApiKey(apiKey: string): Promise<string> {\n  if (emailCache[apiKey]) {\n    return emailCache[apiKey];\n  }\n\n  try {\n    const baseUrl = \"https://api.cloudflare.com/client/v4\";\n\n    // Call the /user endpoint to get user information\n    const response = await fetch(`${baseUrl}/user`, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Auth-Key\": apiKey,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to get user information: ${response.status} ${response.statusText}`\n      );\n    }\n\n    const data = (await response.json()) as {\n      success: boolean;\n      result: {\n        id: string;\n        email: string;\n        name: string;\n        [key: string]: any;\n      };\n    };\n\n    if (!data.success || !data.result || !data.result.email) {\n      throw new Error(\"Cloudflare API did not return valid user information\");\n    }\n\n    emailCache[apiKey] = data.result.email;\n    return data.result.email;\n  } catch (error) {\n    console.error(\"Error retrieving email from Cloudflare API:\", error);\n    throw new Error(\n      \"Failed to automatically discover email for API Key authentication\"\n    );\n  }\n}\n\nasync function refreshAuthToken(\n  options: WranglerConfig\n): Promise<WranglerConfig> {\n  const response = await fetch(\"https://dash.cloudflare.com/oauth2/token\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    body: new URLSearchParams({\n      grant_type: \"refresh_token\",\n      refresh_token: options.refresh_token!,\n      client_id: \"54d11594-84e4-41aa-b438-e81b8fa78ee7\",\n    }).toString(),\n  });\n\n  if (!response.ok) {\n    throw new Error(\n      `Failed to refresh auth token: ${response.status} ${response.statusText}`\n    );\n  }\n\n  const data: any = await response.json();\n  if (!data.access_token) {\n    throw new Error(\"Failed to refresh auth token - no access token returned\");\n  }\n\n  options.oauth_token = data.access_token;\n  options.refresh_token = data.refresh_token;\n  options.expiration_time = new Date(\n    Date.now() + data.expires_in * 1000\n  ).toISOString();\n  options.scopes = data.scope?.split(\" \") || [];\n\n  return options;\n}\n\ninterface WranglerConfig {\n  path: string;\n  oauth_token?: string;\n  refresh_token?: string;\n  expiration_time?: string;\n  scopes?: string[];\n  /** @deprecated - this field was only provided by the deprecated v1 `wrangler config` command. */\n  api_token?: string;\n}\n\nasync function getRefreshedAuthConfig(): Promise<WranglerConfig> {\n  let authConfig = await readWranglerConfig();\n  if (authConfig.expiration_time) {\n    const expiry = new Date(authConfig.expiration_time);\n    // if expiring in 10s\n    if (expiry.getTime() < Date.now() + 10 * 1000) {\n      authConfig = await refreshAuthToken(authConfig);\n      authConfigCache[authConfig.path] = authConfig;\n      await writeWranglerConfig(authConfig);\n    }\n  }\n  return authConfig;\n}\n\nasync function writeWranglerConfig(config: WranglerConfig) {\n  const TOML = await import(\"@iarna/toml\");\n  const configPath = await findWranglerConfig();\n  config = {\n    ...config,\n  };\n  // @ts-ignore - i put this here\n  delete config.path;\n  const toml = TOML.stringify(config as any);\n  await fs.writeFile(configPath, toml);\n}\n\n// cache the file once per process\nconst authConfigCache: Record<string, WranglerConfig> = {};\n\nasync function readWranglerConfig(): Promise<WranglerConfig> {\n  const configPath = await findWranglerConfig();\n  const config = (authConfigCache[configPath] ??= await parseTOML(\n    await fs.readFile(configPath, \"utf-8\")\n  ));\n  config.path = configPath;\n  return config;\n}\n\nlet wranglerConfigPath: string | undefined;\n\nasync function findWranglerConfig(): Promise<string> {\n  if (wranglerConfigPath) {\n    return wranglerConfigPath;\n  }\n  const environment = process.env.WRANGLER_API_ENVIRONMENT ?? \"production\";\n  const filePath = path.join(\n    \"config\",\n    `${environment === \"production\" ? \"default.toml\" : `${environment}.toml`}`\n  );\n\n  const xdgAppPaths = (await import(\"xdg-app-paths\")).default;\n  //TODO: We should implement a custom path --global-config and/or the WRANGLER_HOME type environment variable\n  const configDir = xdgAppPaths(\".wrangler\").config(); // New XDG compliant config path\n  const legacyConfigDir = path.join(os.homedir(), \".wrangler\"); // Legacy config in user's home directory\n\n  // Check for the .wrangler directory in root if it is not there then use the XDG compliant path.\n  wranglerConfigPath = path.join(\n    (await isDirectory(legacyConfigDir)) ? legacyConfigDir : configDir,\n    filePath\n  );\n  return wranglerConfigPath;\n}\n\nasync function parseTOML(input: string): Promise<any> {\n  const TOML = await import(\"@iarna/toml\");\n  try {\n    // Normalize CRLF to LF to avoid hitting https://github.com/iarna/iarna-toml/issues/33.\n    const normalizedInput = input.replace(/\\r\\n/g, \"\\n\");\n    return TOML.parse(normalizedInput);\n  } catch (err: any) {\n    const { name } = err;\n    if (name !== \"TomlError\") {\n      throw err;\n    }\n    throw new Error(\"TOML parse error\");\n  }\n}\n\nasync function isDirectory(dir: string) {\n  try {\n    return (await fs.stat(dir)).isDirectory();\n  } catch (err) {\n    return false;\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/bindings.ts\n```ts\n/**\n * Type definitions for Cloudflare Worker bindings\n * Based on Cloudflare API documentation:\n * https://developers.cloudflare.com/api/resources/workers/subresources/scripts/methods/update/\n */\nimport type { Secret } from \"../secret\";\nimport type { Assets } from \"./assets\";\nimport type { R2Bucket } from \"./bucket\";\nimport type { D1Database } from \"./d1-database\";\nimport type { DurableObjectNamespace } from \"./durable-object-namespace\";\nimport type { KVNamespace } from \"./kv-namespace\";\nimport type { Pipeline } from \"./pipeline\";\nimport type { Queue } from \"./queue\";\nimport type { VectorizeIndex } from \"./vectorize-index\";\nimport type { Worker } from \"./worker\";\nimport type { Workflow } from \"./workflow\";\n\nexport type Bindings = {\n  [bindingName: string]: Binding;\n};\n\n/**\n * L2 Binding Resources.\n */\nexport type Binding =\n  | Assets\n  | D1Database\n  | DurableObjectNamespace\n  | KVNamespace\n  | Pipeline\n  | Queue\n  | R2Bucket\n  | Secret\n  | string\n  | VectorizeIndex\n  | Worker\n  | Workflow;\n\n/**\n * Union type for all Worker binding types (API spec)\n */\nexport type WorkerBindingSpec =\n  | WorkerBindingAI\n  | WorkerBindingAnalyticsEngine\n  | WorkerBindingAssets\n  | WorkerBindingBrowserRendering\n  | WorkerBindingD1\n  | WorkerBindingDispatchNamespace\n  | WorkerBindingDurableObjectNamespace\n  | WorkerBindingHyperdrive\n  | WorkerBindingJson\n  | WorkerBindingKVNamespace\n  | WorkerBindingMTLSCertificate\n  | WorkerBindingPipeline\n  | WorkerBindingPlainText\n  | WorkerBindingQueue\n  | WorkerBindingR2Bucket\n  | WorkerBindingSecretText\n  | WorkerBindingService\n  | WorkerBindingStaticContent\n  | WorkerBindingTailConsumer\n  | WorkerBindingVectorize\n  | WorkerBindingVersionMetadata\n  | WorkerBindingWasmModule\n  | WorkerBindingWorkflow;\n\n/**\n * AI binding type\n */\nexport interface WorkerBindingAI {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for AI binding */\n  type: \"ai\";\n}\n\n/**\n * Analytics Engine binding type\n */\nexport interface WorkerBindingAnalyticsEngine {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Analytics Engine binding */\n  type: \"analytics_engine\";\n  /** Dataset name */\n  dataset: string;\n}\n\n/**\n * Assets binding type\n */\nexport interface WorkerBindingAssets {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Assets binding */\n  type: \"assets\";\n}\n\n/**\n * Browser Rendering binding type\n */\nexport interface WorkerBindingBrowserRendering {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Browser Rendering binding */\n  type: \"browser_rendering\";\n}\n\n/**\n * D1 database binding type\n */\nexport interface WorkerBindingD1 {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for D1 binding */\n  type: \"d1\";\n  /** D1 database ID */\n  id: string;\n}\n\n/**\n * Dispatch Namespace binding type\n */\nexport interface WorkerBindingDispatchNamespace {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Dispatch Namespace binding */\n  type: \"dispatch_namespace\";\n  /** Namespace identifier */\n  namespace: string;\n  /** Optional outbound service */\n  outbound?: any; // Documentation doesn't specify the exact type\n}\n\n/**\n * Durable Object Namespace binding type\n */\nexport interface WorkerBindingDurableObjectNamespace {\n  /**\n   * The stable ID of the binding\n   * @internal\n   */\n  stableId?: string;\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Durable Object Namespace binding */\n  type: \"durable_object_namespace\";\n  /** Durable Object class name */\n  class_name: string;\n  /** Script name that contains the Durable Object */\n  script_name?: string;\n  /** Environment */\n  environment?: string;\n  /** Namespace ID */\n  namespace_id?: string;\n}\n\n/**\n * Hyperdrive binding type\n */\nexport interface WorkerBindingHyperdrive {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Hyperdrive binding */\n  type: \"hyperdrive\";\n  /** Hyperdrive ID */\n  id: string;\n}\n\n/**\n * JSON binding type\n */\nexport interface WorkerBindingJson {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for JSON binding */\n  type: \"json\";\n  /** JSON value */\n  json: any;\n}\n\n/**\n * KV Namespace binding type\n */\nexport interface WorkerBindingKVNamespace {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for KV Namespace binding */\n  type: \"kv_namespace\";\n  /** KV Namespace ID */\n  namespace_id: string;\n}\n\n/**\n * MTLS Certificate binding type\n */\nexport interface WorkerBindingMTLSCertificate {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for MTLS Certificate binding */\n  type: \"mtls_certificate\";\n  /** Certificate ID */\n  certificate_id: string;\n}\n\n/**\n * Plain Text binding type\n */\nexport interface WorkerBindingPlainText {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Plain Text binding */\n  type: \"plain_text\";\n  /** Text content */\n  text: string;\n}\n\n/**\n * Queue binding type\n */\nexport interface WorkerBindingQueue {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Queue binding */\n  type: \"queue\";\n  /** Queue name */\n  queue_name: string;\n}\n\n/**\n * R2 Bucket binding type\n */\nexport interface WorkerBindingR2Bucket {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for R2 Bucket binding */\n  type: \"r2_bucket\";\n  /** Bucket name */\n  bucket_name: string;\n}\n\n/**\n * Secret Text binding type\n */\nexport interface WorkerBindingSecretText {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Secret Text binding */\n  type: \"secret_text\";\n  /** Secret value */\n  text: string;\n}\n\n/**\n * Service binding type\n */\nexport interface WorkerBindingService {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Service binding */\n  type: \"service\";\n  /** Service name */\n  service: string;\n  /** Environment */\n  environment?: string;\n  /** Service namespace */\n  namespace?: string;\n}\n\n/**\n * Tail Consumer binding type\n */\nexport interface WorkerBindingTailConsumer {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Tail Consumer binding */\n  type: \"tail_consumer\";\n  /** Service name */\n  service: string;\n}\n\n/**\n * Vectorize binding type\n */\nexport interface WorkerBindingVectorize {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Vectorize binding */\n  type: \"vectorize\";\n  /** Index name */\n  index_name: string;\n}\n\n/**\n * Version Metadata binding type\n */\nexport interface WorkerBindingVersionMetadata {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Version Metadata binding */\n  type: \"version_metadata\";\n}\n\n/**\n * WASM Module binding type\n */\nexport interface WorkerBindingWasmModule {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for WASM Module binding */\n  type: \"wasm_module\";\n  /** Module name */\n  module: string;\n}\n\n/**\n * Static content binding for Cloudflare Workers\n * Used for Workers Sites and static assets\n */\nexport interface WorkerBindingStaticContent {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Static Content binding */\n  type: \"static_content\";\n}\n\nexport interface WorkerBindingWorkflow {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Workflow binding */\n  type: \"workflow\";\n  /** Workflow name */\n  workflow_name: string;\n  /** Workflow class name */\n  class_name: string;\n  /**\n   * Workflow script name\n   *\n   * @default - the name of the script it is bound to\n   */\n  script_name?: string;\n}\n\n/**\n * Pipeline binding type\n */\nexport interface WorkerBindingPipeline {\n  /** The name of the binding */\n  name: string;\n  /** Type identifier for Pipeline binding */\n  type: \"pipelines\";\n  /** Pipeline name */\n  pipeline: string;\n}\n\n```\n\n// alchemy/src/cloudflare/bound.ts\n```ts\nimport type { Pipeline } from \"cloudflare:pipelines\";\nimport type { Secret } from \"../secret\";\nimport type { Assets } from \"./assets\";\nimport type { Binding } from \"./bindings\";\nimport type { R2Bucket as _R2Bucket } from \"./bucket\";\nimport type { D1Database as _D1Database } from \"./d1-database\";\nimport type { DurableObjectNamespace as _DurableObjectNamespace } from \"./durable-object-namespace\";\nimport type { KVNamespace as _KVNamespace } from \"./kv-namespace\";\nimport type { Pipeline as _Pipeline } from \"./pipeline\";\nimport type { Queue as _Queue } from \"./queue\";\nimport type { VectorizeIndex as _VectorizeIndex } from \"./vectorize-index\";\nimport type { Worker as _Worker } from \"./worker\";\nimport type { Workflow as _Workflow } from \"./workflow\";\n\nexport type Bound<T extends Binding> = T extends _DurableObjectNamespace\n  ? DurableObjectNamespace\n  : T extends _KVNamespace\n    ? KVNamespace\n    : T extends _Worker\n      ? Worker\n      : T extends _R2Bucket\n        ? R2Bucket\n        : T extends Secret\n          ? string\n          : T extends Assets\n            ? Service\n            : T extends _Workflow<infer P>\n              ? Workflow<P>\n              : T extends _D1Database\n                ? D1Database\n                : T extends _VectorizeIndex\n                  ? VectorizeIndex\n                  : T extends _Queue\n                    ? Queue\n                    : T extends _Pipeline<infer R>\n                      ? Pipeline<R>\n                      : Service;\n\n```\n\n// alchemy/src/cloudflare/bucket.ts\n```ts\nimport { AwsClient } from \"aws4fetch\";\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport { CloudflareApi, createCloudflareApi } from \"./api\";\nimport { CloudflareApiError, handleApiError } from \"./api-error\";\n\n/**\n * Properties for creating or updating an R2 Bucket\n */\nexport interface BucketProps {\n  /**\n   * Name of the bucket\n   * Names can only contain lowercase letters (a-z), numbers (0-9), and hyphens (-)\n   * Cannot begin or end with a hyphen\n   */\n  name: string;\n\n  /**\n   * Optional location hint for the bucket\n   * Indicates the primary geographical location data will be accessed from\n   */\n  locationHint?: string;\n\n  /**\n   * Optional jurisdiction for the bucket\n   * Determines the regulatory jurisdiction the bucket data falls under\n   */\n  jurisdiction?: \"default\" | \"eu\" | \"fedramp\";\n\n  /**\n   * Whether to allow public access through the r2.dev subdomain\n   * Only for development purposes - use custom domains for production\n   */\n  allowPublicAccess?: boolean;\n\n  /**\n   * Whether to delete the bucket.\n   * If set to false, the bucket will remain but the resource will be removed from state\n   *\n   * @default true\n   */\n  delete?: boolean;\n\n  /**\n   * Whether to empty the bucket and delete all objects during resource deletion\n   * @default false\n   */\n  empty?: boolean;\n\n  /**\n   * API Token to use for the bucket\n   */\n  apiToken?: Secret;\n\n  /**\n   * API Key to use for the bucket\n   */\n  apiKey?: Secret;\n\n  /**\n   * Email to use for the bucket\n   */\n  email?: string;\n\n  /**\n   * Account ID to use for the bucket\n   */\n  accountId?: string;\n\n  /**\n   * Access Key to use for the bucket\n   */\n  accessKey?: Secret;\n\n  /**\n   * Secret Access Key to use for the bucket\n   */\n  secretAccessKey?: Secret;\n}\n\n/**\n * Output returned after R2 Bucket creation/update\n */\nexport interface R2Bucket\n  extends Resource<\"cloudflare::R2Bucket\">,\n    BucketProps {\n  /**\n   * Resource type identifier\n   */\n  type: \"r2_bucket\";\n\n  /**\n   * Location of the bucket\n   */\n  location: string;\n\n  /**\n   * Time at which the bucket was created\n   */\n  creationDate: Date;\n}\n\n/**\n * Creates and manages Cloudflare R2 Buckets for object storage.\n *\n * R2 Buckets provide S3-compatible object storage with automatic data replication\n * across multiple regions for high availability and durability.\n *\n * @example\n * // Create a basic R2 bucket with default settings\n * const basicBucket = await R2Bucket(\"my-app-data\", {\n *   name: \"my-app-data\"\n * });\n *\n * @example\n * // Create a bucket with location hint for optimal performance\n * const euBucket = await R2Bucket(\"eu-user-data\", {\n *   name: \"eu-user-data\",\n *   locationHint: \"eu\",\n *   jurisdiction: \"eu\"\n * });\n *\n * @example\n * // Create a development bucket with public access enabled\n * const publicBucket = await R2Bucket(\"public-assets\", {\n *   name: \"public-assets\",\n *   allowPublicAccess: true\n * });\n *\n * @example\n * // Create a FedRAMP compliant bucket for government workloads\n * const fedRampBucket = await R2Bucket(\"gov-data\", {\n *   name: \"gov-data\",\n *   jurisdiction: \"fedramp\"\n * });\n *\n * @example\n * // Create a bucket that will be automatically emptied when deleted\n * // This will delete all objects in the bucket before deleting the bucket itself\n * const temporaryBucket = await R2Bucket(\"temp-storage\", {\n *   name: \"temp-storage\",\n *   empty: true  // All objects will be deleted when this resource is destroyed\n * });\n *\n * @see https://developers.cloudflare.com/r2/buckets/\n */\nexport const R2Bucket = Resource(\n  \"cloudflare::R2Bucket\",\n  async function (\n    this: Context<R2Bucket>,\n    id: string,\n    props: BucketProps\n  ): Promise<R2Bucket> {\n    const api = await createCloudflareApi(props);\n    const bucketName = props.name || this.id;\n\n    if (this.phase === \"delete\") {\n      console.log(\"Deleting R2 bucket:\", bucketName);\n      if (props.delete !== false) {\n        if (props.empty) {\n          console.log(\"Emptying R2 bucket:\", bucketName);\n          const r2Client = await createR2Client({\n            ...props,\n            accountId: api.accountId,\n          });\n          // Empty the bucket first by deleting all objects\n          await emptyBucket(r2Client, bucketName, props.jurisdiction);\n        }\n\n        // Delete R2 bucket\n        console.log(\"Deleting R2 bucket:\", bucketName);\n        await deleteBucket(api, bucketName, props);\n      }\n\n      // Return void (a deleted bucket has no content)\n      return this.destroy();\n    } else {\n      if (this.phase === \"create\") {\n        console.log(\"Creating R2 bucket:\", bucketName);\n        await createBucket(api, bucketName, props);\n      }\n\n      await updatePublicAccess(\n        api,\n        bucketName,\n        props.allowPublicAccess === true,\n        props.jurisdiction\n      );\n\n      return this({\n        name: bucketName,\n        location: props.locationHint || \"default\",\n        creationDate: new Date(),\n        jurisdiction: props.jurisdiction || \"default\",\n        type: \"r2_bucket\",\n        accountId: api.accountId,\n      });\n    }\n  }\n);\n\n/**\n * Configuration for R2 client to connect to Cloudflare R2\n */\nexport interface R2ClientConfig {\n  accountId: string;\n  accessKeyId?: Secret;\n  secretAccessKey?: Secret;\n  jurisdiction?: string;\n}\n\ntype R2Client = AwsClient & { accountId: string };\n\n/**\n * Creates an aws4fetch client configured for Cloudflare R2\n *\n * @see https://developers.cloudflare.com/r2/examples/aws/aws-sdk-js-v3/\n */\nexport function createR2Client(config?: R2ClientConfig): Promise<R2Client> {\n  const accountId = config?.accountId ?? process.env.CLOUDFLARE_ACCOUNT_ID;\n  const accessKeyId =\n    config?.accessKeyId?.unencrypted || process.env.R2_ACCESS_KEY_ID;\n  const secretAccessKey =\n    config?.secretAccessKey?.unencrypted || process.env.R2_SECRET_ACCESS_KEY;\n\n  if (!accountId) {\n    throw new Error(\"CLOUDFLARE_ACCOUNT_ID environment variable is required\");\n  }\n\n  if (!accessKeyId || !secretAccessKey) {\n    throw new Error(\n      \"R2_ACCESS_KEY_ID and R2_SECRET_ACCESS_KEY environment variables are required\"\n    );\n  }\n\n  // Create aws4fetch client with Cloudflare R2 endpoint\n  const client: any = new AwsClient({\n    accessKeyId,\n    secretAccessKey,\n    service: \"s3\",\n    region: \"auto\",\n  });\n  client.accountId = accountId;\n  return client;\n}\n\ninterface CloudflareBucketResponse {\n  result: {\n    name: string;\n    location?: string;\n    creation_date: string;\n  };\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n}\n\n/**\n * Adds jurisdiction header to the headers object if specified in props\n *\n * @param headers Headers object to modify\n * @param props Props or jurisdiction string\n * @returns Modified headers object\n */\nexport function withJurisdiction(\n  headers: Record<string, string> = {},\n  props: BucketProps | { jurisdiction?: string } | string | undefined\n): Record<string, string> {\n  // Clone the headers object to avoid modifying the original\n  const result = { ...headers };\n\n  let jurisdiction: string | undefined;\n  if (typeof props === \"string\") {\n    jurisdiction = props;\n  } else if (props && \"jurisdiction\" in props) {\n    jurisdiction = props.jurisdiction;\n  }\n\n  if (jurisdiction && jurisdiction !== \"default\") {\n    result[\"cf-r2-jurisdiction\"] = jurisdiction;\n  }\n\n  return result;\n}\n\n/**\n * Create a new bucket\n */\nexport async function createBucket(\n  api: CloudflareApi,\n  bucketName: string,\n  props: BucketProps\n): Promise<CloudflareBucketResponse> {\n  // Create new R2 bucket\n  const createPayload: any = {\n    name: bucketName,\n  };\n\n  if (props.locationHint) {\n    createPayload.location_hint = props.locationHint;\n  }\n\n  const headers = withJurisdiction({}, props);\n\n  const createResponse = await api.post(\n    `/accounts/${api.accountId}/r2/buckets`,\n    createPayload,\n    { headers }\n  );\n\n  if (!createResponse.ok) {\n    return await handleApiError(\n      createResponse,\n      \"creating\",\n      \"R2 bucket\",\n      bucketName\n    );\n  }\n\n  return (await createResponse.json()) as CloudflareBucketResponse;\n}\n\n/**\n * Delete a bucket\n */\nexport async function deleteBucket(\n  api: CloudflareApi,\n  bucketName: string,\n  props: BucketProps\n): Promise<void> {\n  // Delete R2 bucket\n  const headers = withJurisdiction({}, props);\n\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/r2/buckets/${bucketName}`,\n    { headers }\n  );\n\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    const errorData: any = await deleteResponse.json().catch(() => ({\n      errors: [{ message: deleteResponse.statusText }],\n    }));\n    throw new CloudflareApiError(\n      `Error deleting R2 bucket '${bucketName}': ${errorData.errors?.[0]?.message || deleteResponse.statusText}`,\n      deleteResponse\n    );\n  }\n}\n\n/**\n * List objects in an R2 bucket\n *\n * @param r2 R2Client instance\n * @param bucketName Name of the bucket\n * @param continuationToken Optional token for pagination\n * @param jurisdiction Optional jurisdiction for the bucket\n * @returns Object containing the list of objects and the next continuation token\n */\nexport async function listObjects(\n  r2: R2Client,\n  bucketName: string,\n  continuationToken?: string,\n  jurisdiction?: string\n): Promise<{ objects: { Key: string }[]; continuationToken?: string }> {\n  // List objects in the bucket\n  const url = new URL(\n    `https://${r2.accountId}.r2.cloudflarestorage.com/${bucketName}`\n  );\n  if (continuationToken) {\n    url.searchParams.set(\"continuation-token\", continuationToken);\n  }\n  url.searchParams.set(\"list-type\", \"2\");\n\n  const headers = withJurisdiction({}, jurisdiction);\n\n  const listResponse = await r2.fetch(url.toString(), { headers });\n  if (!listResponse.ok) {\n    throw new CloudflareApiError(\n      `Failed to list objects: ${listResponse.statusText}`,\n      listResponse\n    );\n  }\n\n  const responseText = await listResponse.text();\n\n  // Extract objects from XML response using regex\n  const keyRegex = /<Key>([^<]+)<\\/Key>/g;\n  const objects: { Key: string }[] = [];\n  let match;\n  while ((match = keyRegex.exec(responseText)) !== null) {\n    objects.push({ Key: match[1] });\n  }\n\n  // Get continuation token if present using regex\n  const tokenMatch =\n    /<NextContinuationToken>([^<]+)<\\/NextContinuationToken>/.exec(\n      responseText\n    );\n  const nextContinuationToken = tokenMatch ? tokenMatch[1] : undefined;\n\n  return { objects, continuationToken: nextContinuationToken };\n}\n\n/**\n * Helper function to empty a bucket by deleting all objects\n */\nexport async function emptyBucket(\n  r2: R2Client,\n  bucketName: string,\n  jurisdiction?: string\n): Promise<void> {\n  let continuationToken: string | undefined;\n  let totalDeleted = 0;\n\n  try {\n    do {\n      console.log(`Listing objects in bucket ${bucketName}`);\n      // List objects in the bucket\n      const { objects, continuationToken: nextToken } = await listObjects(\n        r2,\n        bucketName,\n        continuationToken,\n        jurisdiction\n      );\n\n      continuationToken = nextToken;\n\n      console.log(`Found ${objects.length} objects in bucket ${bucketName}`);\n\n      // Delete objects in batches\n      if (objects.length > 0) {\n        // Process delete in batches of 1000 (S3 limit)\n        for (let i = 0; i < objects.length; i += 1000) {\n          const batch = objects.slice(i, i + 1000);\n\n          // Create DeleteObjects request XML\n          const deleteXml = `\n            <Delete>\n              ${batch.map((obj) => `<Object><Key>${obj.Key}</Key></Object>`).join(\"\")}\n            </Delete>\n          `;\n\n          const deleteUrl = new URL(\n            `https://${r2.accountId}.r2.cloudflarestorage.com/${bucketName}?delete`\n          );\n\n          console.log(\n            `Deleting ${batch.length} objects from bucket ${bucketName}`\n          );\n\n          const headers = withJurisdiction(\n            { \"Content-Type\": \"application/xml\" },\n            jurisdiction\n          );\n\n          const deleteResponse = await r2.fetch(deleteUrl.toString(), {\n            method: \"POST\",\n            body: deleteXml,\n            headers,\n          });\n\n          if (!deleteResponse.ok) {\n            throw new CloudflareApiError(\n              `Failed to delete objects: ${deleteResponse.statusText}`,\n              deleteResponse\n            );\n          }\n\n          totalDeleted += batch.length;\n        }\n      }\n    } while (continuationToken);\n\n    console.log(\n      `Successfully emptied bucket ${bucketName}, deleted ${totalDeleted} objects total`\n    );\n  } catch (error) {\n    if (error instanceof CloudflareApiError && error.status === 404) {\n      // the bucket was not found\n      return;\n    }\n    console.error(`Failed to empty bucket ${bucketName}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Update public access setting for a bucket\n *\n * This operation is not available through the S3 API for R2,\n * so we still use the Cloudflare API directly.\n */\nexport async function updatePublicAccess(\n  api: CloudflareApi,\n  bucketName: string,\n  allowPublicAccess: boolean,\n  jurisdiction?: string\n): Promise<void> {\n  const headers = withJurisdiction({}, jurisdiction);\n\n  const response = await api.put(\n    `/accounts/${api.accountId}/r2/buckets/${bucketName}/domains/managed`,\n    {\n      enabled: allowPublicAccess,\n    },\n    { headers }\n  );\n\n  if (!response.ok) {\n    await handleApiError(\n      response,\n      \"updating public access for\",\n      \"R2 bucket\",\n      bucketName\n    );\n  }\n}\n\n/**\n * Set CORS configuration for a bucket using aws4fetch\n */\nexport async function setCorsConfiguration(\n  r2: R2Client,\n  bucketName: string,\n  allowedOrigins: string[] = [\"*\"],\n  allowedMethods: string[] = [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\"],\n  allowedHeaders: string[] = [\"*\"],\n  maxAgeSeconds: number = 3600,\n  jurisdiction?: string\n): Promise<void> {\n  try {\n    // Construct CORS XML configuration\n    const corsXml = `\n      <CORSConfiguration>\n        <CORSRule>\n          ${allowedOrigins.map((origin) => `<AllowedOrigin>${origin}</AllowedOrigin>`).join(\"\")}\n          ${allowedMethods.map((method) => `<AllowedMethod>${method}</AllowedMethod>`).join(\"\")}\n          ${allowedHeaders.map((header) => `<AllowedHeader>${header}</AllowedHeader>`).join(\"\")}\n          <ExposeHeader>ETag</ExposeHeader>\n          <MaxAgeSeconds>${maxAgeSeconds}</MaxAgeSeconds>\n        </CORSRule>\n      </CORSConfiguration>\n    `;\n\n    const url = new URL(\n      `https://${r2.accountId}.r2.cloudflarestorage.com/${bucketName}?cors`\n    );\n\n    const headers = withJurisdiction(\n      { \"Content-Type\": \"application/xml\" },\n      jurisdiction\n    );\n\n    const response = await r2.fetch(url.toString(), {\n      method: \"PUT\",\n      body: corsXml,\n      headers,\n    });\n\n    if (!response.ok) {\n      throw new CloudflareApiError(\n        `Failed to set CORS configuration: ${response.statusText}`,\n        response\n      );\n    }\n\n    console.log(`Successfully set CORS configuration for bucket ${bucketName}`);\n  } catch (error) {\n    console.error(\n      `Failed to set CORS configuration for bucket ${bucketName}:`,\n      error\n    );\n    throw error;\n  }\n}\n\n/**\n * Information about an R2 bucket returned by list operations\n */\nexport interface R2BucketInfo {\n  /**\n   * Name of the bucket\n   */\n  Name: string;\n\n  /**\n   * Creation date of the bucket\n   */\n  CreationDate: Date;\n}\n\n/**\n * List all R2 buckets in an account\n *\n * @param api CloudflareApi instance\n * @param options Optional listing options\n * @returns Array of bucket information\n */\nexport async function listBuckets(\n  api: CloudflareApi,\n  options: {\n    nameContains?: string;\n    perPage?: number;\n    cursor?: string;\n    direction?: \"asc\" | \"desc\";\n    jurisdiction?: string;\n  } = {}\n): Promise<R2BucketInfo[]> {\n  // Build query parameters\n  const params = new URLSearchParams();\n\n  if (options.nameContains) {\n    params.append(\"name_contains\", options.nameContains);\n  }\n\n  if (options.perPage) {\n    params.append(\"per_page\", options.perPage.toString());\n  }\n\n  if (options.cursor) {\n    params.append(\"cursor\", options.cursor);\n  }\n\n  if (options.direction) {\n    params.append(\"direction\", options.direction);\n  }\n\n  // Build URL with query parameters\n  const path = `/accounts/${api.accountId}/r2/buckets${params.toString() ? \"?\" + params.toString() : \"\"}`;\n\n  // Set jurisdiction header if provided\n  const headers = withJurisdiction({}, options.jurisdiction);\n\n  // Make the API request\n  const response = await api.get(path, { headers });\n\n  if (!response.ok) {\n    throw new CloudflareApiError(\n      `Failed to list buckets: ${response.statusText}`,\n      response\n    );\n  }\n\n  const data = (await response.json()) as {\n    success: boolean;\n    errors?: Array<{ code: number; message: string }>;\n    result?: {\n      buckets: Array<{\n        name: string;\n        creation_date: string;\n        location?: string;\n      }>;\n    };\n  };\n\n  if (!data.success) {\n    const errorMessage = data.errors?.[0]?.message || \"Unknown error\";\n    throw new Error(`Failed to list buckets: ${errorMessage}`);\n  }\n\n  // Transform API response to R2BucketInfo objects\n  return (data.result?.buckets || []).map((bucket) => ({\n    Name: bucket.name,\n    CreationDate: new Date(bucket.creation_date),\n  }));\n}\n\n```\n\n// alchemy/src/cloudflare/custom-domain.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport {\n  CloudflareApi,\n  createCloudflareApi,\n  type CloudflareApiOptions,\n} from \"./api\";\nimport { handleApiError } from \"./api-error\";\n\n/**\n * Properties for creating or updating a CustomDomain\n */\nexport interface CustomDomainProps extends CloudflareApiOptions {\n  /**\n   * The domain name to bind to the worker\n   */\n  name: string;\n\n  /**\n   * Cloudflare Zone ID for the domain\n   */\n  zoneId: string;\n\n  /**\n   * Name of the worker to bind to the domain\n   */\n  workerName: string;\n\n  /**\n   * Worker environment (defaults to production)\n   * @default \"production\"\n   */\n  environment?: string;\n}\n\n/**\n * Cloudflare Domain object structure from API\n */\ninterface CloudflareDomain {\n  id: string;\n  zone_id: string;\n  zone_name: string;\n  hostname: string;\n  service: string;\n  environment: string;\n}\n\n/**\n * Output returned after CustomDomain creation/update\n */\nexport interface CustomDomain\n  extends Resource<\"cloudflare::CustomDomain\">,\n    CustomDomainProps {\n  /**\n   * The unique identifier for the Cloudflare domain binding.\n   */\n  id: string;\n\n  /**\n   * Time at which the domain binding was created (approximated if not returned by API)\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the domain binding was last updated\n   */\n  updatedAt: number;\n}\n\n/**\n * Configure custom domain for a Cloudflare Worker using the Cloudflare Custom Domains API\n * This attaches a worker to a specific hostname within a zone.\n *\n * @example\n * // Bind a domain to a standard Cloudflare Worker\n * const apiWorker = await Worker(\"api\", {\n *   name: \"my-api-worker\",\n *   entrypoint: \"./src/api-worker.ts\"\n * });\n *\n * const apiDomain = await CustomDomain(\"api-domain-binding\", {\n *   name: \"api.example.com\",\n *   zoneId: \"YOUR_ZONE_ID\", // Replace with actual Zone ID\n *   workerName: apiWorker.name // Use the name from the Worker resource\n * });\n *\n * @see https://developers.cloudflare.com/api/resources/workers/subresources/domains/\n */\nexport const CustomDomain = Resource(\n  \"cloudflare::CustomDomain\",\n  async function (\n    this: Context<CustomDomain>,\n    logicalId: string, // Changed param name from id to logicalId for clarity\n    props: CustomDomainProps\n  ): Promise<CustomDomain> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    // Validate required properties\n    if (!props.name) {\n      throw new Error(\"Domain name (props.name) is required\");\n    }\n    if (!props.zoneId) {\n      throw new Error(\"Zone ID (props.zoneId) is required\");\n    }\n    if (!props.workerName) {\n      throw new Error(\"Worker name (props.workerName) is required\");\n    }\n\n    if (this.phase === \"delete\") {\n      await deleteCustomDomain(this, api, logicalId, props);\n      return this.destroy();\n    } else {\n      // Create or Update phase\n      return await ensureCustomDomain(this, api, logicalId, props);\n    }\n  }\n);\n\n// Helper function to delete the custom domain binding\nasync function deleteCustomDomain(\n  context: Context<CustomDomain>,\n  api: CloudflareApi,\n  logicalId: string,\n  props: CustomDomainProps\n): Promise<void> {\n  const domainHostname = props.name;\n  const domainIdToDelete = context.output?.id;\n\n  if (!domainIdToDelete) {\n    console.warn(\n      `Cannot delete CustomDomain ${logicalId} (${domainHostname}): Missing domain ID in state. Assuming already deleted.`\n    );\n    return; // Exit early if no ID\n  }\n\n  console.log(\n    `Deleting CustomDomain binding ${domainIdToDelete} for ${domainHostname}`\n  );\n  const response = await api.delete(\n    `/accounts/${api.accountId}/workers/domains/${domainIdToDelete}`\n  );\n\n  console.log(\n    `Delete result for ${domainIdToDelete} (${domainHostname}):`,\n    response.status,\n    response.statusText\n  );\n\n  // 404 is acceptable during deletion for idempotency\n  if (!response.ok && response.status !== 404) {\n    await handleApiError(\n      response,\n      \"deleting\",\n      \"custom domain binding\",\n      domainIdToDelete\n    );\n    // Throw after handling to ensure failure is reported\n    throw new Error(\n      `Failed to delete custom domain binding ${domainIdToDelete}: ${response.statusText}`\n    );\n  }\n}\n\n// Helper function to create or update the custom domain binding\nasync function ensureCustomDomain(\n  context: Context<CustomDomain>,\n  api: CloudflareApi,\n  logicalId: string,\n  props: CustomDomainProps\n): Promise<CustomDomain> {\n  const environment = props.environment || \"production\";\n  const domainHostname = props.name;\n\n  // Check if domain binding already exists for this account\n  console.log(`Checking existing domain bindings for account ${api.accountId}`);\n  const listResponse = await api.get(\n    `/accounts/${api.accountId}/workers/domains`\n  );\n\n  if (!listResponse.ok) {\n    // Fix: Added the 4th argument (resource identifier/context)\n    await handleApiError(\n      listResponse,\n      \"listing\",\n      \"worker domains\",\n      `Account ${api.accountId}`\n    );\n    // If listing fails, we cannot proceed reliably\n    throw new Error(\n      `Failed to list worker domains for account ${api.accountId}: ${listResponse.statusText}`\n    );\n  }\n\n  const listData = (await listResponse.json()) as {\n    result?: CloudflareDomain[];\n    success: boolean;\n  };\n\n  if (!listData.success || !listData.result) {\n    throw new Error(\n      `Failed to parse list worker domains response: ${JSON.stringify(listData)}`\n    );\n  }\n\n  // Find the specific binding by hostname AND zoneId\n  const existingBinding = listData.result.find(\n    (b) => b.hostname === domainHostname && b.zone_id === props.zoneId\n  );\n\n  let currentDomainId = existingBinding?.id;\n  const bindingExists = !!existingBinding;\n\n  console.log(\n    `Domain binding status for ${domainHostname} (Zone: ${props.zoneId}):`,\n    bindingExists\n      ? `Found (ID: ${currentDomainId}, Worker: ${existingBinding.service}, Env: ${existingBinding.environment})`\n      : \"Not found\"\n  );\n\n  // Determine if we need to update (binding exists but has different service or environment)\n  const needsUpdate =\n    bindingExists &&\n    (existingBinding.service !== props.workerName ||\n      existingBinding.environment !== environment);\n\n  let operationPerformed: \"create\" | \"update\" | \"none\" = \"none\";\n  let resultantBinding: CloudflareDomain | undefined = existingBinding;\n\n  // Create or Update the binding using PUT\n  // Cloudflare's PUT /accounts/{account_id}/workers/domains acts as an upsert\n  if (!bindingExists || needsUpdate) {\n    operationPerformed = bindingExists ? \"update\" : \"create\";\n    console.log(\n      `${operationPerformed === \"update\" ? \"Updating\" : \"Creating\"} domain binding: ${domainHostname} (Zone: ${props.zoneId}) → ${props.workerName}:${environment}`\n    );\n\n    const putPayload = {\n      zone_id: props.zoneId,\n      hostname: domainHostname,\n      service: props.workerName,\n      environment: environment,\n    };\n\n    const putResponse = await api.put(\n      `/accounts/${api.accountId}/workers/domains`,\n      putPayload\n    );\n\n    if (!putResponse.ok) {\n      await handleApiError(\n        putResponse,\n        operationPerformed === \"update\" ? \"updating\" : \"creating\",\n        \"custom domain binding\",\n        domainHostname\n      );\n      // Throw after handling to prevent inconsistent state\n      throw new Error(\n        `Failed to ${operationPerformed} custom domain binding: ${putResponse.statusText}`\n      );\n    }\n\n    const putResult = (await putResponse.json()) as {\n      result?: CloudflareDomain;\n      success: boolean;\n    };\n\n    if (!putResult.success || !putResult.result) {\n      throw new Error(\n        `Failed to parse ${operationPerformed} domain binding response: ${JSON.stringify(putResult)}`\n      );\n    }\n\n    resultantBinding = putResult.result;\n    currentDomainId = resultantBinding.id; // Update ID from the PUT response\n    console.log(\n      `Successfully ${operationPerformed}d binding, new ID: ${currentDomainId}`\n    );\n  } else {\n    console.log(\n      `Domain binding already exists and is up to date: ${domainHostname} (ID: ${currentDomainId}) → ${props.workerName}:${environment}`\n    );\n  }\n\n  // Ensure we have the final binding details\n  if (!resultantBinding || !currentDomainId) {\n    // This case should ideally not happen if API calls succeed\n    console.error(\"Error: Could not determine final domain binding state.\", {\n      existingBinding,\n      resultantBinding,\n      currentDomainId,\n    });\n    throw new Error(\n      `Failed to get final state for custom domain ${domainHostname}`\n    );\n  }\n\n  const now = Date.now();\n\n  // Construct the output state\n  return context({\n    ...props, // Include all input props\n    id: currentDomainId, // Use the definitive ID\n    environment: resultantBinding.environment, // Use actual environment from CF\n    createdAt: context.output?.createdAt || now, // Preserve create time or set new\n    updatedAt:\n      operationPerformed !== \"none\" ? now : context.output?.updatedAt || now, // Update time only if changed\n  });\n}\n\n```\n\n// alchemy/src/cloudflare/d1-database.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport {\n  CloudflareApi,\n  createCloudflareApi,\n  type CloudflareApiOptions,\n} from \"./api\";\nimport { CloudflareApiError, handleApiError } from \"./api-error\";\n\n/**\n * Properties for creating or updating a D1 Database\n */\nexport interface D1DatabaseProps extends CloudflareApiOptions {\n  /**\n   * Name of the database\n   */\n  name: string;\n\n  /**\n   * Optional primary location hint for the database\n   * Indicates the primary geographical location data will be stored\n   */\n  primaryLocationHint?:\n    | \"wnam\"\n    | \"enam\"\n    | \"weur\"\n    | \"eeur\"\n    | \"apac\"\n    | \"auto\"\n    | string;\n\n  /**\n   * Read replication configuration\n   * Only mutable property during updates\n   */\n  readReplication?: {\n    /**\n     * Read replication mode\n     * - auto: Automatic read replication\n     * - disabled: No read replication\n     */\n    mode: \"auto\" | \"disabled\";\n  };\n\n  /**\n   * Whether to delete the database.\n   * If set to false, the database will remain but the resource will be removed from state\n   *\n   * @default true\n   */\n  delete?: boolean;\n\n  /**\n   * Whether to adopt an existing database with the same name if it exists\n   * If true and a database with the same name exists, it will be adopted rather than creating a new one\n   *\n   * @default false\n   */\n  adopt?: boolean;\n}\n\n/**\n * Output returned after D1 Database creation/update\n */\nexport interface D1Database\n  extends Resource<\"cloudflare::D1Database\">,\n    D1DatabaseProps {\n  type: \"d1\";\n  /**\n   * The unique ID of the database (UUID)\n   */\n  id: string;\n\n  /**\n   * File size of the database\n   */\n  fileSize: number;\n\n  /**\n   * Number of tables in the database\n   */\n  numTables: number;\n\n  /**\n   * Version of the database\n   */\n  version: string;\n\n  /**\n   * Read replication configuration\n   */\n  readReplication?: {\n    /**\n     * Read replication mode\n     */\n    mode: \"auto\" | \"disabled\";\n  };\n}\n\n/**\n * Creates and manages Cloudflare D1 Databases.\n *\n * D1 Databases provide serverless SQL databases built on SQLite with\n * automatic data replication for high availability.\n *\n * @example\n * // Create a basic D1 database with default settings\n * const basicDatabase = await D1Database(\"my-app-db\", {\n *   name: \"my-app-db\"\n * });\n *\n * @example\n * // Create a database with location hint for optimal performance\n * const westUsDatabase = await D1Database(\"west-us-db\", {\n *   name: \"west-us-db\",\n *   primaryLocationHint: \"wnam\"\n * });\n *\n * @example\n * // Adopt an existing database if it already exists instead of failing\n * const existingDb = await D1Database(\"existing-db\", {\n *   name: \"existing-db\",\n *   adopt: true,\n *   readReplication: {\n *     mode: \"auto\"\n *   }\n * });\n *\n * @see https://developers.cloudflare.com/d1/\n */\nexport const D1Database = Resource(\n  \"cloudflare::D1Database\",\n  async function (\n    this: Context<D1Database>,\n    id: string,\n    props: D1DatabaseProps\n  ): Promise<D1Database> {\n    const api = await createCloudflareApi(props);\n    const databaseName = props.name || id;\n\n    if (this.phase === \"delete\") {\n      console.log(\"Deleting D1 database:\", databaseName);\n      if (props.delete !== false) {\n        // Delete D1 database\n        console.log(\"Deleting D1 database:\", databaseName);\n        await deleteDatabase(api, this.output?.id);\n      }\n\n      // Return void (a deleted database has no content)\n      return this.destroy();\n    } else {\n      let dbData: CloudflareD1Response;\n\n      if (this.phase === \"create\") {\n        console.log(\"Creating D1 database:\", databaseName);\n        try {\n          dbData = await createDatabase(api, databaseName, props);\n        } catch (error) {\n          // Check if this is a \"database already exists\" error and adopt is enabled\n          if (\n            props.adopt &&\n            error instanceof CloudflareApiError &&\n            error.message.includes(\"already exists\")\n          ) {\n            console.log(`Database ${databaseName} already exists, adopting it`);\n            // Find the existing database by name\n            const databases = await listDatabases(api, databaseName);\n            const existingDb = databases.find((db) => db.name === databaseName);\n\n            if (!existingDb) {\n              throw new Error(\n                `Failed to find existing database '${databaseName}' for adoption`\n              );\n            }\n\n            // Get the database details using its ID\n            dbData = await getDatabase(api, existingDb.id);\n\n            // Update the database with the provided properties\n            if (props.readReplication) {\n              console.log(\n                `Updating adopted database ${databaseName} with new properties`\n              );\n              dbData = await updateDatabase(api, existingDb.id, props);\n            }\n          } else {\n            // Re-throw the error if adopt is false or it's not a \"database already exists\" error\n            throw error;\n          }\n        }\n      } else {\n        // Update operation\n        if (this.output?.id) {\n          console.log(\"Updating D1 database:\", databaseName);\n          // Update the database with new properties\n          dbData = await updateDatabase(api, this.output.id, props);\n        } else {\n          // If no ID exists, fall back to creating a new database\n          console.log(\n            \"No existing database ID found, creating new D1 database:\",\n            databaseName\n          );\n          dbData = await createDatabase(api, databaseName, props);\n        }\n      }\n\n      return this({\n        type: \"d1\",\n        id: dbData.result.uuid || \"\",\n        name: databaseName,\n        fileSize: dbData.result.file_size,\n        numTables: dbData.result.num_tables,\n        version: dbData.result.version,\n        readReplication: dbData.result.read_replication,\n        primaryLocationHint: props.primaryLocationHint,\n        accountId: api.accountId,\n      });\n    }\n  }\n);\n\ninterface CloudflareD1Response {\n  result: {\n    uuid?: string;\n    name: string;\n    file_size: number;\n    num_tables: number;\n    version: string;\n    primary_location_hint?: string;\n    read_replication?: {\n      mode: \"auto\" | \"disabled\";\n    };\n  };\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n}\n\n/**\n * Create a new D1 database\n */\nexport async function createDatabase(\n  api: CloudflareApi,\n  databaseName: string,\n  props: D1DatabaseProps\n): Promise<CloudflareD1Response> {\n  // Create new D1 database\n  const createPayload: any = {\n    name: databaseName,\n  };\n\n  if (props.primaryLocationHint) {\n    createPayload.primary_location_hint = props.primaryLocationHint;\n  }\n\n  const createResponse = await api.post(\n    `/accounts/${api.accountId}/d1/database`,\n    createPayload\n  );\n\n  if (!createResponse.ok) {\n    return await handleApiError(\n      createResponse,\n      \"creating\",\n      \"D1 database\",\n      databaseName\n    );\n  }\n\n  return (await createResponse.json()) as CloudflareD1Response;\n}\n\n/**\n * Get a D1 database\n */\nexport async function getDatabase(\n  api: CloudflareApi,\n  databaseId?: string\n): Promise<CloudflareD1Response> {\n  if (!databaseId) {\n    throw new Error(\"Database ID is required\");\n  }\n\n  const response = await api.get(\n    `/accounts/${api.accountId}/d1/database/${databaseId}`\n  );\n\n  if (!response.ok) {\n    return await handleApiError(response, \"getting\", \"D1 database\", databaseId);\n  }\n\n  return (await response.json()) as CloudflareD1Response;\n}\n\n/**\n * Delete a D1 database\n */\nexport async function deleteDatabase(\n  api: CloudflareApi,\n  databaseId?: string\n): Promise<void> {\n  if (!databaseId) {\n    console.log(\"No database ID provided, skipping delete\");\n    return;\n  }\n\n  // Delete D1 database\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/d1/database/${databaseId}`\n  );\n\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    const errorData: any = await deleteResponse.json().catch(() => ({\n      errors: [{ message: deleteResponse.statusText }],\n    }));\n    throw new CloudflareApiError(\n      `Error deleting D1 database '${databaseId}': ${errorData.errors?.[0]?.message || deleteResponse.statusText}`,\n      deleteResponse\n    );\n  }\n}\n\n/**\n * List all D1 databases in an account\n */\nexport async function listDatabases(\n  api: CloudflareApi,\n  name?: string\n): Promise<{ name: string; id: string }[]> {\n  // Construct query string if name is provided\n  const queryParams = name ? `?name=${encodeURIComponent(name)}` : \"\";\n\n  const response = await api.get(\n    `/accounts/${api.accountId}/d1/database${queryParams}`\n  );\n\n  if (!response.ok) {\n    throw new CloudflareApiError(\n      `Failed to list databases: ${response.statusText}`,\n      response\n    );\n  }\n\n  const data = (await response.json()) as {\n    success: boolean;\n    errors?: Array<{ code: number; message: string }>;\n    result?: Array<{\n      name: string;\n      uuid: string;\n    }>;\n  };\n\n  if (!data.success) {\n    const errorMessage = data.errors?.[0]?.message || \"Unknown error\";\n    throw new Error(`Failed to list databases: ${errorMessage}`);\n  }\n\n  // Transform API response\n  return (data.result || []).map((db) => ({\n    name: db.name,\n    id: db.uuid,\n  }));\n}\n\n/**\n * Update a D1 database\n *\n * Note: According to Cloudflare API, only read_replication.mode can be modified during updates.\n */\nexport async function updateDatabase(\n  api: CloudflareApi,\n  databaseId: string,\n  props: D1DatabaseProps\n): Promise<CloudflareD1Response> {\n  // Get current database state to check for non-mutable changes\n  const currentDB = await getDatabase(api, databaseId);\n\n  // Only read_replication can be modified in update\n  if (\n    props.primaryLocationHint &&\n    props.primaryLocationHint !== currentDB.result.primary_location_hint\n  ) {\n    throw new Error(\n      \"Cannot update primaryLocationHint after database creation. Only readReplication.mode can be modified.\"\n    );\n  }\n\n  const updatePayload: any = {};\n\n  // Only include read_replication in update payload\n  if (props.readReplication) {\n    updatePayload.read_replication = {\n      mode: props.readReplication.mode,\n    };\n  }\n\n  const updateResponse = await api.patch(\n    `/accounts/${api.accountId}/d1/database/${databaseId}`,\n    updatePayload\n  );\n\n  if (!updateResponse.ok) {\n    return await handleApiError(\n      updateResponse,\n      \"updating\",\n      \"D1 database\",\n      databaseId\n    );\n  }\n\n  return (await updateResponse.json()) as CloudflareD1Response;\n}\n\n```\n\n// alchemy/src/cloudflare/dns-records.ts\n```ts\nimport type { Context } from \"../context\";\nimport type {\n  DnsRecord as BaseDnsRecord,\n  DnsRecordType,\n  DnsRecordWithMetadata,\n} from \"../dns/record\";\nimport { Resource } from \"../resource\";\nimport {\n  type CloudflareApi,\n  type CloudflareApiOptions,\n  createCloudflareApi,\n} from \"./api\";\nimport type { CloudflareResponse } from \"./response\";\n\n/**\n * Cloudflare DNS Record response format\n */\ninterface CloudflareDnsRecord {\n  id: string;\n  type: string;\n  name: string;\n  content: string;\n  proxiable: boolean;\n  proxied: boolean;\n  ttl: number;\n  locked: boolean;\n  zone_id: string;\n  zone_name: string;\n  created_on: string;\n  modified_on: string;\n  data?: Record<string, unknown>;\n  priority?: number;\n  comment?: string;\n  tags?: string[];\n}\n\n/**\n * Properties for a DNS record\n */\nexport interface DnsRecordProps extends Omit<BaseDnsRecord, \"type\"> {\n  /**\n   * Record type (A, AAAA, CNAME, etc.)\n   */\n  type: DnsRecordType;\n}\n\n/**\n * Output returned after DNS record creation/update\n */\nexport interface DnsRecord extends DnsRecordWithMetadata {}\n\n/**\n * Properties for managing multiple DNS records\n */\nexport interface DnsRecordsProps extends CloudflareApiOptions {\n  /**\n   * Zone ID or domain name where records will be created\n   */\n  zoneId: string;\n\n  /**\n   * Array of DNS records to manage\n   */\n  records: DnsRecordProps[];\n}\n\n/**\n * Output returned after DNS records creation/update\n */\nexport interface DnsRecords extends Resource<\"cloudflare::DnsRecords\"> {\n  /**\n   * Zone ID where records are created\n   */\n  zoneId: string;\n\n  /**\n   * Array of created/updated DNS records\n   */\n  records: DnsRecord[];\n}\n\n/**\n * Manages a batch of DNS records in a Cloudflare zone.\n * Supports creating, updating, and deleting multiple records at once.\n *\n * @example\n * // Create multiple A and CNAME records\n * const dnsRecords = await DnsRecords(\"example.com-dns\", {\n *   zone: \"example.com\",\n *   records: [\n *     {\n *       name: \"www.example.com\",\n *       type: \"A\",\n *       content: \"192.0.2.1\",\n *       proxied: true\n *     },\n *     {\n *       name: \"blog.example.com\",\n *       type: \"CNAME\",\n *       content: \"www.example.com\",\n *       proxied: true\n *     }\n *   ]\n * });\n *\n * @example\n * // Create MX records for email routing\n * const emailRecords = await DnsRecords(\"example.com-email\", {\n *   zone: \"example.com\",\n *   records: [\n *     {\n *       name: \"example.com\",\n *       type: \"MX\",\n *       content: \"aspmx.l.google.com\",\n *       priority: 1\n *     },\n *     {\n *       name: \"example.com\",\n *       type: \"MX\",\n *       content: \"alt1.aspmx.l.google.com\",\n *       priority: 5\n *     }\n *   ]\n * });\n */\nexport const DnsRecords = Resource(\n  \"cloudflare::DnsRecords\",\n  async function (\n    this: Context<DnsRecords>,\n    id: string,\n    props: DnsRecordsProps\n  ): Promise<DnsRecords> {\n    // Create Cloudflare API client\n    const api = await createCloudflareApi(props);\n\n    // Get zone ID if domain name was provided\n    const zoneId = props.zoneId;\n\n    if (this.phase === \"delete\") {\n      if (this.output?.records) {\n        // Delete all existing records\n        await Promise.all(\n          this.output.records.map(async (record) => {\n            try {\n              const response = await api.delete(\n                `/zones/${zoneId}/dns_records/${record.id}`\n              );\n              if (!response.ok && response.status !== 404) {\n                console.error(\n                  `Failed to delete DNS record ${record.name}: ${response.statusText}`\n                );\n              }\n            } catch (error) {\n              console.error(`Error deleting DNS record ${record.name}:`, error);\n            }\n          })\n        );\n      }\n      return this.destroy();\n    }\n\n    if (this.phase === \"update\" && this.output?.records) {\n      // Get current records to compare with desired state\n      const currentRecords = this.output.records;\n      const desiredRecords = props.records;\n\n      // Find records to delete (exist in current but not in desired)\n      const recordsToDelete = currentRecords.filter(\n        (current) =>\n          !desiredRecords.some(\n            (desired) =>\n              desired.name === current.name && desired.type === current.type\n          )\n      );\n\n      // Delete orphaned records\n      await Promise.all(\n        recordsToDelete.map(async (record) => {\n          try {\n            const response = await api.delete(\n              `/zones/${zoneId}/dns_records/${record.id}`\n            );\n            if (!response.ok && response.status !== 404) {\n              console.error(\n                `Failed to delete DNS record ${record.name}: ${response.statusText}`\n              );\n            }\n          } catch (error) {\n            console.error(`Error deleting DNS record ${record.name}:`, error);\n          }\n        })\n      );\n\n      // Update or create records\n      const updatedRecords = await Promise.all(\n        desiredRecords.map(async (desired) => {\n          // Find matching existing record\n          const existing = currentRecords.find(\n            (current) =>\n              current.name === desired.name && current.type === desired.type\n          );\n\n          if (existing) {\n            // Update if content or other properties changed\n            if (\n              existing.content !== desired.content ||\n              existing.ttl !== (desired.ttl || 1) ||\n              existing.proxied !== (desired.proxied || false) ||\n              existing.priority !== desired.priority ||\n              existing.comment !== desired.comment\n            ) {\n              return createOrUpdateRecord(api, zoneId, desired, existing.id);\n            }\n            return existing;\n          } else {\n            // Create new record\n            return createOrUpdateRecord(api, zoneId, desired);\n          }\n        })\n      );\n\n      return this({\n        zoneId,\n        records: updatedRecords,\n      });\n    }\n\n    // Create new records\n    const uniqueRecords = props.records.reduce(\n      (acc, record) => {\n        // For record types that can have multiple entries with the same name (MX, TXT, NS, etc.),\n        // include content and/or priority in the key to avoid deduplication\n        let key = `${record.name}-${record.type}`;\n\n        // If it's a record type that can have multiple entries with the same name, make the key unique\n        if ([\"MX\", \"TXT\", \"NS\", \"SRV\", \"CAA\"].includes(record.type)) {\n          // For MX, include priority in the key\n          if (record.type === \"MX\" || record.type === \"SRV\") {\n            key = `${key}-${record.priority}-${record.content}`;\n          } else {\n            // For other multi-record types, content is the differentiator\n            key = `${key}-${record.content}`;\n          }\n        }\n\n        acc[key] = record;\n        return acc;\n      },\n      {} as Record<string, DnsRecordProps>\n    );\n\n    const createdRecords = await Promise.all(\n      Object.values(uniqueRecords).map(async (record) => {\n        // First check if record exists\n        const listResponse = await api.get(\n          `/zones/${zoneId}/dns_records?type=${record.type}&name=${record.name}`\n        );\n        if (!listResponse.ok) {\n          throw new Error(\n            `Failed to check existing DNS records: ${listResponse.statusText}`\n          );\n        }\n\n        const listResult = (await listResponse.json()) as CloudflareResponse<\n          CloudflareDnsRecord[]\n        >;\n        const existingRecord = listResult.result[0];\n\n        return createOrUpdateRecord(api, zoneId, record, existingRecord?.id);\n      })\n    );\n\n    return this({\n      zoneId,\n      records: createdRecords,\n    });\n  }\n);\n\n/**\n * Create or update a DNS record\n */\nasync function createOrUpdateRecord(\n  api: CloudflareApi,\n  zoneId: string,\n  record: DnsRecordProps,\n  existingId?: string\n): Promise<DnsRecord> {\n  const payload = getRecordPayload(record);\n\n  const response = await (existingId\n    ? api.put(`/zones/${zoneId}/dns_records/${existingId}`, payload)\n    : api.post(`/zones/${zoneId}/dns_records`, payload));\n\n  if (!response.ok) {\n    const errorBody = await response.text();\n\n    // If it's an update operation and the record doesn't exist, fall back to creation\n    if (existingId && response.status === 404) {\n      try {\n        const createResponse = await api.post(\n          `/zones/${zoneId}/dns_records`,\n          payload\n        );\n        if (createResponse.ok) {\n          return convertCloudflareRecord(\n            ((await createResponse.json()) as any).result,\n            zoneId\n          );\n        }\n      } catch (err) {\n        // Fall through to the original error\n      }\n    }\n\n    throw new Error(\n      `Failed to ${existingId ? \"update\" : \"create\"} DNS record ${record.name}: ${response.statusText}\\nResponse: ${errorBody}`\n    );\n  }\n\n  const result =\n    (await response.json()) as CloudflareResponse<CloudflareDnsRecord>;\n  return convertCloudflareRecord(result.result, zoneId);\n}\n\n/**\n * Get the record payload for create/update operations\n */\nfunction getRecordPayload(record: DnsRecordProps) {\n  return {\n    type: record.type,\n    name: record.name,\n    content: record.content,\n    ttl: record.ttl || 1,\n    proxied: record.proxied || false,\n    priority: record.priority,\n    comment: record.comment,\n  };\n}\n\n/**\n * Convert a Cloudflare DNS record response to our DnsRecord type\n */\nfunction convertCloudflareRecord(\n  record: CloudflareDnsRecord,\n  zoneId: string\n): DnsRecord {\n  return {\n    id: record.id,\n    name: record.name,\n    type: record.type as DnsRecordProps[\"type\"],\n    content: record.content,\n    ttl: record.ttl,\n    proxied: record.proxied,\n    priority: record.priority,\n    comment: record.comment,\n    tags: record.tags,\n    createdAt: new Date(record.created_on).getTime(),\n    modifiedAt: new Date(record.modified_on).getTime(),\n    zoneId,\n  };\n}\n\n```\n\n// alchemy/src/cloudflare/durable-object-namespace.ts\n```ts\n/**\n * Properties for creating a Durable Object Namespace\n */\nexport interface DurableObjectNamespaceInput {\n  className: string;\n  scriptName?: string | undefined;\n  environment?: string | undefined;\n  sqlite?: boolean | undefined;\n  namespaceId?: string | undefined;\n}\n\n/**\n * @example\n * // Create a basic Durable Object namespace for stateful chat rooms\n * const rooms = new DurableObjectNamespace(\"chat-rooms\", {\n *   className: \"ChatRoom\"\n * });\n *\n * @example\n * // Create a Durable Object with SQLite storage for user data\n * const users = new DurableObjectNamespace(\"user-store\", {\n *   className: \"User\",\n *   sqlite: true\n * });\n *\n * @example\n * // Create a Durable Object in production for game state management\n * const game = new DurableObjectNamespace(\"game-state\", {\n *   className: \"GameState\",\n *   scriptName: \"game-worker\",\n *   environment: \"production\"\n * });\n */\nexport class DurableObjectNamespace implements DurableObjectNamespaceInput {\n  public readonly type = \"durable_object_namespace\" as const;\n  // alias for bindingName to be consistent with other bindings\n  public readonly className: string;\n  public readonly scriptName?: string | undefined;\n  public readonly environment?: string | undefined;\n  public readonly sqlite?: boolean | undefined;\n  public readonly namespaceId?: string | undefined;\n\n  constructor(\n    public readonly id: string,\n    input: DurableObjectNamespaceInput\n  ) {\n    this.className = input.className;\n    this.scriptName = input.scriptName;\n    this.environment = input.environment;\n    this.sqlite = input.sqlite;\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/kv-namespace.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport {\n  CloudflareApi,\n  createCloudflareApi,\n  type CloudflareApiOptions,\n} from \"./api\";\nimport { handleApiError } from \"./api-error\";\n\n/**\n * Properties for creating or updating a KV Namespace\n */\nexport interface KVNamespaceProps extends CloudflareApiOptions {\n  /**\n   * Title of the namespace\n   */\n  title: string;\n\n  /**\n   * KV pairs to store in the namespace\n   * Only used for initial setup or updates\n   */\n  values?: KVPair[];\n}\n\n/**\n * Key-value pair to store in a KV Namespace\n */\nexport interface KVPair {\n  /**\n   * Key name\n   */\n  key: string;\n\n  /**\n   * Value to store (string or JSON object)\n   */\n  value: string | object;\n\n  /**\n   * Optional expiration in seconds from now\n   */\n  expiration?: number;\n\n  /**\n   * Optional expiration timestamp in seconds since epoch\n   */\n  expirationTtl?: number;\n\n  /**\n   * Optional metadata for the key\n   */\n  metadata?: any;\n}\n\n/**\n * Output returned after KV Namespace creation/update\n */\nexport interface KVNamespace\n  extends Resource<\"cloudflare::KVNamespace\">,\n    KVNamespaceProps {\n  type: \"kv_namespace\";\n  /**\n   * The ID of the namespace\n   */\n  namespaceId: string;\n\n  /**\n   * Time at which the namespace was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the namespace was last modified\n   */\n  modifiedAt: number;\n}\n\n/**\n * A Cloudflare KV Namespace is a key-value store that can be used to store data for your application.\n *\n * @see https://developers.cloudflare.com/kv/concepts/kv-namespaces/\n *\n * @example\n * // Create a basic KV namespace for storing user data\n * const users = await KVNamespace(\"users\", {\n *   title: \"user-data\"\n * });\n *\n * @example\n * // Create a KV namespace with initial values and TTL\n * const sessions = await KVNamespace(\"sessions\", {\n *   title: \"user-sessions\",\n *   values: [{\n *     key: \"session_123\",\n *     value: { userId: \"user_456\", role: \"admin\" },\n *     expirationTtl: 3600 // Expires in 1 hour\n *   }]\n * });\n *\n * @example\n * // Create a KV namespace with metadata for caching\n * const assets = await KVNamespace(\"assets\", {\n *   title: \"static-assets\",\n *   values: [{\n *     key: \"main.js\",\n *     value: \"content...\",\n *     metadata: {\n *       contentType: \"application/javascript\",\n *       etag: \"abc123\"\n *     }\n *   }]\n * });\n */\nexport const KVNamespace = Resource(\n  \"cloudflare::KVNamespace\",\n  async function (\n    this: Context<KVNamespace>,\n    id: string,\n    props: KVNamespaceProps\n  ) {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    if (this.phase === \"delete\") {\n      // For delete operations, we need to check if the namespace ID exists in the output\n      const namespaceId = this.output?.namespaceId;\n      if (namespaceId) {\n        await deleteKVNamespace(api, namespaceId);\n      }\n\n      // Return minimal output for deleted state\n      return this.destroy();\n    } else {\n      // For create or update operations\n      // If this.phase is \"update\", we expect this.output to exist\n      let namespaceId =\n        this.phase === \"update\" ? this.output?.namespaceId || \"\" : \"\";\n      let createdAt =\n        this.phase === \"update\"\n          ? this.output?.createdAt || Date.now()\n          : Date.now();\n\n      if (this.phase === \"update\" && namespaceId) {\n        // Can't update a KV namespace title directly, just work with existing ID\n      } else {\n        // TODO: if it already exists, then check the tags to see if we own it and continue\n        const { id } = await createKVNamespace(api, props);\n        createdAt = Date.now();\n        namespaceId = id;\n      }\n\n      await insertKVRecords(api, namespaceId, props);\n\n      return this({\n        type: \"kv_namespace\",\n        namespaceId: namespaceId,\n        title: props.title,\n        values: props.values,\n        createdAt: createdAt,\n        modifiedAt: Date.now(),\n      });\n    }\n  }\n);\n\nexport async function createKVNamespace(\n  api: CloudflareApi,\n  props: KVNamespaceProps\n): Promise<{ id: string }> {\n  const createResponse = await api.post(\n    `/accounts/${api.accountId}/storage/kv/namespaces`,\n    {\n      title: props.title,\n    }\n  );\n\n  if (!createResponse.ok) {\n    await handleApiError(createResponse, \"create\", \"kv_namespace\", props.title);\n  }\n\n  return { id: ((await createResponse.json()) as any).result.id };\n}\n\nexport async function deleteKVNamespace(\n  api: CloudflareApi,\n  namespaceId: string\n) {\n  // Delete KV namespace\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/storage/kv/namespaces/${namespaceId}`\n  );\n\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    await handleApiError(deleteResponse, \"delete\", \"kv_namespace\", namespaceId);\n  }\n}\n\nexport async function insertKVRecords(\n  api: CloudflareApi,\n  namespaceId: string,\n  props: KVNamespaceProps\n) {\n  if (props.values && props.values.length > 0) {\n    // Process KV pairs in batches of 10000 (API limit)\n    const BATCH_SIZE = 10000;\n\n    for (let i = 0; i < props.values.length; i += BATCH_SIZE) {\n      const batch = props.values.slice(i, i + BATCH_SIZE);\n\n      const bulkPayload = batch.map((entry) => {\n        const item: any = {\n          key: entry.key,\n          value:\n            typeof entry.value === \"string\"\n              ? entry.value\n              : JSON.stringify(entry.value),\n        };\n\n        if (entry.expiration) {\n          item.expiration = entry.expiration;\n        }\n\n        if (entry.expirationTtl) {\n          item.expiration_ttl = entry.expirationTtl;\n        }\n\n        if (entry.metadata) {\n          item.metadata = entry.metadata;\n        }\n\n        return item;\n      });\n\n      try {\n        await withExponentialBackoff(\n          async () => {\n            const bulkResponse = await api.put(\n              `/accounts/${api.accountId}/storage/kv/namespaces/${namespaceId}/bulk`,\n              bulkPayload\n            );\n\n            if (!bulkResponse.ok) {\n              const errorData: any = await bulkResponse.json().catch(() => ({\n                errors: [{ message: bulkResponse.statusText }],\n              }));\n              const errorMessage =\n                errorData.errors?.[0]?.message || bulkResponse.statusText;\n\n              // Throw error to trigger retry\n              throw new Error(`Error writing KV batch: ${errorMessage}`);\n            }\n\n            return bulkResponse;\n          },\n          (error) => {\n            // Retry on \"namespace not found\" errors as they're likely propagation delays\n            return error.message?.includes(\"not found\");\n          },\n          5, // 5 retry attempts\n          1000 // Start with 1 second delay\n        );\n      } catch (error: any) {\n        console.warn(error.message);\n      }\n    }\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/permission-groups.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { createCloudflareApi, type CloudflareApiOptions } from \"./api\";\n\n/**\n * Cloudflare permission group as returned by the API\n */\nexport interface PermissionGroup {\n  /**\n   * Unique identifier for the permission group\n   */\n  id: string;\n\n  /**\n   * Human-readable name of the permission group\n   */\n  name: string;\n\n  /**\n   * Scopes included in this permission group\n   */\n  scopes: string[];\n}\n\n/**\n * Response from the Cloudflare permission groups API\n */\ninterface PermissionGroupsResponse {\n  result: PermissionGroup[];\n  success: boolean;\n  errors: any[];\n  messages: any[];\n}\n\n/**\n * All Cloudflare permission groups mapped by name to ID\n *\n * @see https://developers.cloudflare.com/r2/api/tokens/#permissions\n */\nexport type PermissionGroups = Resource<\"cloudflare::PermissionGroups\"> & {\n  /**\n   * Admin Read & Write - Allows create, list, delete buckets and edit bucket configurations\n   * plus list, write, and read object access\n   */\n  \"Workers R2 Storage Write\": PermissionGroup;\n\n  /**\n   * Admin Read only - Allows list buckets and view bucket configuration\n   * plus list and read object access\n   */\n  \"Workers R2 Storage Read\": PermissionGroup;\n\n  /**\n   * Object Read & Write - Allows read, write, and list objects in specific buckets\n   */\n  \"Workers R2 Storage Bucket Item Write\": PermissionGroup;\n\n  /**\n   * Object Read only - Allows read and list objects in specific buckets\n   */\n  \"Workers R2 Storage Bucket Item Read\": PermissionGroup;\n\n  /**\n   * Dynamically discovered permission groups\n   */\n  [name: string]: PermissionGroup;\n};\n\n/**\n * Lists all permission groups available for the Cloudflare account\n * and returns a typed map of permission names to their IDs.\n *\n * This is primarily used when creating API tokens for Cloudflare services like R2.\n *\n * Note: Requires a Cloudflare API Key or Token with account read access.\n * The API token must have permission to read token permission groups.\n * The OAuth token from `wrangler login` is NOT sufficient for this operation.\n *\n * @example\n * // Get all permission groups including those for R2\n * const permissions = await PermissionGroups(\"cloudflare-permissions\");\n *\n * // Use with AccountApiToken to create a token with proper permissions\n * const token = await AccountApiToken(\"r2-token\", {\n *   name: \"R2 Read-Only Token\",\n *   policies: [\n *     {\n *       effect: \"allow\",\n *       resources: {\n *         \"com.cloudflare.edge.r2.bucket.abc123_default_my-bucket\": \"*\"\n *       },\n *       permissionGroups: [\n *         {\n *           id: permissions[\"Workers R2 Storage Bucket Item Read\"]\n *         }\n *       ]\n *     }\n *   ]\n * });\n */\nexport const PermissionGroups = Resource(\n  \"cloudflare::PermissionGroups\",\n  async function (\n    this: Context<PermissionGroups>,\n    id: string,\n    options: CloudflareApiOptions = {}\n  ): Promise<PermissionGroups> {\n    // Only create and update phases are supported\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    // Initialize API client\n    const api = await createCloudflareApi(options);\n\n    // Fetch permission groups from Cloudflare API\n    const response = await api.get(\n      `/accounts/${api.accountId}/tokens/permission_groups`\n    );\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch permission groups: ${response.statusText}`\n      );\n    }\n\n    const data = (await response.json()) as PermissionGroupsResponse;\n\n    if (!data.success || !data.result) {\n      throw new Error(\n        `API returned error: ${data.errors?.[0]?.message || \"Unknown error\"}`\n      );\n    }\n\n    return this(\n      Object.fromEntries(\n        data.result.map((group) => [group.name, group])\n      ) as PermissionGroups\n    );\n  }\n);\n\n```\n\n// alchemy/src/cloudflare/pipeline.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport type { Secret } from \"../secret\";\nimport {\n  CloudflareApi,\n  createCloudflareApi,\n  type CloudflareApiOptions,\n} from \"./api\";\nimport { CloudflareApiError, handleApiError } from \"./api-error\";\n\n/**\n * Settings for compression of pipeline output\n */\nexport interface CompressionSettings {\n  /**\n   * Type of compression to use for pipeline output\n   * @default \"gzip\"\n   */\n  type: \"gzip\" | \"none\";\n}\n\n/**\n * Settings for batching behavior of pipeline output\n */\nexport interface BatchSettings {\n  /**\n   * Maximum size of batch in megabytes before delivery (1-100 MB)\n   * @default 100\n   */\n  maxMb?: number;\n\n  /**\n   * Maximum number of rows in a batch before delivery (1-10,000,000 rows)\n   * @default 10000000\n   */\n  maxRows?: number;\n\n  /**\n   * Maximum duration of a batch in seconds before delivery (1-300 seconds)\n   * @default 300\n   */\n  maxSeconds?: number;\n}\n\n/**\n * Configuration for a pipeline HTTP source\n */\nexport interface HttpSource {\n  /**\n   * Format of the source data\n   * @default \"json\"\n   */\n  format: \"json\";\n\n  /**\n   * Type of source\n   */\n  type: \"http\";\n\n  /**\n   * Whether authentication is required\n   * @default true\n   */\n  authentication?: boolean;\n\n  /**\n   * CORS configuration for HTTP endpoint source\n   */\n  cors?: {\n    /**\n     * Allowed origins for CORS requests\n     * @default [\"*\"]\n     */\n    origins: string[];\n  };\n}\n\n/**\n * Configuration for a pipeline binding source\n */\nexport interface BindingSource {\n  /**\n   * Format of the source data\n   * @default \"json\"\n   */\n  format: \"json\";\n\n  /**\n   * Type of source\n   */\n  type: \"binding\";\n}\n\n/**\n * Configuration for a pipeline source\n */\nexport type PipelineSource = HttpSource | BindingSource;\n\n/**\n * Configuration for an R2 destination\n */\nexport interface R2DestinationConfig {\n  /**\n   * Type of destination (R2)\n   */\n  type: \"r2\";\n\n  /**\n   * Format of the output data\n   * @default \"json\"\n   */\n  format: \"json\" | \"ndjson\";\n\n  /**\n   * Path configuration for the R2 destination\n   */\n  path: {\n    /**\n     * R2 bucket name\n     */\n    bucket: string;\n\n    /**\n     * Optional prefix for files in the bucket\n     */\n    prefix?: string;\n\n    /**\n     * Optional filename pattern\n     * @default \"${slug}${extension}\"\n     */\n    filename?: string;\n\n    /**\n     * Optional filepath pattern\n     * @default \"${date}/${hour}\"\n     */\n    filepath?: string;\n  };\n\n  /**\n   * Compression settings\n   */\n  compression?: CompressionSettings;\n\n  /**\n   * Batch settings\n   */\n  batch?: BatchSettings;\n\n  /**\n   * Credentials for the R2 bucket\n   * Required for R2 destinations\n   */\n  credentials: {\n    /**\n     * Access key ID for the R2 bucket\n     */\n    accessKeyId: Secret;\n\n    /**\n     * Secret access key for the R2 bucket\n     */\n    secretAccessKey: Secret;\n\n    /**\n     * Endpoint for the R2 bucket\n     */\n    endpoint?: string;\n  };\n}\n\n/**\n * Allowed destination types\n */\nexport type PipelineDestination = R2DestinationConfig;\n\n/**\n * Properties for creating or updating a Pipeline\n */\nexport interface PipelineProps extends CloudflareApiOptions {\n  /**\n   * Name of the pipeline\n   */\n  name: string;\n\n  /**\n   * Source configuration for the pipeline\n   */\n  source: PipelineSource[];\n\n  /**\n   * Destination configuration for the pipeline\n   */\n  destination: PipelineDestination;\n\n  /**\n   * Compression settings for the pipeline\n   * @default { type: \"gzip\" }\n   */\n  compression?: CompressionSettings;\n\n  /**\n   * Whether to delete the pipeline.\n   * If set to false, the pipeline will remain but the resource will be removed from state\n   *\n   * @default true\n   */\n  delete?: boolean;\n}\n\n/**\n * Base type for pipeline records\n */\nexport interface PipelineRecord {\n  [key: string]: any;\n}\n\n/**\n * Output returned after Pipeline creation/update\n */\nexport interface Pipeline<T extends PipelineRecord = PipelineRecord>\n  extends Resource<\"cloudflare::Pipeline\">,\n    PipelineProps {\n  /**\n   * Type identifier for the Pipeline resource\n   */\n  type: \"pipeline\";\n\n  /**\n   * The unique ID of the pipeline\n   */\n  id: string;\n\n  /**\n   * HTTP endpoint URL for the pipeline\n   */\n  endpoint: string;\n\n  /**\n   * Version of the pipeline\n   */\n  version: number;\n}\n\n/**\n * Creates and manages Cloudflare Pipelines.\n *\n * Pipelines provide a managed data pipeline service that lets you collect, transform,\n * and route data to various destinations like R2 buckets.\n *\n * @example\n * // Create a basic pipeline with an R2 bucket destination\n * const bucket = await R2Bucket(\"logs-bucket\", {\n *   name: \"logs-bucket\"\n * });\n *\n * const accessKey = alchemy.secret(process.env.R2_ACCESS_KEY_ID!);\n * const secretKey = alchemy.secret(process.env.R2_SECRET_ACCESS_KEY!);\n *\n * const pipeline = await Pipeline(\"logs-pipeline\", {\n *   name: \"logs-pipeline\",\n *   destination: {\n *     type: \"r2\",\n *     format: \"json\",\n *     path: {\n *       bucket: bucket.name,\n *       prefix: \"app-logs\",\n *     },\n *     credentials: {\n *       accessKeyId: accessKey,\n *       secretAccessKey: secretKey\n *     }\n *   },\n *   batch: {\n *     maxMb: 50,\n *     maxSeconds: 60\n *   }\n * });\n *\n * @example\n * // Create a pipeline with custom source configuration\n * const customPipeline = await Pipeline(\"custom-pipeline\", {\n *   name: \"custom-pipeline\",\n *   source: [{\n *     type: \"http\",\n *     format: \"json\",\n *     authentication: true,\n *     cors: {\n *       origins: [\"https://example.com\"]\n *     }\n *   }],\n *   destination: {\n *     type: \"r2\",\n *     format: \"json\",\n *     path: {\n *       bucket: \"my-bucket\",\n *       prefix: \"data\"\n *     },\n *     credentials: {\n *       accessKeyId: alchemy.secret(process.env.R2_ACCESS_KEY_ID!),\n *       secretAccessKey: alchemy.secret(process.env.R2_SECRET_ACCESS_KEY!)\n *     },\n *     compression: {\n *       type: \"gzip\"\n *     }\n *   }\n * });\n *\n * @see https://developers.cloudflare.com/pipelines/\n */\nexport const Pipeline = Resource(\"cloudflare::Pipeline\", async function <\n  T extends PipelineRecord = PipelineRecord,\n>(this: Context<Pipeline<T>>, id: string, props: PipelineProps): Promise<\n  Pipeline<T>\n> {\n  const api = await createCloudflareApi(props);\n  const pipelineName = props.name || id;\n\n  if (this.phase === \"delete\") {\n    if (props.delete !== false) {\n      // Delete Pipeline\n      await deletePipeline(api, pipelineName);\n    }\n\n    // Return void (a deleted pipeline has no content)\n    return this.destroy();\n  } else {\n    let pipelineData: CloudflarePipelineResponse;\n\n    if (this.phase === \"create\") {\n      pipelineData = await createPipeline(api, pipelineName, props);\n    } else {\n      // Update operation\n      if (this.output?.id) {\n        // Check if name is being changed, which is not allowed\n        if (props.name !== this.output.name) {\n          throw new Error(\n            \"Cannot update Pipeline name after creation. Pipeline name is immutable.\"\n          );\n        }\n\n        // Update the pipeline with new settings\n        pipelineData = await updatePipeline(api, pipelineName, props);\n      } else {\n        // If no ID exists, fall back to creating a new pipeline\n        console.log(\n          \"No existing Pipeline ID found, creating new Cloudflare Pipeline:\",\n          pipelineName\n        );\n        pipelineData = await createPipeline(api, pipelineName, props);\n      }\n    }\n\n    return this({\n      type: \"pipeline\",\n      id: pipelineData.result.id,\n      name: pipelineName,\n      endpoint: pipelineData.result.endpoint,\n      version: pipelineData.result.version,\n      source: pipelineData.result.source!.map((s) => ({\n        type: s.type as \"http\" | \"binding\",\n        format: s.format as \"json\",\n        authentication: s.authentication,\n        cors: s.cors,\n      })),\n      destination: props.destination, // Use the input destination, not the API response\n      compression: props.compression,\n      accountId: api.accountId,\n    });\n  }\n});\n\ninterface CloudflarePipelineResponse {\n  result: {\n    id: string;\n    name: string;\n    endpoint: string;\n    version: number;\n    source: Array<{\n      type: \"http\" | \"binding\";\n      format: string;\n      authentication?: boolean;\n      cors?: {\n        origins: string[];\n      };\n    }>;\n    destination: {\n      type: string;\n      format: string;\n      path?: {\n        bucket: string;\n        prefix?: string;\n        filename?: string;\n        filepath?: string;\n      };\n      compression?: {\n        type: string;\n      };\n      batch: {\n        max_bytes?: number;\n        max_rows?: number;\n        max_duration_s?: number;\n      };\n    };\n  };\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n}\n\n/**\n * Get a pipeline\n */\nexport async function getPipeline(\n  api: CloudflareApi,\n  pipelineName: string\n): Promise<CloudflarePipelineResponse> {\n  const response = await api.get(\n    `/accounts/${api.accountId}/pipelines/${pipelineName}`\n  );\n\n  if (!response.ok) {\n    return await handleApiError(response, \"getting\", \"Pipeline\", pipelineName);\n  }\n\n  return (await response.json()) as CloudflarePipelineResponse;\n}\n\n/**\n * Delete a pipeline\n */\nexport async function deletePipeline(\n  api: CloudflareApi,\n  pipelineName: string\n): Promise<void> {\n  // Delete Pipeline\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/pipelines/${pipelineName}`\n  );\n\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    const errorData: any = await deleteResponse.json().catch(() => ({\n      errors: [{ message: deleteResponse.statusText }],\n    }));\n    throw new CloudflareApiError(\n      `Error deleting Cloudflare Pipeline '${pipelineName}': ${errorData.errors?.[0]?.message || deleteResponse.statusText}`,\n      deleteResponse\n    );\n  }\n}\n\n/**\n * Create a new pipeline\n */\nexport async function createPipeline(\n  api: CloudflareApi,\n  pipelineName: string,\n  props: PipelineProps\n): Promise<CloudflarePipelineResponse> {\n  // Prepare the create payload\n  const createPayload = preparePipelinePayload(api, pipelineName, props);\n\n  const createResponse = await api.post(\n    `/accounts/${api.accountId}/pipelines`,\n    createPayload\n  );\n\n  if (!createResponse.ok) {\n    return await handleApiError(\n      createResponse,\n      \"creating\",\n      \"Pipeline\",\n      pipelineName\n    );\n  }\n\n  return (await createResponse.json()) as CloudflarePipelineResponse;\n}\n\n/**\n * Update a pipeline\n */\nexport async function updatePipeline(\n  api: CloudflareApi,\n  pipelineName: string,\n  props: PipelineProps\n): Promise<CloudflarePipelineResponse> {\n  // Get current pipeline to build update payload\n  const currentPipeline = await getPipeline(api, pipelineName);\n\n  // Prepare the update payload\n  const updatePayload = preparePipelinePayload(\n    api,\n    pipelineName,\n    props,\n    currentPipeline\n  );\n\n  const updateResponse = await api.put(\n    `/accounts/${api.accountId}/pipelines/${pipelineName}`,\n    updatePayload\n  );\n\n  if (!updateResponse.ok) {\n    return await handleApiError(\n      updateResponse,\n      \"updating\",\n      \"Pipeline\",\n      pipelineName\n    );\n  }\n\n  return (await updateResponse.json()) as CloudflarePipelineResponse;\n}\n\n/**\n * Helper function to prepare pipeline payload for create/update operations\n */\nfunction preparePipelinePayload(\n  api: CloudflareApi,\n  pipelineName: string,\n  props: PipelineProps,\n  currentPipeline?: CloudflarePipelineResponse\n): any {\n  // Prepare the payload with name and source\n  const payload: any = {\n    name: pipelineName,\n    source: props.source ||\n      currentPipeline?.result.source || [\n        {\n          type: \"http\",\n          format: \"json\",\n          authentication: true,\n          cors: { origins: [\"*\"] },\n        },\n      ],\n  };\n\n  // Handle destination\n  if (props.destination) {\n    payload.destination = { ...props.destination };\n\n    // Handle special formatting for R2 destination\n    const r2Dest = props.destination as R2DestinationConfig;\n\n    // Format credentials for API\n    if (payload.destination.credentials) {\n      payload.destination.credentials = {\n        access_key_id: r2Dest.credentials.accessKeyId.unencrypted,\n        secret_access_key: r2Dest.credentials.secretAccessKey.unencrypted,\n        endpoint:\n          r2Dest.credentials.endpoint ??\n          `https://${api.accountId}.r2.cloudflarestorage.com`,\n      };\n    }\n\n    // Format batch settings\n    payload.destination.batch = convertBatchSettings(payload.destination.batch);\n  } else if (currentPipeline?.result.destination) {\n    payload.destination = currentPipeline.result.destination;\n  } else if (!props.destination && !currentPipeline) {\n    throw new Error(\n      \"An R2 destination is required for creating/updating a pipeline\"\n    );\n  }\n\n  // Add compression if not specified\n  if (!payload.destination.compression) {\n    payload.destination.compression = { type: \"gzip\" };\n  }\n\n  return payload;\n}\n\n/**\n * List all pipelines in an account\n */\nexport async function listPipelines(\n  api: CloudflareApi\n): Promise<{ name: string; id: string }[]> {\n  const response = await api.get(`/accounts/${api.accountId}/pipelines`);\n\n  if (!response.ok) {\n    throw new CloudflareApiError(\n      `Failed to list pipelines: ${response.statusText}`,\n      response\n    );\n  }\n\n  const data = (await response.json()) as {\n    success: boolean;\n    errors?: Array<{ code: number; message: string }>;\n    results?: Array<{\n      name: string;\n      id: string;\n    }>;\n  };\n\n  if (!data.success) {\n    const errorMessage = data.errors?.[0]?.message || \"Unknown error\";\n    throw new Error(`Failed to list pipelines: ${errorMessage}`);\n  }\n\n  // Transform API response\n  return (data.results || []).map((pipeline) => ({\n    name: pipeline.name,\n    id: pipeline.id,\n  }));\n}\n\n/**\n * Helper function to convert batch settings to the format expected by the API\n */\ninterface CloudflareBatchSettings {\n  max_bytes?: number;\n  max_rows?: number;\n  max_duration_s?: number;\n}\n\nfunction convertBatchSettings(batch?: BatchSettings): CloudflareBatchSettings {\n  const result: CloudflareBatchSettings = {};\n\n  if (batch?.maxMb !== undefined) {\n    // Convert MB to bytes\n    result.max_bytes = batch.maxMb * 1024 * 1024;\n  }\n\n  if (batch?.maxRows !== undefined) {\n    result.max_rows = batch.maxRows;\n  }\n\n  if (batch?.maxSeconds !== undefined) {\n    result.max_duration_s = batch.maxSeconds;\n  }\n\n  return result;\n}\n\n```\n\n// alchemy/src/cloudflare/queue.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport {\n  CloudflareApi,\n  createCloudflareApi,\n  type CloudflareApiOptions,\n} from \"./api\";\nimport { CloudflareApiError, handleApiError } from \"./api-error\";\n\n/**\n * Settings for a Cloudflare Queue\n */\nexport interface QueueSettings {\n  /**\n   * Delay in seconds before message delivery\n   * Queue will not deliver messages until this time has elapsed\n   */\n  deliveryDelay?: number;\n\n  /**\n   * Whether delivery is paused\n   * If true, the queue will not deliver messages to consumers\n   */\n  deliveryPaused?: boolean;\n\n  /**\n   * Period in seconds to retain messages\n   * Messages will be automatically deleted after this time\n   */\n  messageRetentionPeriod?: number;\n}\n\n/**\n * Properties for creating or updating a Cloudflare Queue\n */\nexport interface QueueProps extends CloudflareApiOptions {\n  /**\n   * Name of the queue\n   * Required during creation\n   * Cannot be changed after creation\n   */\n  name: string;\n\n  /**\n   * Settings for the queue\n   * These can be updated after queue creation\n   */\n  settings?: QueueSettings;\n\n  /**\n   * Whether to delete the queue.\n   * If set to false, the queue will remain but the resource will be removed from state\n   *\n   * @default true\n   */\n  delete?: boolean;\n}\n\n/**\n * Output returned after Cloudflare Queue creation/update\n */\nexport interface Queue extends Resource<\"cloudflare::Queue\">, QueueProps {\n  /**\n   * Type identifier for Cloudflare Queue\n   */\n  type: \"queue\";\n\n  /**\n   * The unique ID of the queue\n   */\n  id: string;\n\n  /**\n   * Time when the queue was created\n   */\n  createdOn: string;\n\n  /**\n   * Modified timestamp\n   */\n  modifiedOn: string;\n}\n\ninterface CloudflareQueueResponse {\n  result: {\n    queue_id?: string;\n    queue_name: string;\n    created_on?: string;\n    modified_on?: string;\n    settings?: {\n      delivery_delay?: number;\n      delivery_paused?: boolean;\n      message_retention_period?: number;\n    };\n  };\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n}\n\n/**\n * Creates and manages Cloudflare Queues.\n *\n * Queues provide a managed queue system for reliable message delivery\n * between workers and other systems.\n *\n * @example\n * // Create a basic queue with default settings\n * const basicQueue = await Queue(\"my-app-queue\", {\n *   name: \"my-app-queue\"\n * });\n *\n * @example\n * // Create a queue with custom settings\n * const customQueue = await Queue(\"delayed-queue\", {\n *   name: \"delayed-queue\",\n *   settings: {\n *     deliveryDelay: 30, // 30 second delay before message delivery\n *     messageRetentionPeriod: 86400 // Store messages for 1 day\n *   }\n * });\n *\n * @example\n * // Create a paused queue for later activation\n * const pausedQueue = await Queue(\"paused-queue\", {\n *   name: \"paused-queue\",\n *   settings: {\n *     deliveryPaused: true\n *   }\n * });\n *\n * @see https://developers.cloudflare.com/queues/\n */\nexport const Queue = Resource(\n  \"cloudflare::Queue\",\n  async function (\n    this: Context<Queue>,\n    id: string,\n    props: QueueProps\n  ): Promise<Queue> {\n    const api = await createCloudflareApi(props);\n    const queueName = props.name || id;\n\n    if (this.phase === \"delete\") {\n      console.log(\"Deleting Cloudflare Queue:\", queueName);\n      if (props.delete !== false) {\n        // Delete Queue\n        await deleteQueue(api, this.output?.id);\n      }\n\n      // Return void (a deleted queue has no content)\n      return this.destroy();\n    } else {\n      let queueData: CloudflareQueueResponse;\n\n      if (this.phase === \"create\") {\n        console.log(\"Creating Cloudflare Queue:\", queueName);\n        queueData = await createQueue(api, queueName, props);\n      } else {\n        // Update operation\n        if (this.output?.id) {\n          console.log(\"Updating Cloudflare Queue:\", queueName);\n\n          // Check if name is being changed, which is not allowed\n          if (props.name !== this.output.name) {\n            throw new Error(\n              \"Cannot update Queue name after creation. Queue name is immutable.\"\n            );\n          }\n\n          // Update the queue with new settings\n          queueData = await updateQueue(api, this.output.id, props);\n        } else {\n          // If no ID exists, fall back to creating a new queue\n          console.log(\n            \"No existing Queue ID found, creating new Cloudflare Queue:\",\n            queueName\n          );\n          queueData = await createQueue(api, queueName, props);\n        }\n      }\n\n      return this({\n        type: \"queue\",\n        id: queueData.result.queue_id || \"\",\n        name: queueName,\n        settings: queueData.result.settings\n          ? {\n              deliveryDelay: queueData.result.settings.delivery_delay,\n              deliveryPaused: queueData.result.settings.delivery_paused,\n              messageRetentionPeriod:\n                queueData.result.settings.message_retention_period,\n            }\n          : undefined,\n        createdOn: queueData.result.created_on || new Date().toISOString(),\n        modifiedOn: queueData.result.modified_on || new Date().toISOString(),\n        accountId: api.accountId,\n      });\n    }\n  }\n);\n\n/**\n * Create a new Cloudflare Queue\n */\nexport async function createQueue(\n  api: CloudflareApi,\n  queueName: string,\n  props: QueueProps\n): Promise<CloudflareQueueResponse> {\n  // Prepare the create payload\n  const createPayload: any = {\n    queue_name: queueName,\n  };\n\n  // Add settings if provided\n  if (props.settings) {\n    createPayload.settings = {};\n\n    if (props.settings.deliveryDelay !== undefined) {\n      createPayload.settings.delivery_delay = props.settings.deliveryDelay;\n    }\n\n    if (props.settings.deliveryPaused !== undefined) {\n      createPayload.settings.delivery_paused = props.settings.deliveryPaused;\n    }\n\n    if (props.settings.messageRetentionPeriod !== undefined) {\n      createPayload.settings.message_retention_period =\n        props.settings.messageRetentionPeriod;\n    }\n  }\n\n  const createResponse = await api.post(\n    `/accounts/${api.accountId}/queues`,\n    createPayload\n  );\n\n  if (!createResponse.ok) {\n    return await handleApiError(createResponse, \"creating\", \"Queue\", queueName);\n  }\n\n  return (await createResponse.json()) as CloudflareQueueResponse;\n}\n\n/**\n * Get a Cloudflare Queue\n */\nexport async function getQueue(\n  api: CloudflareApi,\n  queueId: string\n): Promise<CloudflareQueueResponse> {\n  const response = await api.get(\n    `/accounts/${api.accountId}/queues/${queueId}`\n  );\n\n  if (!response.ok) {\n    return await handleApiError(response, \"getting\", \"Queue\", queueId);\n  }\n\n  return (await response.json()) as CloudflareQueueResponse;\n}\n\n/**\n * Delete a Cloudflare Queue\n */\nexport async function deleteQueue(\n  api: CloudflareApi,\n  queueId?: string\n): Promise<void> {\n  if (!queueId) {\n    console.log(\"No Queue ID provided, skipping delete\");\n    return;\n  }\n\n  // Delete Queue\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/queues/${queueId}`\n  );\n\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    const errorData: any = await deleteResponse.json().catch(() => ({\n      errors: [{ message: deleteResponse.statusText }],\n    }));\n    throw new CloudflareApiError(\n      `Error deleting Cloudflare Queue '${queueId}': ${errorData.errors?.[0]?.message || deleteResponse.statusText}`,\n      deleteResponse\n    );\n  }\n}\n\n/**\n * Update a Cloudflare Queue\n *\n * Note: According to Cloudflare API, the queue name cannot be changed after creation.\n * Only the settings can be updated.\n */\nexport async function updateQueue(\n  api: CloudflareApi,\n  queueId: string,\n  props: QueueProps\n): Promise<CloudflareQueueResponse> {\n  // Prepare the update payload - only include settings\n  const updatePayload: any = {};\n\n  // Add settings if provided\n  if (props.settings) {\n    updatePayload.settings = {};\n\n    if (props.settings.deliveryDelay !== undefined) {\n      updatePayload.settings.delivery_delay = props.settings.deliveryDelay;\n    }\n\n    if (props.settings.deliveryPaused !== undefined) {\n      updatePayload.settings.delivery_paused = props.settings.deliveryPaused;\n    }\n\n    if (props.settings.messageRetentionPeriod !== undefined) {\n      updatePayload.settings.message_retention_period =\n        props.settings.messageRetentionPeriod;\n    }\n  }\n\n  // Use PATCH for partial updates (only settings can be updated)\n  const updateResponse = await api.patch(\n    `/accounts/${api.accountId}/queues/${queueId}`,\n    updatePayload\n  );\n\n  if (!updateResponse.ok) {\n    return await handleApiError(updateResponse, \"updating\", \"Queue\", queueId);\n  }\n\n  return (await updateResponse.json()) as CloudflareQueueResponse;\n}\n\n/**\n * List all Cloudflare Queues in an account\n */\nexport async function listQueues(\n  api: CloudflareApi\n): Promise<{ name: string; id: string }[]> {\n  const response = await api.get(`/accounts/${api.accountId}/queues`);\n\n  if (!response.ok) {\n    throw new CloudflareApiError(\n      `Failed to list queues: ${response.statusText}`,\n      response\n    );\n  }\n\n  const data = (await response.json()) as {\n    success: boolean;\n    errors?: Array<{ code: number; message: string }>;\n    result?: Array<{\n      queue_name: string;\n      queue_id: string;\n    }>;\n  };\n\n  if (!data.success) {\n    const errorMessage = data.errors?.[0]?.message || \"Unknown error\";\n    throw new Error(`Failed to list queues: ${errorMessage}`);\n  }\n\n  // Transform API response\n  return (data.result || []).map((queue) => ({\n    name: queue.queue_name,\n    id: queue.queue_id,\n  }));\n}\n\n```\n\n// alchemy/src/cloudflare/r2-rest-state-store.ts\n```ts\nimport type { Scope } from \"../scope\";\nimport { deserialize, serialize } from \"../serde\";\nimport type { State, StateStore } from \"../state\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport {\n  type CloudflareApi,\n  type CloudflareApiOptions,\n  createCloudflareApi,\n} from \"./api\";\nimport { CloudflareApiError, handleApiError } from \"./api-error\";\n\n/**\n * Options for CloudflareR2StateStore\n */\nexport interface CloudflareR2StateStoreOptions extends CloudflareApiOptions {\n  /**\n   * The prefix to use for object keys in the R2 bucket\n   * This allows multiple state stores to use the same R2 bucket\n   */\n  prefix?: string;\n\n  /**\n   * The R2 bucket name to use\n   * Required - the bucket must already exist\n   */\n  bucketName: string;\n}\n\n/**\n * State store implementation using Cloudflare R2 API\n * Uses R2 for immediate consistency compared to KV's eventual consistency\n */\nexport class R2RestStateStore implements StateStore {\n  private api: CloudflareApi;\n  private prefix: string;\n  private bucketName: string;\n  private initialized = false;\n\n  /**\n   * Create a new CloudflareR2StateStore\n   *\n   * @param scope The scope this store belongs to\n   * @param options Options for the state store\n   */\n  constructor(\n    public readonly scope: Scope,\n    private readonly options: CloudflareR2StateStoreOptions\n  ) {\n    // Use the scope's chain to build the prefix, similar to how FileSystemStateStore builds its directory\n    const scopePath = scope.chain.join(\"/\");\n    this.prefix = options.prefix\n      ? `${options.prefix}${scopePath}/`\n      : `alchemy/${scopePath}/`;\n\n    if (!options.bucketName) {\n      throw new Error(\"bucketName is required for CloudflareR2StateStore\");\n    }\n    this.bucketName = options.bucketName;\n\n    // We'll initialize the API in init() to allow for async creation\n    this.api = null as any;\n  }\n\n  /**\n   * Initialize the R2 client\n   */\n  async init(): Promise<void> {\n    if (this.initialized) return;\n\n    // Create Cloudflare API client with automatic account discovery\n    this.api = await createCloudflareApi(this.options);\n\n    this.initialized = true;\n  }\n\n  /**\n   * R2 buckets cannot be deleted programmatically via this method\n   */\n  async deinit(): Promise<void> {\n    // We don't delete the bucket here, only via explicit resource deletion\n  }\n\n  /**\n   * List all resources in the state store\n   */\n  async list(): Promise<string[]> {\n    await this.ensureInitialized();\n\n    // Using pagination to get all objects\n    let keys: string[] = [];\n    let cursor: string | null = null;\n\n    do {\n      const params = new URLSearchParams({\n        prefix: this.prefix,\n        limit: \"1000\",\n      });\n\n      if (cursor) {\n        params.append(\"cursor\", cursor);\n      }\n\n      const listPath = `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects?${params.toString()}`;\n\n      const response = await withExponentialBackoff(\n        async () => {\n          const response = await this.api.get(listPath);\n\n          if (!response.ok) {\n            await handleApiError(response, \"list\", \"bucket\", this.bucketName);\n          }\n\n          return response;\n        },\n        // Retry on transient errors\n        isRetryableError,\n        5, // 5 retry attempts\n        1000 // Start with 1 second delay\n      );\n\n      const data = (await response.json()) as any;\n\n      // The result structure may be under \"result\" key in Cloudflare's API\n      const result = data.result || data;\n      const objects = result.objects || [];\n\n      // Add keys to our list, removing the prefix and converting from storage format\n      keys = keys.concat(\n        objects.map((obj: any) => {\n          const keyName = obj.key || obj.name;\n          return this.convertKeyFromStorage(keyName.slice(this.prefix.length));\n        })\n      );\n\n      // Update cursor for next page if available\n      cursor =\n        result.truncated || result.cursor_pagination\n          ? result.cursor || null\n          : null;\n    } while (cursor);\n\n    return keys;\n  }\n\n  /**\n   * Count the number of items in the state store\n   */\n  async count(): Promise<number> {\n    const keys = await this.list();\n    return keys.length;\n  }\n\n  /**\n   * Get a state by key\n   *\n   * @param key The key to look up\n   * @returns The state or undefined if not found\n   */\n  async get(key: string): Promise<State | undefined> {\n    await this.ensureInitialized();\n\n    try {\n      const response = await withExponentialBackoff(\n        async () => {\n          const response = await this.api.get(\n            `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects/${this.getObjectKey(key)}`\n          );\n\n          if (!response.ok && response.status !== 404) {\n            await handleApiError(response, \"get\", \"object\", key);\n          }\n\n          return response;\n        },\n        // Retry on transient errors\n        isRetryableError,\n        5, // 5 retry attempts\n        1000 // Start with 1 second delay\n      );\n\n      if (response.status === 404) {\n        return undefined;\n      }\n\n      // Parse and deserialize the state data\n      const rawData = await response.json();\n      const state = (await deserialize(this.scope, rawData)) as State;\n\n      // Create a new state object with proper output\n      return {\n        ...state,\n        output: {\n          ...(state.output || {}),\n          Scope: this.scope,\n        },\n      };\n    } catch (error: any) {\n      if (error.message?.includes(\"404\")) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get multiple states by their keys\n   *\n   * @param ids Array of keys to fetch\n   * @returns Record mapping keys to their states\n   */\n  async getBatch(ids: string[]): Promise<Record<string, State>> {\n    const result: Record<string, State> = {};\n\n    // R2 REST API doesn't have a batch get operation, so we need to make multiple requests\n    const promises = ids.map(async (id) => {\n      const state = await this.get(id);\n      if (state) {\n        result[id] = state;\n      }\n    });\n\n    await Promise.all(promises);\n    return result;\n  }\n\n  /**\n   * Get all states in the store\n   *\n   * @returns Record mapping all keys to their states\n   */\n  async all(): Promise<Record<string, State>> {\n    const keys = await this.list();\n    return this.getBatch(keys);\n  }\n\n  /**\n   * Set a state for a key\n   *\n   * @param key The key to set\n   * @param value The state to store\n   */\n  async set(key: string, value: State): Promise<void> {\n    await this.ensureInitialized();\n\n    const objectKey = this.getObjectKey(key);\n\n    // Serialize the state to handle cyclic structures\n    const serializedData = await serialize(this.scope, value);\n\n    // Using withExponentialBackoff for reliability\n    await withExponentialBackoff(\n      async () => {\n        const response = await this.api.put(\n          `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects/${objectKey}`,\n          serializedData,\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n          }\n        );\n\n        if (!response.ok) {\n          await handleApiError(response, \"put\", \"object\", objectKey);\n        }\n        return response;\n      },\n      // Retry on transient errors\n      isRetryableError,\n      5, // 5 retry attempts\n      1000 // Start with 1 second delay\n    );\n  }\n\n  /**\n   * Delete a state by key\n   *\n   * @param key The key to delete\n   */\n  async delete(key: string): Promise<void> {\n    await this.ensureInitialized();\n\n    await withExponentialBackoff(\n      async () => {\n        const response = await this.api.delete(\n          `/accounts/${this.api.accountId}/r2/buckets/${this.bucketName}/objects/${this.getObjectKey(key)}`\n        );\n\n        if (!response.ok && response.status !== 404) {\n          await handleApiError(response, \"delete\", \"object\", key);\n        }\n\n        return response;\n      },\n      isRetryableError,\n      5, // 5 retry attempts\n      1000 // Start with 1 second delay\n    );\n  }\n\n  /**\n   * Convert key for storage by replacing slashes with colons\n   * since R2 treats slashes as directory separators\n   *\n   * @param key The original key\n   * @returns Key with slashes replaced by colons\n   */\n  private convertKeyForStorage(key: string): string {\n    return key.replaceAll(\"/\", \":\");\n  }\n\n  /**\n   * Convert key from storage by replacing colons with slashes\n   *\n   * @param key The storage key\n   * @returns Key with colons replaced by slashes\n   */\n  private convertKeyFromStorage(key: string): string {\n    return key.replaceAll(\":\", \"/\");\n  }\n\n  /**\n   * Get the full object key for storage\n   *\n   * @param key The original key\n   * @returns The key with prefix for use in the R2 bucket\n   */\n  private getObjectKey(key: string): string {\n    return `${this.prefix}${this.convertKeyForStorage(key)}`;\n  }\n\n  /**\n   * Ensure the store is initialized before operations\n   */\n  private async ensureInitialized(): Promise<void> {\n    if (!this.initialized) {\n      await this.init();\n    }\n  }\n}\n\nfunction isRetryableError(error: any): boolean {\n  if (error instanceof CloudflareApiError) {\n    return (\n      error.status === 500 ||\n      error.status === 502 ||\n      error.status === 503 ||\n      error.message.includes(\"timeout\") ||\n      error.message.includes(\"internal error\")\n    );\n  }\n  return false;\n}\n\n```\n\n// alchemy/src/cloudflare/response.ts\n```ts\n/**\n * Cloudflare API response format\n */\nexport interface CloudflareResponse<T = unknown> {\n  result: T;\n  success: boolean;\n  errors: Array<{ code: number; message: string }>;\n  messages: string[];\n}\n\n```\n\n// alchemy/src/cloudflare/types.ts\n```ts\n/**\n * Cloudflare API response format\n */\nexport interface CloudflareApiResponse<T> {\n  /**\n   * API response result\n   */\n  result: T;\n\n  /**\n   * Success status\n   */\n  success: boolean;\n\n  /**\n   * Error details if success is false\n   */\n  errors: CloudflareApiError[];\n\n  /**\n   * Response messages\n   */\n  messages: string[];\n\n  /**\n   * Result information (typically for paginated results)\n   */\n  result_info?: {\n    page: number;\n    per_page: number;\n    total_pages: number;\n    count: number;\n    total_count: number;\n  };\n}\n\n/**\n * Cloudflare API error format\n */\nexport interface CloudflareApiError {\n  /**\n   * Error code\n   */\n  code: number;\n\n  /**\n   * Error message\n   */\n  message: string;\n}\n\n/**\n * Helper to extract and handle Cloudflare API errors\n *\n * @param response Fetch response object\n * @returns Formatted error message\n */\nexport async function extractCloudflareError(\n  response: Response,\n): Promise<string> {\n  try {\n    const data = (await response.json()) as CloudflareApiResponse<any>;\n    if (data.errors && data.errors.length > 0) {\n      return data.errors.map((e) => `Error ${e.code}: ${e.message}`).join(\", \");\n    } else {\n      return `HTTP ${response.status}: ${response.statusText}`;\n    }\n  } catch (e) {\n    return `HTTP ${response.status}: ${response.statusText}`;\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/vite-site.ts\n```ts\nimport fs from \"node:fs/promises\";\nimport path from \"node:path\";\nimport { alchemy } from \"../alchemy\";\nimport { Exec } from \"../os\";\nimport { Assets } from \"./assets\";\nimport type { Bindings } from \"./bindings\";\nimport { Worker } from \"./worker\";\nimport { WranglerJson } from \"./wrangler.json\";\n\nexport interface ViteSiteProps<B extends Bindings> {\n  /**\n   * The command to run to build the site\n   */\n  command: string;\n  /**\n   * The name of the worker\n   *\n   * @default id\n   */\n  name?: string;\n  /**\n   * The entrypoint to your server\n   *\n   * @default - a simple server that serves static assets is generated\n   */\n  main?: string;\n  /**\n   * The directory containing your static assets\n   */\n  assets: string;\n  /**\n   * The bindings to pass to the worker\n   */\n  bindings?: B;\n  /**\n   * @default process.cwd()\n   */\n  cwd?: string;\n}\n\nexport type ViteSite<B extends Bindings> = Promise<\n  // don't allow the ASSETS to be overriden\n  B extends { ASSETS: any } ? never : Worker<B & { ASSETS: Assets }>\n>;\n\nexport async function ViteSite<B extends Bindings>(\n  id: string,\n  props: ViteSiteProps<B>\n): ViteSite<B> {\n  if (props.bindings?.ASSETS) {\n    throw new Error(\"ASSETS binding is reserved for internal use\");\n  }\n\n  // @ts-ignore - we know the types are correct\n  return await alchemy.run(id, async () => {\n    // Create minimal wrangler.jsonc if it doesn't exist\n\n    // `building the site requires a wrangler.jsonc file to start - so initialize an empty one if it doesn't exist`\n    const cwd = props.cwd || process.cwd();\n    const wranglerPath = path.join(cwd, \"wrangler.jsonc\");\n    try {\n      await fs.access(wranglerPath);\n    } catch {\n      await fs.writeFile(\n        wranglerPath,\n        JSON.stringify(\n          {\n            name: id,\n            main: props.main,\n            compatibility_date: new Date().toISOString().split(\"T\")[0],\n          },\n          null,\n          2\n        )\n      );\n    }\n\n    await Exec(\"build\", {\n      command: props.command,\n    });\n\n    const staticAssets = await Assets(\"assets\", {\n      path: \"./dist\",\n    });\n\n    const worker = await Worker(\"worker\", {\n      name: props.name ?? id,\n      entrypoint: props.main,\n      script: props.main\n        ? undefined\n        : `\nexport default {\n  async fetch(request, env) {\n    return env.ASSETS.fetch(request);\n  },\n};`,\n      url: true,\n      adopt: true,\n      bindings: {\n        ...props.bindings,\n        ASSETS: staticAssets,\n      },\n    });\n\n    await WranglerJson(\"wrangler.jsonc\", {\n      worker,\n    });\n\n    return worker;\n  });\n}\n\n```\n\n// alchemy/src/cloudflare/worker-metadata.ts\n```ts\n/**\n * Metadata returned by Cloudflare API for a worker script\n */\nexport interface WorkerScriptMetadata {\n  /**\n   * Worker ID\n   */\n  id: string;\n\n  /**\n   * Default environment information\n   */\n  default_environment?: WorkerDefaultEnvironment;\n\n  /**\n   * Worker creation timestamp\n   */\n  created_on: string;\n\n  /**\n   * Worker last modification timestamp\n   */\n  modified_on: string;\n\n  /**\n   * Worker usage model\n   */\n  usage_model: string;\n\n  /**\n   * Worker environments\n   */\n  environments?: WorkerEnvironment[];\n}\n\n/**\n * Worker script information\n */\nexport interface WorkerScriptInfo {\n  /**\n   * Script creation timestamp\n   */\n  created_on: string;\n\n  /**\n   * Script last modification timestamp\n   */\n  modified_on: string;\n\n  /**\n   * Script ID\n   */\n  id: string;\n\n  /**\n   * Script tag\n   */\n  tag: string;\n\n  /**\n   * Script tags\n   */\n  tags: string[];\n\n  /**\n   * Deployment ID\n   */\n  deployment_id: string;\n\n  /**\n   * Tail consumers\n   */\n  tail_consumers: any;\n\n  /**\n   * Whether logpush is enabled\n   */\n  logpush: boolean;\n\n  /**\n   * Observability settings\n   */\n  observability: {\n    /**\n     * Whether observability is enabled\n     */\n    enabled: boolean;\n\n    /**\n     * Head sampling rate\n     */\n    head_sampling_rate: number | null;\n  };\n\n  /**\n   * Whether the script has assets\n   */\n  has_assets: boolean;\n\n  /**\n   * Whether the script has modules\n   */\n  has_modules: boolean;\n\n  /**\n   * Script etag\n   */\n  etag: string;\n\n  /**\n   * Script handlers\n   */\n  handlers: string[];\n\n  /**\n   * Where the script was last deployed from\n   */\n  last_deployed_from: string;\n\n  /**\n   * Script usage model\n   */\n  usage_model: string;\n}\n\n/**\n * Worker environment information\n */\nexport interface WorkerEnvironment {\n  /**\n   * Environment name\n   */\n  environment: string;\n\n  /**\n   * Environment creation timestamp\n   */\n  created_on: string;\n\n  /**\n   * Environment last modification timestamp\n   */\n  modified_on: string;\n}\n\n/**\n * Default environment with script information\n */\nexport interface WorkerDefaultEnvironment extends WorkerEnvironment {\n  /**\n   * Script information\n   */\n  script: WorkerScriptInfo;\n}\n\n```\n\n// alchemy/src/cloudflare/worker-migration.ts\n```ts\nexport type WorkerMigrations = SingleStepMigration | MultiStepMigration;\n\nexport function isSingleStepMigration(\n  migration: WorkerMigrations,\n): migration is SingleStepMigration {\n  return (\n    \"deleted_classes\" in migration ||\n    \"new_classes\" in migration ||\n    \"new_sqlite_classes\" in migration ||\n    \"renamed_classes\" in migration ||\n    \"transferred_classes\" in migration\n  );\n}\n\nexport interface SingleStepMigration {\n  /**\n   * A list of classes to delete Durable Object namespaces from\n   */\n  deleted_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces from\n   */\n  new_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces with SQLite from\n   */\n  new_sqlite_classes?: string[];\n\n  /**\n   * Tag to set as the latest migration tag\n   */\n  new_tag?: string;\n\n  /**\n   * Tag used to verify against the latest migration tag for this Worker.\n   * If they don't match, the upload is rejected.\n   */\n  old_tag?: string;\n\n  /**\n   * A list of classes with Durable Object namespaces that were renamed\n   */\n  renamed_classes?: RenamedClass[];\n\n  /**\n   * A list of transfers for Durable Object namespaces from a different Worker\n   * and class to a class defined in this Worker\n   */\n  transferred_classes?: TransferredClass[];\n}\n\n/**\n * Represents a renamed class in a Durable Object migration\n */\nexport interface RenamedClass {\n  /**\n   * Original class name\n   */\n  from: string;\n\n  /**\n   * New class name\n   */\n  to: string;\n}\n\n/**\n * Represents a transferred class in a Durable Object migration\n */\nexport interface TransferredClass {\n  /**\n   * Original class name\n   */\n  from: string;\n\n  /**\n   * Original script name\n   */\n  from_script: string;\n\n  /**\n   * New class name in this Worker\n   */\n  to: string;\n}\n\nexport function isMultiStepMigration(\n  migration: WorkerMigrations,\n): migration is MultiStepMigration {\n  return \"steps\" in migration;\n}\n\n/**\n * Represents a multi-step migration for Durable Objects\n */\nexport interface MultiStepMigration {\n  /**\n   * Tag to set as the latest migration tag\n   */\n  new_tag?: string;\n\n  /**\n   * Tag used to verify against the latest migration tag for this Worker.\n   * If they don't match, the upload is rejected.\n   */\n  old_tag?: string;\n\n  /**\n   * Migrations to apply in order\n   */\n  steps: MigrationStep[];\n}\n\n/**\n * Represents a single step in a Durable Object migration\n */\nexport interface MigrationStep {\n  /**\n   * A list of classes to delete Durable Object namespaces from\n   */\n  deleted_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces from\n   */\n  new_classes?: string[];\n\n  /**\n   * A list of classes to create Durable Object namespaces with SQLite from\n   */\n  new_sqlite_classes?: string[];\n\n  /**\n   * A list of classes with Durable Object namespaces that were renamed\n   */\n  renamed_classes?: RenamedClass[];\n\n  /**\n   * A list of transfers for Durable Object namespaces from a different Worker\n   * and class to a class defined in this Worker\n   */\n  transferred_classes?: TransferredClass[];\n}\n\n```\n\n// alchemy/src/cloudflare/worker.ts\n```ts\nimport * as crypto from \"crypto\";\nimport * as fs from \"fs/promises\";\nimport type { Context } from \"../context\";\nimport { Bundle, type BundleProps } from \"../esbuild/bundle\";\nimport { Resource } from \"../resource\";\nimport { getContentType } from \"../util/content-type\";\nimport { withExponentialBackoff } from \"../util/retry\";\nimport { slugify } from \"../util/slugify\";\nimport {\n  createCloudflareApi,\n  type CloudflareApi,\n  type CloudflareApiOptions,\n} from \"./api\";\nimport { type Assets } from \"./assets\";\nimport { type Bindings, type WorkerBindingSpec } from \"./bindings\";\nimport type { Bound } from \"./bound\";\nimport { type DurableObjectNamespace } from \"./durable-object-namespace\";\nimport type { WorkerScriptMetadata } from \"./worker-metadata\";\nimport type { SingleStepMigration } from \"./worker-migration\";\nimport { upsertWorkflow, type Workflow } from \"./workflow\";\n\n/**\n * Properties for creating or updating a Worker\n */\nexport interface WorkerProps<B extends Bindings = Bindings>\n  extends CloudflareApiOptions {\n  /**\n   * The worker script content (JavaScript or WASM)\n   * One of script, entryPoint, or bundle must be provided\n   */\n  script?: string;\n\n  /**\n   * Path to the entry point file\n   * Will be bundled using esbuild\n   * One of script, entryPoint, or bundle must be provided\n   */\n  entrypoint?: string;\n\n  /**\n   * Bundle options when using entryPoint\n   * Ignored if bundle is provided\n   */\n  bundle?: Omit<BundleProps, \"entryPoint\">;\n\n  /**\n   * Module format for the worker script\n   * 'esm' - ECMAScript modules (default)\n   * 'cjs' - CommonJS modules\n   * @default 'esm'\n   */\n  format?: \"esm\" | \"cjs\";\n\n  /**\n   * Name for the worker\n   * This is mandatory - must be explicitly specified\n   */\n  name: string;\n\n  /**\n   * Bindings to attach to the worker\n   */\n  bindings?: B;\n\n  /**\n   * Environment variables to attach to the worker\n   * These will be converted to plain_text bindings\n   */\n  env?: {\n    [key: string]: string;\n  };\n\n  /**\n   * Whether to enable a workers.dev URL for this worker\n   * If true, the worker will be available at {name}.{subdomain}.workers.dev\n   * @default false\n   */\n  url?: boolean;\n\n  /**\n   * Observability configuration for the worker\n   * Controls whether worker logs are enabled\n   * @default { enabled: true }\n   */\n  observability?: {\n    /**\n     * Whether to enable worker logs\n     * @default true\n     */\n    enabled?: boolean;\n  };\n\n  /**\n   * Migrations to apply to the worker\n   */\n  migrations?: SingleStepMigration;\n\n  /**\n   * Whether to adopt the Worker if it already exists when creating\n   */\n  adopt?: boolean;\n\n  /**\n   * The compatibility date for the worker\n   * @default \"2024-09-09\"\n   */\n  compatibilityDate?: string;\n\n  /**\n   * The compatibility flags for the worker\n   */\n  compatibilityFlags?: string[];\n}\n\n/**\n * Output returned after Worker creation/update\n */\nexport interface Worker<B extends Bindings = Bindings>\n  extends Resource<\"cloudflare::Worker\">,\n    Omit<WorkerProps<B>, \"url\"> {\n  type: \"service\";\n\n  /**\n   * The ID of the worker\n   */\n  id: string;\n\n  /**\n   * Time at which the worker was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the worker was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * The worker's URL if enabled\n   * Format: {name}.{subdomain}.workers.dev\n   */\n  url?: string;\n\n  /**\n   * The bindings that were created\n   */\n  bindings: B | undefined;\n\n  // phantom property (for typeof myWorker.Env)\n  Env: {\n    [bindingName in keyof B]: Bound<B[bindingName]>;\n  };\n}\n\n/**\n * A Cloudflare Worker is a serverless function that can be deployed to the Cloudflare network.\n *\n * @example\n * // Create a basic HTTP handler worker with custom domain routing\n * // and workers.dev URL:\n * const api = await Worker(\"api\", {\n *   name: \"api-worker\",\n *   entrypoint: \"./src/api.ts\",\n *   routes: [\"api.example.com/*\"],\n *   url: true\n * });\n *\n * @example\n * // Create a real-time chat worker using Durable Objects\n * // for state management:\n * const chatRooms = new DurableObjectNamespace(\"chat-rooms\");\n * const userStore = new DurableObjectNamespace(\"user-store\");\n *\n * const chat = await Worker(\"chat\", {\n *   name: \"chat-worker\",\n *   entrypoint: \"./src/chat.ts\",\n *   bindings: {\n *     ROOMS: chatRooms,\n *     USERS: userStore\n *   },\n * });\n *\n * @example\n * // Create a worker with KV namespace for caching and data storage:\n * const cache = await KVNamespace(\"cache-store\");\n * const settings = await KVNamespace(\"user-settings\");\n *\n * const cacheWorker = await Worker(\"cache\", {\n *   name: \"cache-worker\",\n *   entrypoint: \"./src/cache.ts\",\n *   bindings: {\n *     CACHE: cache,\n *     SETTINGS: settings\n *   }\n * });\n *\n * @example\n * // Create a worker with R2 bucket for object storage:\n * const uploads = await R2Bucket(\"uploads\", {\n *   name: \"user-uploads\"\n * });\n * const assets = await R2Bucket(\"assets\", {\n *   name: \"static-assets\",\n *   allowPublicAccess: true\n * });\n *\n * const storageWorker = await Worker(\"storage\", {\n *   name: \"storage-worker\",\n *   entrypoint: \"./src/storage.ts\",\n *   bindings: {\n *     UPLOADS: uploads,\n *     ASSETS: assets\n *   }\n * });\n *\n * @example\n * // Create a worker with static assets:\n * const staticAssets = await Assets(\"static\", {\n *   path: \"./src/assets\"\n * });\n *\n * const frontendWorker = await Worker(\"frontend\", {\n *   name: \"frontend-worker\",\n *   entrypoint: \"./src/worker.ts\",\n *   bindings: {\n *     ASSETS: staticAssets\n *   }\n * });\n *\n * @see https://developers.cloudflare.com/workers/\n */\nexport const Worker = Resource(\n  \"cloudflare::Worker\",\n  {\n    alwaysUpdate: true,\n  },\n  async function <const B extends Bindings>(\n    this: Context<Worker<NoInfer<B>>>,\n    id: string,\n    props: WorkerProps<B>\n  ): Promise<Worker<B>> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    // Use the provided name\n    const workerName = props.name;\n\n    // Validate input - we need either script, entryPoint, or bundle\n    if (!props.script && !props.entrypoint) {\n      throw new Error(\"One of script or entryPoint must be provided\");\n    }\n\n    if (this.phase === \"delete\") {\n      await deleteWorker(this, api, workerName);\n      return this.destroy();\n    } else if (this.phase === \"create\") {\n      if (!props.adopt) {\n        await assertWorkerDoesNotExist(this, api, workerName);\n      }\n    }\n\n    const oldBindings = await this.get<Bindings>(\"bindings\");\n\n    // Get the script content - either from props.script, or by bundling\n    const scriptContent = props.script ?? (await bundleWorkerScript(props));\n\n    // Find any assets bindings\n    const assetsBindings: { name: string; assets: Assets }[] = [];\n    const workflowsBindings: Workflow[] = [];\n\n    if (props.bindings) {\n      for (const [bindingName, binding] of Object.entries(props.bindings)) {\n        if (typeof binding === \"object\") {\n          if (binding.type === \"assets\") {\n            assetsBindings.push({ name: bindingName, assets: binding });\n          } else if (binding.type === \"workflow\") {\n            workflowsBindings.push(binding);\n          }\n        }\n      }\n    }\n\n    // Upload any assets and get completion tokens\n    let assetUploadResult: AssetUploadResult | undefined;\n    if (assetsBindings.length > 0) {\n      // We'll use the first asset binding for now\n      // In the future, we might want to support multiple asset bindings\n      const assetBinding = assetsBindings[0];\n\n      // Upload the assets and get the completion token\n      assetUploadResult = await uploadAssets(\n        api,\n        workerName,\n        assetBinding.assets\n      );\n    }\n\n    // Prepare metadata with bindings\n    const scriptMetadata = await prepareWorkerMetadata(\n      this,\n      oldBindings,\n      props,\n      assetUploadResult\n    );\n\n    await putWorker(api, workerName, scriptContent, scriptMetadata);\n\n    for (const workflow of workflowsBindings) {\n      await upsertWorkflow(api, {\n        workflowName: workflow.workflowName,\n        className: workflow.className,\n        scriptName: workerName,\n      });\n    }\n\n    // TODO: it is less than ideal that this can fail, resulting in state problem\n    await this.set(\"bindings\", props.bindings);\n\n    // Handle worker URL if requested\n    const workerUrl = await configureURL(\n      this,\n      api,\n      workerName,\n      props.url ?? false\n    );\n\n    // Get current timestamp\n    const now = Date.now();\n\n    // Construct the output\n    return this({\n      ...props,\n      type: \"service\",\n      id,\n      entrypoint: props.entrypoint,\n      name: workerName,\n      script: scriptContent,\n      format: props.format || \"esm\", // Include format in the output\n      bindings: props.bindings ?? ({} as B),\n      env: props.env,\n      observability: scriptMetadata.observability,\n      createdAt: now,\n      updatedAt: now,\n      url: workerUrl,\n      // phantom property\n      Env: undefined!,\n    });\n  }\n);\n\nasync function deleteWorker<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  api: CloudflareApi,\n  workerName: string\n) {\n  // Delete worker\n  const deleteResponse = await api.delete(\n    `/accounts/${api.accountId}/workers/scripts/${workerName}`\n  );\n\n  // Check for success (2xx status code)\n  if (!deleteResponse.ok && deleteResponse.status !== 404) {\n    const errorData: any = await deleteResponse\n      .json()\n      .catch(() => ({ errors: [{ message: deleteResponse.statusText }] }));\n    console.error(\n      \"Error deleting worker:\",\n      errorData.errors?.[0]?.message || deleteResponse.statusText\n    );\n  }\n\n  // Disable the URL if it was enabled\n  if (ctx.output?.url) {\n    try {\n      await api.post(\n        `/accounts/${api.accountId}/workers/scripts/${workerName}/subdomain`,\n        JSON.stringify({ enabled: false }),\n        {\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    } catch (error) {\n      console.warn(\"Failed to disable worker URL during deletion:\", error);\n    }\n  }\n\n  // Return minimal output for deleted state\n  return;\n}\n\nasync function putWorker(\n  api: CloudflareApi,\n  workerName: string,\n  scriptContent: string,\n  scriptMetadata: WorkerMetadata\n) {\n  return withExponentialBackoff(\n    async () => {\n      const scriptName =\n        scriptMetadata.main_module ?? scriptMetadata.body_part!;\n\n      // Create FormData for the upload\n      const formData = new FormData();\n\n      // Add the actual script content as a named file part\n      formData.append(\n        scriptName,\n        new Blob([scriptContent], {\n          type: scriptMetadata.main_module\n            ? \"application/javascript+module\"\n            : \"application/javascript\",\n        }),\n        scriptName\n      );\n\n      // Add metadata as JSON\n      formData.append(\n        \"metadata\",\n        new Blob([JSON.stringify(scriptMetadata)], {\n          type: \"application/json\",\n        })\n      );\n\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n\n      // Upload worker script with bindings\n      const uploadResponse = await api.put(\n        `/accounts/${api.accountId}/workers/scripts/${workerName}`,\n        formData,\n        {\n          headers: {\n            \"Content-Type\": \"multipart/form-data\",\n          },\n        }\n      );\n\n      // Check if the upload was successful\n      if (!uploadResponse.ok) {\n        const errorData: any = await uploadResponse\n          .json()\n          .catch(() => ({ errors: [{ message: uploadResponse.statusText }] }));\n\n        const errorMessage = `Error (HTTP ${uploadResponse.status}) uploading worker script '${workerName}': ${errorData.errors?.[0]?.message || uploadResponse.statusText}`;\n\n        if (\n          uploadResponse.status === 400 &&\n          errorMessage.includes(\"not found\")\n        ) {\n          throw new NotFoundError(errorMessage);\n        }\n        throw new Error(errorMessage);\n      }\n\n      return formData;\n    },\n    (err) => err instanceof NotFoundError,\n    10,\n    100\n  );\n}\n\nclass NotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"NotFoundError\";\n  }\n}\n\ninterface WorkerMetadata {\n  compatibility_date: string;\n  compatibility_flags?: string[];\n  bindings: WorkerBindingSpec[];\n  observability: {\n    enabled: boolean;\n  };\n  migrations?: SingleStepMigration;\n  main_module?: string;\n  body_part?: string;\n  tags?: string[];\n  assets?: {\n    jwt?: string;\n    keep_assets?: boolean;\n    config?: {\n      html_handling?: \"auto-trailing-slash\" | \"none\";\n      not_found_handling?: \"none\" | \"fall-through\";\n    };\n  };\n}\n\ninterface AssetUploadResult {\n  completionToken: string;\n  assetConfig?: {\n    html_handling?: \"auto-trailing-slash\" | \"none\";\n    not_found_handling?: \"none\" | \"fall-through\";\n  };\n}\n\nasync function prepareWorkerMetadata<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  oldBindings: Bindings | undefined,\n  props: WorkerProps,\n  assetUploadResult?: AssetUploadResult\n): Promise<WorkerMetadata> {\n  // Prepare metadata with bindings\n  const meta: WorkerMetadata = {\n    compatibility_date: props.compatibilityDate ?? \"2024-09-09\",\n    compatibility_flags: props.compatibilityFlags,\n    bindings: [],\n    observability: {\n      enabled: props.observability?.enabled !== false,\n    },\n    // TODO(sam): base64 encode instead? 0 collision risk vs readability.\n    tags: [`alchemy:id:${slugify(ctx.fqn)}`],\n    migrations: {\n      new_classes: props.migrations?.new_classes ?? [],\n      deleted_classes: props.migrations?.deleted_classes ?? [],\n      renamed_classes: props.migrations?.renamed_classes ?? [],\n      transferred_classes: props.migrations?.transferred_classes ?? [],\n      new_sqlite_classes: props.migrations?.new_sqlite_classes ?? [],\n    },\n  };\n\n  // If we have asset upload results, add them to the metadata\n  if (assetUploadResult) {\n    meta.assets = {\n      jwt: assetUploadResult.completionToken,\n    };\n\n    if (assetUploadResult.assetConfig) {\n      meta.assets.config = assetUploadResult.assetConfig;\n    }\n  }\n\n  const bindings = (props.bindings ?? {}) as Bindings;\n\n  // Convert bindings to the format expected by the API\n  for (const [bindingName, binding] of Object.entries(bindings)) {\n    // Create a copy of the binding to avoid modifying the original\n\n    if (typeof binding === \"string\") {\n      meta.bindings.push({\n        type: \"plain_text\",\n        name: bindingName,\n        text: binding,\n      });\n    } else if (binding.type === \"d1\") {\n      meta.bindings.push({\n        type: \"d1\",\n        name: bindingName,\n        id: binding.id,\n      });\n    } else if (binding.type === \"kv_namespace\") {\n      meta.bindings.push({\n        type: \"kv_namespace\",\n        name: bindingName,\n        namespace_id: binding.namespaceId,\n      });\n    } else if (binding.type === \"service\") {\n      meta.bindings.push({\n        type: \"service\",\n        name: bindingName,\n        service: binding.id,\n      });\n    } else if (binding.type === \"durable_object_namespace\") {\n      meta.bindings.push({\n        type: \"durable_object_namespace\",\n        name: bindingName,\n        class_name: binding.className,\n        script_name: binding.scriptName,\n        environment: binding.environment,\n        namespace_id: binding.namespaceId,\n      });\n      configureClassMigration(binding, binding.id, binding.className);\n    } else if (binding.type === \"r2_bucket\") {\n      meta.bindings.push({\n        type: \"r2_bucket\",\n        name: bindingName,\n        bucket_name: binding.name,\n      });\n    } else if (binding.type === \"assets\") {\n      meta.bindings.push({\n        type: \"assets\",\n        name: bindingName,\n      });\n    } else if (binding.type === \"secret\") {\n      meta.bindings.push({\n        type: \"secret_text\",\n        name: bindingName,\n        text: binding.unencrypted,\n      });\n    } else if (binding.type === \"workflow\") {\n      meta.bindings.push({\n        type: \"workflow\",\n        name: bindingName,\n        workflow_name: binding.workflowName,\n        class_name: binding.className,\n        // this should be set if the Workflow is in another script ...\n        // script_name: ??,\n      });\n      // it's unclear whether this is needed, but it works both ways\n      configureClassMigration(binding, binding.id, binding.className);\n    } else if (binding.type === \"queue\") {\n      meta.bindings.push({\n        type: \"queue\",\n        name: bindingName,\n        queue_name: binding.name,\n      });\n    } else if (binding.type === \"pipeline\") {\n      meta.bindings.push({\n        type: \"pipelines\",\n        name: bindingName,\n        pipeline: binding.name,\n      });\n    } else if (binding.type === \"vectorize\") {\n      meta.bindings.push({\n        type: \"vectorize\",\n        name: bindingName,\n        index_name: binding.name,\n      });\n    } else {\n      // @ts-expect-error - we should never reach here\n      throw new Error(`Unsupported binding type: ${binding.type}`);\n    }\n  }\n\n  function configureClassMigration(\n    binding: DurableObjectNamespace | Workflow,\n    stableId: string,\n    className: string\n  ) {\n    const oldBinding: DurableObjectNamespace | Workflow | undefined =\n      Object.values(oldBindings ?? {})\n        ?.filter(\n          (b) =>\n            typeof b === \"object\" &&\n            (b.type === \"durable_object_namespace\" || b.type === \"workflow\")\n        )\n        ?.find((b) => b.id === stableId);\n\n    if (!oldBinding) {\n      if (binding.type === \"durable_object_namespace\" && binding.sqlite) {\n        meta.migrations!.new_sqlite_classes!.push(className);\n      } else {\n        meta.migrations!.new_classes!.push(className);\n      }\n    } else if (oldBinding.className !== className) {\n      meta.migrations!.renamed_classes!.push({\n        from: oldBinding.className,\n        to: className,\n      });\n    }\n  }\n\n  // Convert env variables to plain_text bindings\n  // TODO(sam): remove Worker.env in favor of always bindings\n  if (props.env) {\n    for (const [key, value] of Object.entries(props.env)) {\n      meta.bindings.push({\n        name: key,\n        type: \"plain_text\",\n        text: value,\n      });\n    }\n  }\n\n  // Determine if we're using ESM or service worker format\n  const isEsModule = props.format !== \"cjs\"; // Default to ESM unless CJS is specified\n  const scriptName = isEsModule ? \"worker.js\" : \"script\";\n\n  if (isEsModule) {\n    // For ES modules format\n    meta.main_module = scriptName;\n  } else {\n    // For service worker format (CJS)\n    meta.body_part = scriptName;\n  }\n  return meta;\n}\n\nasync function assertWorkerDoesNotExist<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  api: CloudflareApi,\n  workerName: string\n) {\n  const response = await api.get(\n    `/accounts/${api.accountId}/workers/scripts/${workerName}`\n  );\n  if (response.status === 404) {\n    return true;\n  }\n  if (response.status === 200) {\n    const metadata = await getWorkerScriptMetadata(api, workerName);\n\n    if (!metadata) {\n      throw new Error(\n        `Worker exists but failed to fetch metadata: ${response.status} ${response.statusText}`\n      );\n    }\n\n    if (\n      metadata.default_environment?.script.tags.includes(\n        `alchemy:id:${slugify(ctx.fqn)}`\n      )\n    ) {\n      return true;\n    }\n\n    throw new Error(\n      `Worker with name '${workerName}' already exists. Please use a unique name.`\n    );\n  } else {\n    throw new Error(\n      `Error checking if worker exists: ${response.status} ${response.statusText} ${await response.text()}`\n    );\n  }\n}\n\nasync function bundleWorkerScript<B extends Bindings>(props: WorkerProps) {\n  // Get the script content - either from props.script, or by bundling\n\n  // Create and use a Bundle resource with worker-optimized configuration\n  const defaultBundleOptions: Omit<BundleProps, \"entryPoint\"> = {\n    format: props.format === \"cjs\" ? \"cjs\" : \"esm\", // Use the specified format or default to ESM\n    target: \"es2020\",\n    platform: \"browser\",\n    minify: true,\n    options: {\n      keepNames: true, // Important for Durable Object classes\n      loader: {\n        \".sql\": \"text\",\n        \".json\": \"json\",\n      },\n    },\n  };\n\n  // Merge with user-provided options\n  const bundleOptions = {\n    ...defaultBundleOptions,\n    ...(props.bundle || {}),\n  };\n\n  // Create the bundle\n  const bundle = await Bundle(\"bundle\", {\n    entryPoint: props.entrypoint!,\n    ...bundleOptions,\n    external: [...(bundleOptions.external ?? []), \"cloudflare:workers\"],\n  });\n\n  try {\n    return await fs.readFile(bundle.path, \"utf-8\");\n  } catch (error) {\n    console.error(\"Error reading bundle:\", error);\n    throw new Error(\"Error reading bundle\");\n  }\n}\n\nasync function configureURL<B extends Bindings>(\n  ctx: Context<Worker<B>>,\n  api: CloudflareApi,\n  workerName: string,\n  url: boolean\n) {\n  let workerUrl;\n  if (url) {\n    // Enable the workers.dev subdomain for this worker\n    await api.post(\n      `/accounts/${api.accountId}/workers/scripts/${workerName}/subdomain`,\n      { enabled: true, previews_enabled: true },\n      {\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n\n    // Get the account's workers.dev subdomain\n    const subdomainResponse = await api.get(\n      `/accounts/${api.accountId}/workers/subdomain`\n    );\n\n    if (!subdomainResponse.ok) {\n      throw new Error(\n        `Could not fetch workers.dev subdomain: ${subdomainResponse.status} ${subdomainResponse.statusText}`\n      );\n    }\n    const subdomainData: {\n      result: {\n        subdomain: string;\n      };\n    } = await subdomainResponse.json();\n    const subdomain = subdomainData.result?.subdomain;\n\n    if (subdomain) {\n      workerUrl = `https://${workerName}.${subdomain}.workers.dev`;\n\n      // Add a delay when the subdomain is first created.\n      // This is to prevent an issue where a negative cache-hit\n      // causes the subdomain to be unavailable for 30 seconds.\n      if (ctx.phase === \"create\" || !ctx.output?.url) {\n        await new Promise((resolve) => setTimeout(resolve, 3000));\n      }\n    }\n  } else if (url === false && ctx.output?.url) {\n    // Explicitly disable URL if it was previously enabled\n    const response = await api.post(\n      `/accounts/${api.accountId}/workers/scripts/${workerName}/subdomain`,\n      JSON.stringify({ enabled: false }),\n      {\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n    if (!response.ok) {\n      throw new Error(\n        `Failed to disable worker URL: ${response.status} ${response.statusText}`\n      );\n    }\n  }\n  return workerUrl;\n}\n\nasync function getWorkerScriptMetadata(\n  api: CloudflareApi,\n  workerName: string\n): Promise<WorkerScriptMetadata | undefined> {\n  const response = await api.get(\n    `/accounts/${api.accountId}/workers/services/${workerName}`\n  );\n  if (response.status === 404) {\n    return undefined;\n  }\n  if (!response.ok) {\n    throw new Error(\n      `Error getting worker script metadata: ${response.status} ${response.statusText}`\n    );\n  }\n  return ((await response.json()) as any).result as WorkerScriptMetadata;\n}\n\nasync function getWorkerBindings(\n  api: CloudflareApi,\n  workerName: string,\n  environment = \"production\"\n) {\n  const response = await api.get(\n    `/accounts/${api.accountId}/workers/services/${workerName}/environments/${environment}/bindings`,\n    {\n      headers: {\n        Authorization: `Bearer ${process.env.CLOUDFLARE_API_TOKEN}`,\n        \"Content-Type\": \"application/json\",\n      },\n    }\n  );\n\n  if (response.status === 404) {\n    return undefined;\n  }\n\n  if (!response.ok) {\n    throw new Error(\n      `Failed to fetch bindings: ${response.status} ${response.statusText}`\n    );\n  }\n\n  const data: any = await response.json();\n\n  return data.result;\n}\n\n/**\n * Interface for a file's metadata to be uploaded\n */\ninterface FileMetadata {\n  hash: string;\n  size: number;\n}\n\n/**\n * Response from the assets upload session API\n */\ninterface UploadSessionResponse {\n  result: {\n    jwt: string;\n    buckets: string[][];\n  };\n  success: boolean;\n  errors: any[];\n  messages: any[];\n}\n\n/**\n * Response from the file upload API\n */\ninterface UploadResponse {\n  result: {\n    jwt: string;\n    buckets?: string[][];\n  };\n  success: boolean;\n  errors: any[];\n  messages: any[];\n}\n\n/**\n * Uploads assets to Cloudflare and returns a completion token\n *\n * @param api CloudflareApi instance\n * @param workerName Name of the worker\n * @param assets Assets resource containing files to upload\n * @returns Completion token for the assets upload\n */\nasync function uploadAssets(\n  api: CloudflareApi,\n  workerName: string,\n  assets: Assets\n): Promise<AssetUploadResult> {\n  // Generate the file manifest\n  const fileMetadata: Record<string, FileMetadata> = {};\n\n  // Process each file in the assets\n  for (const file of assets.files) {\n    const { hash, size } = await calculateFileMetadata(file.filePath);\n    // Use the relative path as the key, ensuring it starts with a slash\n    const key = file.path.startsWith(\"/\") ? file.path : `/${file.path}`;\n    fileMetadata[key] = { hash, size };\n  }\n\n  // Start the upload session\n  const uploadSessionUrl = `/accounts/${api.accountId}/workers/scripts/${workerName}/assets-upload-session`;\n  const uploadSessionResponse = await api.post(\n    uploadSessionUrl,\n    JSON.stringify({ manifest: fileMetadata }),\n    {\n      headers: { \"Content-Type\": \"application/json\" },\n    }\n  );\n\n  if (!uploadSessionResponse.ok) {\n    throw new Error(\n      `Failed to start assets upload session: ${uploadSessionResponse.status} ${uploadSessionResponse.statusText}`\n    );\n  }\n\n  const sessionData =\n    (await uploadSessionResponse.json()) as UploadSessionResponse;\n\n  // If there are no buckets, assets are already uploaded or empty\n  if (!sessionData.result.buckets || sessionData.result.buckets.length === 0) {\n    return { completionToken: sessionData.result.jwt };\n  }\n\n  // Upload the files in batches as specified by the API\n  let completionToken = sessionData.result.jwt;\n  const buckets = sessionData.result.buckets;\n\n  // Process each bucket of files\n  for (const bucket of buckets) {\n    const formData = new FormData();\n\n    let totalBytes = 0;\n\n    // Add each file in the bucket to the form\n    for (const fileHash of bucket) {\n      // Find the file with this hash\n      const file = assets.files.find((f) => {\n        const filePath = f.path.startsWith(\"/\") ? f.path : `/${f.path}`;\n        return fileMetadata[filePath]?.hash === fileHash;\n      });\n\n      if (!file) {\n        throw new Error(`Could not find file with hash ${fileHash}`);\n      }\n\n      // Read the file content\n      const fileContent = await fs.readFile(file.filePath);\n\n      // Convert to base64 as required by the API when using base64=true\n      const base64Content = fileContent.toString(\"base64\");\n\n      // Add the file to the form with the hash as the key and set the correct content type\n      const blob = new Blob([base64Content], {\n        type: getContentType(file.filePath),\n      });\n      totalBytes += blob.size;\n      formData.append(fileHash, blob, fileHash);\n    }\n\n    // Upload this batch of files\n    const uploadResponse = await api.post(\n      `/accounts/${api.accountId}/workers/assets/upload?base64=true`,\n      formData,\n      {\n        headers: {\n          Authorization: `Bearer ${completionToken}`,\n          \"Content-Type\": \"multipart/form-data\",\n        },\n      }\n    );\n\n    if (!uploadResponse.ok) {\n      throw new Error(\n        `Failed to upload asset files: ${uploadResponse.status} ${uploadResponse.statusText}`\n      );\n    }\n\n    const uploadData = (await uploadResponse.json()) as UploadResponse;\n    // Update the completion token for the next batch\n    if (uploadData.result.jwt) {\n      completionToken = uploadData.result.jwt;\n    }\n  }\n\n  // Return the final completion token\n  return {\n    completionToken,\n    assetConfig: {\n      html_handling: \"auto-trailing-slash\",\n    },\n  };\n}\n\n/**\n * Calculate the SHA-256 hash and size of a file\n *\n * @param filePath Path to the file\n * @returns Hash (first 32 chars of SHA-256) and size of the file\n */\nasync function calculateFileMetadata(\n  filePath: string\n): Promise<{ hash: string; size: number }> {\n  const hash = crypto.createHash(\"sha256\");\n  const fileContent = await fs.readFile(filePath);\n\n  hash.update(fileContent);\n  const fileHash = hash.digest(\"hex\").substring(0, 32); // First 32 chars of hash\n\n  return {\n    hash: fileHash,\n    size: fileContent.length,\n  };\n}\n\n```\n\n// alchemy/src/cloudflare/workflow.ts\n```ts\nimport type { CloudflareApi } from \"./api\";\nimport { handleApiError } from \"./api-error\";\n\nexport interface WorkflowProps {\n  /**\n   * Name of the workflow\n   *\n   * @maxLength 64\n   * @minLength 1\n   * @default - className if provided, otherwise id\n   */\n  workflowName?: string;\n  /**\n   * Name of the class that implements the workflow\n   *\n   * @maxLength 255\n   * @minLength 1\n   * @default - workflowName if provided, otherwise id\n   */\n  className?: string;\n}\n\nexport class Workflow<PARAMS = unknown> {\n  public readonly type: \"workflow\" = \"workflow\";\n  /**\n   * Phantom property to preserve workflow params at the type level.\n   *\n   * No value exists.\n   */\n  public readonly _PARAMS: PARAMS = undefined!;\n\n  public readonly workflowName: string;\n  public readonly className: string;\n\n  constructor(\n    public readonly id: string,\n    props: WorkflowProps = {}\n  ) {\n    this.workflowName = props.workflowName ?? props.className ?? id;\n    this.className = props.className ?? this.workflowName;\n  }\n}\n\nexport interface WorkflowMetadata {\n  id: string; // uuid\n  class_name: string;\n  created_on: string; // date-time\n  modified_on: string; // date-time\n  name: string; // maxLength: 64, minLength: 1\n  script_name: string;\n  triggered_on: string; // date-time\n  version_id: string; // uuid\n}\n\nexport async function upsertWorkflow(\n  api: CloudflareApi,\n  props: WorkflowProps & {\n    workflowName: string;\n    scriptName: string;\n  }\n) {\n  const response = await api.put(\n    `/accounts/${api.accountId}/workflows/${props.workflowName}`,\n    {\n      class_name: props.className,\n      script_name: props.scriptName,\n    }\n  );\n\n  if (!response.ok) {\n    await handleApiError(response, \"create\", \"workflow\", props.workflowName);\n  }\n\n  const body = (await response.json()) as {\n    result: WorkflowMetadata;\n  };\n\n  return body.result;\n}\n\n```\n\n// alchemy/src/cloudflare/wrangler.json.ts\n```ts\nimport type { Context } from \"../context\";\nimport { StaticJsonFile } from \"../fs\";\nimport { Resource } from \"../resource\";\nimport type { Bindings } from \"./bindings\";\nimport type { DurableObjectNamespace } from \"./durable-object-namespace\";\nimport type { Worker } from \"./worker\";\n\n/**\n * Properties for wrangler.json configuration file\n */\nexport interface WranglerJsonProps {\n  name?: string;\n  /**\n   * The worker to generate the wrangler.json file for\n   */\n  worker: Worker;\n  /**\n   * Path to write the wrangler.json file to\n   *\n   * @default cwd/wrangler.json\n   */\n  path?: string;\n}\n\n/**\n * Output returned after WranglerJson creation/update\n */\nexport interface WranglerJson\n  extends Resource<\"cloudflare::WranglerJson\">,\n    WranglerJsonProps {\n  /**\n   * Time at which the file was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the file was last updated\n   */\n  updatedAt: number;\n\n  /**\n   * Path to the wrangler.json file\n   */\n  path: string;\n}\n\n/**\n * Resource for managing wrangler.json configuration files\n */\nexport const WranglerJson = Resource(\n  \"cloudflare::WranglerJson\",\n  async function (\n    this: Context<WranglerJson>,\n    id: string,\n    props: WranglerJsonProps\n  ): Promise<WranglerJson> {\n    // Default path is wrangler.json in current directory\n    const filePath = props.path || \"wrangler.jsonc\";\n\n    if (this.phase === \"delete\") {\n      return this.destroy();\n    }\n\n    if (props.worker.entrypoint === undefined) {\n      throw new Error(\n        \"Worker must have an entrypoint to generate a wrangler.json\"\n      );\n    }\n\n    const worker = props.worker;\n\n    const spec: WranglerJsonSpec = {\n      name: worker.name,\n      // Use entrypoint as main if it exists\n      main: worker.entrypoint,\n      // see: https://developers.cloudflare.com/workers/configuration/compatibility-dates/\n      compatibility_date: \"2022-04-05\",\n    };\n\n    // Process bindings if they exist\n    if (worker.bindings) {\n      processBindings(spec, worker.bindings);\n    }\n\n    // Add environment variables as vars\n    if (worker.env) {\n      spec.vars = { ...worker.env };\n    }\n\n    await StaticJsonFile(\"wrangler.json\", spec);\n\n    // Return the resource\n    return this({\n      ...props,\n      path: filePath,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n  }\n);\n\n/**\n * Wrangler.json configuration specification based on Cloudflare's schema\n */\nexport interface WranglerJsonSpec {\n  /**\n   * The name of the worker\n   */\n  name: string;\n\n  /**\n   * Main entry point for the worker\n   */\n  main?: string;\n\n  /**\n   * A date in the form yyyy-mm-dd used to determine Workers runtime version\n   */\n  compatibility_date?: string;\n\n  /**\n   * A list of flags that enable features from upcoming Workers runtime\n   */\n  compatibility_flags?: string[];\n\n  /**\n   * Whether to enable a workers.dev URL for this worker\n   */\n  workers_dev?: boolean;\n\n  /**\n   * Routes to attach to the worker\n   */\n  routes?: string[];\n\n  /**\n   * KV Namespace bindings\n   */\n  kv_namespaces?: {\n    binding: string;\n    id: string;\n  }[];\n\n  /**\n   * Durable Object bindings\n   */\n  durable_objects?: {\n    bindings: {\n      name: string;\n      class_name: string;\n      script_name?: string;\n      environment?: string;\n    }[];\n  };\n\n  /**\n   * R2 bucket bindings\n   */\n  r2_buckets?: {\n    binding: string;\n    bucket_name: string;\n  }[];\n\n  /**\n   * Queue bindings\n   */\n  queues?: {\n    binding: string;\n    queue: string;\n  }[];\n\n  /**\n   * Service bindings\n   */\n  services?: {\n    binding: string;\n    service: string;\n    environment?: string;\n  }[];\n\n  /**\n   * Workflow bindings\n   */\n  workflows?: {\n    name: string;\n    binding: string;\n    class_name: string;\n  }[];\n\n  /**\n   * Vectorize index bindings\n   */\n  vectorize_indexes?: {\n    binding: string;\n    index_name: string;\n  }[];\n\n  /**\n   * Plain text bindings (vars)\n   */\n  vars?: Record<string, string>;\n\n  /**\n   * D1 database bindings\n   */\n  d1_databases?: {\n    binding: string;\n    database_id: string;\n    database_name: string;\n  }[];\n\n  /**\n   * Assets bindings\n   */\n  assets?: {\n    directory: string;\n    binding: string;\n  };\n\n  /**\n   * Workflow bindings\n   */\n  wasm_modules?: Record<string, string>;\n\n  /**\n   * Safe mode configuration\n   */\n  node_compat?: boolean;\n\n  /**\n   * Whether to minify the worker script\n   */\n  minify?: boolean;\n}\n\n/**\n * Process worker bindings into wrangler.json format\n */\nfunction processBindings(spec: WranglerJsonSpec, bindings: Bindings): void {\n  // Arrays to collect different binding types\n  const kvNamespaces: { binding: string; id: string }[] = [];\n  const durableObjects: {\n    name: string;\n    class_name: string;\n    script_name?: string;\n    environment?: string;\n  }[] = [];\n  const r2Buckets: { binding: string; bucket_name: string }[] = [];\n  const services: { binding: string; service: string; environment?: string }[] =\n    [];\n  const secrets: string[] = [];\n  const workflows: { name: string; binding: string; class_name: string }[] = [];\n  const d1Databases: {\n    binding: string;\n    database_id: string;\n    database_name: string;\n  }[] = [];\n  const queues: { binding: string; queue: string }[] = [];\n  const vectorizeIndexes: { binding: string; index_name: string }[] = [];\n\n  // Process each binding\n  for (const [bindingName, binding] of Object.entries(bindings)) {\n    if (typeof binding === \"string\") {\n      // Plain text binding - add to vars\n      if (!spec.vars) {\n        spec.vars = {};\n      }\n      spec.vars[bindingName] = binding;\n    } else if (binding.type === \"kv_namespace\") {\n      // KV Namespace binding\n      kvNamespaces.push({\n        binding: bindingName,\n        id: binding.namespaceId,\n      });\n    } else if (\n      typeof binding === \"object\" &&\n      binding.type === \"durable_object_namespace\"\n    ) {\n      // Durable Object binding\n      const doBinding = binding as DurableObjectNamespace;\n      durableObjects.push({\n        name: bindingName,\n        class_name: doBinding.className,\n        script_name: doBinding.scriptName,\n        environment: doBinding.environment,\n      });\n    } else if (binding.type === \"r2_bucket\") {\n      r2Buckets.push({\n        binding: bindingName,\n        bucket_name: binding.name,\n      });\n    } else if (binding.type === \"service\") {\n      // Service binding\n      services.push({\n        binding: bindingName,\n        service: binding.id,\n      });\n    } else if (binding.type === \"secret\") {\n      // Secret binding\n      secrets.push(bindingName);\n    } else if (binding.type === \"assets\") {\n      spec.assets = {\n        directory: binding.path,\n        binding: bindingName,\n      };\n    } else if (binding.type === \"workflow\") {\n      workflows.push({\n        name: bindingName,\n        binding: binding.id,\n        class_name: binding.className,\n      });\n    } else if (binding.type === \"d1\") {\n      d1Databases.push({\n        binding: bindingName,\n        database_id: binding.id,\n        database_name: binding.name,\n      });\n    } else if (binding.type === \"queue\") {\n      queues.push({\n        binding: bindingName,\n        queue: binding.name,\n      });\n    } else if (binding.type === \"vectorize\") {\n      vectorizeIndexes.push({\n        binding: bindingName,\n        index_name: binding.name,\n      });\n    }\n  }\n\n  // Add collected bindings to the spec\n  if (kvNamespaces.length > 0) {\n    spec.kv_namespaces = kvNamespaces;\n  }\n\n  if (durableObjects.length > 0) {\n    spec.durable_objects = {\n      bindings: durableObjects,\n    };\n  }\n\n  if (r2Buckets.length > 0) {\n    spec.r2_buckets = r2Buckets;\n  }\n\n  if (services.length > 0) {\n    spec.services = services;\n  }\n\n  if (d1Databases.length > 0) {\n    spec.d1_databases = d1Databases;\n  }\n\n  if (queues.length > 0) {\n    spec.queues = queues;\n  }\n\n  if (vectorizeIndexes.length > 0) {\n    spec.vectorize_indexes = vectorizeIndexes;\n  }\n}\n\n```\n\n// alchemy/src/cloudflare/zone-settings.ts\n```ts\n/**\n * Common response fields for all settings\n */\nexport interface CloudflareSettingBase {\n  /**\n   * The identifier of the setting\n   */\n  id: string;\n\n  /**\n   * When the setting was last modified\n   */\n  modified_on: string | null;\n\n  /**\n   * Whether the setting can be modified\n   */\n  editable: boolean;\n}\n\n/**\n * Value types for each setting\n */\nexport type SSLValue = \"off\" | \"flexible\" | \"full\" | \"strict\";\nexport type MinTLSVersionValue = \"1.0\" | \"1.1\" | \"1.2\" | \"1.3\";\nexport type TLS13Value = \"on\" | \"off\" | \"zrt\";\nexport type CacheLevelValue = \"aggressive\" | \"basic\" | \"simplified\";\n\n// Boolean setting values\nexport type AlwaysUseHTTPSValue = \"on\" | \"off\";\nexport type AutomaticHTTPSRewritesValue = \"on\" | \"off\";\nexport type BrotliValue = \"on\" | \"off\";\nexport type DevelopmentModeValue = \"on\" | \"off\";\nexport type EarlyHintsValue = \"on\" | \"off\";\nexport type EmailObfuscationValue = \"on\" | \"off\";\nexport type HotlinkProtectionValue = \"on\" | \"off\";\nexport type HTTP2Value = \"on\" | \"off\";\nexport type HTTP3Value = \"on\" | \"off\";\nexport type IPv6Value = \"on\" | \"off\";\nexport type WebSocketsValue = \"on\" | \"off\";\nexport type ZeroRTTValue = \"on\" | \"off\";\n\n/**\n * Common response fields for boolean settings that use \"on\"/\"off\"\n */\nexport interface CloudflareBooleanSetting extends CloudflareSettingBase {\n  /**\n   * The value of the setting\n   */\n  value: \"on\" | \"off\";\n}\n\n/**\n * Advanced DDoS protection setting\n * @see https://developers.cloudflare.com/api/resources/zones/#advanced-ddos\n */\nexport interface AdvancedDDoSSetting extends CloudflareBooleanSetting {\n  id: \"advanced_ddos\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * Always Online setting\n * When enabled, Cloudflare serves limited copies of web pages from the Internet Archive if your server is offline\n */\nexport interface AlwaysOnlineSetting extends CloudflareBooleanSetting {\n  id: \"always_online\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * Always Use HTTPS setting\n * Redirects all HTTP traffic to HTTPS\n */\nexport interface AlwaysUseHTTPSSetting extends CloudflareSettingBase {\n  id: \"always_use_https\";\n  value: AlwaysUseHTTPSValue;\n}\n\n/**\n * Automatic HTTPS Rewrites setting\n * Automatically rewrites HTTP URLs to HTTPS\n */\nexport interface AutomaticHTTPSRewritesSetting extends CloudflareSettingBase {\n  id: \"automatic_https_rewrites\";\n  value: AutomaticHTTPSRewritesValue;\n}\n\n/**\n * Automatic Platform Optimization setting\n */\nexport interface AutomaticPlatformOptimizationSetting\n  extends CloudflareSettingBase {\n  id: \"automatic_platform_optimization\";\n  value: {\n    enabled: boolean;\n    cf: boolean;\n    wordpress: boolean;\n    wordpress_plugin: boolean;\n    cache_by_device_type: boolean;\n  };\n}\n\n/**\n * Brotli compression setting\n */\nexport interface BrotliSetting extends CloudflareSettingBase {\n  id: \"brotli\";\n  value: BrotliValue;\n}\n\n/**\n * Browser Cache TTL setting\n */\nexport interface BrowserCacheTTLSetting extends CloudflareSettingBase {\n  id: \"browser_cache_ttl\";\n  value: number;\n}\n\n/**\n * Browser Check setting\n */\nexport interface BrowserCheckSetting extends CloudflareSettingBase {\n  id: \"browser_check\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * Cache Level setting\n */\nexport interface CacheLevelSetting extends CloudflareSettingBase {\n  id: \"cache_level\";\n  value: CacheLevelValue;\n}\n\n/**\n * Challenge TTL setting\n */\nexport interface ChallengeTTLSetting extends CloudflareSettingBase {\n  id: \"challenge_ttl\";\n  value: number;\n}\n\n/**\n * Ciphers setting\n */\nexport interface CiphersSetting extends CloudflareSettingBase {\n  id: \"ciphers\";\n  value: string[];\n}\n\n/**\n * Development Mode setting\n */\nexport interface DevelopmentModeSetting extends CloudflareSettingBase {\n  id: \"development_mode\";\n  value: DevelopmentModeValue;\n}\n\n/**\n * Early Hints setting\n */\nexport interface EarlyHintsSetting extends CloudflareSettingBase {\n  id: \"early_hints\";\n  value: EarlyHintsValue;\n}\n\n/**\n * Email Obfuscation setting\n */\nexport interface EmailObfuscationSetting extends CloudflareSettingBase {\n  id: \"email_obfuscation\";\n  value: EmailObfuscationValue;\n}\n\n/**\n * Hotlink Protection setting\n */\nexport interface HotlinkProtectionSetting extends CloudflareSettingBase {\n  id: \"hotlink_protection\";\n  value: HotlinkProtectionValue;\n}\n\n/**\n * HTTP/2 setting\n */\nexport interface HTTP2Setting extends CloudflareSettingBase {\n  id: \"http2\";\n  value: HTTP2Value;\n}\n\n/**\n * HTTP/3 setting\n */\nexport interface HTTP3Setting extends CloudflareSettingBase {\n  id: \"http3\";\n  value: HTTP3Value;\n}\n\n/**\n * IP Geolocation setting\n */\nexport interface IPGeolocationSetting extends CloudflareSettingBase {\n  id: \"ip_geolocation\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * IPv6 setting\n */\nexport interface IPv6Setting extends CloudflareSettingBase {\n  id: \"ipv6\";\n  value: IPv6Value;\n}\n\n/**\n * Minimum TLS Version setting\n */\nexport interface MinTLSVersionSetting extends CloudflareSettingBase {\n  id: \"min_tls_version\";\n  value: MinTLSVersionValue;\n}\n\n/**\n * Opportunistic Encryption setting\n */\nexport interface OpportunisticEncryptionSetting extends CloudflareSettingBase {\n  id: \"opportunistic_encryption\";\n  value: \"on\" | \"off\";\n}\n\n/**\n * SSL setting\n */\nexport interface SSLSetting extends CloudflareSettingBase {\n  id: \"ssl\";\n  value: SSLValue;\n  certificate_status?: string;\n  validation_errors?: Array<{\n    message: string;\n  }>;\n}\n\n/**\n * TLS 1.3 setting\n */\nexport interface TLS13Setting extends CloudflareSettingBase {\n  id: \"tls_1_3\";\n  value: TLS13Value;\n}\n\n/**\n * WebSockets setting\n */\nexport interface WebSocketsSetting extends CloudflareSettingBase {\n  id: \"websockets\";\n  value: WebSocketsValue;\n}\n\n/**\n * Zero-RTT setting\n */\nexport interface ZeroRTTSetting extends CloudflareSettingBase {\n  id: \"0rtt\";\n  value: ZeroRTTValue;\n}\n\n/**\n * All possible zone settings\n */\nexport type CloudflareZoneSetting =\n  | AdvancedDDoSSetting\n  | AlwaysOnlineSetting\n  | AlwaysUseHTTPSSetting\n  | AutomaticHTTPSRewritesSetting\n  | AutomaticPlatformOptimizationSetting\n  | BrotliSetting\n  | BrowserCacheTTLSetting\n  | BrowserCheckSetting\n  | CacheLevelSetting\n  | ChallengeTTLSetting\n  | CiphersSetting\n  | DevelopmentModeSetting\n  | EarlyHintsSetting\n  | EmailObfuscationSetting\n  | HotlinkProtectionSetting\n  | HTTP2Setting\n  | HTTP3Setting\n  | IPGeolocationSetting\n  | IPv6Setting\n  | MinTLSVersionSetting\n  | OpportunisticEncryptionSetting\n  | SSLSetting\n  | TLS13Setting\n  | WebSocketsSetting\n  | ZeroRTTSetting;\n\n/**\n * Input for updating a zone setting\n */\nexport interface UpdateZoneSettingParams {\n  /**\n   * The value to set\n   */\n  value: CloudflareZoneSetting[\"value\"];\n}\n\n/**\n * Response for zone settings operations\n */\nexport interface CloudflareZoneSettingResponse {\n  /**\n   * Whether the API call was successful\n   */\n  success: boolean;\n\n  /**\n   * Any error messages\n   */\n  errors: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * Any informational messages\n   */\n  messages: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * The settings that were operated on\n   */\n  result: CloudflareZoneSetting[];\n}\n\n/**\n * Response for a single zone setting operation\n */\nexport interface CloudflareZoneSettingSingleResponse {\n  /**\n   * Whether the API call was successful\n   */\n  success: boolean;\n\n  /**\n   * Any error messages\n   */\n  errors: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * Any informational messages\n   */\n  messages: Array<{\n    code: number;\n    message: string;\n  }>;\n\n  /**\n   * The setting that was operated on\n   */\n  result: CloudflareZoneSetting;\n}\n\n```\n\n// alchemy/src/cloudflare/zone.ts\n```ts\nimport type { Context } from \"../context\";\nimport { Resource } from \"../resource\";\nimport { createCloudflareApi, type CloudflareApiOptions } from \"./api\";\nimport type {\n  AlwaysUseHTTPSValue,\n  AutomaticHTTPSRewritesValue,\n  BrotliValue,\n  CloudflareZoneSettingResponse,\n  DevelopmentModeValue,\n  EarlyHintsValue,\n  EmailObfuscationValue,\n  HTTP2Value,\n  HTTP3Value,\n  HotlinkProtectionValue,\n  IPv6Value,\n  MinTLSVersionValue,\n  SSLValue,\n  TLS13Value,\n  UpdateZoneSettingParams,\n  WebSocketsValue,\n  ZeroRTTValue,\n} from \"./zone-settings\";\n\n/**\n * Properties for creating or updating a Zone\n */\nexport interface ZoneProps extends CloudflareApiOptions {\n  /**\n   * The domain name for the zone\n   */\n  name: string;\n\n  /**\n   * The type of zone to create\n   * \"full\" - Full zone implies that DNS is hosted with Cloudflare\n   * \"partial\" - Partial zone is typically a partner-hosted zone or a CNAME setup\n   * \"secondary\" - Secondary zone is a zone that mirrors the primary zone\n   * @default \"full\"\n   */\n  type?: \"full\" | \"partial\" | \"secondary\";\n\n  /**\n   * Whether to jump start the zone\n   * When enabled, Cloudflare will attempt to fetch existing DNS records\n   * @default true\n   */\n  jumpStart?: boolean;\n\n  /**\n   * Settings to apply to the zone\n   */\n  settings?: {\n    /**\n     * Enable SSL/TLS encryption for the zone\n     * \"off\" - SSL disabled\n     * \"flexible\" - Encrypts traffic between browser and Cloudflare\n     * \"full\" - Encrypts traffic between browser and server, allows self-signed certs\n     * \"strict\" - Encrypts traffic between browser and server, requires valid cert\n     */\n    ssl?: SSLValue;\n\n    /**\n     * Enable Always Use HTTPS\n     * Redirects all HTTP traffic to HTTPS\n     * @default \"off\"\n     */\n    alwaysUseHttps?: AlwaysUseHTTPSValue;\n\n    /**\n     * Enable Automatic HTTPS Rewrites\n     * Automatically rewrites HTTP URLs to HTTPS\n     * @default \"off\"\n     */\n    automaticHttpsRewrites?: AutomaticHTTPSRewritesValue;\n\n    /**\n     * Enable TLS 1.3\n     * Enables the latest version of TLS encryption\n     * @default \"off\"\n     */\n    tls13?: TLS13Value;\n\n    /**\n     * Enable Early Hints\n     * Speeds up page loads by serving Link headers\n     * @default \"off\"\n     */\n    earlyHints?: EarlyHintsValue;\n\n    /**\n     * Enable Email Obfuscation\n     * Obfuscates email addresses on the site\n     * @default \"off\"\n     */\n    emailObfuscation?: EmailObfuscationValue;\n\n    /**\n     * Enable Browser Cache TTL\n     * Sets the browser cache TTL in seconds\n     */\n    browserCacheTtl?: number;\n\n    /**\n     * Enable Development Mode\n     * Disables caching and enables real-time updates\n     * @default \"off\"\n     */\n    developmentMode?: DevelopmentModeValue;\n\n    /**\n     * Enable HTTP/2\n     * @default \"on\"\n     */\n    http2?: HTTP2Value;\n\n    /**\n     * Enable HTTP/3\n     * @default \"on\"\n     */\n    http3?: HTTP3Value;\n\n    /**\n     * Enable IPv6\n     * @default \"on\"\n     */\n    ipv6?: IPv6Value;\n\n    /**\n     * Enable WebSockets\n     * @default \"on\"\n     */\n    websockets?: WebSocketsValue;\n\n    /**\n     * Enable Zero-RTT\n     * @default \"off\"\n     */\n    zeroRtt?: ZeroRTTValue;\n\n    /**\n     * Enable Brotli compression\n     * @default \"on\"\n     */\n    brotli?: BrotliValue;\n\n    /**\n     * Enable Hotlink Protection\n     * @default \"off\"\n     */\n    hotlinkProtection?: HotlinkProtectionValue;\n\n    /**\n     * Minimum TLS Version\n     * @default \"1.0\"\n     */\n    minTlsVersion?: MinTLSVersionValue;\n  };\n}\n\n/**\n * Output returned after Zone creation/update\n */\nexport interface Zone extends Resource<\"cloudflare::Zone\"> {\n  /**\n   * The ID of the zone\n   */\n  id: string;\n\n  /**\n   * The domain name for the zone\n   */\n  name: string;\n\n  /**\n   * The type of zone\n   */\n  type: \"full\" | \"partial\" | \"secondary\";\n\n  /**\n   * The status of the zone\n   */\n  status: string;\n\n  /**\n   * Whether the zone is paused\n   */\n  paused: boolean;\n\n  /**\n   * The account ID the zone belongs to\n   */\n  accountId: string;\n\n  /**\n   * The nameservers assigned to the zone\n   */\n  nameservers: string[];\n\n  /**\n   * The original nameservers for the zone\n   */\n  originalNameservers: string[] | null;\n\n  /**\n   * Time at which the zone was created\n   */\n  createdAt: number;\n\n  /**\n   * Time at which the zone was last modified\n   */\n  modifiedAt: number;\n\n  /**\n   * Time at which the zone was activated\n   */\n  activatedAt: number | null;\n\n  /**\n   * The zone's current settings\n   */\n  settings: {\n    ssl: SSLValue;\n    alwaysUseHttps: AlwaysUseHTTPSValue;\n    automaticHttpsRewrites: AutomaticHTTPSRewritesValue;\n    tls13: TLS13Value;\n    earlyHints: EarlyHintsValue;\n    emailObfuscation: EmailObfuscationValue;\n    browserCacheTtl: number;\n    developmentMode: DevelopmentModeValue;\n    http2: HTTP2Value;\n    http3: HTTP3Value;\n    ipv6: IPv6Value;\n    websockets: WebSocketsValue;\n    zeroRtt: ZeroRTTValue;\n    brotli: BrotliValue;\n    hotlinkProtection: HotlinkProtectionValue;\n    minTlsVersion: MinTLSVersionValue;\n  };\n}\n\n/**\n * A Cloudflare Zone represents a domain and its configuration settings on Cloudflare.\n * Zones allow you to manage DNS, SSL/TLS, caching, security and other settings for a domain.\n *\n * @example\n * // Create a basic zone with default settings\n * const basicZone = await Zone(\"example.com\", {\n *   name: \"example.com\",\n *   type: \"full\",\n *   jumpStart: true\n * });\n *\n * @example\n * // Create a zone with enhanced security settings\n * const secureZone = await Zone(\"secure.example.com\", {\n *   name: \"secure.example.com\",\n *   type: \"full\",\n *   settings: {\n *     ssl: \"strict\",\n *     alwaysUseHttps: \"on\",\n *     automaticHttpsRewrites: \"on\",\n *     minTlsVersion: \"1.3\",\n *     tls13: \"zrt\"\n *   }\n * });\n *\n * @example\n * // Create a zone with optimized performance settings\n * const fastZone = await Zone(\"fast.example.com\", {\n *   name: \"fast.example.com\",\n *   settings: {\n *     browserCacheTtl: 7200,\n *     brotli: \"on\",\n *     zeroRtt: \"on\",\n *     http2: \"on\",\n *     http3: \"on\",\n *     earlyHints: \"on\"\n *   }\n * });\n *\n * @example\n * // Create a development zone with specific features\n * const devZone = await Zone(\"dev.example.com\", {\n *   name: \"dev.example.com\",\n *   settings: {\n *     developmentMode: \"on\",\n *     emailObfuscation: \"on\",\n *     hotlinkProtection: \"on\",\n *     ipv6: \"on\",\n *     websockets: \"on\"\n *   }\n * });\n *\n * @see https://developers.cloudflare.com/dns/zone-setups/\n */\nexport const Zone = Resource(\n  \"cloudflare::Zone\",\n  async function (\n    this: Context<Zone>,\n    id: string,\n    props: ZoneProps\n  ): Promise<Zone> {\n    // Create Cloudflare API client with automatic account discovery\n    const api = await createCloudflareApi(props);\n\n    if (this.phase === \"delete\") {\n      if (this.output?.id) {\n        // Delete zone\n        const deleteResponse = await api.delete(`/zones/${this.output.id}`);\n\n        if (!deleteResponse.ok && deleteResponse.status !== 404) {\n          const errorData: any = await deleteResponse.json().catch(() => ({\n            errors: [{ message: deleteResponse.statusText }],\n          }));\n          throw new Error(\n            `Error deleting zone '${props.name}': ${errorData.errors?.[0]?.message || deleteResponse.statusText}`\n          );\n        }\n      } else {\n        console.warn(`Zone '${props.name}' not found, skipping delete`);\n      }\n      return this.destroy();\n    }\n\n    if (this.phase === \"update\" && this.output?.id) {\n      // Get zone details to verify it exists\n      const response = await api.get(`/zones/${this.output.id}`);\n\n      if (!response.ok) {\n        throw new Error(\n          `Error getting zone '${props.name}': ${response.statusText}`\n        );\n      }\n\n      const zoneData = ((await response.json()) as { result: CloudflareZone })\n        .result;\n\n      // Update zone settings if provided\n      if (props.settings) {\n        await updateZoneSettings(api, this.output.id, props.settings);\n        // Add a small delay to ensure settings are propagated\n        await new Promise((resolve) => setTimeout(resolve, 2000));\n      }\n\n      return this({\n        id: zoneData.id,\n        name: zoneData.name,\n        type: zoneData.type,\n        status: zoneData.status,\n        paused: zoneData.paused,\n        accountId: zoneData.account.id,\n        nameservers: zoneData.name_servers,\n        originalNameservers: zoneData.original_name_servers,\n        createdAt: new Date(zoneData.created_on).getTime(),\n        modifiedAt: new Date(zoneData.modified_on).getTime(),\n        activatedAt: zoneData.activated_on\n          ? new Date(zoneData.activated_on).getTime()\n          : null,\n        settings: await getZoneSettings(api, zoneData.id),\n      });\n    } else {\n      // Create new zone\n\n      const response = await api.post(\"/zones\", {\n        name: props.name,\n        type: props.type || \"full\",\n        jump_start: props.jumpStart !== false,\n        account: {\n          id: api.accountId,\n        },\n      });\n\n      const body = await response.text();\n      let zoneData;\n      if (!response.ok) {\n        if (response.status === 400 && body.includes(\"already exists\")) {\n          // Zone already exists, fetch it instead\n          console.warn(\n            `Zone '${props.name}' already exists during Zone create, adopting it...`\n          );\n          const getResponse = await api.get(`/zones?name=${props.name}`);\n\n          if (!getResponse.ok) {\n            throw new Error(\n              `Error fetching existing zone '${props.name}': ${getResponse.statusText}`\n            );\n          }\n\n          const zones = (\n            (await getResponse.json()) as { result: CloudflareZone[] }\n          ).result;\n          if (zones.length === 0) {\n            throw new Error(\n              `Zone '${props.name}' does not exist, but the name is reserved for another user.`\n            );\n          }\n          zoneData = zones[0];\n        } else {\n          throw new Error(\n            `Error creating zone '${props.name}': ${response.statusText}\\n${body}`\n          );\n        }\n      } else {\n        zoneData = (JSON.parse(body) as { result: CloudflareZone }).result;\n      }\n\n      // Update zone settings if provided\n      if (props.settings) {\n        await updateZoneSettings(api, zoneData.id, props.settings);\n        // Add a small delay to ensure settings are propagated\n        await new Promise((resolve) => setTimeout(resolve, 2000));\n      }\n\n      return this({\n        id: zoneData.id,\n        name: zoneData.name,\n        type: zoneData.type,\n        status: zoneData.status,\n        paused: zoneData.paused,\n        accountId: zoneData.account.id,\n        nameservers: zoneData.name_servers,\n        originalNameservers: zoneData.original_name_servers,\n        createdAt: new Date(zoneData.created_on).getTime(),\n        modifiedAt: new Date(zoneData.modified_on).getTime(),\n        activatedAt: zoneData.activated_on\n          ? new Date(zoneData.activated_on).getTime()\n          : null,\n        settings: await getZoneSettings(api, zoneData.id),\n      });\n    }\n  }\n);\n\n/**\n * Helper function to update zone settings\n */\nasync function updateZoneSettings(\n  api: any,\n  zoneId: string,\n  settings: ZoneProps[\"settings\"]\n): Promise<void> {\n  if (!settings) return;\n\n  const settingsMap = {\n    ssl: \"ssl\",\n    alwaysUseHttps: \"always_use_https\",\n    automaticHttpsRewrites: \"automatic_https_rewrites\",\n    tls13: \"tls_1_3\",\n    earlyHints: \"early_hints\",\n    emailObfuscation: \"email_obfuscation\",\n    browserCacheTtl: \"browser_cache_ttl\",\n    developmentMode: \"development_mode\",\n    http2: \"http2\",\n    http3: \"http3\",\n    ipv6: \"ipv6\",\n    websockets: \"websockets\",\n    zeroRtt: \"0rtt\",\n    brotli: \"brotli\",\n    hotlinkProtection: \"hotlink_protection\",\n    minTlsVersion: \"min_tls_version\",\n  };\n\n  await Promise.all(\n    Object.entries(settings)\n      .filter(([_, value]) => value !== undefined)\n      .map(async ([key, value]) => {\n        const settingId = settingsMap[key as keyof typeof settings];\n        if (!settingId) return;\n\n        const response = await api.patch(\n          `/zones/${zoneId}/settings/${settingId}`,\n          {\n            value,\n          } as UpdateZoneSettingParams\n        );\n\n        if (!response.ok) {\n          const data = await response.text();\n          if (response.status === 400 && data.includes(\"already enabled\")) {\n            console.warn(`Warning: Setting '${key}' already enabled`);\n            return;\n          }\n          throw new Error(\n            `Failed to update zone setting ${key}: ${response.statusText}`\n          );\n        }\n      })\n  );\n}\n\n/**\n * Helper function to get current zone settings\n */\nasync function getZoneSettings(\n  api: any,\n  zoneId: string\n): Promise<Zone[\"settings\"]> {\n  const settingsResponse = await api.get(`/zones/${zoneId}/settings`);\n\n  if (!settingsResponse.ok) {\n    throw new Error(\n      `Failed to fetch zone settings: ${settingsResponse.status} ${settingsResponse.statusText}`\n    );\n  }\n\n  const result =\n    (await settingsResponse.json()) as CloudflareZoneSettingResponse;\n  const settingsData = result.result;\n\n  // Helper to get setting value with default\n  const getSetting = <T>(id: string, defaultValue: T): T => {\n    const setting = settingsData.find((s: any) => s.id === id);\n    return (setting?.value as T) ?? defaultValue;\n  };\n\n  return {\n    ssl: getSetting(\"ssl\", \"off\"),\n    alwaysUseHttps: getSetting(\"always_use_https\", \"off\"),\n    automaticHttpsRewrites: getSetting(\"automatic_https_rewrites\", \"off\"),\n    tls13: getSetting(\"tls_1_3\", \"off\"),\n    earlyHints: getSetting(\"early_hints\", \"off\"),\n    emailObfuscation: getSetting(\"email_obfuscation\", \"off\"),\n    browserCacheTtl: getSetting(\"browser_cache_ttl\", 14400),\n    developmentMode: getSetting(\"development_mode\", \"off\"),\n    http2: getSetting(\"http2\", \"on\"),\n    http3: getSetting(\"http3\", \"on\"),\n    ipv6: getSetting(\"ipv6\", \"on\"),\n    websockets: getSetting(\"websockets\", \"on\"),\n    zeroRtt: getSetting(\"0rtt\", \"off\"),\n    brotli: getSetting(\"brotli\", \"on\"),\n    hotlinkProtection: getSetting(\"hotlink_protection\", \"off\"),\n    minTlsVersion: getSetting(\"min_tls_version\", \"1.0\"),\n  };\n}\n\n/**\n * Cloudflare Zone response format\n */\nexport interface CloudflareZone {\n  id: string;\n  name: string;\n  type: \"full\" | \"partial\" | \"secondary\";\n  status: string;\n  paused: boolean;\n  account: {\n    id: string;\n  };\n  name_servers: string[];\n  original_name_servers: string[] | null;\n  created_on: string;\n  modified_on: string;\n  activated_on: string | null;\n}\n\n```"
  }
}